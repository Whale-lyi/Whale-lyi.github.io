<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 9 | Whale&#39;s Blog | Stay hungry, Stay foolish</title>

  
  <meta name="author" content="Whale">
  

  
  <meta name="description" content="码农预备役">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Whale&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whale&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Whale&#39;s Blog</a>
    </h1>
    <p class="site-description">Stay hungry, Stay foolish</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/06/Kaptcha使用简介/"><span>基于Kaptcha + Redis实现图片验证码</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/06/Kaptcha使用简介/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-06T08:42:09.000Z">
          2022-08-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h3><p>Kaptcha是谷歌开源的简单实用的验证码生成工具。通过设置参数，可以自定义验证码大小、颜色、显示的字符等等。</p>
<p>这篇博客基于SpringBoot + Kaptcha + Redis实现一个简单的图片验证码功能</p>
<h3 id="1-添加Maven依赖"><a href="#1-添加Maven依赖" class="headerlink" title="1. 添加Maven依赖"></a>1. 添加Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--kaptcha--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.penggle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kaptcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--redis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-添加配置类"><a href="#2-添加配置类" class="headerlink" title="2. 添加配置类"></a>2. 添加配置类</h3><h4 id="2-1-Kaptcha配置"><a href="#2-1-Kaptcha配置" class="headerlink" title="2.1 Kaptcha配置"></a>2.1 Kaptcha配置</h4><p><strong>注册 <code>DefaultKaptcha</code> 到 IOC 容器中，在 config 包中，新建 <code>KaptchaConfig</code> 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KaptchaConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DefaultKaptcha <span class="hljs-title function_">getDefaultKaptcha</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DefaultKaptcha</span> <span class="hljs-variable">defaultKaptcha</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultKaptcha</span>();<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">// 图片边框</span><br>        properties.put(Constants.KAPTCHA_BORDER, <span class="hljs-string">&quot;no&quot;</span>);<br>        <span class="hljs-comment">// 验证码长度</span><br>        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, <span class="hljs-string">&quot;4&quot;</span>);<br>        <span class="hljs-comment">// 取值</span><br>        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_STRING, <span class="hljs-string">&quot;0123456789&quot;</span>);<br>        <span class="hljs-comment">// 干扰线</span><br>        properties.setProperty(Constants.KAPTCHA_NOISE_IMPL, <span class="hljs-string">&quot;com.google.code.kaptcha.impl.NoNoise&quot;</span>);<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>(properties);<br>        defaultKaptcha.setConfig(config);<br>        <span class="hljs-keyword">return</span> defaultKaptcha;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>可供配置的属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">KAPTCHA_SESSION_KEY = <span class="hljs-string">&quot;KAPTCHA_SESSION_KEY&quot;</span>;<br>KAPTCHA_SESSION_DATE = <span class="hljs-string">&quot;KAPTCHA_SESSION_DATE&quot;</span>;<br>KAPTCHA_SESSION_CONFIG_KEY = <span class="hljs-string">&quot;kaptcha.session.key&quot;</span>;<br>KAPTCHA_SESSION_CONFIG_DATE = <span class="hljs-string">&quot;kaptcha.session.date&quot;</span>;<br>KAPTCHA_BORDER = <span class="hljs-string">&quot;kaptcha.border&quot;</span>; <span class="hljs-comment">//边框</span><br>KAPTCHA_BORDER_COLOR = <span class="hljs-string">&quot;kaptcha.border.color&quot;</span>; <span class="hljs-comment">//边框颜色</span><br>KAPTCHA_BORDER_THICKNESS = <span class="hljs-string">&quot;kaptcha.border.thickness&quot;</span>; <span class="hljs-comment">//边框厚度</span><br>KAPTCHA_NOISE_COLOR = <span class="hljs-string">&quot;kaptcha.noise.color&quot;</span>; <span class="hljs-comment">//干扰线颜色</span><br>KAPTCHA_NOISE_IMPL = <span class="hljs-string">&quot;kaptcha.noise.impl&quot;</span>; <span class="hljs-comment">//干扰线实现</span><br>KAPTCHA_OBSCURIFICATOR_IMPL = <span class="hljs-string">&quot;kaptcha.obscurificator.impl&quot;</span>; <span class="hljs-comment">//图片样式</span><br>KAPTCHA_PRODUCER_IMPL = <span class="hljs-string">&quot;kaptcha.producer.impl&quot;</span>; <span class="hljs-comment">//图片实现类</span><br>KAPTCHA_TEXTPRODUCER_IMPL = <span class="hljs-string">&quot;kaptcha.textproducer.impl&quot;</span>; <span class="hljs-comment">//文本实现类</span><br>KAPTCHA_TEXTPRODUCER_CHAR_STRING = <span class="hljs-string">&quot;kaptcha.textproducer.char.string&quot;</span>; <span class="hljs-comment">//文本集合，验证码值从此集合中获取</span><br>KAPTCHA_TEXTPRODUCER_CHAR_LENGTH = <span class="hljs-string">&quot;kaptcha.textproducer.char.length&quot;</span>; <span class="hljs-comment">//验证码长度</span><br>KAPTCHA_TEXTPRODUCER_FONT_NAMES = <span class="hljs-string">&quot;kaptcha.textproducer.font.names&quot;</span>; <span class="hljs-comment">//字体</span><br>KAPTCHA_TEXTPRODUCER_FONT_COLOR = <span class="hljs-string">&quot;kaptcha.textproducer.font.color&quot;</span>; <span class="hljs-comment">//字体颜色</span><br>KAPTCHA_TEXTPRODUCER_FONT_SIZE = <span class="hljs-string">&quot;kaptcha.textproducer.font.size&quot;</span>; <span class="hljs-comment">//字体大小</span><br>KAPTCHA_TEXTPRODUCER_CHAR_SPACE = <span class="hljs-string">&quot;kaptcha.textproducer.char.space&quot;</span>; <span class="hljs-comment">//文字间隔</span><br>KAPTCHA_WORDRENDERER_IMPL = <span class="hljs-string">&quot;kaptcha.word.impl&quot;</span>; <span class="hljs-comment">//文字渲染器</span><br>KAPTCHA_BACKGROUND_IMPL = <span class="hljs-string">&quot;kaptcha.background.impl&quot;</span>; <span class="hljs-comment">//背景实现类</span><br>KAPTCHA_BACKGROUND_CLR_FROM = <span class="hljs-string">&quot;kaptcha.background.clear.from&quot;</span>; <span class="hljs-comment">//背景颜色渐变，开始颜色</span><br>KAPTCHA_BACKGROUND_CLR_TO = <span class="hljs-string">&quot;kaptcha.background.clear.to&quot;</span>; <span class="hljs-comment">//背景颜色渐变，结束颜色</span><br>KAPTCHA_IMAGE_WIDTH = <span class="hljs-string">&quot;kaptcha.image.width&quot;</span>; <span class="hljs-comment">//图片宽</span><br>KAPTCHA_IMAGE_HEIGHT = <span class="hljs-string">&quot;kaptcha.image.height&quot;</span>; <span class="hljs-comment">//图片高</span><br></code></pre></td></tr></table></figure>
<h4 id="2-2-Redis配置"><a href="#2-2-Redis配置" class="headerlink" title="2.2 Redis配置"></a>2.2 Redis配置</h4><p><strong>application.yml中的配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">***.***.***.***</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">******</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 连接超时时间</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">180000</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-comment"># 连接池最大连接数(负值表示没有限制)</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span><br>        <span class="hljs-comment"># 最大阻塞等待时间(负数表示没有限制)</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 连接池中的最小空闲连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">5</span><br>        <span class="hljs-comment"># 连接池中的最小空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>注册 <code>RedisTemplate</code> 到 IOC 容器中，在 config 包中，新建 <code>RedisConfig</code> 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        <span class="hljs-comment">// 1.创建 redisTemplate 模版</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 2.关联 redisConnectionFactory</span><br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">// 3.创建 序列化类</span><br>        <span class="hljs-type">GenericToStringSerializer</span> <span class="hljs-variable">genericToStringSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericToStringSerializer</span>(Object.class);<br>        <span class="hljs-comment">// 6.序列化类，对象映射设置</span><br>        <span class="hljs-comment">// 7.设置 value 的转化格式和 key 的转化格式</span><br>        template.setValueSerializer(genericToStringSerializer);<br>        template.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        template.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-接口开发"><a href="#3-接口开发" class="headerlink" title="3. 接口开发"></a>3. 接口开发</h3><h4 id="3-1-Controller层"><a href="#3-1-Controller层" class="headerlink" title="3.1 Controller层"></a>3.1 Controller层</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>KaptchaService kaptchaService;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送图形验证码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/captcha/send&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getCaptcha</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">deviceCode</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;deviceCode&quot;</span>);<br>    <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> kaptchaService.getCaptcha(deviceCode);<br>    ServletOutputStream outputStream;<br>    <span class="hljs-keyword">try</span> &#123;<br>        outputStream = response.getOutputStream();<br>        ImageIO.write(image, <span class="hljs-string">&quot;jpg&quot;</span>, outputStream);<br>        outputStream.flush();<br>        outputStream.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 验证图形验证码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/captcha/check&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkCaptcha</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;captcha&quot;)</span> String captcha, HttpServletRequest request)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">deviceCode</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;deviceCode&quot;</span>);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> kaptchaService.checkCaptcha(captcha, deviceCode);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-Service层"><a href="#3-2-Service层" class="headerlink" title="3.2 Service层"></a>3.2 Service层</h4><p>设置有效期为30分钟，且30min内最多尝试20次，根据设备id作为唯一标识</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>RedisTemplate&lt;String, Object&gt; redisTemplate;<br><span class="hljs-meta">@Autowired</span><br>Producer producer;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> BufferedImage <span class="hljs-title function_">getCaptcha</span><span class="hljs-params">(String deviceCode)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">captchaText</span> <span class="hljs-operator">=</span> producer.createText();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> deviceCode + <span class="hljs-string">&quot;:captcha&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">countKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;count:&quot;</span> + deviceCode + <span class="hljs-string">&quot;:captcha&quot;</span>;<br>    <span class="hljs-comment">// 限制次数</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(countKey);<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-literal">null</span>) &#123;<br>        redisTemplate.opsForValue().set(countKey, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">30</span>, TimeUnit.MINUTES);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Integer.parseInt(count) &lt;= <span class="hljs-number">20</span>) &#123;<br>        redisTemplate.opsForValue().increment(countKey);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Integer.parseInt(count) &gt; <span class="hljs-number">20</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;请稍后尝试&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 设置值</span><br>    redisTemplate.opsForValue().set(key, captchaText, <span class="hljs-number">30</span>, TimeUnit.MINUTES);<br><br>    <span class="hljs-keyword">return</span> producer.createImage(captchaText);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkCaptcha</span><span class="hljs-params">(String captcha, String deviceCode)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;captcha&quot;</span> + deviceCode + <span class="hljs-string">&quot;:code&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(key);<br>    <span class="hljs-keyword">if</span> (captcha.equals(value)) &#123;<br>        redisTemplate.delete(key);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><p><strong>使用Apifox进行测试</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220811101923033.png" alt="image-20220811101923033"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tools/">Tools</a>, <a href="/categories/Tools/Kaptcha/">Kaptcha</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Kaptcha/">Kaptcha</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/05/Sa-Token-Notes/"><span>Sa-Token Notes(1) 基础篇</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/05/Sa-Token-Notes/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-05T09:07:30.000Z">
          2022-08-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="http://sa-token.dev33.cn/">http://sa-token.dev33.cn/</a></p>
<h2 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1 快速开始"></a>1 快速开始</h2><p>整合示例在官方仓库的<code>/sa-token-demo/sa-token-demo-springboot</code>文件夹下，如遇到难点可结合源码进行学习测试。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dromara/sa-token">https://github.com/dromara/sa-token</a></p>
<h3 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1 创建项目"></a>1.1 创建项目</h3><p>在 IDE 中新建一个 SpringBoot 项目，例如：<code>sa-token-demo-springboot</code></p>
<h3 id="1-2-添加依赖"><a href="#1-2-添加依赖" class="headerlink" title="1.2 添加依赖"></a>1.2 添加依赖</h3><p>在项目中直接通过 <code>pom.xml</code> 引入 Sa-Token 的依赖即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Sa-Token 权限认证, 在线文档：http://sa-token.dev33.cn/ --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.dev33<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sa-token-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.30.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="1-3-设置配置文件"><a href="#1-3-设置配置文件" class="headerlink" title="1.3 设置配置文件"></a>1.3 设置配置文件</h3><p>可以<strong>零配置启动项目</strong> ，但同时也可以在 <code>application.yml</code> 中增加如下配置，定制性使用框架：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>    <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-comment"># Sa-Token配置</span><br><span class="hljs-attr">sa-token:</span> <br>    <span class="hljs-comment"># token 名称 (同时也是cookie名称)</span><br>    <span class="hljs-attr">token-name:</span> <span class="hljs-string">satoken</span><br>    <span class="hljs-comment"># token 有效期，单位s 默认30天, -1代表永不过期 </span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">2592000</span><br>    <span class="hljs-comment"># token 临时有效期 (指定时间内无操作就视为token过期) 单位: 秒</span><br>    <span class="hljs-attr">activity-timeout:</span> <span class="hljs-number">-1</span><br>    <span class="hljs-comment"># 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录) </span><br>    <span class="hljs-attr">is-concurrent:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 为false时每次登录新建一个token) </span><br>    <span class="hljs-attr">is-share:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># token风格</span><br>    <span class="hljs-attr">token-style:</span> <span class="hljs-string">uuid</span><br>    <span class="hljs-comment"># 是否输出操作日志 </span><br>    <span class="hljs-attr">is-log:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<h3 id="1-4-创建项目"><a href="#1-4-创建项目" class="headerlink" title="1.4 创建项目"></a>1.4 创建项目</h3><p>在项目中新建包 <code>com.pj</code> ，在此包内新建主类 <code>SaTokenDemoApplication.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaTokenDemoApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>        SpringApplication.run(SaTokenDemoApplication.class, args);<br>        System.out.println(<span class="hljs-string">&quot;启动成功：Sa-Token配置如下：&quot;</span> + SaManager.getConfig());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-5-创建测试Controller"><a href="#1-5-创建测试Controller" class="headerlink" title="1.5 创建测试Controller"></a>1.5 创建测试Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-comment">// 测试登录，浏览器访问： http://localhost:8081/user/doLogin?username=zhang&amp;password=123456</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/doLogin&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doLogin</span><span class="hljs-params">(String username, String password)</span> &#123;<br>        <span class="hljs-comment">// 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;zhang&quot;</span>.equals(username) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(password)) &#123;<br>            StpUtil.login(<span class="hljs-number">10001</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录成功&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录失败&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询登录状态，浏览器访问： http://localhost:8081/user/isLogin</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/isLogin&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">isLogin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;当前会话是否登录：&quot;</span> + StpUtil.isLogin();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-登录认证"><a href="#2-登录认证" class="headerlink" title="2 登录认证"></a>2 登录认证</h2><h3 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a>2.1 设计思路</h3><p><strong>增加一层接口校验</strong>：</p>
<ul>
<li>如果校验通过，则：正常返回数据。</li>
<li>如果校验未通过，则：抛出异常，告知其需要先进行登录。</li>
</ul>
<p><strong>登录访问流程</strong></p>
<ol>
<li>用户提交 <code>name</code> + <code>password</code> 参数，调用登录接口。</li>
<li>登录成功，返回这个用户的 Token 会话凭证。</li>
<li>用户后续的每次请求，都携带上这个 Token。</li>
<li>服务器根据 Token 判断此会话是否登录成功。</li>
</ol>
<h3 id="2-2-登陆与注销"><a href="#2-2-登陆与注销" class="headerlink" title="2.2 登陆与注销"></a>2.2 登陆与注销</h3><p><strong>登录</strong></p>
<p><code>StpUtil.login(Object id);</code><br>会话登录</p>
<p>参数填写要登录的账号id，建议的数据类型：long | int | String，不可以传入复杂类型，如：User、Admin 等等</p>
<p>Sa-Token 为这个账号<strong>创建了一个Token凭证</strong>，且<strong>通过 Cookie 上下文返回给了前端</strong>，利用了 Cookie 自动注入的特性，省略了手写返回 Token 的代码。</p>
<p>Cookie基本功能：</p>
<ul>
<li>Cookie 可以从后端控制往浏览器中写入 Token 值。</li>
<li>Cookie 会在每次请求时自动提交 Token 值。</li>
</ul>
<p><strong>注销</strong></p>
<p><code>StpUtil.logout();</code><br>当前会话注销登录</p>
<p><strong>登陆状态</strong></p>
<p><code>StpUtil.isLogin();</code><br>获取当前会话是否已经登录，返回true=已登录，false=未登录</p>
<p><code>StpUtil.checkLogin();</code><br>检验当前会话是否已经登录, 如果未登录，则抛出异常：<code>NotLoginException</code></p>
<h3 id="2-3-会话查询"><a href="#2-3-会话查询" class="headerlink" title="2.3 会话查询"></a>2.3 会话查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前会话账号id, 如果未登录，则抛出异常：`NotLoginException`</span><br>StpUtil.getLoginId();<br><br><span class="hljs-comment">// 类似查询API还有：</span><br>StpUtil.getLoginIdAsString();    <span class="hljs-comment">// 获取当前会话账号id, 并转化为`String`类型</span><br>StpUtil.getLoginIdAsInt();       <span class="hljs-comment">// 获取当前会话账号id, 并转化为`int`类型</span><br>StpUtil.getLoginIdAsLong();      <span class="hljs-comment">// 获取当前会话账号id, 并转化为`long`类型</span><br><br><span class="hljs-comment">// ---------- 指定未登录情形下返回的默认值 ----------</span><br><br><span class="hljs-comment">// 获取当前会话账号id, 如果未登录，则返回null </span><br>StpUtil.getLoginIdDefaultNull();<br><br><span class="hljs-comment">// 获取当前会话账号id, 如果未登录，则返回默认值 （`defaultValue`可以为任意类型）</span><br>StpUtil.getLoginId(T defaultValue);<br></code></pre></td></tr></table></figure>
<h3 id="2-4-Token查询"><a href="#2-4-Token查询" class="headerlink" title="2.4 Token查询"></a>2.4 Token查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前会话的token值</span><br>StpUtil.getTokenValue();<br><br><span class="hljs-comment">// 获取当前`StpLogic`的token名称</span><br>StpUtil.getTokenName();<br><br><span class="hljs-comment">// 获取指定token对应的账号id，如果未登录，则返回 null</span><br>StpUtil.getLoginIdByToken(String tokenValue);<br><br><span class="hljs-comment">// 获取当前会话剩余有效期（单位：s，返回-1代表永久有效）</span><br>StpUtil.getTokenTimeout();<br><br><span class="hljs-comment">// 获取当前会话的token信息参数</span><br>StpUtil.getTokenInfo();<br></code></pre></td></tr></table></figure>
<p><strong>TokenInfo详解</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;ok&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;tokenName&quot;</span>: <span class="hljs-string">&quot;satoken&quot;</span>,           <span class="hljs-comment">// token名称</span><br>        <span class="hljs-string">&quot;tokenValue&quot;</span>: <span class="hljs-string">&quot;e67b99f1-3d7a-4a8d-bb2f-e888a0805633&quot;</span>,      <span class="hljs-comment">// token值</span><br>        <span class="hljs-string">&quot;isLogin&quot;</span>: <span class="hljs-literal">true</span>,                  <span class="hljs-comment">// 此token是否已经登录</span><br>        <span class="hljs-string">&quot;loginId&quot;</span>: <span class="hljs-string">&quot;10001&quot;</span>,               <span class="hljs-comment">// 此token对应的LoginId，未登录时为null</span><br>        <span class="hljs-string">&quot;loginType&quot;</span>: <span class="hljs-string">&quot;login&quot;</span>,              <span class="hljs-comment">// 账号类型标识</span><br>        <span class="hljs-string">&quot;tokenTimeout&quot;</span>: <span class="hljs-number">2591977</span>,          <span class="hljs-comment">// token剩余有效期 (单位: 秒)</span><br>        <span class="hljs-string">&quot;sessionTimeout&quot;</span>: <span class="hljs-number">2591977</span>,        <span class="hljs-comment">// User-Session剩余有效时间 (单位: 秒)</span><br>        <span class="hljs-string">&quot;tokenSessionTimeout&quot;</span>: -<span class="hljs-number">2</span>,        <span class="hljs-comment">// Token-Session剩余有效时间 (单位: 秒)</span><br>        <span class="hljs-string">&quot;tokenActivityTimeout&quot;</span>: -<span class="hljs-number">1</span>,       <span class="hljs-comment">// token剩余无操作有效时间 (单位: 秒)</span><br>        <span class="hljs-string">&quot;loginDevice&quot;</span>: <span class="hljs-string">&quot;default-device&quot;</span>   <span class="hljs-comment">// 登录设备类型 </span><br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-5-示例"><a href="#2-5-示例" class="headerlink" title="2.5 示例"></a>2.5 示例</h3><p>新建 <code>LoginController</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录测试 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/acc/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;<br><br>    <span class="hljs-comment">// 测试登录  ---- http://localhost:8081/acc/doLogin?name=zhang&amp;pwd=123456</span><br>    <span class="hljs-meta">@RequestMapping(&quot;doLogin&quot;)</span><br>    <span class="hljs-keyword">public</span> SaResult <span class="hljs-title function_">doLogin</span><span class="hljs-params">(String name, String pwd)</span> &#123;<br>        <span class="hljs-comment">// 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;zhang&quot;</span>.equals(name) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(pwd)) &#123;<br>            StpUtil.login(<span class="hljs-number">10001</span>);<br>            <span class="hljs-keyword">return</span> SaResult.ok(<span class="hljs-string">&quot;登录成功&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> SaResult.error(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 查询登录状态  ---- http://localhost:8081/acc/isLogin</span><br>    <span class="hljs-meta">@RequestMapping(&quot;isLogin&quot;)</span><br>    <span class="hljs-keyword">public</span> SaResult <span class="hljs-title function_">isLogin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SaResult.ok(<span class="hljs-string">&quot;是否登录：&quot;</span> + StpUtil.isLogin());<br>    &#125;<br><br>    <span class="hljs-comment">// 查询 Token 信息  ---- http://localhost:8081/acc/tokenInfo</span><br>    <span class="hljs-meta">@RequestMapping(&quot;tokenInfo&quot;)</span><br>    <span class="hljs-keyword">public</span> SaResult <span class="hljs-title function_">tokenInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SaResult.data(StpUtil.getTokenInfo());<br>    &#125;<br><br>    <span class="hljs-comment">// 测试注销  ---- http://localhost:8081/acc/logout</span><br>    <span class="hljs-meta">@RequestMapping(&quot;logout&quot;)</span><br>    <span class="hljs-keyword">public</span> SaResult <span class="hljs-title function_">logout</span><span class="hljs-params">()</span> &#123;<br>        StpUtil.logout();<br>        <span class="hljs-keyword">return</span> SaResult.ok();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-权限认证"><a href="#3-权限认证" class="headerlink" title="3 权限认证"></a>3 权限认证</h2><h3 id="3-1-设计思路"><a href="#3-1-设计思路" class="headerlink" title="3.1 设计思路"></a>3.1 设计思路</h3><p>核心逻辑就是判断一个账号是否拥有指定权限</p>
<p>深入到底层数据中，就是每个账号都会拥有一个<strong>权限码集合</strong>，框架来校验这个集合中是否包含指定的权限码。</p>
<p>例如：当前账号拥有权限码集合 <code>[&quot;user-add&quot;, &quot;user-delete&quot;, &quot;user-get&quot;]</code>，这时候我来校验权限 <code>&quot;user-update&quot;</code>，则其结果就是：<strong>验证失败，禁止访问</strong>。</p>
<h3 id="3-2-获取当前账号权限码集合"><a href="#3-2-获取当前账号权限码集合" class="headerlink" title="3.2 获取当前账号权限码集合"></a>3.2 获取当前账号权限码集合</h3><p>新建一个类，实现 <code>StpInterface</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义权限验证接口扩展 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span>    <span class="hljs-comment">// 保证此类被SpringBoot扫描，完成Sa-Token的自定义权限验证扩展 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StpInterfaceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StpInterface</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回一个账号所拥有的权限码集合 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loginId 账号id，即你在调用 StpUtil.login(id) 时写入的标识值。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loginType 账号体系标识</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getPermissionList</span><span class="hljs-params">(Object loginId, String loginType)</span> &#123;<br>        <span class="hljs-comment">// 本list仅做模拟，实际项目中要根据具体业务逻辑来查询权限</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();    <br>        list.add(<span class="hljs-string">&quot;101&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;user-add&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;user-delete&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;user-update&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;user-get&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;article-get&quot;</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回一个账号所拥有的角色标识集合 (权限与角色可分开校验)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getRoleList</span><span class="hljs-params">(Object loginId, String loginType)</span> &#123;<br>        <span class="hljs-comment">// 本list仅做模拟，实际项目中要根据具体业务逻辑来查询角色</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();    <br>        list.add(<span class="hljs-string">&quot;admin&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;super-admin&quot;</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-权限认证"><a href="#3-3-权限认证" class="headerlink" title="3.3 权限认证"></a>3.3 权限认证</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取：当前账号所拥有的权限集合</span><br>StpUtil.getPermissionList();<br><br><span class="hljs-comment">// 判断：当前账号是否含有指定权限, 返回true或false</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;user-update&quot;</span>);        <br><br><span class="hljs-comment">// 校验：当前账号是否含有指定权限, 如果验证未通过，则抛出异常: NotPermissionException </span><br>StpUtil.checkPermission(<span class="hljs-string">&quot;user-update&quot;</span>);        <br><br><span class="hljs-comment">// 校验：当前账号是否含有指定权限 [指定多个，必须全部验证通过]</span><br>StpUtil.checkPermissionAnd(<span class="hljs-string">&quot;user-update&quot;</span>, <span class="hljs-string">&quot;user-delete&quot;</span>);        <br><br><span class="hljs-comment">// 校验：当前账号是否含有指定权限 [指定多个，只要其一验证通过即可]</span><br>StpUtil.checkPermissionOr(<span class="hljs-string">&quot;user-update&quot;</span>, <span class="hljs-string">&quot;user-delete&quot;</span>);    <br></code></pre></td></tr></table></figure>
<p>扩展：<code>NotPermissionException</code> 对象可通过 <code>getLoginType()</code> 方法获取具体是哪个 <code>StpLogic</code> 抛出的异常</p>
<h3 id="3-4-角色认证"><a href="#3-4-角色认证" class="headerlink" title="3.4 角色认证"></a>3.4 角色认证</h3><p>在Sa-Token中，角色和权限可以独立验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取：当前账号所拥有的角色集合</span><br>StpUtil.getRoleList();<br><br><span class="hljs-comment">// 判断：当前账号是否拥有指定角色, 返回true或false</span><br>StpUtil.hasRole(<span class="hljs-string">&quot;super-admin&quot;</span>);        <br><br><span class="hljs-comment">// 校验：当前账号是否含有指定角色标识, 如果验证未通过，则抛出异常: NotRoleException</span><br>StpUtil.checkRole(<span class="hljs-string">&quot;super-admin&quot;</span>);        <br><br><span class="hljs-comment">// 校验：当前账号是否含有指定角色标识 [指定多个，必须全部验证通过]</span><br>StpUtil.checkRoleAnd(<span class="hljs-string">&quot;super-admin&quot;</span>, <span class="hljs-string">&quot;shop-admin&quot;</span>);        <br><br><span class="hljs-comment">// 校验：当前账号是否含有指定角色标识 [指定多个，只要其一验证通过即可] </span><br>StpUtil.checkRoleOr(<span class="hljs-string">&quot;super-admin&quot;</span>, <span class="hljs-string">&quot;shop-admin&quot;</span>);        <br></code></pre></td></tr></table></figure>
<p>扩展：<code>NotRoleException</code> 对象可通过 <code>getLoginType()</code> 方法获取具体是哪个 <code>StpLogic</code> 抛出的异常</p>
<h3 id="3-5-拦截全局异常"><a href="#3-5-拦截全局异常" class="headerlink" title="3.5 拦截全局异常"></a>3.5 拦截全局异常</h3><p>创建一个全局异常拦截器，统一返回给前端的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">// 全局异常拦截 </span><br>    <span class="hljs-meta">@ExceptionHandler</span><br>    <span class="hljs-keyword">public</span> SaResult <span class="hljs-title function_">handlerException</span><span class="hljs-params">(Exception e)</span> &#123;<br>        e.printStackTrace(); <br>        <span class="hljs-keyword">return</span> SaResult.error(e.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-6-权限通配符"><a href="#3-6-权限通配符" class="headerlink" title="3.6 权限通配符"></a>3.6 权限通配符</h3><p>Sa-Token允许你根据通配符指定<strong>泛权限</strong>，例如当一个账号拥有<code>user*</code>的权限时，<code>user-add</code>、<code>user-delete</code>、<code>user-update</code>都将匹配通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当拥有 user* 权限时</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;user-add&quot;</span>);        <span class="hljs-comment">// true</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;user-update&quot;</span>);     <span class="hljs-comment">// true</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;art-add&quot;</span>);         <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 当拥有 *-delete 权限时</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;user-add&quot;</span>);        <span class="hljs-comment">// false</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;user-delete&quot;</span>);     <span class="hljs-comment">// true</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;art-delete&quot;</span>);      <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 当拥有 *.js 权限时</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;index.js&quot;</span>);        <span class="hljs-comment">// true</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;index.css&quot;</span>);       <span class="hljs-comment">// false</span><br>StpUtil.hasPermission(<span class="hljs-string">&quot;index.html&quot;</span>);      <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>上帝权限：当一个账号拥有 <code>&quot;*&quot;</code> 权限时，他可以验证通过任何权限码 （角色认证同理）</p>
</blockquote>
<h3 id="3-7-如何把权限精确到按钮级"><a href="#3-7-如何把权限精确到按钮级" class="headerlink" title="3.7 如何把权限精确到按钮级"></a>3.7 如何把权限精确到按钮级</h3><p>权限精确到按钮级的意思就是指：<strong>权限范围可以控制到页面上的每一个按钮是否显示</strong>。</p>
<ul>
<li>在登录时，把当前账号拥有的所有权限码一次性返回给前端。</li>
<li>前端将权限码集合保存在<code>localStorage</code>或其它全局状态管理对象中。</li>
<li>在需要权限控制的按钮上，使用 js 进行逻辑判断</li>
</ul>
<h2 id="4-踢人下线"><a href="#4-踢人下线" class="headerlink" title="4 踢人下线"></a>4 踢人下线</h2><p>找到指定 <code>loginId</code> 对应的 <code>Token</code>，并设置其失效。</p>
<h3 id="4-1-强制注销"><a href="#4-1-强制注销" class="headerlink" title="4.1 强制注销"></a>4.1 强制注销</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">StpUtil.logout(<span class="hljs-number">10001</span>);                    <span class="hljs-comment">// 强制指定账号注销下线 </span><br>StpUtil.logout(<span class="hljs-number">10001</span>, <span class="hljs-string">&quot;PC&quot;</span>);              <span class="hljs-comment">// 强制指定账号指定端注销下线, 可在登录时设置设备</span><br>StpUtil.logoutByTokenValue(<span class="hljs-string">&quot;token&quot;</span>);      <span class="hljs-comment">// 强制指定 Token 注销下线 </span><br></code></pre></td></tr></table></figure>
<h3 id="4-2-踢人下线"><a href="#4-2-踢人下线" class="headerlink" title="4.2 踢人下线"></a>4.2 踢人下线</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">StpUtil.kickout(<span class="hljs-number">10001</span>);                    <span class="hljs-comment">// 将指定账号踢下线 </span><br>StpUtil.kickout(<span class="hljs-number">10001</span>, <span class="hljs-string">&quot;PC&quot;</span>);              <span class="hljs-comment">// 将指定账号指定端踢下线</span><br>StpUtil.kickoutByTokenValue(<span class="hljs-string">&quot;token&quot;</span>);      <span class="hljs-comment">// 将指定 Token 踢下线</span><br></code></pre></td></tr></table></figure>
<p>强制注销 和 踢人下线 的区别在于：</p>
<ul>
<li>强制注销等价于对方主动调用了注销方法，再次访问会提示：Token无效。</li>
<li>踢人下线不会清除Token信息，而是将其打上特定标记，再次访问会提示：Token已被踢下线。</li>
</ul>
<h3 id="4-3-账号封禁"><a href="#4-3-账号封禁" class="headerlink" title="4.3 账号封禁"></a>4.3 账号封禁</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 封禁指定账号 </span><br><span class="hljs-comment">// 参数一：账号id</span><br><span class="hljs-comment">// 参数二：封禁时长，单位：秒  (86400秒=1天，此值为-1时，代表永久封禁)</span><br>StpUtil.disable(<span class="hljs-number">10001</span>, <span class="hljs-number">86400</span>); <br><br><span class="hljs-comment">// 获取指定账号是否已被封禁 (true=已被封禁, false=未被封禁) </span><br>StpUtil.isDisable(<span class="hljs-number">10001</span>); <br><br><span class="hljs-comment">// 获取指定账号剩余封禁时间，单位：秒</span><br>StpUtil.getDisableTime(<span class="hljs-number">10001</span>); <br><br><span class="hljs-comment">// 解除封禁</span><br>StpUtil.untieDisable(<span class="hljs-number">10001</span>); <br></code></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>对于正在登录的账号，对其账号封禁时并不会使其立刻注销<br>如果需要将其封禁后立即掉线，可采取先踢再封禁的策略。</p>
<h2 id="5-注解鉴权"><a href="#5-注解鉴权" class="headerlink" title="5 注解鉴权"></a>5 注解鉴权</h2><h2 id="6-路由拦截鉴权"><a href="#6-路由拦截鉴权" class="headerlink" title="6 路由拦截鉴权"></a>6 路由拦截鉴权</h2><h2 id="7-Session会话"><a href="#7-Session会话" class="headerlink" title="7 Session会话"></a>7 Session会话</h2><h2 id="8-框架配置"><a href="#8-框架配置" class="headerlink" title="8 框架配置"></a>8 框架配置</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tools/">Tools</a>, <a href="/categories/Tools/Sa-Token/">Sa-Token</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Sa-Token/">Sa-Token</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/06/04/cpp高级程序设计/"><span>C++高级程序设计</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/06/04/cpp高级程序设计/" rel="bookmark">
        <time class="entry-date published" datetime="2022-06-04T15:51:54.000Z">
          2022-06-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="结构化程序设计部分"><a href="#结构化程序设计部分" class="headerlink" title="结构化程序设计部分"></a>结构化程序设计部分</h2><h3 id="1-C-历史"><a href="#1-C-历史" class="headerlink" title="1. C++历史"></a>1. C++历史</h3><h4 id="1-1-演化历程"><a href="#1-1-演化历程" class="headerlink" title="1.1 演化历程"></a>1.1 演化历程</h4><ul>
<li>Father of Simula67、Father of OO programming<ul>
<li>Ole-Johan Dahl、Kristen Nygaard</li>
</ul>
</li>
<li>C语言之父、共同发明UNIX<ul>
<li>Dennis Ritchie、Ken Thompson</li>
</ul>
</li>
<li>1980年形成C with class<ul>
<li>Bjarne Stroustrup</li>
</ul>
</li>
<li>1983年正式命名为C++<ul>
<li>Rick Mascitti</li>
</ul>
</li>
<li>1994年制定ANSI C++标准草案</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621131005571.png" alt="image-20220621131005571"></p>
<h4 id="1-2-设计理念"><a href="#1-2-设计理念" class="headerlink" title="1.2 设计理念"></a>1.2 设计理念</h4><ul>
<li>效率</li>
<li>实用性优于艺术性严谨性</li>
<li>相信程序员（允许一个有用的特征比防止各种错误使用更重要）</li>
</ul>
<h4 id="1-3-C-与-C-的关系"><a href="#1-3-C-与-C-的关系" class="headerlink" title="1.3 C 与 C++ 的关系"></a>1.3 C 与 C++ 的关系</h4><ul>
<li>C++ 完全包含了 C 语言成分，支持 C 支持的全部编程技巧，C 是建立 C++ 的基础，同时 C++ 还添加了OOP的完全支持。</li>
<li>任何 C 程序都能被 C++ 用基本相同的方法编写，并具有相同的运行效率和空间。</li>
<li>C++ 还引入了重载、内联函数、异常处理等功能，对 C 中过程化控制及其功能进行了扩充</li>
</ul>
<h4 id="1-4-C和C-混合编程应该注意的问题"><a href="#1-4-C和C-混合编程应该注意的问题" class="headerlink" title="1.4 C和C++混合编程应该注意的问题"></a>1.4 C和C++混合编程应该注意的问题</h4><ul>
<li><p>名变换：如果调用C语言库中的函数，则需要附加 <code>&quot;extern C&quot;</code>，限制 C++ 编译器进行名变换，便于可以连接</p>
</li>
<li><p>静态初始化：C++ 静态的类对象和定义在全局的、命名空间中的或文件体中的类对象的构造函数通常在 <code>main</code> 被执行前就被调用，尽可能把主函数写在 cpp 文件当中</p>
</li>
<li><p>内存动态分配：C++ 使用 <code>new/delete</code>，C 使用 <code>malloc/free</code>，需要注意匹配</p>
</li>
<li><p>数据结构兼容：将在两种语言间传递的东西限制在用 C 编译的数据结构的范围内，这些结构的 C++版本可以包含⾮虚成员函数，不能有虚函数。</p>
</li>
<li><p>因为C++是C的超集，且C是结构化编程语言，⽽C++支持面向对象编程语言，所以在混合编程时，不应当出现class等⾯向对象的关键字</p>
</li>
<li><p>C语言不支持函数重载。</p>
<blockquote>
<p>在C++中f (int, int) 与 f(int, double) 是不同的函数，都重载了函数 f()；但是在C语言中却被认为是相同的函数。因为在编译时，<em>C语言给这几个函数的命名为 f；而C++命名分别为 f_int_int，f_int_double，f</em>，以表示区别；所以混合编程时应注意重载函数的问题</p>
</blockquote>
</li>
<li><p>在 C++ 中也允许在 <code>struct</code> 和 <code>union</code> 中定义函数，他们也具有类的基本功能，与 <code>class</code> 所不同的是，<code>struct</code> 和 <code>union</code> 的成员的默认访问控制为 <code>public</code></p>
</li>
</ul>
<h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h3><h4 id="2-1-Data"><a href="#2-1-Data" class="headerlink" title="2.1 Data"></a>2.1 Data</h4><ul>
<li>强类型，动/静结合</li>
</ul>
<h4 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h4><ul>
<li>Modifiers ：long、short、signed、unsigned<ul>
<li>char 只能用signed、unsigned修饰</li>
<li>float 不能被修饰</li>
<li>double 只能用long修饰</li>
<li>int 可以用4种修饰符组合修饰</li>
</ul>
</li>
<li>操作符 sizeof</li>
<li>typedef 定义同义词</li>
</ul>
<h4 id="2-3-表达式"><a href="#2-3-表达式" class="headerlink" title="2.3 表达式"></a>2.3 表达式</h4><ul>
<li><p>赋值表达式</p>
<ul>
<li>左值＝右值表达式<ul>
<li>左值：可以出现在赋值表达式左部的表达式，具有存放数据的确定地址</li>
<li>类型不同时，先计算右值表达式的值，再转换为左值类型，然后赋值</li>
</ul>
</li>
</ul>
</li>
<li><p>条件运算符表达式</p>
<ul>
<li>\<exp1> ? \<exp2> : \<exp3></li>
<li>如果\<exp2> 和\<exp3>的值类型相同，且均为左值，则该条件运算符表达式为左值表达式</li>
<li>可嵌套<ul>
<li>sign(x)      x &gt; 0? 1: x == 0? 0 : -1</li>
<li>就近原则</li>
</ul>
</li>
</ul>
</li>
<li><p>逗号表达式</p>
<ul>
<li><p>$<exp_1>,<exp_2>,…,<exp_n>$</p>
</li>
<li><p>$<exp_n>$的值作为该逗号表达式的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a, b, c;<br><span class="hljs-type">int</span> d = (a = <span class="hljs-number">1</span>, b = a+<span class="hljs-number">2</span>, c = b+<span class="hljs-number">3</span>);<br>cout &lt;&lt; d &lt;&lt; endl; <span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如$<exp_n>$为左值，则该逗号表达式为左值</p>
</li>
</ul>
</li>
<li><p>影响表达式值的因素</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h4 id="2-4-语句"><a href="#2-4-语句" class="headerlink" title="2.4 语句"></a>2.4 语句</h4><ul>
<li>表达式语句、IO语句和控制流语句</li>
<li>switch<ul>
<li>整形常量表达式：<code>5、const、enum、define</code>(对于compiler是固定的)</li>
<li>值不重复</li>
<li>次序任意(特指case)</li>
<li>switch可以和enum结合使用，将具体数值解耦</li>
<li>switch的进一步优化可以使用表驱动</li>
</ul>
</li>
</ul>
<h5 id="2-4-1-switch的实现与优化-表驱动"><a href="#2-4-1-switch的实现与优化-表驱动" class="headerlink" title="2.4.1 switch的实现与优化(表驱动)"></a>2.4.1 switch的实现与优化(表驱动)</h5><ul>
<li>对于switch的汇编格式，其只需要被翻译为cmp一次即可。</li>
<li>switch：使用表驱动来提高效率</li>
<li>详见PPT 36页的动画：不要将提示语进行硬编码，可以使用枚举类型(集中管理)</li>
<li>计算机中的所有的鼠标操作都会对应一个事件</li>
<li>字面常量调整为枚举类型，还可以使用事件表来完成<ul>
<li>使用一个handler</li>
<li>表是从内存中装载进来</li>
</ul>
</li>
<li>目前操作系统中的对应存储对应的文件为RC</li>
</ul>
<h5 id="2-4-2-switch的实现与优化（编译过程）"><a href="#2-4-2-switch的实现与优化（编译过程）" class="headerlink" title="2.4.2 switch的实现与优化（编译过程）"></a>2.4.2 switch的实现与优化（编译过程）</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621172638151.png" alt="image-20220621172638151" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621172655516.png" alt="image-20220621172655516" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621173115017.png" alt="image-20220621173115017" style="zoom:80%;" /></p>
<h5 id="2-4-3-如果range很大"><a href="#2-4-3-如果range很大" class="headerlink" title="2.4.3 如果range很大"></a>2.4.3 如果range很大</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621173711476.png" alt="image-20220621173711476" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621173748658.png" alt="image-20220621173748658" style="zoom:80%;" /></p>
<h4 id="2-5-表驱动"><a href="#2-5-表驱动" class="headerlink" title="2.5 表驱动"></a>2.5 表驱动</h4><ul>
<li>Application Scene应用<ul>
<li>Error/exception handle 异常处理</li>
<li>Message-driven 信息驱动</li>
<li>Function pointer 函数指针：就是例子中case里面只是简答的打印，而实际情况中可能只是相似的接口而已，这是我们就要使用到函数指针了。</li>
</ul>
</li>
<li>Implementation 实现<ul>
<li>Array 数组</li>
<li>Map</li>
</ul>
</li>
</ul>
<h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul>
<li>原则<ul>
<li>定义不允许嵌套</li>
<li>先定义后使用</li>
</ul>
</li>
<li>函数的执行机制<ul>
<li>建立被调用函数的栈空间</li>
<li>参数传递<ul>
<li>值传递 (call by value)</li>
<li>引用传递 (call by reference)</li>
</ul>
</li>
<li>保存调用函数的运行状态</li>
<li>将控制转交被调函数</li>
</ul>
</li>
</ul>
<h4 id="3-1-函数与内存"><a href="#3-1-函数与内存" class="headerlink" title="3.1 函数与内存"></a>3.1 函数与内存</h4><h5 id="3-1-1-存储空间与内存"><a href="#3-1-1-存储空间与内存" class="headerlink" title="3.1.1 存储空间与内存"></a>3.1.1 存储空间与内存</h5><ul>
<li>从上到下分别是<ul>
<li>Code：存放函数体的二进制代码</li>
<li>Data：存放数据(静态变量和全局变量和字符串常量)</li>
<li>Stack：由系统管理，存放函数参数值，局部变量</li>
<li>Heap：可以用程序员进行分配，可以在运行时动态确定，<code>int *p = (int *)malloc(4)</code>，归还内存<code>free</code>(在C++中不推荐使用这种方法进行处理，而是使用new和delete)</li>
</ul>
</li>
</ul>
<h5 id="3-1-2-Runtime-Environment"><a href="#3-1-2-Runtime-Environment" class="headerlink" title="3.1.2 Runtime Environment"></a>3.1.2 Runtime Environment</h5><ul>
<li><p>__cdecl</p>
</li>
<li><p>__stdcall</p>
</li>
<li><p>__fastcall</p>
</li>
<li><p>__thiscall</p>
</li>
</ul>
<h4 id="3-2-函数执行机制"><a href="#3-2-函数执行机制" class="headerlink" title="3.2 函数执行机制"></a>3.2 函数执行机制</h4><h5 id="3-2-1-建立被调用函数栈空间"><a href="#3-2-1-建立被调用函数栈空间" class="headerlink" title="3.2.1 建立被调用函数栈空间"></a>3.2.1 建立被调用函数栈空间</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621190618458.png" alt="image-20220621190618458" style="zoom:80%;" /></p>
<h5 id="3-2-2-参数传递"><a href="#3-2-2-参数传递" class="headerlink" title="3.2.2 参数传递"></a>3.2.2 参数传递</h5><ul>
<li>值传递</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621192112390.png" alt="image-20220621192112390" style="zoom:80%;" /></p>
<ul>
<li>引用传递<ul>
<li>传递的是地址，会同时修改对应地址单元中的值。（函数副作用）</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621192134712.png" alt="image-20220621192134712" style="zoom:80%;" /></p>
<ul>
<li>call by name：是指在用到该参数的时候才会计算参数表达式的值</li>
<li>call by value-result</li>
</ul>
<h5 id="3-2-3-保存调用函数的运行状态-额外的Cost"><a href="#3-2-3-保存调用函数的运行状态-额外的Cost" class="headerlink" title="3.2.3 保存调用函数的运行状态(额外的Cost)"></a>3.2.3 保存调用函数的运行状态(额外的Cost)</h5><ul>
<li>存储新的基指针：如上面，将ret_addr和main_esp进行存储。</li>
<li>分配函数存储的空间</li>
<li>执行某些功能</li>
<li>释放不必要的存储空间</li>
</ul>
<h5 id="3-2-4-将控制转交给被调函数"><a href="#3-2-4-将控制转交给被调函数" class="headerlink" title="3.2.4 将控制转交给被调函数"></a>3.2.4 将控制转交给被调函数</h5><ul>
<li>加载调用者的基指针</li>
<li>记载返回地址</li>
</ul>
<h5 id="3-2-5-Summary"><a href="#3-2-5-Summary" class="headerlink" title="3.2.5 Summary"></a>3.2.5 Summary</h5><ul>
<li>加载参数(进栈)</li>
<li>保存上下文环境<ul>
<li>保存返回地址</li>
<li>保存调用者基指针</li>
</ul>
</li>
<li>执行函数<ul>
<li>设置新的基指针</li>
<li>分配空间(可选)</li>
<li>执行一些任务</li>
<li>释放空间(如果分配了的话)</li>
</ul>
</li>
<li>恢复上下文环境<ul>
<li>加载调用者基指针</li>
<li>加载返回指针</li>
</ul>
</li>
<li>继续执行调用者的功能</li>
</ul>
<h4 id="3-3-函数原型"><a href="#3-3-函数原型" class="headerlink" title="3.3 函数原型"></a>3.3 函数原型</h4><ul>
<li><p>遵守先定义后使用原则</p>
</li>
<li><p>自由安排函数定义位置</p>
</li>
<li><p>语句:只需参数类型，无需参数名称</p>
</li>
<li><p>编译器检查</p>
</li>
<li><p>函数原型:只需要看到函数名和参数读取到即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">int func(int,int)<br></code></pre></td></tr></table></figure>
<ul>
<li>在调用点一定要能看到接口</li>
<li>仅仅需要函数名和参数类型即可</li>
</ul>
</li>
<li><p>函数原型应当放置在头文件中</p>
</li>
</ul>
<h4 id="3-4-函数重载"><a href="#3-4-函数重载" class="headerlink" title="3.4 函数重载"></a>3.4 函数重载</h4><ul>
<li><p>原则：</p>
<ul>
<li>名称相同，参数不同(重载函数的参数个数、参数类型、参数顺序至少一个不同)</li>
<li>返回值类型不作为区别重载函数的依据</li>
</ul>
</li>
<li><p>匹配原则</p>
<ul>
<li>严格匹配</li>
<li>内部转换</li>
<li>用户定义的转换</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//下面这种是不被允许的，ambiguous</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;            <br><span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-5-函数的默认参数"><a href="#3-5-函数的默认参数" class="headerlink" title="3.5 函数的默认参数"></a>3.5 函数的默认参数</h4><ul>
<li><p>默认参数的声明</p>
<ul>
<li><strong>函数原型中给出</strong></li>
<li>先定义的函数中给出</li>
</ul>
</li>
<li><p>默认参数的顺序</p>
<ul>
<li><strong>右→左</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">2</span>)</span> <span class="hljs-comment">//正确</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> c)</span> <span class="hljs-comment">//错误</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li>不间断</li>
</ul>
</li>
<li><p>默认参数与函数重载要注意</p>
<ul>
<li><code>void f(int); void f(int, int=2);</code>，ambiguous</li>
</ul>
</li>
</ul>
<h4 id="3-6-外部函数-extern"><a href="#3-6-外部函数-extern" class="headerlink" title="3.6 外部函数 extern"></a>3.6 外部函数 extern</h4><ul>
<li>符号表：Name mangling: extern “C”<ul>
<li>在C++的g中调用C中的f，会在link的时候出问题(因为不在C++ 的符号表中)</li>
<li>解决方案:在函数名前面加上extern的关键词(这样子编译器就会在编译过程中从外部进行寻找)</li>
</ul>
</li>
<li>C编译器编译的文件被放置在lib库中，C++不能直接调用，而是需要extern才可以</li>
<li>原因：符号表机制<ul>
<li>符号表：与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表<code>&lt;name,address&gt;</code>，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行</li>
<li>对于C语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载)</li>
<li>对于C++来说，因为有重载，所以f(int)和f(float)在符号表里的name是不同的</li>
<li>C++对于C语言的函数 f 会按c++的方式生成函数表中的nameA，但 C 编译好的函数表内 f 对应的nameB和nameA不一致，导致C++无法找到该函数</li>
</ul>
</li>
</ul>
<h4 id="3-7-inline"><a href="#3-7-inline" class="headerlink" title="3.7 inline"></a>3.7 inline</h4><ul>
<li>内联函数inline<ul>
<li>目的<ul>
<li>提高可读性</li>
<li>提高效率</li>
</ul>
</li>
<li>实现方法<ul>
<li>编译系统将为inline函数创建一段代码，在调用点，以相应的代码替换</li>
</ul>
</li>
<li>限制<ul>
<li>递归</li>
<li>函数指针</li>
</ul>
</li>
<li><strong>inline</strong> 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</li>
<li>适用<ul>
<li>使用频率高、简单、小段代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">ascii</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    r = <span class="hljs-built_in">ascii</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;r = %d\n&quot;</span>, r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;	<br></code></pre></td></tr></table></figure>
<ul>
<li><p>缺点：</p>
<ul>
<li><p>增大目标代码</p>
</li>
<li><p>病态的换页</p>
<blockquote>
<p><strong>如果有过长的代码，被替换进入代码的段中，代码页在内存和磁盘中反复换页抖动</strong>(每调用一次内联函数就会将那段代码复制到主文件中，内存增加，内存调用时原本一页的内容可能出现在第一页+第二页的一部分，<strong>造成操作系统的”抖动”</strong>)</p>
</blockquote>
</li>
<li><p>降低指令快取装置的命中率(instruction cache hit rate)</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-程序组织"><a href="#4-程序组织" class="headerlink" title="4 程序组织"></a>4 程序组织</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621200100752.png" alt="image-20220621200100752" style="zoom:80%;" /></p>
<ul>
<li>编译只编译当前模块</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">g</span>()&#123;  <span class="hljs-comment">//a.cpp</span><br>	<span class="hljs-built_in">f</span>()  <span class="hljs-comment">//b.cpp</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>编译每个编译单元(<code>.cpp</code>)时是相互独立的，即每个cpp文件之间是不知道对方的存在的,<code>.cpp</code>编译成<code>.obj</code>后，link期时<code>a.obj</code>才会从<code>b.obj</code>中获得<code>f()</code>函数的信息</li>
<li>link时将编译的结果连接成可执行代码，主要是确定各部分的地址,将编译结果中的<strong>地址符号全换成实地址</strong>(call指令在a.cpp被编译时只是call f的符号，而不知道f确切的地址)</li>
</ul>
<h4 id="4-1-static"><a href="#4-1-static" class="headerlink" title="4.1 static"></a>4.1 static</h4><ul>
<li>修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。<ul>
<li>其他文件中可以定义相同名字的变量</li>
</ul>
</li>
<li>修饰局部变量时，表明该变量的值不会因为函数终止而丢失。<ul>
<li>该变量在全局数据区分配内存(局部变量在栈分配内存)</li>
<li>始终驻留在全局数据区直到程序运行结束，但作用域为局部作用域，不能再函数外访问</li>
</ul>
</li>
<li>修饰函数时，表明该函数只在同一文件中调用。<ul>
<li>其他文件中可以定义相同名字的函数</li>
</ul>
</li>
<li>修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有</li>
</ul>
<h4 id="4-2-namespace"><a href="#4-2-namespace" class="headerlink" title="4.2 namespace"></a>4.2 namespace</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> A<br>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">namespace</span> D<br>	&#123;<br>		<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> B<br>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">namespace</span> C<br>	&#123;<br>		<span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> B;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> C;<br>	cout &lt;&lt; b；<span class="hljs-comment">//必须using B,C否则b会报错</span><br>	<span class="hljs-built_in">getchar</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>using-declaration<ul>
<li>指定使用L中的哪些变量/函数 <code>using L::k</code></li>
</ul>
</li>
<li>using-directive<ul>
<li>使用L中的全部内容 <code>using namespace L</code></li>
</ul>
</li>
</ul>
<h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h3><ul>
<li>特征：<ul>
<li>相同类型</li>
<li>连续存储</li>
</ul>
</li>
</ul>
<h4 id="5-1-一维数组"><a href="#5-1-一维数组" class="headerlink" title="5.1 一维数组"></a>5.1 一维数组</h4><ul>
<li><p>函数接口：void f(int a[]，int n)</p>
<ul>
<li><p>元素个数须通过参数<strong>显式</strong>给出，不能通过<em>sizeof</em>取得</p>
<ul>
<li><p>字符串特例：void f(char a[])</p>
</li>
<li><p>```c++<br>char s1[] = “abc”;  //等价于2<br>char s2[] = {‘a’, ‘b’, ‘c’, ‘\0’};<br>char s2[] = {‘a’, ‘b’, ‘c’};  //不正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>#### 5.2 二维数组<br><br>- 定义<br><br>  ```c++<br>  int B[2][6];<br>  typedef int T[6];<br>  T B[2];//等价于int B[2][6]<br>  int C[2][3][2];<br>  typedef int T2[2];<br>  typedef T2 T1[3];<br>  T1 C[2];//等价于int C[2][3][2]<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>参数传递</p>
<ul>
<li>缺省第一维</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">2</span>], <span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>], <span class="hljs-type">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-Struct"><a href="#6-Struct" class="headerlink" title="6. Struct"></a>6. Struct</h3><ul>
<li><p>可以做赋值操作：同类型，大块数据的传输</p>
<ul>
<li><p>struct按不同顺序排列sizeof()会不一样</p>
</li>
<li><p>```c++<br>struct A {</p>
<pre><code>char a;
int b;
short c;
</code></pre><p>}<br>cout &lt;&lt; sizeof(A) &lt;&lt; endl; //此时sizeof(A) = 12<br>struct B {</p>
<pre><code>short c;
char a;
int b;
</code></pre><p>}<br>cout &lt;&lt; sizeof(B) &lt;&lt; endl;//此时sizeof(B) = 8，因为short占2个字节，四个字节并未占满，所以还可以填入一个char，但是再遇到int（4个字节）就不能再填充了，只能从写一个四字节地址开始，所以共占8个字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>### 7. Union<br><br>- 共享存储空间（公共的容器），能够节省空间，union变量占用的内存长度等于最长的成员的内存长度，所有成员的起始地址是一样的，故下面的&amp;test.b &amp;test.a &amp;test.c是一样的<br><br>  - ```c++<br>    union B &#123;<br>        char b;<br>        int a;<br>        short c;<br>    &#125; test;<br>    cout &lt;&lt; sizeof(B) &lt;&lt; endl;//输出存储空间最大的一位，即输出max(sizeof(b), sizeof(a), sizeof(c))<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li><p>矩阵</p>
<ul>
<li>```c++<br>union Matrix {<pre><code>struct &#123;
    double _a11, _a12, _a13;
    double _a21, _a22, _a23;
    double _a31, _a32, _a33;
&#125;
</code></pre>}<br>Matrix m;<br>int i,j;<br>for (i = 0; i &lt; 3; i++)<pre><code>for (j = 0; j &lt; 3; j++)
    m._element[i][j] = (i + 1) * (j + 1)
</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>### 8. 指针<br><br>- **最基本的作用：管理地址信息**<br><br>  - 管理数据<br>  - 调用代码<br><br>- 定义<br><br>  - 格式：&lt;基类型&gt; *&lt;指针变量&gt; 例：int *p;<br><br>  - 使用typedef定义一个指针类型<br><br>    ```c++<br>    typedef int* pointer;<br>    pointer p, q;//p,q均是指针变量<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作符</p>
<ul>
<li><p>&amp;取地址，*间接取内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">9</span>;<br><span class="hljs-type">int</span> *p;<br>p = &amp;x;<br>*p = <span class="hljs-number">1000</span>;<span class="hljs-comment">//p存储的是x的内容，*p间接获得x的内容</span><br><span class="hljs-comment">//x的地址是0X5212，x的内容是9，p的地址是0X7B77，p的内容是x的地址0X5212，*p就是x的内容</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>NULL和nullptr区别，在C++中，NULL代表0，nullptr代表空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;This is a NULL example&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *num)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;This is a nullptr example&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>);<br>	<span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br><span class="hljs-comment">// 输出结果为</span><br><span class="hljs-comment">// This is a NULL example</span><br><span class="hljs-comment">// This is a nullptr example</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>指针运算</p>
<ul>
<li><p>赋值</p>
<ul>
<li>同类型赋值</li>
</ul>
</li>
<li><p>+/- 整形</p>
<ul>
<li><p>结果类型不变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x; <span class="hljs-type">int</span> *p;<br>p = p + <span class="hljs-number">1</span>;<br>p = &amp;x + <span class="hljs-number">2</span>;<br>p++; p--;<br></code></pre></td></tr></table></figure>
</li>
<li><p>数值：sizeof(基类型) * 整型数值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * p; <span class="hljs-type">double</span> * q;<br>p++;  <span class="hljs-comment">//p的值加4</span><br>q++;  <span class="hljs-comment">//q的值加8</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>同类型指针相减</p>
<ul>
<li><p>结果类型：整形</p>
</li>
<li><p>数值：偏移量    </p>
<ul>
<li>值差/sizeof(基类型)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p, *q, offset;<br><span class="hljs-type">int</span> A[<span class="hljs-number">12</span>];<br>p = &amp;A[<span class="hljs-number">0</span>];<br>q = &amp;A[<span class="hljs-number">3</span>];<br>offset = q - p;<span class="hljs-comment">//offfset = 3</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>同类型指针比较</p>
<ul>
<li>==、!=</li>
</ul>
</li>
<li><p>输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> *p = &amp;x;<br>cout &lt;&lt; p;  <span class="hljs-comment">//x的地址</span><br>cout &lt;&lt; *p; <span class="hljs-comment">//x的值</span><br><br><span class="hljs-comment">//特例</span><br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;ABCD&quot;</span>;<br>cout &lt;&lt; p; 	 <span class="hljs-comment">//p指向的字符串，ABCD</span><br>cout &lt;&lt; *p;  <span class="hljs-comment">//p指向的字符，A</span><br>cout &lt;&lt; (<span class="hljs-type">int</span> *)p <span class="hljs-comment">//p的值，非char*</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>void *</p>
<ul>
<li><p>只管理地址信息</p>
</li>
<li><p>任何一种指针类型都能赋值给void <em>，void </em>是所有指针类型的公共接口</p>
</li>
<li><p>任何操作都要做<strong>强制类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将某块内存清零</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *pointer, <span class="hljs-type">unsigned</span> size)</span> </span>&#123;<br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)pointer;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; size; k++) &#123;<br>        *p++ = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;     <br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常量指针</p>
<ul>
<li><p>一般形式 const &lt;类型&gt; * &lt;指针变量&gt;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cp;<br><span class="hljs-type">int</span> y = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> *q;<br>cp =&amp;c;		<span class="hljs-comment">//√</span><br>q = &amp;y;		<span class="hljs-comment">//√</span><br>*cp = <span class="hljs-number">1</span>;	<span class="hljs-comment">//×</span><br>*q = <span class="hljs-number">2</span>;		<span class="hljs-comment">//√</span><br>cp = &amp;y;	<span class="hljs-comment">//√，用于消除函数副作用</span><br>q = &amp;c;		<span class="hljs-comment">//×</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>不能把一个有读写权力的指针赋值给只有读权力的地址</p>
<ul>
<li>不能用普通指针指向常量</li>
</ul>
</li>
<li><p>const_cast可以取消常量属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> c=<span class="hljs-number">128</span>;<br><span class="hljs-type">int</span> * q = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(&amp;c);<br>*q = <span class="hljs-number">111</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot; c &quot;</span> &lt;&lt; &amp;c &lt;&lt; c &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot; q &quot;</span> &lt;&lt; &amp;q &lt;&lt; q &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*q &quot;</span> &lt;&lt; q &lt;&lt; *q &lt;&lt; endl;<br><span class="hljs-comment">//c      0012FF74    128  为什么？</span><br><span class="hljs-comment">//q      0012FF70    0012FF74</span><br><span class="hljs-comment">//*q     0012FF74    111</span><br></code></pre></td></tr></table></figure>
<ul>
<li>编译器编译时已经把c换成字面常量128</li>
</ul>
</li>
</ul>
</li>
<li><p>指针常量</p>
<ul>
<li>一般形式 &lt;类型&gt; * const &lt;指针变量&gt; 必须在定义时初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x,y;<br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;x;<br>p = &amp;y;<span class="hljs-comment">//错误</span><br>*p = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>指针与数组</p>
<ul>
<li>数据升降维</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">void</span>(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n);<span class="hljs-comment">//此时的A是一个指针常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">12</span>];<br>    <span class="hljs-built_in">f</span>(a,<span class="hljs-number">12</span>);<br>    <span class="hljs-comment">//此时的a已经转化为一个int *const表达式，失去了原来数组的含义</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">12</span>];<br><span class="hljs-type">int</span> *p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">12</span>;i++)&#123;<br>    *(p++) = <span class="hljs-number">0</span>;<br>    *(a + i) = <span class="hljs-number">0</span>;<br>    *(a++) = <span class="hljs-number">0</span>;<span class="hljs-comment">//该写法错误</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622003704361.png" alt="image-20220622003704361" style="zoom:80%;" /></p>
<h3 id="9-动态变量"><a href="#9-动态变量" class="headerlink" title="9. 动态变量"></a>9. 动态变量</h3><ul>
<li><p>申请</p>
<ul>
<li>new</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622011214723.png" alt="image-20220622011214723" style="zoom:80%;" /></p>
<ul>
<li>new vs malloc<ul>
<li>强制类型转换、构造函数</li>
</ul>
</li>
</ul>
</li>
<li><p>归还</p>
<ul>
<li>delete</li>
<li>delete[]</li>
</ul>
</li>
</ul>
<h3 id="10-函数指针、泛型"><a href="#10-函数指针、泛型" class="headerlink" title="10. 函数指针、泛型"></a>10. 函数指针、泛型</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622183805313.png" alt="image-20220622183805313" style="zoom:80%;" /></p>
<h3 id="11-引用"><a href="#11-引用" class="headerlink" title="11. 引用"></a>11. 引用</h3><ul>
<li>定义：<strong>为一块已有的内存空间取一个别名</strong><ul>
<li>引用变量和被引用变量，必须是同类型</li>
<li>引用变量定义中的&amp;不是取地址操作符</li>
<li>定义引用变量时，<strong>必须初始化</strong></li>
</ul>
</li>
<li>应用<ul>
<li>函数参数传递</li>
<li>动态变量命名</li>
</ul>
</li>
<li>函数返回值类型为引用<ul>
<li>注：<strong>不能返回局部变量的引用</strong></li>
</ul>
</li>
</ul>
<h2 id="面向对象部分"><a href="#面向对象部分" class="headerlink" title="面向对象部分"></a>面向对象部分</h2><h3 id="1-OOP"><a href="#1-OOP" class="headerlink" title="1. OOP"></a>1. OOP</h3><ul>
<li>Cfront编译之后（C++ —&gt; C）还是变成和c一样的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>  --&gt;  <span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack * <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> i)</span></span><br></code></pre></td></tr></table></figure>
<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h3><ul>
<li><strong>类的定义和声明是分开的，类声明的头文件仅仅给出接口部分</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类的声明 a.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TDate</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d)</span></span>;<br>    	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsLeapYear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-type">int</span> year,month,day;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类的定义 a.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TDate::SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    year = y;<br>    month = m;<br>    day = d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TDate::IsLeapYear</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (year%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year%<span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>定义在类内部的函数是隐式的<strong>inline</strong>函数</li>
</ul>
<h4 id="2-1-声明方法"><a href="#2-1-声明方法" class="headerlink" title="2.1 声明方法"></a>2.1 声明方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">TDate g; <span class="hljs-comment">//保存在全局静态区，已经初始化好，g不是引用就是一个对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    g.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <br>    TDate t;<span class="hljs-comment">//保存在栈</span><br>    t.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">11</span>, <span class="hljs-number">17</span>);<br>    <br>    TDate *p = <span class="hljs-keyword">new</span> TDate;<span class="hljs-comment">//保存在堆</span><br>    p-&gt;<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">11</span>, <span class="hljs-number">17</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-构造函数"><a href="#2-2-构造函数" class="headerlink" title="2.2 构造函数"></a>2.2 构造函数</h4><ul>
<li><p>功能</p>
<ul>
<li>给创建的对象建立标识符</li>
<li>为数据成员开辟内存空间</li>
<li>根据规定进行初始化</li>
</ul>
</li>
<li><p>默认构造函数不会对成员变量初始化</p>
<ul>
<li>c++11规定，对于未指定默认初始化的堆、栈中的变量，是一个不确定的值，不会进行初始化。而全局变量，静态变量会被初始化为0</li>
</ul>
</li>
<li><p>对象的<strong>初始化</strong>，构造函数可以被定义，也可以只声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br>      <span class="hljs-built_in">Line</span>();  <span class="hljs-comment">// 这是构造函数</span><br> <br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;<br>&#125;;<br> <br><span class="hljs-comment">// 成员函数定义，包括构造函数</span><br>Line::<span class="hljs-built_in">Line</span>(<span class="hljs-type">void</span>)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Line::setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span><br><span class="hljs-function"></span>&#123;<br>    length = len;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Line::getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br><span class="hljs-comment">// 程序的主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>   Line line;<br>   <span class="hljs-comment">// 设置长度</span><br>   line.<span class="hljs-built_in">setLength</span>(<span class="hljs-number">6.0</span>); <br>   cout &lt;&lt; <span class="hljs-string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="hljs-built_in">getLength</span>() &lt;&lt;endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br><span class="hljs-comment">//Object is being create</span><br><span class="hljs-comment">//6.0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>描述</p>
<ul>
<li><p>与类同名，<strong>无返回类型</strong>，构造函数可以<strong>有参数</strong>，初始化要带参数，比如上面的Line类的构造函数可以改为Line(double  len)，构造函数的定义改为将length初始化为len</p>
</li>
<li><p>自动调用，不可以直接调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">A</span>();<br>    	<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i);<br>    	<span class="hljs-built_in">A</span>(<span class="hljs-type">char</span> *p);<br>&#125;;<br>A a1 = <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//等价于A a1(a) //等价于A a1=1;	自动调用A(int i);</span><br>A a2 = <span class="hljs-built_in">A</span>();<span class="hljs-comment">//等价于A a2;	调用A(),不能写成A a2();</span><br>A a3 = <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<span class="hljs-comment">//等价于A a3(&quot;abcd&quot;) //等价于 A a3 = &quot;abcd&quot;	调用A (char *p)</span><br>A a[<span class="hljs-number">4</span>];<span class="hljs-comment">//调用a[0],a[1],a[2],a[3]的A()</span><br>A b[<span class="hljs-number">5</span>] = &#123;<span class="hljs-built_in">A</span>(), <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>), <span class="hljs-number">2</span>, <span class="hljs-string">&quot;xyz&quot;</span> &#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可重载</p>
</li>
<li><p>当类中没有提供构造函数时，编译系统自动提供</p>
</li>
<li><p>一般声明为public，但也可以定义为private</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-成员初始化表"><a href="#2-3-成员初始化表" class="headerlink" title="2.3 成员初始化表"></a>2.3 成员初始化表</h4><ul>
<li><p>构造函数的补充</p>
</li>
<li><p>先于构造体函数执行，<strong>按类数据成员声明次序</strong>，减轻compiler的负担</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span>    x;<br>    <span class="hljs-type">const</span>  <span class="hljs-type">int</span>   y;<br>    <span class="hljs-type">int</span>&amp; z;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">A</span>(): <span class="hljs-built_in">y</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">z</span>(x), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>)  &#123;  x = <span class="hljs-number">100</span>; &#125; <span class="hljs-comment">//按照xyz顺序初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li>构造函数中尽量使用成员初始化表代替赋值动作</li>
<li>数据成员太多时，不要使用，降低了可维护性</li>
</ul>
</li>
<li><p>c++98只有static const成员可以在类内部直接初始化<br>c++11允许非静态成员在声明处初始化</p>
</li>
</ul>
<h4 id="2-4-析构函数"><a href="#2-4-析构函数" class="headerlink" title="2.4 析构函数"></a>2.4 析构函数</h4><ul>
<li><p>结构：~类名()</p>
</li>
<li><p>对象消亡时，系统自动调用，释放对象持有的非内存资源</p>
</li>
<li><p>一般声明在public中，也可以声明在private中</p>
</li>
<li><p>没有返回值，不接受参数（不能重载）</p>
</li>
<li><p>声明为private：不能在栈上创建对象，只能通过new在堆上创建对象，通过实现一个public的方法来调用析构函数进行释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">A</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>更好的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(A *p)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br>A::<span class="hljs-built_in">free</span>(P);<br></code></pre></td></tr></table></figure>
<p>优点：可以强制自主控制对象存储分配</p>
</li>
<li><p>静态绑定，避免内存泄漏，基类析构函数需要声明为virtual</p>
</li>
</ul>
<h4 id="2-5-拷贝构造函数"><a href="#2-5-拷贝构造函数" class="headerlink" title="2.5 拷贝构造函数"></a>2.5 拷贝构造函数</h4><ul>
<li><p>创建对象时，用一同类的对象对其初始化</p>
</li>
<li><p>自动调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明</span><br>A a;<br>A b = a; <span class="hljs-comment">//等价于A b(a);</span><br><span class="hljs-comment">//传参</span><br><span class="hljs-built_in">f</span>(A a) &#123;...&#125;<br>A b;<br><span class="hljs-built_in">f</span>(b);<br><span class="hljs-comment">//返回值</span><br><span class="hljs-function">A <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    ...<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>声明</p>
<p>  public:</p>
<pre><code>  A(const A&amp; a); //为什么要写引用: 如果不写，传参本身就要调用拷贝构造
</code></pre></li>
<li><p>默认拷贝构造函数执行的是浅拷贝，一旦对象存在了动态成员，浅拷贝会出问题。此时要使用深拷贝</p>
</li>
<li><p>参考网址： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8459250.html">https://www.cnblogs.com/alantu2018/p/8459250.html</a> </p>
</li>
<li><p>例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-type">char</span> *p;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">string</span>(<span class="hljs-type">char</span> *str)&#123;<br>            p=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,str);<br>        &#125;<br>    	~<span class="hljs-built_in">string</span>()&#123;<br>            <span class="hljs-keyword">delete</span>[] p;<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>    string s2=s1;<br>    <span class="hljs-comment">//浅拷贝：s2和s1这两个指针指向堆里的同一空间，再销毁对象时，两个对象的析构函数将同一个内存空间释放两次，这就是错误所在</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-type">char</span> *p;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">string</span>(<span class="hljs-type">char</span> *str)&#123;<br>            p=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,str);<br>        &#125;<br>    	<span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string &amp; c)&#123;<br>            p=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(c.p)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,c.p);<br>        &#125;<br>    	~<span class="hljs-built_in">string</span>()&#123;<br>            <span class="hljs-keyword">delete</span>[] p;<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>    string s2=s1;<br>    <span class="hljs-comment">//深拷贝：s1和s2各自指向一段内存空间，他们指向的空间具有相同的内容</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>包含成员对象的类</strong></p>
<ul>
<li>调用默认拷贝构造函数<ul>
<li>调用成员对象的<strong>拷贝构造函数</strong></li>
</ul>
</li>
<li>自定义拷贝构造函数<ul>
<li>调用成员对象的<strong>默认构造函数</strong></li>
<li>避免上面情况可以使用类似<strong>成员初始化表</strong>方式显式调用构造函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-6-拷贝赋值函数"><a href="#2-6-拷贝赋值函数" class="headerlink" title="2.6 拷贝赋值函数"></a>2.6 拷贝赋值函数</h4><ul>
<li><p>类似拷贝构造</p>
</li>
<li><p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp; other_a) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-7-移动构造函数"><a href="#2-7-移动构造函数" class="headerlink" title="2.7 移动构造函数"></a>2.7 移动构造函数</h4><ul>
<li><p>引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp; y = x;<br><span class="hljs-comment">//int &amp; y = 5; 不允许，只能使用const引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; z = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; z = x;<br></code></pre></td></tr></table></figure>
</li>
<li><p>右值引用（A&amp;&amp;）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int &amp;&amp; a = num;不允许，右值引用不能初始化为左值</span><br><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<span class="hljs-comment">//可以进行修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">10</span>;<span class="hljs-comment">//编译器不会报错，支持定义常量右值引用</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string::<span class="hljs-built_in">string</span> (string &amp;&amp; s) : <span class="hljs-built_in">p</span>(s.p) &#123;<br>    s.p = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">generate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>&#125;<br><span class="hljs-comment">//string s = generate();</span><br>string &amp;&amp; s = <span class="hljs-built_in">generate</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>编译器会合成默认的移动构造函数，<strong>前提</strong>：</p>
<ul>
<li>没有自定义<strong>拷贝构造函数</strong>，<strong>拷贝赋值函数</strong><ul>
<li>移动构造目的是为了降低拷贝代价</li>
<li>定义了拷贝构造说明有一种特定的拷贝行为，移动也会有一种特定行为</li>
</ul>
</li>
<li>没有自定义<strong>析构函数</strong><ul>
<li>对申请的资源进行释放，自定义说明申请了额外的资源</li>
<li>对于这部分资源编译器不知道如何拷贝，移动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-8-移动赋值函数"><a href="#2-8-移动赋值函数" class="headerlink" title="2.8 移动赋值函数"></a>2.8 移动赋值函数</h4><ul>
<li><p>类似移动构造</p>
</li>
<li><p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A &amp;<span class="hljs-keyword">operator</span>=(A &amp;&amp; a);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-9-拷贝构造和移动构造举例"><a href="#2-9-拷贝构造和移动构造举例" class="headerlink" title="2.9 拷贝构造和移动构造举例"></a>2.9 拷贝构造和移动构造举例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">http:<span class="hljs-comment">//c.biancheng.net/view/7847.html</span><br></code></pre></td></tr></table></figure>
<h3 id="3-动态内存"><a href="#3-动态内存" class="headerlink" title="3. 动态内存"></a>3. 动态内存</h3><h4 id="3-1-动态对象"><a href="#3-1-动态对象" class="headerlink" title="3.1 动态对象"></a>3.1 动态对象</h4><ul>
<li>在heap（堆）中创建</li>
<li><p>new/delete</p>
<ul>
<li><strong>使用new和delete可以自动调用constructor和destructor</strong></li>
</ul>
</li>
<li><p>new可重载</p>
</li>
<li>malloc和free不调用构造函数和析构函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A *p,*q;<br>p = <span class="hljs-keyword">new</span> A;     <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 在程序的heap中申请一块大小为sizeof(A)的内存</span><br><span class="hljs-comment">2. 调用A的默认构造函数对该空间上的对象初始化</span><br><span class="hljs-comment">3. 返回创建的对象的地址并赋值给p</span><br><span class="hljs-comment">*/</span><br><br>q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);   <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. ……	</span><br><span class="hljs-comment">2. 调用A的另一个构造函数 A::A(int)</span><br><span class="hljs-comment">3. ……</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">delete</span>  p; 	<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 调用p所指向的对象的析构函数</span><br><span class="hljs-comment">2. 释放对象空间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">delete</span> q;	<br></code></pre></td></tr></table></figure>
<ul>
<li><p>对象删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> intPtr;<br>intPtr = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-动态对象数组"><a href="#3-2-动态对象数组" class="headerlink" title="3.2 动态对象数组"></a>3.2 动态对象数组</h4><ul>
<li><p>创建与撤销</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A *p;<br>p = <span class="hljs-keyword">new</span> A[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">delete</span> []p;<br><br><span class="hljs-type">int</span> *q;<br>q = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">delete</span> q;<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li><p><strong>不能显式初始化，相应的类必须有默认构造函数</strong></p>
<ul>
<li><p>c++11引入统一初始化表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123;&#125;<br>&#125;;<br>A * p = <span class="hljs-keyword">new</span> A[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>delete中的<strong>[]</strong>不能省</p>
<ul>
<li>自定义对象数组前4个字节用来存储数组长度，因为要调用析构函数</li>
<li>普通类型因为不调用析构函数，不用存储，可以直接delete，也可以delete[]</li>
</ul>
</li>
</ul>
</li>
<li><p>动态2D数组</p>
<ul>
<li><p>普通申请方式会有指针的额外内存开销</p>
</li>
<li><p>可以使用一维数组申请，然后进行换算（<strong>通过下标操作符的重载</strong>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">12</span>];<br>a[i][j]  --&gt;  a[i * <span class="hljs-number">4</span> + j]<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="4-特殊成员"><a href="#4-特殊成员" class="headerlink" title="4. 特殊成员"></a>4. 特殊成员</h3><h4 id="4-1-Const成员"><a href="#4-1-Const成员" class="headerlink" title="4.1 Const成员"></a>4.1 Const成员</h4><ul>
<li><p>const成员变量</p>
<ul>
<li>初始化必须放在构造函数的<strong>成员初始化表</strong>中进行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    	<span class="hljs-type">const</span> <span class="hljs-type">int</span> x;<br>    	<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> y = <span class="hljs-number">100</span>;<span class="hljs-comment">//static const必须在声明的地方初始化</span><br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> c): <span class="hljs-built_in">x</span>(c) &#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>const成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//a.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123; <br>        <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//a.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  x = <span class="hljs-number">1</span>; y = <span class="hljs-number">1</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;  cout &lt;&lt;x &lt;&lt; y;&#125;<br><br><span class="hljs-comment">//b.cpp</span><br><span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">//a.f(); 不允许</span><br>a.<span class="hljs-built_in">show</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li><p>如果把f()也标记为const，如何分辨呢</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">( A * <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">const</span> A* <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>引用指向的值可以更改，因为引用本身没有改变</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> &amp; indirect_int;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>():<span class="hljs-built_in">indirect_int</span>(*<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)&#123; ... &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; <span class="hljs-keyword">delete</span> &amp;indirect_int; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; indirect_int++; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>mutable</strong>关键字</p>
<ul>
<li>可以在const成员函数中修改被mutable修饰的变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-静态成员"><a href="#4-2-静态成员" class="headerlink" title="4.2 静态成员"></a>4.2 静态成员</h4><ul>
<li><p>静态成员变量</p>
<ul>
<li>类对象所共享</li>
<li>唯一拷贝</li>
<li>遵循类访问控制</li>
<li>不随对象创建而分配内存，也不随对象销毁而销毁，保存在全局静态区，程序结束才释放内存</li>
</ul>
</li>
<li><p>静态成员变量必须在类声明的<strong>外部初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>  	<span class="hljs-type">int</span> x, y;<br>  	<span class="hljs-type">static</span> <span class="hljs-type">int</span> shared;<br>&#125;;<br><span class="hljs-type">int</span> A::shared = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>静态成员函数</p>
<ul>
<li>静态成员函数只能访问<strong>静态成员</strong>（变量，函数）</li>
<li>遵循类访问控制</li>
<li>静态成员函数与普通成员函数的根本区别在于<ul>
<li>普通成员函数有 <strong>this 指针</strong>，可以<strong>访问类中的任意成员</strong></li>
<li>而静态成员函数<strong>没有 this 指针</strong>，只能访问静态成员（包括静态成员变量和静态成员函数）。 </li>
</ul>
</li>
</ul>
</li>
<li><p>静态成员的使用</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A a;<br>a.<span class="hljs-built_in">f</span>();<span class="hljs-comment">//通过对象使用</span><br>    <br>A::<span class="hljs-built_in">f</span>();<span class="hljs-comment">//通过类使用</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>静态成员函数常用于：控制对象创建</p>
<ul>
<li>eg：单例模式</li>
</ul>
</li>
</ul>
<h4 id="4-3-友元"><a href="#4-3-友元" class="headerlink" title="4.3 友元"></a>4.3 友元</h4><ul>
<li><p>类外部不能访问该类的private成员</p>
<ul>
<li>通过public方法<ul>
<li>会降低对private成员的访问效率，缺乏灵活性</li>
</ul>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元类成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//友元函数,可以不提前声明</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;         <span class="hljs-comment">//友元类</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">C::f</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//友元类成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>特性</p>
<ul>
<li><p>友元不具有传递性</p>
<ul>
<li>```c++<br>class Matrix{<pre><code>friend void multiply(Matrix &amp;m, Vector &amp;v, Vector &amp;r);
</code></pre>};<br>class Vector{<pre><code>friend void multiply(Matrix &amp;m, Vector &amp;v, Vector &amp;r);
</code></pre>};<br>//定义在两个类中的友元是单独针对Matrix或者Vector类的，两个不互通<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- 上述代码不能编译通过，需要进行**前置声明**<br><br>  ```c++<br>  class Vector;<br>  void multiply(Matrix &amp;m, Vector &amp;v, Vector &amp;r);<br>  ...<br>  //函数必须使用引用，因为通过第一行不知道Vector有多大，如果不使用引用需要使用拷贝，所以会出错，而引用的大小是一致的<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>C++11之后可以访问private成员</p>
</li>
<li><p>重点：<strong>先声明后使用</strong></p>
</li>
</ul>
</li>
<li><p>原则</p>
<ul>
<li><p>避免将数据成员放在公开接口中</p>
</li>
<li><p>努力将接口完满且最小化</p>
</li>
<li><p>```c++<br>class AccessLevels {<br>public:<br>   int getReadOnly const { return readOnly; }<br>   void setReadWrite(int value) { readWrite = value; }<br>   int getReadWrite() { return readWrite; }<br>   void setWriteOnly(int value) { writeOnly = value; }<br>private:<br>   int noAccess;<br>   int readOnly;<br>   int readWrite;<br>   int writeOnly;<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- 作用<br><br>  - 提高程序设计的灵活性<br>  - 数据保护和对数据的存取效率之间的一个折中方案<br><br>### 5. 继承<br><br>- 继承机制<br>  - 基于目标代码的复用<br>  - 对事物进行分类<br>  - 增量开发<br><br>#### 5.1 单继承<br><br>- 单继承<br><br>  - protected<br><br>    - 派生类的**成员函数**可以访问基类的保护成员<br>    - 派生类/基类的**对象**都不能访问保护成员，在对象中相当于private<br><br>  - 子类无法继承父类的构造函数，友元函数，析构函数<br><br>  - ```c++<br>    class Student&#123;       <br>      int id; <br>      public:<br>        char nickname[16];<br>        void set_ID(int x)  &#123; id = x; &#125;<br>        void SetNickName(char* s) &#123; strcpy(nickname,s);&#125; <br>        virtual void showInfo() <br>        &#123; cout &lt;&lt; nickname &lt;&lt; &quot;:&quot; &lt;&lt; id &lt;&lt;endl; &#125;<br>      	//virtual使得函数可以被动态重载<br>    &#125;;<br>    //父类的变量子类同样拥有，可以通过sizeof验证<br>    //子类中父类已经定义元素的访问权限与父类相同<br>    class Undergraduated_Student : public Student&#123;      <br>      int dept_no; <br>      public:<br>      	void setDeptNo(int x) &#123; dept_np = x; &#125;<br>      	void set_ID(int x)&#123;<br>          //函数重定义（静态的，并非动态）,但不是同一个名空间<br>        &#125;<br>      	void showInfo()&#123;<br>          cout &lt;&lt; dept_no &lt;&lt; &quot;:&quot; &lt;&lt; nickname &lt;&lt; &quot;:&quot; &lt;&lt; id &lt;&lt;endl; <br>        &#125;<br>      private:<br>        using Student::nickname; //Undergraduated_Student的派生类不能再访问nickname，由于权限变成private<br>      	void SetNickName(); <br>      	//编译器：1.找名字（可以调用则调用，否则不调用）；2.在子类中找到了SetNickName的名空间，就不会去父类找（名空间覆盖）；3.子类SetNickName名空间没有匹配char* s的函数，因此调用失败<br>    &#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>友元和protected</p>
<ul>
<li>友元不具有传递性</li>
<li>派生类可以访问<strong>基类</strong>的保护成员，但不能访问<strong>基类对象</strong>的保护成员</li>
</ul>
</li>
<li><p>基类构造函数的调用</p>
<ul>
<li><p>缺省执行基类默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;    <br>  <span class="hljs-type">int</span> x;<br>  <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>() &#123; x = <span class="hljs-number">0</span>; &#125;<br>     <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;   <br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">B</span>() &#123; y = <span class="hljs-number">0</span>; &#125;<br>   <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i) &#123; y = i; &#125;<br>   <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j):<span class="hljs-built_in">A</span>(i) <br>   &#123;   y = j;  &#125;<br>&#125;;<br><br>B b1; 	    <span class="hljs-comment">//执行A::A()和B::B()</span><br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; 	   <span class="hljs-comment">//执行A::A()和B::B(int)</span><br><span class="hljs-function">B <span class="hljs-title">b3</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//执行A::A(int)和B::B(int,int)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>没有指明基类如何拷贝且自定义派生类的拷贝构造函数，则会执行基类的默认构造函数<br>如何指明调用基类拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B &amp; b) : <span class="hljs-built_in">A</span>(b) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造函数不能继承</p>
<ul>
<li><p>但如果派生类成员很少，基类很多会很麻烦<br>解决方法（语法糖）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-keyword">using</span> A::A <span class="hljs-comment">//继承A的构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造函数执行次序</p>
<ul>
<li>基类的构造函数</li>
<li>派生类对象成员类的构造函数</li>
<li>派生类的构造函数</li>
</ul>
</li>
</ul>
<h4 id="5-2-虚函数"><a href="#5-2-虚函数" class="headerlink" title="5.2 虚函数"></a>5.2 虚函数</h4><ul>
<li><p>类型相容</p>
<ul>
<li><p>对象切片</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>a = b;<br></code></pre></td></tr></table></figure>
<p>b的占用空间会比a大，执行a=b时会有信息丢失</p>
<p>实现上：调用拷贝赋值函数（A的），不包含B的信息</p>
</li>
</ul>
</li>
<li><p>前期绑定</p>
<ul>
<li>编译时刻</li>
<li>依据对象的静态类型</li>
<li>效率高、灵活性差</li>
</ul>
</li>
<li><p>动态绑定</p>
<ul>
<li>运行时刻</li>
<li>依据对象的实际类型</li>
<li>灵活性高、效率差</li>
</ul>
</li>
<li><p>限制</p>
<ul>
<li>类的成员函数才可以是虚函数</li>
<li>静态成员函数不能是虚函数</li>
<li>内联成员函数不能是虚函数</li>
<li>构造函数不能是虚函数</li>
<li>析构函数可以（往往）是虚函数</li>
</ul>
</li>
<li><p>后期绑定的实现</p>
<ul>
<li><p>虚函数表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A a; B b;<br>A *p;<br>(**((<span class="hljs-type">char</span> *)p - <span class="hljs-number">4</span>))(p)<br><span class="hljs-comment">//函数调用 (p) -- 参数, this</span><br>(<span class="hljs-type">char</span> *)p - <span class="hljs-number">4</span> : 指向虚函数表的指针<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//基类中声明即可</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>构造函数完成后才有虚函数表</strong>，因此完成前virtual不生效，调用构造函数所属类的函数</p>
</li>
<li><p><strong>final，override</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span> <span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span> <span class="hljs-params">()</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f5</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">final</span></span>;<br><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span>: B &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>;<span class="hljs-comment">//正确： f1与基类中的f1 匹配 </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span> </span>;<span class="hljs-comment">//错误： B没有形如f2(int) 的函数。int f2()？</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span> <span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>;<span class="hljs-comment">//错误： f3不是虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f4</span> <span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>;<span class="hljs-comment">//错误： B没有名为f4的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f5</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>;<span class="hljs-comment">//错误： B已经将f5声明成final</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>纯虚函数和抽象类<ul>
<li>纯虚函数<ul>
<li>声明时在函数原型后面加上<strong>=0</strong></li>
<li>往往只给出函数声明，不给出实现</li>
<li>虚函数表中留位置但没有地址，直到派生类重写</li>
</ul>
</li>
<li>抽象类<ul>
<li>至少包含一个纯虚函数</li>
<li>不能用于创建对象</li>
<li>为派生类提供框架</li>
</ul>
</li>
<li>应用：抽象工厂模式</li>
</ul>
</li>
<li>虚析构函数</li>
<li><strong>绝对不要重新定义继承而来的缺省参数值</strong><ul>
<li><strong>静态绑定</strong></li>
</ul>
</li>
<li><p>访问控制是静态绑定：</p>
<ul>
<li>即使派生类将父类的public方法改为private，通过父类指针或引用依然可以调用</li>
</ul>
</li>
</ul>
<h4 id="5-3-多继承"><a href="#5-3-多继承" class="headerlink" title="5.3 多继承"></a>5.3 多继承</h4><ul>
<li><p>基类的声明次序决定</p>
<ul>
<li>对基类构造函数/析构函数的调用次序</li>
<li>对基类数据成员的存储安排</li>
</ul>
</li>
<li><p>名冲突</p>
<ul>
<li>&lt;基类名&gt;::&lt;基类成员名&gt;</li>
</ul>
</li>
<li><p><strong>虚继承、虚基类</strong></p>
<ul>
<li><p>问题：如果直接基类有公共的基类，则该公共基类中的成员变量再多继承的派生类中有多个副本</p>
</li>
<li><p>解决：虚继承</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> A;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: B, C;<br></code></pre></td></tr></table></figure>
<ul>
<li>实现：创建虚基类，虚继承的派生类持有虚基类的指针</li>
</ul>
</li>
<li><p>虚基类的构造函数由最新派生出的类的构造函数调用（D构造A）</p>
</li>
<li><p>虚基类的构造函数优先于非虚基类的构造函数执行</p>
</li>
</ul>
</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>一名多用：函数重载</li>
<li>类属：template</li>
<li>OO程序设计：虚函数</li>
</ul>
<h3 id="1-操作符重载"><a href="#1-操作符重载" class="headerlink" title="1. 操作符重载"></a>1. 操作符重载</h3><h4 id="1-1-一般操作符重载"><a href="#1-1-一般操作符重载" class="headerlink" title="1.1 一般操作符重载"></a>1.1 一般操作符重载</h4><ul>
<li><p>歧义控制：</p>
<ul>
<li>顺序</li>
<li>更好匹配（整型提升 eg. bool -&gt; int）</li>
</ul>
</li>
<li><p>不允许重载：</p>
<ul>
<li>.     .*    ::    ?:</li>
</ul>
</li>
<li>成员函数默认第一个参数为this</li>
<li>全局函数作为补充</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//成员函数支持obj + 10,不支持10 + obj</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CL</span>&#123;<br>    <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">friend</span> CL operater+(<span class="hljs-type">int</span> i, CL&amp; a);    <br>    <span class="hljs-keyword">friend</span> CL operater+(CL&amp; a, <span class="hljs-type">int</span> i);    <br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>永远不要重载&amp;&amp;和||</p>
<ul>
<li><p>利用了短路机制，如果重载则两个表达式都会被计算，可能会出错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>((p != <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">strlen</span>(p) &gt; <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>有效率但不是过度有效率<br>一些例子：<br>+-*/一般使用拷贝即可，不需要引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational &amp; <span class="hljs-keyword">operator</span> *(<span class="hljs-type">const</span> Rational &amp; r) <span class="hljs-type">const</span>;<br><br>- <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(n*r.n, d*r.d); <span class="hljs-comment">//有&amp;临时变量无法赋给引用，无&amp;时在返回处创建对象不会发生拷贝</span><br><br>- Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(n*r.n, d*r.d); <span class="hljs-comment">//连乘会有内存泄漏</span><br>  <span class="hljs-keyword">return</span> *result;<br><br>- <span class="hljs-type">static</span> Rational result; <span class="hljs-comment">//不能同时利用 eg. if((a*b) == (c*d))</span><br>  result.n = n*r.n;<br>  result.d = d*r.d;<br>  <span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure>
</li>
<li><p>++a与a++</p>
<ul>
<li><p>++a返回的是左值，可以继续调用函数</p>
</li>
<li><p>a++仅仅返回一个值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>&#123;<br>  <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Counter</span>() &#123;value = <span class="hljs-number">0</span>;&#125;<br>  Counter&amp; <span class="hljs-keyword">operator</span>++() &#123; <span class="hljs-comment">// ++a</span><br>      value++;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  Counter <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// a++  //dummy argument哑元参数</span><br>      Counter temp = *<span class="hljs-keyword">this</span>;<br>      value++;<br>      <span class="hljs-keyword">return</span> temp;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-特殊操作符重载"><a href="#1-2-特殊操作符重载" class="headerlink" title="1.2 特殊操作符重载"></a>1.2 特殊操作符重载</h4><h5 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2.1 ="></a>1.2.1 =</h5><ul>
<li><p>为了支持链式赋值，要返回同类型引用，即*this</p>
</li>
<li><p>返回类型是否要加const，不要加，否则：</p>
<ul>
<li>支持a=b=c</li>
<li>不支持(a=b).f()</li>
</ul>
</li>
<li><p>A a = b; 调用拷贝构造函数</p>
</li>
<li><p>A a，b；a=b；调用=操作符重载</p>
</li>
<li><p>赋值到一半失败了（例如分配内存时内存不够），且已经发生了更改</p>
<ul>
<li><p>先赋值后释放（还可以解决自我赋值问题）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> *pOrig = p;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[...];<br><span class="hljs-built_in">strcpy</span>(...);<br><span class="hljs-keyword">delete</span>[] pOrig;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1.2.2 []"></a>1.2.2 []</h5><ul>
<li><p>问题：对于 非常量 希望返回char &amp;（更改），对于 常量 希望返回const char（不更改，只显示）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> i); <span class="hljs-comment">//string * const this</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;  <span class="hljs-comment">//可以重载,const string * const this</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>多维数组</p>
<ul>
<li>使用wrapper</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array2D</span>&#123; <br>  <span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">Array1D</span>&#123;  <br>      <span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Array1D</span>(<span class="hljs-type">int</span> *p) &#123; <span class="hljs-keyword">this</span>-&gt;p = p; &#125;<br>		<span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123; <span class="hljs-keyword">return</span> p[index]; &#125;<br>		<span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> p[index]; &#125;<br>	  <span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> *p;<br>	&#125;;<br>    <br>	<span class="hljs-built_in">Array2D</span>(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2) &#123; p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n1*n2]; num1 = n1; num2 = n2; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Array2D</span>() &#123; <span class="hljs-keyword">delete</span> [] p; &#125;<br>    <br>	Array1D <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index) &#123; <span class="hljs-keyword">return</span> p+index*num2; &#125;<br>	<span class="hljs-type">const</span> Array1D <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> p+index*num2; &#125;<br>    <br>  <span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> *p;<br>	<span class="hljs-type">int</span> num1, num2;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h5 id="1-2-3"><a href="#1-2-3" class="headerlink" title="1.2.3 ()"></a>1.2.3 ()</h5></li>
<li><p>函数调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br>Func f;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">2.4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) n / d;&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>若A -&gt; B<ul>
<li>B中构造函数有B(A)，同时A中定义了operator B()，会出错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="1-2-4-gt"><a href="#1-2-4-gt" class="headerlink" title="1.2.4 -&gt;"></a>1.2.4 -&gt;</h5><ul>
<li><p>无法确定参数类型</p>
<ul>
<li>重载时按一元操作符重载描述，返回指针类型、其他定义了-&gt;重载的对象</li>
</ul>
</li>
<li><p>智能指针</p>
<ul>
<li>程序运行时可能有多个出口，内存管理比较困难，可以使用一个封装类封装要使用的指针，在栈上创建</li>
<li>局限性：堆上创建的资源也要符合compiler控制的生命周期</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPointer</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmartPointer</span>(T *p=<span class="hljs-number">0</span>) :<span class="hljs-built_in">ptr</span>(p) &#123;&#125;<br>    ~<span class="hljs-built_in">SmartPointer</span>() &#123;<span class="hljs-keyword">delete</span> ptr;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br>    T&amp; <span class="hljs-keyword">operator</span> *() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125; <br><span class="hljs-keyword">private</span>:<br>    T* ptr;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="1-2-5-new、delete"><a href="#1-2-5-new、delete" class="headerlink" title="1.2.5 new、delete"></a>1.2.5 new、delete</h5></li>
</ul>
<ul>
<li><p>new的过程</p>
<ul>
<li>分配内存（只能重载这一步）</li>
<li>调用构造函数</li>
<li>返回对象指针</li>
</ul>
</li>
<li><p>delete的过程</p>
<ul>
<li>调用析构函数</li>
<li>确定指向分配空间的指针</li>
<li>释放内存（可重载）</li>
</ul>
</li>
<li><p>new、delete为静态成员，在对象创建之前，析构函数之后</p>
<ul>
<li>隐式静态，不需要显式声明（声明也没事）</li>
</ul>
</li>
<li><p>全局函数（所有内存分配）、成员函数（只对重载过的类有效，<strong>推荐</strong>）</p>
</li>
<li><p>可继承</p>
</li>
<li><p>new和new[]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size, ...)</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[] (<span class="hljs-type">size_t</span> size, ...);<br><span class="hljs-comment">//这两个是不同的、如果没有重载new[]，创建数组时依然使用全局默认的</span><br><span class="hljs-comment">//系统自动计算对象大小,并传值给size</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>delete</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-comment">//p:被撤销对象的地址</span><br><span class="hljs-comment">//第二个参数是被撤销对象的大小,可有可无</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>用途：内存池</p>
</li>
</ul>
<h3 id="2-模板template"><a href="#2-模板template" class="headerlink" title="2. 模板template"></a>2. 模板template</h3><h4 id="2-1-模板"><a href="#2-1-模板" class="headerlink" title="2.1 模板"></a>2.1 模板</h4><ul>
<li>源代码复用机制<ul>
<li>编译时代码实例化（eg. 将T换为int），根据类型不同<strong>复制</strong>为很多个版本</li>
<li>已经有的版本直接调用即可</li>
</ul>
</li>
<li><p>实例化</p>
<ul>
<li><p>函数模板</p>
<ul>
<li>隐式实现</li>
<li>根据具体模板函数调用</li>
</ul>
</li>
<li><p>类模板</p>
<ul>
<li>创建对象时显式指定</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>模板的完整定义通常出现在头文件中</li>
</ul>
<h4 id="2-2-函数模板（类属函数）"><a href="#2-2-函数模板（类属函数）" class="headerlink" title="2.2 函数模板（类属函数）"></a>2.2 函数模板（类属函数）</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622145754868.png" alt="image-20220622145754868" style="zoom:80%;" /></p>
<ul>
<li><p>隐式实例化：编译器会自动推导类型</p>
</li>
<li><p>使用自定义类型时，函数重载和函数模板同时使用</p>
</li>
<li><p>函数模板的参数</p>
<ul>
<li><p>可带多个类型参数，用逗号分隔</p>
</li>
<li><p>可带普通参数</p>
<ul>
<li><p>必须列在类型参数之后</p>
</li>
<li><p>调用时需显式实例化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T, <span class="hljs-type">int</span> size&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    T temp[size];<br>&#125;<br><br><span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-number">10</span>&gt;(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>默认参数：</p>
<ul>
<li>顺序可以任意，最好从右向左（与类模板一致）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U </span>= <span class="hljs-type">double</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t = <span class="hljs-number">0</span>, U u = <span class="hljs-number">0</span>)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;t=&quot;</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;u=&quot;</span> &lt;&lt; u &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;a&#x27;</span>);			<span class="hljs-comment">//调用test&lt;int, char&gt;(4, &#x27;a&#x27;)</span><br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">4</span>);				<span class="hljs-comment">//调用test&lt;int double&gt;(4, 0)</span><br>    <span class="hljs-built_in">test</span>(); 				<span class="hljs-comment">//编译失败，没有指明T的类型</span><br>    <span class="hljs-built_in">test</span>&lt;<span class="hljs-type">int</span>&gt;();			<span class="hljs-comment">//调用test&lt;int, double&gt;(0, 0)</span><br>    <span class="hljs-built_in">test</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;();		<span class="hljs-comment">//调用test&lt;int, char&gt;(0, 0)</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数模板与函数重载配合使用</p>
<ul>
<li>函数重载优先于函数模板</li>
</ul>
</li>
</ul>
<h4 id="2-3-类属类"><a href="#2-3-类属类" class="headerlink" title="2.3 类属类"></a>2.3 类属类</h4><ul>
<li>类定义带有类型参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>需要显式实例化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Stack&lt;<span class="hljs-type">int</span>&gt; st1;<br>Stack&lt;<span class="hljs-type">double</span>&gt; st2;<br></code></pre></td></tr></table></figure>
<ul>
<li>类模板的静态成员属于实例化后的类</li>
</ul>
<h3 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h3><ul>
<li><p>异常特征</p>
<ul>
<li>可以预见</li>
<li>无法避免</li>
</ul>
</li>
<li><p>throw</p>
<ul>
<li>调用拷贝构造函数</li>
<li>可以抛出指针，但不能指向局部变量</li>
</ul>
</li>
<li>catch<ul>
<li>精确匹配</li>
<li>允许派生类到基类的转换</li>
<li>自定义类使用引用，避免拷贝</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Base &amp; e)</span> </span>&#123;<br>    <span class="hljs-comment">//调用拷贝构造函数，发生对象切片</span><br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived e;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-built_in">f</span>(e);<br>    &#125;<span class="hljs-built_in">catch</span>(Derived &amp; e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span>;<br>    &#125;<span class="hljs-built_in">catch</span>(Base &amp; e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//输出Base</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>构造函数出现异常</p>
<ul>
<li><p>不能自己处理，要在try中new</p>
</li>
<li><p>初始化列表异常，不属于构造函数</p>
<ul>
<li><p>最好的方法，不在初始化列表new对象</p>
</li>
<li><p>```c++<br>A()try{:…}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- 析构函数出现异常<br><br>  - 内部处理即可<br>  <br>- 特例<br><br>  - 无参数throw<br>  <br>    - 将捕获到的异常对象重新抛出<br>  <br>      ```c++<br>      catch(int) &#123; throw; &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>catch(…)</p>
<ul>
<li>默认异常处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="1-c-为我们默认添加了哪些函数"><a href="#1-c-为我们默认添加了哪些函数" class="headerlink" title="1. c++为我们默认添加了哪些函数"></a>1. c++为我们默认添加了哪些函数</h3>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123; <br>    <span class="hljs-built_in">Empty</span>();<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp;);<br>    ~<span class="hljs-built_in">Empty</span>();<br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp;);<br>    Empty *<span class="hljs-keyword">operator</span> &amp;();<span class="hljs-comment">//取地址操作符重载</span><br>    <span class="hljs-type">const</span> Empty *<span class="hljs-keyword">operator</span> &amp;() <span class="hljs-type">const</span>;<span class="hljs-comment">//常成员情况 const Empty e; 防止常成员通过指针被修改</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2-c-没有finally"><a href="#2-c-没有finally" class="headerlink" title="2. c++没有finally"></a>2. c++没有finally</h3><ul>
<li>理念：RAII，资源应该能做到自清理</li>
<li>RAII：资源的获取过程就是对象的初始化过程</li>
<li>可以使用智能指针</li>
<li>将指针内容转移到另一个智能指针实现所有权转移</li>
</ul>
<h3 id="3-遇到不能虚化的函数，但需要虚化"><a href="#3-遇到不能虚化的函数，但需要虚化" class="headerlink" title="3. 遇到不能虚化的函数，但需要虚化"></a>3. 遇到不能虚化的函数，但需要虚化</h3><ul>
<li><p>非虚接口</p>
</li>
<li><p>先构造一个可以虚化的函数，然后将不能虚化的包装起来</p>
<ul>
<li><p>全局函数</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622153214208.png" alt="image-20220622153214208" style="zoom:80%;" /></p>
</li>
<li><p>构造函数</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622153114909.png" alt="image-20220622153114909" style="zoom:80%;" /></p>
<h3 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPointer</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmartPointer</span>(T *p=<span class="hljs-number">0</span>) :<span class="hljs-built_in">ptr</span>(p) &#123;&#125;<br>    ~<span class="hljs-built_in">SmartPointer</span>() &#123;<span class="hljs-keyword">delete</span> ptr;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br>    T&amp; <span class="hljs-keyword">operator</span> *() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125; <br><span class="hljs-keyword">private</span>:<br>    T* ptr;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-永远不要多态地对待数组"><a href="#5-永远不要多态地对待数组" class="headerlink" title="5. 永远不要多态地对待数组"></a>5. 永远不要多态地对待数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span> &#123; … &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BalancedBST</span>: <span class="hljs-keyword">public</span> BST &#123; … &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBSTArray</span><span class="hljs-params">(ostream&amp; s, <span class="hljs-type">const</span> BST array[], <span class="hljs-type">int</span> numElements)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; numElements; i++)  s &lt;&lt; array[i]; &#125;  <span class="hljs-comment">//有问题,遍历的时候子类和父类偏移的大小是不一致的</span><br><br>BalancedBST bBSTArray[<span class="hljs-number">10</span>];<br>…<br><span class="hljs-built_in">printBSTArray</span>(cout, bBSTArray, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/C-高级程序设计/">C++高级程序设计</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/C/">C++</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/8/" class="pagination-prev">Prev</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Whale
    
  </p>
</footer>
    
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>