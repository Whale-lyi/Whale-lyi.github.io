<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 7 | Whale&#39;s Blog | Stay hungry, Stay foolish</title>

  
  <meta name="author" content="Whale">
  

  
  <meta name="description" content="码农预备役">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Whale&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whale&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Whale&#39;s Blog</a>
    </h1>
    <p class="site-description">Stay hungry, Stay foolish</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2022/11/16/Web前端开发-2-HTML/"><span>Web前端开发(2) HTML</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/11/16/Web前端开发-2-HTML/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-16T02:28:15.000Z">
          2022-11-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="2-HTML-Basics"><a href="#2-HTML-Basics" class="headerlink" title="2-HTML Basics"></a>2-HTML Basics</h1><h2 id="1-HTML-Overview"><a href="#1-HTML-Overview" class="headerlink" title="1 HTML Overview"></a>1 HTML Overview</h2><h3 id="1-1-HTML"><a href="#1-1-HTML" class="headerlink" title="1.1 HTML"></a>1.1 HTML</h3><ul>
<li>Hypertext Markup Language (HTML) , 全称为超文本标记语言, 是⼀种标记语言。它包括⼀系列标签．通过这些标签可以将网络上的文档格式统⼀, 使分散的Internet资源连接为⼀个逻辑整体。</li>
<li>HTML(超文本标记语言——HyperText Markup Language)是构成 Web 世界的⼀砖⼀瓦。它定义了网页内容的含义和结构。除 HTML 以外的其它技术则通常用来描述⼀个网页的表现与展示效果(如 CSS), 或功能与行为(如 JavaScript) — MDN</li>
</ul>
<h4 id="1-1-1-HTML版本"><a href="#1-1-1-HTML版本" class="headerlink" title="1.1.1 HTML版本"></a>1.1.1 HTML版本</h4><ul>
<li>1989: 伯纳斯-李写了⼀份备忘录, 提议建⽴⼀个基于互联网的超文本系统</li>
<li>1995: RFC 1866, HTML 2成为官方标准语言</li>
<li>1997: HTML 4</li>
<li>1999: HTML 4.01</li>
<li>2001-01: XHTML</li>
<li>2014 html5</li>
<li>2016 html5.1</li>
<li>2017 html5.2</li>
</ul>
<h4 id="1-1-2-HTML-and-XHTML"><a href="#1-1-2-HTML-and-XHTML" class="headerlink" title="1.1.2 HTML and XHTML"></a>1.1.2 HTML and XHTML</h4><ul>
<li>HTML最初是⼀种应用程序标准通用标记语言(SGML)<ul>
<li>SGML是⼀种非常灵活的标记语言</li>
<li>需要⼀个相对复杂、宽松且通常自定义的解析器</li>
</ul>
</li>
<li>XHTML:<ul>
<li>XML的应用程序, SGML的⼀个更严格的子集</li>
<li>真正的XHTML文档允许使用标准XML工具执行自动化处理</li>
</ul>
</li>
</ul>
<h3 id="1-2-标记语言"><a href="#1-2-标记语言" class="headerlink" title="1.2 标记语言"></a>1.2 标记语言</h3><ul>
<li><p>标记:</p>
<ul>
<li>在文档中嵌入代码</li>
<li>代码被称为“标签”</li>
<li>代码：描述结构文档、包括处理说明</li>
</ul>
</li>
<li><p>标记语言:</p>
<ul>
<li>描述标签语法的计算机语言</li>
<li>可以与其他工具⼀起使用来指定渲染</li>
</ul>
</li>
</ul>
<h4 id="1-2-1-逻辑标记"><a href="#1-2-1-逻辑标记" class="headerlink" title="1.2.1 逻辑标记"></a>1.2.1 逻辑标记</h4><ul>
<li>逻辑标记:<ul>
<li>描述文档的各个部分</li>
<li>不指定如何渲染</li>
</ul>
</li>
<li>例如：<ul>
<li><code>This is &lt;strong&gt;very&lt;/strong&gt; important</code></li>
<li>This is <strong>very</strong> important</li>
<li>用这个标记向浏览器传达了一个强调某段文字的消息，strong就是我们所说的逻辑元素，他是强调文档逻辑的，并非是通知浏览器应该如何显示。</li>
</ul>
</li>
<li>物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性<ul>
<li>类似<code>&lt;b&gt;, &lt;strong&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="1-2-2-逻辑"><a href="#1-2-2-逻辑" class="headerlink" title="1.2.2 逻辑"></a>1.2.2 逻辑</h4><ul>
<li>呈现是客户的“决定”</li>
<li>当客户端无法展示时, 会出现优雅降级<ul>
<li><code>&lt;img alt=&quot;image description&quot; src=&quot;foo.gif&quot;&gt;</code></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Graceful_degradation"><strong>优雅降级</strong>（Graceful degradation）</a>是一种设计理念，其核心是尝试构建可在最新浏览器中运行的现代网站/应用程序，而作为降级体验，在低版本浏览器中仍然提供必要的内容和功能。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Progressive_Enhancement"><strong>渐进增强</strong>（Progressive enhancement）</a>是一种设计理念，其核心是为尽可能多的用户提供基本内容和功能，同时进一步为现代化浏览器用户提供最佳体验，运行所有需要的代码。</li>
</ul>
</li>
</ul>
<h4 id="1-2-3-Markdown"><a href="#1-2-3-Markdown" class="headerlink" title="1.2.3 Markdown"></a>1.2.3 Markdown</h4><ul>
<li>Markdown 是⼀种轻量级标记语言, 它允许人们使用易读易写的纯文本格式编写文档。</li>
<li>Markdown 语言在 2004 由约翰·格鲁伯(英语：John Gruber)创建。</li>
<li>Markdown 编写的文档可以导出 HTML、Word、图像、PDF、Epub等多种格式的文档。</li>
<li>Markdown 编写的文档后缀为 .md, .markdown。</li>
<li>Markdown 应用<ul>
<li>Markdown 能被使用来撰写电子书, 如：Gitbook。</li>
<li>当前许多网站都⼴泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap、SourceForge等。</li>
</ul>
</li>
</ul>
<h3 id="1-3-HTML基础"><a href="#1-3-HTML基础" class="headerlink" title="1.3 HTML基础"></a>1.3 HTML基础</h3><ul>
<li>XHTML 或 HTML 文档组成<ul>
<li>DOCTYPE: 使用的文档类型定义 DTD</li>
<li>Head: 元信息, 只有<code>&lt;title&gt;</code>是必须的</li>
<li>Body: 需要呈现的内容</li>
</ul>
</li>
</ul>
<h4 id="1-3-1-HTML元素详解"><a href="#1-3-1-HTML元素详解" class="headerlink" title="1.3.1 HTML元素详解"></a>1.3.1 HTML元素详解</h4><ul>
<li>开始标签(Opening tag)：包含元素的名称(本例为 p), 被大于号、小于号所包围。表示元素从这里开始或者开始起作用 —— 在本例中即段落由此开始。</li>
<li>结束标签(Closing tag)：与开始标签相似, 只是其在元素名之前包含了⼀个斜杠。这表示着元素的结尾 —— 在本例中即段落在此结束。初学者常常会犯忘记包含结束标签的错误, 这可能会产生⼀些奇怪的结果。</li>
<li>内容(Content)：元素的内容, 本例中就是所输入的文本本身。</li>
<li>元素(Element)：开始标签、结束标签与内容相结合, 便是⼀个完整的元素</li>
</ul>
<h4 id="1-3-2-块级元素或行内元素"><a href="#1-3-2-块级元素或行内元素" class="headerlink" title="1.3.2 块级元素或行内元素"></a>1.3.2 块级元素或行内元素</h4><ul>
<li>块级元素占据其父元素(容器)的整个水平空间, 垂直空间等于其内容高度, 因此创建了⼀个“块”<ul>
<li>例如: paragraphs, lists, table cells</li>
<li>通常浏览器会在块级元素前后另起⼀个新行</li>
</ul>
</li>
<li>行内元素只占据它对应标签的边框所包含的空间<ul>
<li>例如: bold text, code fragments, images</li>
<li>浏览器允许许多行内元素出现在同⼀行上</li>
<li>必须嵌套在块级元素中</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117005354294.png" alt="image-20221117005354294" style="zoom:80%;" /></p>
<h4 id="1-3-3-各种标签"><a href="#1-3-3-各种标签" class="headerlink" title="1.3.3 各种标签"></a>1.3.3 各种标签</h4><h5 id="注释：-lt-gt"><a href="#注释：-lt-gt" class="headerlink" title="注释：&lt;!--..--&gt;"></a>注释：<code>&lt;!--..--&gt;</code></h5><ul>
<li>注释或“注释掉”文本</li>
<li>不能嵌套</li>
<li>许多网页根本没有注释<ul>
<li>防止泄露信息, 节省带宽</li>
</ul>
</li>
</ul>
<h5 id="网页标题：-lt-title-gt"><a href="#网页标题：-lt-title-gt" class="headerlink" title="网页标题：&lt;title&gt;"></a>网页标题：<code>&lt;title&gt;</code></h5><ul>
<li>当前网页的标题</li>
<li>用于<ul>
<li>定义浏览器工具栏中的标题</li>
<li>提供页面被添加到收藏夹时的标题</li>
<li>显示在搜索引擎结果中的页面标题</li>
</ul>
</li>
<li>标题长度受限</li>
<li>SEO权重大</li>
</ul>
<h5 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h5><ul>
<li>用于提供关于HTML文档的元数据</li>
<li><code>&lt;meta&gt;</code>标签只能出现在<code>&lt;head&gt;</code>里</li>
<li>标签通常用于给出网页描述、关键词、文档作者、最后修改日期等信息</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117005731056.png" alt="image-20221117005731056" style="zoom:80%;" /></p>
<h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117005752262.png" alt="image-20221117005752262" style="zoom:80%;" /></p>
<ul>
<li>字符集<ul>
<li>ASCII(basic 7b, extension 1B)</li>
<li>iso-8859-1/latin-1 (West Europe,1B)</li>
<li>GB2312 (2B, Simplified Chinese)</li>
<li>GBK(2B, S. &amp; T. Chinese)</li>
<li>GB18030 (1,2,4B, Eastern Asia)</li>
<li>Unicode (650 languages)<ul>
<li>UTF-8 (1,2,3,4B , Chinese 3B)</li>
<li>UTF-16 (2B, 4B, Chinese 2B)</li>
<li>UTF-32 (4B, future) </li>
</ul>
</li>
<li>UCS<ul>
<li>UCS-2 (2B, comparable with UTF-16)</li>
<li>UCS-4 (4B, future)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="lt-h1-gt-lt-h6-gt-标签"><a href="#lt-h1-gt-lt-h6-gt-标签" class="headerlink" title="&lt;h1&gt; - &lt;h6&gt;标签"></a><code>&lt;h1&gt; - &lt;h6&gt;</code>标签</h5><ul>
<li><code>&lt;h1&gt; - &lt;h6&gt;</code>标签被用来定义 HTML 标题。</li>
<li>用标题来呈现文档结构是很重要的<ul>
<li><code>&lt;h1&gt;</code>定义重要等级最高的标题, <code>&lt;h6&gt;</code>定义重要等级最低的标题</li>
</ul>
</li>
</ul>
<h5 id="lt-p-gt"><a href="#lt-p-gt" class="headerlink" title="&lt;p&gt;"></a><code>&lt;p&gt;</code></h5><ul>
<li>段落</li>
</ul>
<h5 id="lt-br-gt"><a href="#lt-br-gt" class="headerlink" title="&lt;br&gt;"></a><code>&lt;br&gt;</code></h5><ul>
<li>插入⼀个简单的换行符</li>
<li><code>&lt;br&gt;</code>标签是⼀个空标签, 意味着它没有结束标签</li>
</ul>
<h5 id="lt-a-gt"><a href="#lt-a-gt" class="headerlink" title="&lt;a&gt;"></a><code>&lt;a&gt;</code></h5><ul>
<li>定义超链接</li>
<li><code>&lt;a&gt;</code>元素最重要的属性是 href 属性, 它指定链接的目标</li>
<li><p>请使用 CSS 来改变链接的样式</p>
</li>
<li><p>描述性</p>
<blockquote>
<p>Click <a href="">here</a> to check your course schedule Please check your <a href="">course schedule Course Schedule</a> (please check yours before March 15!)”</p>
</blockquote>
</li>
</ul>
<h5 id="图像-lt-img-gt"><a href="#图像-lt-img-gt" class="headerlink" title="图像&lt;img&gt;"></a>图像<code>&lt;img&gt;</code></h5><ul>
<li><code>&lt;img&gt;</code> 是空标签, 只包含属性, 并且没有闭合标签</li>
<li>src 指 “source”。源属性的值是图像的 URL 地址</li>
<li>alt 属性用来为图像定义⼀串预备的可替换的文本</li>
<li>通过在<code>&lt;a&gt;</code>标签中嵌套<code>&lt;img&gt;</code>标签, 给图像添加到另⼀个文档的链接</li>
</ul>
<h5 id="图像格式"><a href="#图像格式" class="headerlink" title="图像格式"></a>图像格式</h5><ul>
<li>GIF<ul>
<li>透明、无损、256</li>
<li>用于动画</li>
</ul>
</li>
<li>JPEG<ul>
<li>使用范围最⼴</li>
<li>有损</li>
<li>背景图、轮播图或者商品的banner图</li>
</ul>
</li>
<li>PNG<ul>
<li>真彩色和调色板、透明、无损</li>
<li>文件体积大</li>
<li>颜色数少的单帧图像, 图标, LOGO</li>
</ul>
</li>
<li>webp<ul>
<li>有损、压缩率高, 同时支持透明度和动画</li>
<li>浏览器兼容性</li>
</ul>
</li>
<li>SVG<ul>
<li>LOGO</li>
</ul>
</li>
</ul>
<h5 id="lt-em-gt-lt-strong-gt"><a href="#lt-em-gt-lt-strong-gt" class="headerlink" title="&lt;em&gt; &lt;strong&gt;"></a><code>&lt;em&gt; &lt;strong&gt;</code></h5><ul>
<li>em: 呈现为被强调的文本</li>
<li>strong: 定义重要的文本</li>
</ul>
<blockquote>
<p>HTML is <code>&lt;em&gt;</code>really<code>&lt;/em&gt;</code>, <code>&lt;strong&gt;</code>REALLY<code>&lt;/strong&gt;</code> fun!</p>
<p>HTML is <em>really</em>, <strong>REALLY</strong> fun!</p>
</blockquote>
<h5 id="嵌套的标签"><a href="#嵌套的标签" class="headerlink" title="嵌套的标签"></a>嵌套的标签</h5><ul>
<li>标签必须正确嵌套<ul>
<li>结束标记必须与最近打开的标记匹配</li>
</ul>
</li>
<li>浏览器可能会正确地呈现它, 但它是无效的XHTML</li>
</ul>
<h5 id="Table-lt-table-gt-lt-tr-gt-lt-td-gt-lt-th-gt-lt-caption-gt"><a href="#Table-lt-table-gt-lt-tr-gt-lt-td-gt-lt-th-gt-lt-caption-gt" class="headerlink" title="Table: &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;th&gt; &lt;caption&gt;"></a>Table: <code>&lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;th&gt; &lt;caption&gt;</code></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117010749347.png" alt="image-20221117010749347" style="zoom:80%;" /></p>
<ul>
<li>不要用于布局<ul>
<li>结构混乱, 不清晰</li>
<li>css更强大, 访问性更好, 能在范围更⼴的设备上运作, 如⼿机</li>
<li>机器难以理解, 不利于SEO</li>
<li>基于css的布局页面比表单布局更小更简单</li>
</ul>
</li>
</ul>
<h5 id="lt-blockquote-gt"><a href="#lt-blockquote-gt" class="headerlink" title="&lt;blockquote&gt;"></a><code>&lt;blockquote&gt;</code></h5><ul>
<li><p>块元素</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117010845662.png" alt="image-20221117010845662" style="zoom:80%;" /></p>
</li>
</ul>
<h5 id="行内引用-lt-q-gt"><a href="#行内引用-lt-q-gt" class="headerlink" title="行内引用&lt;q&gt;"></a>行内引用<code>&lt;q&gt;</code></h5><blockquote>
<p>Quoth the Raven, <code>&lt;q&gt;</code>Nevermore<code>&lt;/q&gt;</code>.</p>
<p>Quoth the Raven, <q>Nevermore</q>.</p>
</blockquote>
<ul>
<li>不使用 “ 的原因是:<ul>
<li>XHTML不应该直接包含引号字符, 应该写成转义<code>&amp;quot;</code></li>
<li>使用<code>&lt;q&gt;</code>的话可以使用CSS样式</li>
</ul>
</li>
</ul>
<h4 id="1-3-4-HTML字符实体"><a href="#1-3-4-HTML字符实体" class="headerlink" title="1.3.4 HTML字符实体"></a>1.3.4 HTML字符实体</h4><ul>
<li><p>HTML 中的预留字符必须被替换为字符实体</p>
</li>
<li><p>⼀些在键盘上找不到的字符也可以使用字符实体来替换</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117011155536.png" alt="image-20221117011155536" style="zoom:80%;" /></p>
</li>
<li><p>要在Web页面中显示链接文本, 必须对其特殊字符进行如下所示的编码</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117011224719.png" alt="image-20221117011224719" style="zoom:80%;" /></p>
</li>
</ul>
<h2 id="2-Form"><a href="#2-Form" class="headerlink" title="2 Form"></a>2 Form</h2><h3 id="2-1-表单"><a href="#2-1-表单" class="headerlink" title="2.1 表单"></a>2.1 表单</h3><ul>
<li><p><code>&lt;form&gt;</code>: HTML 表单用于收集用户的输入信息</p>
</li>
<li><p>HTML 表单表示文档中的⼀个区域, 此区域包含交互控件, 将用户收集到的信息发送到 Web 服务器。</p>
<ul>
<li>基本语法: <code>&lt;form parameters&gt; ...form elements... &lt;/form&gt;</code></li>
<li>表单元素允许用户在表单中输入内容, 比如：文本域 (textarea)、下拉列表(select)、单选框(radiobuttons)、复选框(checkbox)等等</li>
<li>包含提交按钮</li>
<li>当用户单击确认按钮时, 表单的内容会被传送到服务器。表单的动作属性 action 定义了服务端的文件名。</li>
</ul>
</li>
<li><p>例子：必须将表单的控件包装在块元素中, 比如div, fieldset等</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116105212321.png" alt="image-20221116105212321"></p>
</li>
</ul>
<h3 id="2-2-lt-form-gt-标签"><a href="#2-2-lt-form-gt-标签" class="headerlink" title="2.2 &lt;form&gt; 标签"></a>2.2 <code>&lt;form&gt;</code> 标签</h3><ul>
<li>表单属性说明如何处理用户输入<ul>
<li>action=”url” (必须)<ul>
<li>指定单击Submit按钮时将数据发送到哪里</li>
</ul>
</li>
<li>method=”get” (缺省)<ul>
<li>将表单数据以名称/值对的形式附加到 URL 中</li>
<li>URL 的长度是有限的(大约 3000 字符)</li>
<li>绝不要使用 GET 来发送敏感数据！(在 URL 中是可见的)</li>
<li>对于用户希望加入书签的表单提交很有用</li>
<li>GET 更适用于非安全数据, 比如在 Google 中查询字符串</li>
</ul>
</li>
<li>method=”post”<ul>
<li>将表单数据附加到 HTTP 请求的 body 内(数据不显示在 URL 中)</li>
<li>没有长度限制</li>
<li>通过 POST 提交的表单不能加入书签</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-lt-input-gt-标签"><a href="#2-3-lt-input-gt-标签" class="headerlink" title="2.3 &lt;input&gt; 标签"></a>2.3 <code>&lt;input&gt;</code> 标签</h3><ul>
<li><p><code>&lt;input&gt;</code>标签规定了用户可以在其中输入数据的输入字段。</p>
</li>
<li><p><code>&lt;input&gt;</code>元素在<code>&lt;form&gt;</code>元素中使用, 用来声明允许用户输入数据的 input 控件。</p>
</li>
<li><p>输入字段可通过多种方式改变, 取决于 type 属性</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116105456792.png" alt="image-20221116105456792"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116105533147.png" alt="image-20221116105533147" style="zoom: 67%;" /></p>
</li>
</ul>
<h4 id="2-3-1-关于-lt-input-gt-的思考"><a href="#2-3-1-关于-lt-input-gt-的思考" class="headerlink" title="2.3.1 关于 &lt;input&gt; 的思考"></a>2.3.1 关于 <code>&lt;input&gt;</code> 的思考</h4><ul>
<li>输入的类型这么多, 为什么不使用元素呢?<ul>
<li><code>&lt;input type=&quot;text&quot; .../&gt;</code> -&gt; <code>&lt;text/&gt; or &lt;text&gt;&lt;/text&gt;</code></li>
<li><code>&lt;input type=&quot;checkbox&quot; .../&gt;</code> -&gt; <code>&lt;checkbox.../&gt;</code></li>
</ul>
</li>
<li>事实上, 当表单在1996年首次被设计并引入到html中时, 这只是⼀个糟糕的设计决策, 我们⼀直遵循它到目前为止</li>
<li>另一个缺陷：<code>checked=&quot;checked&quot;...</code>, 很怪异</li>
</ul>
<h4 id="2-3-2-隐藏字段"><a href="#2-3-2-隐藏字段" class="headerlink" title="2.3.2 隐藏字段"></a>2.3.2 隐藏字段</h4><ul>
<li><code>&lt;input type=&quot;hidden&quot; name=&quot;hiddenField&quot; value=&quot;...&quot;</code></li>
<li>作用<ul>
<li>隐藏域在页面中对于用户是不可见的, 在表单中插入隐藏域的目的在于收集或发送信息, 以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候, 隐藏域的信息也被⼀起发送到服务器。</li>
<li>在提交表单时提交上来以确定用户身份, 如sessionkey等等</li>
<li>form 里有多个提交按钮, 分清是哪⼀个按钮提交的</li>
<li>⼀个网页中有多个form, 是不能同时提交的, 但有时这些form确实相互作用, 就可以在form中添加隐藏域来使它们联系起来</li>
</ul>
</li>
</ul>
<h2 id="3-Web-Standards"><a href="#3-Web-Standards" class="headerlink" title="3 Web Standards"></a>3 Web Standards</h2><h3 id="3-1-Web标准"><a href="#3-1-Web标准" class="headerlink" title="3.1 Web标准"></a>3.1 Web标准</h3><ul>
<li>更严格和结构化的语言</li>
<li>不同浏览器之间的兼容性更强</li>
<li>更有可能让页面在以后也能正确显示</li>
<li>可以与SVG(图形)、MathML、MusicML等其他XML数据进行交换。</li>
</ul>
<h3 id="3-2-XHTML-1-0-vs-HTML-4-01"><a href="#3-2-XHTML-1-0-vs-HTML-4-01" class="headerlink" title="3.2 XHTML 1.0 vs HTML 4.01"></a>3.2 XHTML 1.0 vs HTML 4.01</h3><ul>
<li>文档结构<ul>
<li>XHTML DOCTYPE 是强制性的</li>
<li><code>&lt;html&gt;</code> 中的XML namespace 属性是强制性的</li>
<li><code>&lt;html&gt;, &lt;head&gt;, &lt;title&gt;, &lt;body&gt;</code> 也是强制性的</li>
</ul>
</li>
<li>元素语法<ul>
<li>XHTML元素必须正确嵌套</li>
<li>XHTML元素必须始终关闭</li>
<li>XHTML元素必须小写</li>
<li>XHTML文档必须有一个根元素</li>
</ul>
</li>
<li>属性语法<ul>
<li>XHTML属性必须使用小写</li>
<li>XHTML属性值必须用引号包围</li>
<li>XHTML属性最小化也是禁止的</li>
</ul>
</li>
</ul>
<h1 id="3-HTML5-Basics"><a href="#3-HTML5-Basics" class="headerlink" title="3-HTML5 Basics"></a>3-HTML5 Basics</h1><ul>
<li>HTML 的最新稳定版本, HTML5 将 HTML 从用于构造⼀个文档的⼀个简单标记, 扩展到⼀个完整的应用程序开发平台。除其他功能外, HTML5 还包括新元素和用于增强存储、多媒体和硬件访问的JavaScript APIs</li>
<li>HTML5 是 W3C 与 WHATWG 合作的结果,WHATWG 指 Web Hypertext Application Technology Working Group。</li>
</ul>
<h2 id="1-HTML5-应用"><a href="#1-HTML5-应用" class="headerlink" title="1 HTML5 应用"></a>1 HTML5 应用</h2><ul>
<li>本地数据存储</li>
<li>访问本地文件</li>
<li>本地SQL数据</li>
<li>缓存引用</li>
<li>Javascript工作者</li>
<li>XHTMLHttpRequest 2</li>
</ul>
<h2 id="2-HTML5-优势"><a href="#2-HTML5-优势" class="headerlink" title="2 HTML5 优势"></a>2 HTML5 优势</h2><ul>
<li>跨浏览器兼容性</li>
<li>大道至简</li>
<li>语义化</li>
<li>可用性和用户体验的改进</li>
<li>无插件范式</li>
<li>安全</li>
<li>大量用于移动应用和游戏</li>
<li>在网站抓取和索引方面, HTML5 对 SEO 友好</li>
</ul>
<h3 id="2-1-大道至简"><a href="#2-1-大道至简" class="headerlink" title="2.1 大道至简"></a>2.1 大道至简</h3><ul>
<li><p>旧路新铺</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116112819692.png" alt="image-20221116112819692" style="zoom:80%;" /></p>
</li>
<li><p>新的 DOCTYPE 声明</p>
<ul>
<li><p>简化的 Doctype</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116112903469.png" alt="image-20221116112903469" style="zoom:80%;" /></p>
</li>
</ul>
</li>
<li><p>干净的标记和改进的代码</p>
<ul>
<li><p>简化的字符集</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116113041638.png" alt="image-20221116113041638" style="zoom:80%;" /></p>
</li>
<li><p>简化的标签</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116113131530.png" alt="image-20221116113131530" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-语义化"><a href="#2-2-语义化" class="headerlink" title="2.2 语义化"></a>2.2 语义化</h3><ul>
<li><p>根据结构化的内容选择合适的标签</p>
</li>
<li><p>优点</p>
<ul>
<li>有利于SEO(搜索引擎优化, 便于爬虫理解)</li>
<li>开发维护体验好</li>
<li>用户体验更好</li>
<li>更好的可访问性, 方便任何设备对代码进行解析</li>
</ul>
</li>
<li><p>Semantic Markup</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116113406881.png" alt="image-20221116113406881" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="2-2-1-微数据"><a href="#2-2-1-微数据" class="headerlink" title="2.2.1 微数据"></a>2.2.1 微数据</h4><ul>
<li>微数据是WHATWG HTML 标准的⼀部分, 用于在网页上的现有内容中嵌套元数据。搜索引擎, 网络抓取工具和浏览器可以从网页中提取和处理微数据, 并使用它为用户提供更丰富的浏览体验。</li>
<li>强调机器的可读性<ul>
<li>SEO 优势</li>
<li>使用 Microdata 在 HTML 文档中嵌入机器可读数据</li>
<li>易于编写的语法(添加到任何元素)</li>
<li>兼容其他数据格式, 如RDF和JSON</li>
</ul>
</li>
<li><p>微数据词汇表</p>
<ul>
<li>schema.org词汇表</li>
<li>Google丰富摘要词汇表(www.data-vocabulary.org)<ul>
<li>若要在 2021 年 1 月 29 日之后继续使用, 需要将 data-vocabulary.org 标记替换为 schema.org 标记。</li>
</ul>
</li>
<li>WHATWG/microformats.org词汇表</li>
</ul>
</li>
<li><p>示例：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116114055177.png" alt="image-20221116114055177" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116114222889.png" alt="image-20221116114222889"></p>
</li>
</ul>
<h4 id="2-2-2-结构化数据"><a href="#2-2-2-结构化数据" class="headerlink" title="2.2.2 结构化数据"></a>2.2.2 结构化数据</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116114132109.png" alt="image-20221116114132109" style="zoom:80%;" /></p>
<h3 id="2-3-可用性和用户体验的改进"><a href="#2-3-可用性和用户体验的改进" class="headerlink" title="2.3 可用性和用户体验的改进"></a>2.3 可用性和用户体验的改进</h3><ul>
<li>HTML5 为 Web 开发人员提供了多项技术改进和改进的功能。使用 HTML5 代码, Web 开发人员可以轻松设计更好的应用程序和动态网站, 从而带来更好的用户体验。</li>
<li>无障碍是⼀种让尽可能多的用户可以使用你的网站的做法。传统上我们认为这只与残疾人士有关, 但提升网站的无障碍也可以让其他用户群体受益。比如使用移动设备的人群, 那些使用低速网络连接的人群。</li>
</ul>
<h4 id="2-3-1-无障碍富网络应用-WAI-ARIA"><a href="#2-3-1-无障碍富网络应用-WAI-ARIA" class="headerlink" title="2.3.1 无障碍富网络应用 WAI-ARIA"></a>2.3.1 无障碍富网络应用 WAI-ARIA</h4><ul>
<li>ARIA是“Accessible Rich Internet Applications ”的缩写。它是W3C的Web无障碍推进组织(Web Accessibility Initiative / WAI)在2014年3月20日发布的可访问富互联网应用实现指南。WAI-ARIA是⼀个为残疾人士等提供无障碍访问动态、可交互Web内容的技术规范。</li>
<li><p>ARIA 提供语义, 因此作者可以将用户界面上的行为和结构信息传达给辅助技术(例如屏幕阅读器)。</p>
</li>
<li><p>屏幕阅读器</p>
<ul>
<li>用表格布局网页, 可能会读出给人造成困惑的结果, 特别是如果布局复杂, 并且有许多嵌套表格的话。</li>
<li>现代的布局, 布局标记不再会妨碍内容的读取。它在代码大小方面也更加精简和小巧, 这意味着代码更容易维护, 并且用户下载的带宽更少(特别适合慢速连接的用户)。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116114638058.png" alt="image-20221116114638058" style="zoom:80%;" /></p>
<h3 id="2-4-HTML5-无插件范式"><a href="#2-4-HTML5-无插件范式" class="headerlink" title="2.4 HTML5 无插件范式"></a>2.4 HTML5 无插件范式</h3><ul>
<li>过去, 很多功能只能通过插件或者复杂的 hack (本地绘图API、本地socket等)来实现, 但是在 HTML5中提供了对这些功能的原生支持。</li>
</ul>
<h4 id="2-4-1-插件的问题"><a href="#2-4-1-插件的问题" class="headerlink" title="2.4.1 插件的问题"></a>2.4.1 插件的问题</h4><ul>
<li>插件安装可能失败。</li>
<li>插件可能被禁用或者是屏蔽。</li>
<li>插件自身会成为被攻击的对象。</li>
<li>插件不容易与HTML文档的其他部分集成(因为插件边界、剪裁和通明度问题)</li>
</ul>
<blockquote>
<p>“Whenever a Mac crashes, more often that not is because of Flash” —Steve Jobs</p>
</blockquote>
<h3 id="2-5-安全"><a href="#2-5-安全" class="headerlink" title="2.5 安全"></a>2.5 安全</h3><ul>
<li>跨源资源共享(CORS)使Web服务器允许其他域名的网页访问自己的资源<ul>
<li>CORS放宽了同源访问规则(Same Origin Rule), 这是Web服务器内置的基础安全措施之一</li>
</ul>
</li>
</ul>
<h3 id="2-6-移动应用和游戏"><a href="#2-6-移动应用和游戏" class="headerlink" title="2.6 移动应用和游戏"></a>2.6 移动应用和游戏</h3><ul>
<li>多设备跨平台</li>
<li>自适应网页设计</li>
</ul>
<h3 id="2-7-SEO"><a href="#2-7-SEO" class="headerlink" title="2.7 SEO"></a>2.7 SEO</h3><ul>
<li>HTML5 带有各种属性和模块, 使网络爬虫可以轻松搜索你的内容并使其正确编入索引, 从而提高其在搜索引擎搜索结果页面中的排名</li>
<li>HTML5 技术提供了具有广泛结构元素、语义、表单类型、新属性和媒体元素的各种功能, 使数字营销专家和开发人员更容易专注于更好的搜索引擎优化技术并推动更多的自然搜索流量</li>
</ul>
<h2 id="3-HTML5-总览"><a href="#3-HTML5-总览" class="headerlink" title="3 HTML5 总览"></a>3 HTML5 总览</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116115918921.png" alt="image-20221116115918921"></p>
<h2 id="4-HTML5-新功能特性"><a href="#4-HTML5-新功能特性" class="headerlink" title="4 HTML5 新功能特性"></a>4 HTML5 新功能特性</h2><ul>
<li>新元素</li>
<li>新属性</li>
<li>完全支持 CSS 3</li>
<li>Video 和 Audio</li>
<li>2D/3D 制图</li>
<li>web存储</li>
<li>离线浏览</li>
<li>HTML5 Web SQL 数据库</li>
<li>HTML5 Web Workers</li>
<li>HTML WebSocket</li>
</ul>
<h3 id="4-1-HTML5-新元素"><a href="#4-1-HTML5-新元素" class="headerlink" title="4.1 HTML5 新元素"></a>4.1 HTML5 新元素</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117234438242.png" alt="image-20221117234438242" style="zoom:80%;" /></p>
<h4 id="4-1-1-过时的元素"><a href="#4-1-1-过时的元素" class="headerlink" title="4.1.1 过时的元素"></a>4.1.1 过时的元素</h4><ul>
<li>能使用CSS替代的元素<ul>
<li><code>basefont, center, font, tt, u</code></li>
</ul>
</li>
<li>不再使用frame框架</li>
<li>只有部分浏览器支持的元素<ul>
<li><code>applet, bgsound, marquee</code></li>
</ul>
</li>
<li>其他被废除的元素<ul>
<li><code>isindex, dir, rb</code>等</li>
</ul>
</li>
</ul>
<h3 id="4-2-HTML5-表单"><a href="#4-2-HTML5-表单" class="headerlink" title="4.2 HTML5 表单"></a>4.2 HTML5 表单</h3><ul>
<li>新的表单功能<ul>
<li>不需要JavaScript, 原生方式</li>
<li>新的输入类型<ul>
<li><code>color, datetime, email</code></li>
<li><code>search, tel, url</code></li>
</ul>
</li>
</ul>
</li>
<li><p>旧浏览器中新的表单控件会平滑降级</p>
<ul>
<li>未知的输入类型被视为文本</li>
</ul>
</li>
<li><p>HTML5 表单的核心设计理念: <strong>规范的核心是功能性动作和语义, 而非外观和显示效果</strong></p>
<ul>
<li><p>好处如下：</p>
<ul>
<li><p>促进浏览器改善用户交互方式</p>
</li>
<li><p>分离了样式和语义</p>
</li>
<li><p>在未来或面对专用用户输入设备时, 可以根据实际情况灵活调整交互方式</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>新输入类型</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118130414056.png" alt="image-20221118130414056" style="zoom:80%;" /></p>
<h3 id="4-3-HTML5-音视频"><a href="#4-3-HTML5-音视频" class="headerlink" title="4.3 HTML5 音视频"></a>4.3 HTML5 音视频</h3><ul>
<li>HTML5 新的媒体元素<ul>
<li><code>&lt;audio&gt;, &lt;video&gt;</code></li>
</ul>
</li>
<li>原生的音视频, 不需要JavaScript<ul>
<li>可用JavaScript编程</li>
<li>CSS样式</li>
</ul>
</li>
<li>支持各种不同的编解码器</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Basic Video --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;goldrush.mp4&quot;</span>&gt;</span><br>    A movie about HTML5<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Video with additional attributes --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;movies&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">controls</span> <span class="hljs-attr">preload</span>=<span class="hljs-string">&quot;metadata&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300px&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">poster</span>=<span class="hljs-string">&quot;html5.png&quot;</span>&gt;</span><br>    	<span class="hljs-comment">&lt;!-- 灵活, 如果第一个不支持会播放第二个 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;goldrush.webm&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;goldrush.mp4&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">track</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;English&quot;</span> <span class="hljs-attr">kind</span>=<span class="hljs-string">&quot;subtitles&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">srclang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;subtitles_en.vtt&quot;</span>&gt;</span><br>    A movie by Rocky Lubbers<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="4-4-HTML5-Canvas画布与SVG"><a href="#4-4-HTML5-Canvas画布与SVG" class="headerlink" title="4.4 HTML5 Canvas画布与SVG"></a>4.4 HTML5 Canvas画布与SVG</h3><ul>
<li>提供原生的绘图功能<ul>
<li>以前只能用插件(Flash, Silverlight)</li>
</ul>
</li>
<li>完全集成到HTML5文档中( DOM 的一部分)<ul>
<li>可用CSS样式</li>
<li>可用JavaScript控制</li>
</ul>
</li>
<li><p>用于动画、图表、图像、像素操作等</p>
</li>
<li><p>Canvas 支持 2D 和 3D (WebGL)</p>
</li>
<li>将影响动画图形和图表(使用库)</li>
</ul>
<h4 id="4-4-1-SVG与Canvas"><a href="#4-4-1-SVG与Canvas" class="headerlink" title="4.4.1 SVG与Canvas"></a>4.4.1 SVG与Canvas</h4><ul>
<li>SVG 是一种用 XML 描绘 2D 图形的语言</li>
<li>Canvas 绘制 2D 图像, 使用 JavaScript</li>
<li>SVG 是基于 XML 的, 这意味着 SVG DOM 中的每个元素都是可用的。可以为元素附加 JavaScript 事件处理程序</li>
<li>在 SVG 中, 每个绘制的形状都作为一个对象。如果 SVG 对象的属性发生了更改, 浏览器可以自动重新渲染形状</li>
<li>Canvas 是一个像素一个像素渲染的。在 Canvas 中, 一旦绘制出图形, 它就会被浏览器遗忘。如果他的位置需要改变, 整个场景需要重新绘制, 包括可能被图形覆盖的任何对象</li>
</ul>
<h4 id="4-4-2-Canvas-与-SVG-的比较"><a href="#4-4-2-Canvas-与-SVG-的比较" class="headerlink" title="4.4.2 Canvas 与 SVG 的比较"></a>4.4.2 Canvas 与 SVG 的比较</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Canvas</th>
<th>SVG</th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖分辨率</td>
<td>不依赖分辨率</td>
</tr>
<tr>
<td>不支持事件处理器</td>
<td>支持事件处理器</td>
</tr>
<tr>
<td>弱的文本渲染能力</td>
<td>最适合带有大型渲染区域的应用程序(比如谷歌地图)</td>
</tr>
<tr>
<td>能够以 .png 或 .jpg 格式保存结果图像</td>
<td>复杂度高会减慢渲染速度(任何过度使用 DOM 的应用都不快)</td>
</tr>
<tr>
<td>最适合图像密集型的游戏, 其中的许多对象会被频繁重绘</td>
<td>不适合游戏应用</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-4-3-SVG"><a href="#4-4-3-SVG" class="headerlink" title="4.4.3 SVG"></a>4.4.3 SVG</h4><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">baseProfile</span>=<span class="hljs-string">&quot;full&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100%&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;black&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;90&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;blue&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118134053321.png" alt="image-20221118134053321" style="zoom:80%;" /></p>
<h3 id="4-5-HTML5-Web-存储"><a href="#4-5-HTML5-Web-存储" class="headerlink" title="4.5 HTML5 Web 存储"></a>4.5 HTML5 Web 存储</h3><ul>
<li><p>最早本地存储使用的是 cookie, 但是 Web 存储更加的安全与快速</p>
</li>
<li><p>客户端存储数据的两个对象为</p>
<ul>
<li><p><code>localStorage</code>: 用于长久保存整个网站的数据, 保存的数据没有过期时间, 直到手动去除</p>
</li>
<li><p><code>sessionStorage</code>: 用于临时保存同⼀窗口(或标签页)的数据, 在关闭窗口或标签页之后将会删除这些数据。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-6-HTML5-应用程序缓存"><a href="#4-6-HTML5-应用程序缓存" class="headerlink" title="4.6 HTML5 应用程序缓存"></a>4.6 HTML5 应用程序缓存</h3><ul>
<li>使用 HTML5, 通过创建 cache manifest 文件, 可以轻松地创建 web 应用的离线版本</li>
<li>HTML5 引入了应用程序缓存, 这意味着 web 应用可进行缓存, 并可在没有因特网连接时进行访问</li>
<li>应用程序缓存为应用带来三个优势<ul>
<li>离线浏览：用户可在应用离线时使用它们</li>
<li>速度：已缓存资源加载得更快</li>
<li>减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源</li>
</ul>
</li>
<li>manifest 文件是简单的文本文件, 他告知浏览器被缓存的内容(以及不缓存的内容)。manifest 文件可分为三个部分<ul>
<li>CACHE MANIFEST：在此标题下列出的文件将在首次下载后进行缓存</li>
<li>NETWORK：在此标题下列出的文件需要与服务器的连接, 且不会被缓存</li>
<li>FALLBACK：在此标题下列出的文件规定当页面无法访问时的回退页面(比如 404 页面)</li>
</ul>
</li>
</ul>
<h4 id="4-6-1-更新缓存"><a href="#4-6-1-更新缓存" class="headerlink" title="4.6.1 更新缓存"></a>4.6.1 更新缓存</h4><ul>
<li>一旦应用被缓存, 他就会保持缓存直到发生下列情况：<ul>
<li>用户清空浏览器缓存</li>
<li>manifest 文件被修改</li>
<li>由程序来更新应用缓存</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118135644913.png" alt="image-20221118135644913" style="zoom:80%;" /></p>
<h3 id="4-7-HTML5-Web-SQL-数据库"><a href="#4-7-HTML5-Web-SQL-数据库" class="headerlink" title="4.7 HTML5 Web SQL 数据库"></a>4.7 HTML5 Web SQL 数据库</h3><ul>
<li>Web SQL 数据库 API 并不是 HTML5 规范的一部分, 但它是一个独立的规范, 引入了一组使用 SQL 操作客户端数据库的 APIs</li>
<li>规范中定义的三个核心方法<ul>
<li><code>openDatabase</code>: 这个方法使用现有的数据库或者新建的数据库创建一个数据库对象</li>
<li><code>transaction</code>: 这个方法让我们能够控制一个事务, 以及基于这种情况执行提交或者回滚</li>
<li><code>executeSql</code>: 这个方法用于执行实际的 SQL 查询</li>
</ul>
</li>
</ul>
<h3 id="4-8-HTML5-Web-Workers"><a href="#4-8-HTML5-Web-Workers" class="headerlink" title="4.8 HTML5 Web Workers"></a>4.8 HTML5 Web Workers</h3><ul>
<li><p>当在 HTML 页面中执行脚本时, 页面的状态是不可响应的, 直到脚本已完成</p>
</li>
<li><p>web worker 是运行在后台的 JavaScript, 独立于其他脚本, 不会影响页面的性能。可以继续做任何愿意做的事情: 点击、选取内容等等, 而此时 web worker 在后台运行</p>
</li>
</ul>
<h3 id="4-9-HTML5-WebSocket"><a href="#4-9-HTML5-WebSocket" class="headerlink" title="4.9 HTML5 WebSocket"></a>4.9 HTML5 WebSocket</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118140432259.png" alt="image-20221118140432259" style="zoom:80%;" /></p>
<h2 id="5-Something-else"><a href="#5-Something-else" class="headerlink" title="5 Something else"></a>5 Something else</h2><h3 id="5-1-Feature-Detection-特征检测"><a href="#5-1-Feature-Detection-特征检测" class="headerlink" title="5.1 Feature Detection(特征检测)"></a>5.1 Feature Detection(特征检测)</h3><ul>
<li>Feature detect with Modernizr (part of H5BP): <a target="_blank" rel="noopener" href="http://www.modernizr.com">http://www.modernizr.com</a></li>
</ul>
<h3 id="5-2-HTML5-Shiv"><a href="#5-2-HTML5-Shiv" class="headerlink" title="5.2 HTML5 Shiv"></a>5.2 HTML5 Shiv</h3><blockquote>
<p>如果浏览器不支持 H5 如何解决</p>
</blockquote>
<ul>
<li>使用 Sjoerd Visscher 创建的 “HTML5 Enabling JavaScript”, “shiv” 来解决该问题</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118140918519.png" alt="image-20221118140918519" style="zoom:80%;" /></p>
<h3 id="5-3-Markup-Validation-Service"><a href="#5-3-Markup-Validation-Service" class="headerlink" title="5.3 Markup Validation Service"></a>5.3 Markup Validation Service</h3><p>验证语法是否符合规则</p>
<p><a target="_blank" rel="noopener" href="http://validator.w3.org">http://validator.w3.org</a></p>
<h3 id="5-4-H5-相关组织"><a href="#5-4-H5-相关组织" class="headerlink" title="5.4 H5 相关组织"></a>5.4 H5 相关组织</h3><ul>
<li>Web Hypertext Application Technology Working Group (WHATWG)<ul>
<li><a target="_blank" rel="noopener" href="http://www.whatwg.org/specs/web-apps/current-work/">http://www.whatwg.org/specs/web-apps/current-work/</a></li>
</ul>
</li>
<li>World Wide Web Consortium (W3C)<ul>
<li><a target="_blank" rel="noopener" href="http://dev.w3.org/html5/spec/Overview.html">http://dev.w3.org/html5/spec/Overview.html</a></li>
</ul>
</li>
<li>Internet Engineering Task Force (IETF)<ul>
<li><a target="_blank" rel="noopener" href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol">http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol</a></li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/Web前端开发/">Web前端开发</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/前端/">前端</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/11/14/Web前端开发-1/"><span>Web前端开发(1) Internet and WWW</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/11/14/Web前端开发-1/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-14T15:08:58.000Z">
          2022-11-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0-Introduction"></a>0-Introduction</h1><h2 id="1-浏览器Browsers"><a href="#1-浏览器Browsers" class="headerlink" title="1 浏览器Browsers"></a>1 浏览器Browsers</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><h4 id="1-1-1-拥抱不确定性"><a href="#1-1-1-拥抱不确定性" class="headerlink" title="1.1.1 拥抱不确定性"></a>1.1.1 拥抱不确定性</h4><ul>
<li>十年前：微软垄断下严格限定的边界</li>
<li>现在：宽松，比如响应式web设计、渐进渐强</li>
<li>放弃所谓绝对的解决方案：不同设备，不同的浏览器，不同规格的屏幕访问</li>
</ul>
<h4 id="1-1-2-从微软独家垄断到今天百花齐放"><a href="#1-1-2-从微软独家垄断到今天百花齐放" class="headerlink" title="1.1.2 从微软独家垄断到今天百花齐放"></a>1.1.2 从微软独家垄断到今天百花齐放</h4><ul>
<li>第一次浏览器大战：1995-1999</li>
<li>后.com大战：2000-2005，IE占据了90%左右的市场份额</li>
<li>今天：Chrome, Firefox，Opera，Safari，IE；移动设备的大规模增长；浏览器版本更新频率极快</li>
</ul>
<h4 id="1-1-3-我们现在所处的位置"><a href="#1-1-3-我们现在所处的位置" class="headerlink" title="1.1.3 我们现在所处的位置"></a>1.1.3 我们现在所处的位置</h4><ul>
<li>可变因素：屏幕分辨率 像素深度 浏览器兼容性 屏幕大小 人机交互输入框类型…</li>
</ul>
<h3 id="1-2-浏览器"><a href="#1-2-浏览器" class="headerlink" title="1.2 浏览器"></a>1.2 浏览器</h3><ul>
<li>四大派系，核心是布局引擎，用以决定文档和样式如何渲染<ul>
<li>微软的Trident，IE的内核</li>
<li>基于开源项目WebKit的浏览器</li>
<li>基于Blink开源项目的浏览器<ul>
<li>2013从WebKit中派生，是最新版的Chrome和Opera的布局引擎</li>
</ul>
</li>
<li>Mozilla公司的Gecko，Firefox的内核</li>
</ul>
</li>
</ul>
<h3 id="1-3-JavaScript引擎"><a href="#1-3-JavaScript引擎" class="headerlink" title="1.3 JavaScript引擎"></a>1.3 JavaScript引擎</h3><ul>
<li>Chakra：IE</li>
<li>SquirrelFish Extreme／Nitro：Webkit</li>
<li>V8：Chrome和Opera<ul>
<li>第⼀个在执行前将JS编译为原生代码的JS引擎</li>
</ul>
</li>
<li>SpiderMonkey：Firefox</li>
</ul>
<h3 id="1-4-因此"><a href="#1-4-因此" class="headerlink" title="1.4 因此"></a>1.4 因此</h3><ul>
<li>测试尽可能多的浏览器是必要</li>
<li>然而为特定浏览器或浏览器版本开发或写特定的代码，很少奏效。这是⼀个过于庞大的清单</li>
<li>需要考虑的是特性，特性检测</li>
</ul>
<h1 id="1-1-Internet"><a href="#1-1-Internet" class="headerlink" title="1.1-Internet"></a>1.1-Internet</h1><h2 id="1-互联网"><a href="#1-互联网" class="headerlink" title="1 互联网"></a>1 互联网</h2><ul>
<li>互联网与万维网有何不同<ul>
<li>WWW = HTML* + HTTP(S)</li>
<li>包含CSS，JavaScript，以及其他浏览器内容</li>
</ul>
</li>
</ul>
<h3 id="1-1-简要发展史"><a href="#1-1-简要发展史" class="headerlink" title="1.1 简要发展史"></a>1.1 简要发展史</h3><ul>
<li>万维网，1989-91由Tim Berners-Lee创造：This is for Everyone</li>
<li>发布流行的浏览器：Netscape 1994, IE 1995</li>
<li>Amazon.com 1995 -&gt; Google 1996 -&gt; .COM 2000-2002 -&gt; web2.0 2004 -&gt; web3.0 2016</li>
</ul>
<h3 id="1-2-相关组织"><a href="#1-2-相关组织" class="headerlink" title="1.2 相关组织"></a>1.2 相关组织</h3><ul>
<li>Internet Engineering Task Force (IETF)：互联网协议标准</li>
<li>Internet Corporation for Assigned Names and Numbers (ICANN)：顶级域名</li>
<li>World Wide Web Consortium (W3C)：Web标准</li>
</ul>
<h2 id="2-常用协议"><a href="#2-常用协议" class="headerlink" title="2 常用协议"></a>2 常用协议</h2><h3 id="2-1-网际互连协议-IP"><a href="#2-1-网际互连协议-IP" class="headerlink" title="2.1 网际互连协议(IP)"></a>2.1 网际互连协议(IP)</h3><ul>
<li>IPv4</li>
<li>IPv6</li>
</ul>
<h3 id="2-2-传输控制协议-TCP"><a href="#2-2-传输控制协议-TCP" class="headerlink" title="2.2 传输控制协议(TCP)"></a>2.2 传输控制协议(TCP)</h3><ul>
<li>是⼀种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。</li>
<li>命令：netstat (Windows)、CurrPorts</li>
</ul>
<h3 id="2-3-用户数据报协议-UDP"><a href="#2-3-用户数据报协议-UDP" class="headerlink" title="2.3 用户数据报协议(UDP)"></a>2.3 用户数据报协议(UDP)</h3><ul>
<li>User Data Protocol，是传输层协议</li>
<li>⼀个简单的面向数据报的传输层协议，提供的是非面向连接的、不可靠的数据流传输</li>
<li>没有超时重发等机制，故而传输速度很快</li>
</ul>
<h3 id="2-4-域名系统-DNS"><a href="#2-4-域名系统-DNS" class="headerlink" title="2.4 域名系统(DNS)"></a>2.4 域名系统(DNS)</h3><ul>
<li>DNS是域名系统,Domain Name System的缩写</li>
<li>因特网上作为域名和IP地址互相映射的⼀个分布式数据库</li>
<li>DNS系统的作用<ul>
<li>正向解析：根据主机名称(域名)查找对应的IP地址</li>
<li>反向解析：根据IP地址查找对应的主机域名</li>
</ul>
</li>
</ul>
<h4 id="2-4-1-DNS之前…"><a href="#2-4-1-DNS之前…" class="headerlink" title="2.4.1 DNS之前…"></a>2.4.1 DNS之前…</h4><p>… hosts.txt文件</p>
<ul>
<li>DNS 之前(直到1985), name-to-IP地址是通过使用FTP从中央服务器下载单个文件(hosts.txt)完成的<ul>
<li>hosts.txt中的名称不是结构化的</li>
<li>hosts.txt文件在大多数操作系统上仍然可以⼯作，可用于定义本地名称<ul>
<li>Windows: C:\Windows\system32\drivers\etc\hosts</li>
<li>Mac: /private/etc/hosts</li>
<li>Linux: /etc/hosts</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-2-解析器与名称服务器"><a href="#2-4-2-解析器与名称服务器" class="headerlink" title="2.4.2 解析器与名称服务器"></a>2.4.2 解析器与名称服务器</h4><ul>
<li>主机上的应用程序通过DNS客户端访问域名系统，称为解析器</li>
<li>解析器联系DNS服务器，称为名称服务器</li>
<li>DNS服务器返回IP地址给解析器，解析器将IP地址传递给应用程序</li>
<li>反向查找也可以，即查找给定IP地址的主机名</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114233154115.png" alt="image-20221114233154115" style="zoom:80%;" /></p>
<h4 id="2-4-3-DNS名称层次结构"><a href="#2-4-3-DNS名称层次结构" class="headerlink" title="2.4.3 DNS名称层次结构"></a>2.4.3 DNS名称层次结构</h4><ul>
<li>DNS层次结构可以用树表示</li>
<li><p>根域名和顶级域名由互联网中央名称注册机构(ICANN)管理。</p>
</li>
<li><p>在顶级域名(TLD，TopLevel Domain)之下，名称空间的管理被委派给不同的组织</p>
</li>
<li>每个组织都可以进⼀步授权</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114233239657.png" alt="image-20221114233239657"></p>
<h4 id="2-4-4-域名"><a href="#2-4-4-域名" class="headerlink" title="2.4.4 域名"></a>2.4.4 域名</h4><ul>
<li>主机和DNS域名根据其在域名树中的位置命名</li>
<li><p>DNS域名树中的每个节点都可以通过唯⼀的全限定域名(FQDN)来标识。FQDN给出了在DNS树中的位置。</p>
<ul>
<li>software.nju.edu.cn or software.nju.edu.cn.</li>
</ul>
</li>
<li><p>⼀个FQDN由标签(“software”，“nju”， “edu”， “cn”)组成，标签之间用句号(“.”)隔开。</p>
<ul>
<li>结尾可以有⼀个句号(“.”)。</li>
<li>每个标签最多可以有63个字符</li>
<li>FQDN包含字符、数字和破折号(“ - “)</li>
<li>fFQDN不区分大小写</li>
</ul>
</li>
</ul>
<h4 id="2-4-5-名称服务器的层次结构"><a href="#2-4-5-名称服务器的层次结构" class="headerlink" title="2.4.5 名称服务器的层次结构"></a>2.4.5 名称服务器的层次结构</h4><ul>
<li>层次名称空间的解析是由层次化的名称服务器完成的</li>
<li><p>每个服务器负责(授权)DNS名称空间的⼀个连续部分，称为区域。</p>
</li>
<li><p>区域是子树的⼀部分</p>
</li>
<li>DNS服务器对其所属区域内的主机进行应答</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114233847492.png" alt="image-20221114233847492" style="zoom:80%;" /></p>
<h4 id="2-4-6-主名称服务器和辅名称服务器"><a href="#2-4-6-主名称服务器和辅名称服务器" class="headerlink" title="2.4.6 主名称服务器和辅名称服务器"></a>2.4.6 主名称服务器和辅名称服务器</h4><ul>
<li>对于每个区域，必须有⼀个主名称服务器和辅助名称服务器<ul>
<li>主服务器(主服务器)维护⼀个区域文件，其中包含关于区域的域名信息。对主服务器进行更新。</li>
<li>辅服务器复制存储在主服务器上的数据。</li>
</ul>
</li>
<li>添加⼀个主机: 当⼀个新主机(“xxx.cs.xxx.edu.cn”)被添加到⼀个区域时，管理员将该主机的IP信息(IP地址和名称)添加到主服务器上的配置文件中</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114233955965.png" alt="image-20221114233955965" style="zoom:80%;" /></p>
<h4 id="2-4-7-根域名服务器"><a href="#2-4-7-根域名服务器" class="headerlink" title="2.4.7 根域名服务器"></a>2.4.7 根域名服务器</h4><ul>
<li>互联网的顶级域名解析服务由根服务器完成</li>
<li>只有13个根域名服务器</li>
<li>根服务器对网络安全、运行稳定至关重要，被称为互联网的“中枢神经”</li>
</ul>
<h4 id="2-4-8-域名解析"><a href="#2-4-8-域名解析" class="headerlink" title="2.4.8 域名解析"></a>2.4.8 域名解析</h4><ul>
<li>用户程序发出主机名到IP地址的请求</li>
<li>本地解析器向主机的名称服务器提出DNS查询</li>
<li>名称服务器检查它是否被授权回答查询。<ul>
<li>如果是，它会响应。</li>
<li>否则，它将从根树开始查询其他名称服务器</li>
</ul>
</li>
<li>当名称服务器得到答案时，它将其发送到解析器。</li>
</ul>
<h4 id="2-4-9-递归和迭代查询"><a href="#2-4-9-递归和迭代查询" class="headerlink" title="2.4.9 递归和迭代查询"></a>2.4.9 递归和迭代查询</h4><ul>
<li>查询有两种类型: 递归查询、迭代(非递归)查询</li>
<li>递归查询:如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下⼀步查询。</li>
<li>迭代查询:当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下⼀步应当向哪⼀个域名服务器进行查询” 。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114234325153.png" alt="image-20221114234325153"></p>
<h4 id="2-4-10-缓存"><a href="#2-4-10-缓存" class="headerlink" title="2.4.10 缓存"></a>2.4.10 缓存</h4><ul>
<li>为了减少DNS流量，名称服务器会缓存域名/IP地址映射信息</li>
<li>当查询的条目在缓存中时，服务器不会联系其他服务器</li>
</ul>
<h4 id="2-4-11-资源记录-Resource-Records"><a href="#2-4-11-资源记录-Resource-Records" class="headerlink" title="2.4.11 资源记录(Resource Records)"></a>2.4.11 资源记录(Resource Records)</h4><ul>
<li>分布式数据库的数据库记录称为资源记录(RR)。</li>
<li>资源记录存储在名称服务器上的配置文件(分区文件)中。</li>
<li>DNS数据库包含的不仅仅是主机名到地址的记录:<ul>
<li>名称服务器记录 ns</li>
<li>主机名别名 CNAME</li>
<li>邮件服务器 mx</li>
<li>主机信息 hinfo</li>
</ul>
</li>
</ul>
<h2 id="3-资源标识符"><a href="#3-资源标识符" class="headerlink" title="3 资源标识符"></a>3 资源标识符</h2><ul>
<li>统⼀资源标识符<ul>
<li>Uniform Resource Identifier，URI</li>
<li>用于标识某⼀互联网资源名称的字符串，该种标识允许用户对任何(包括本地和互联网)的资源通过特定的协议进行交互操作。</li>
</ul>
</li>
<li>统⼀资源定位符<ul>
<li>Uniform Resource Locator，URL</li>
<li>URL是⼀种URI，它标识⼀个互联网资源，并指定对其进行操作或获取该资源的方法。</li>
</ul>
</li>
<li>统⼀资源名称<ul>
<li>Uniform Resource Name，URN</li>
<li>定义某事物的身份</li>
<li>URN仅用于命名，而不指定地址</li>
</ul>
</li>
</ul>
<h3 id="3-1-URI"><a href="#3-1-URI" class="headerlink" title="3.1 URI"></a>3.1 URI</h3><ul>
<li>RFC 2396</li>
<li>URI可被视为定位符(URL)，名称(URN)或两者兼备</li>
<li>URI格式由URI协议名(例如http、ftp、mailto、file)，⼀个冒号，和协议对应的内容所构成</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114235136029.png" alt="image-20221114235136029"></p>
<h3 id="3-2-URN"><a href="#3-2-URN" class="headerlink" title="3.2 URN"></a>3.2 URN</h3><ul>
<li>URN是基于某名字空间通过名称指定资源的URI</li>
<li>位置⽆关</li>
<li>需要基础设施，因而未被⼴泛应用</li>
<li>Example URN：urn:ietf:rfc:2141</li>
</ul>
<h3 id="3-3-URL"><a href="#3-3-URL" class="headerlink" title="3.3 URL"></a>3.3 URL</h3><ul>
<li>统⼀资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的⼀种简洁的表示。</li>
<li>URL 给资源的位置提供⼀种抽象的识别方法，并用这种方法给资源定位。</li>
</ul>
<h4 id="3-3-1-URL的一般形式"><a href="#3-3-1-URL的一般形式" class="headerlink" title="3.3.1 URL的一般形式"></a>3.3.1 URL的一般形式</h4><ul>
<li>协议 (http:): 标识用于获取内容的协议.</li>
<li>主机 (//host.company.com): 要连接到的计算机的名称.</li>
<li>端口 (80): 允许多个服务器在同⼀台机器上运行.</li>
<li>路径(/a/b/c.html): 服务器用于查找内容.</li>
<li>查询字段 (?user=Alice&amp;year=2008): 提供其他参数</li>
<li>片段标识符(p2): 单页面路由，锚点定位</li>
</ul>
<h4 id="3-3-2-URL协议"><a href="#3-3-2-URL协议" class="headerlink" title="3.3.2 URL协议"></a>3.3.2 URL协议</h4><ul>
<li><p>http、https、file、mailto</p>
</li>
<li><p>还有其他几种协议，比如ftp，但已经不常用了</p>
</li>
</ul>
<h4 id="3-3-3-URL路径-a-b-c-html"><a href="#3-3-3-URL路径-a-b-c-html" class="headerlink" title="3.3.3 URL路径(/a/b/c.html)"></a>3.3.3 URL路径(/a/b/c.html)</h4><ul>
<li><p>传递到web服务器进行解释。早期的web服务器: </p>
<ul>
<li>静态HTML文件的路径名。</li>
<li>生成HTML内容的程序的路径名(例如foo.php)。</li>
</ul>
</li>
<li><p>路由信息</p>
<ul>
<li>将层次位置映射到要执行的函数以及函数的参数</li>
</ul>
</li>
<li>应用程序编程接口(API)设计，示例:<ul>
<li>/user/create</li>
<li>/user/list</li>
<li>/user/0x23490</li>
<li>/user/delete/0x23433</li>
</ul>
</li>
</ul>
<h4 id="3-3-4-查询字段"><a href="#3-3-4-查询字段" class="headerlink" title="3.3.4 查询字段"></a>3.3.4 查询字段</h4><ul>
<li>查询字段是指在URL的末尾加上用于向服务器发送信息的字符串(变量)。 将“?”放在URL的末尾，然后再加上“参数 = 值”，想加上多个参数的话，使用“&amp;”。</li>
<li><p>网站访问分析(被动参数)</p>
<ul>
<li>被动参数对显示的内容没有影响。</li>
<li>为了了解用户从哪里到达了自己的网站，设定固有的参数来统计。</li>
<li>通常，当想要分析网站流入的来源以吸引客户，或者想要知道来自搜索引擎⼴告的流入客户时，可以使用它。</li>
</ul>
</li>
<li><p>显示动态页面结果(活动参数)</p>
<ul>
<li>会影响显示的内容。换句话说，添加参数将改变网站上显示的内容</li>
</ul>
</li>
</ul>
<h4 id="3-3-5-URL的使用"><a href="#3-3-5-URL的使用" class="headerlink" title="3.3.5 URL的使用"></a>3.3.5 URL的使用</h4><ul>
<li>加载页面，在浏览器地址栏输入URL</li>
<li>加载图像: <code>&lt;img src=&quot;...&quot; /&gt;</code></li>
<li>加载样式表: <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;...&quot;&gt;</code></li>
<li>嵌入页面: <code>&lt;iframe src=&quot;http://www.google.com&quot;&gt;</code></li>
</ul>
<h4 id="3-3-6-URL编码"><a href="#3-3-6-URL编码" class="headerlink" title="3.3.6 URL编码"></a>3.3.6 URL编码</h4><ul>
<li>URL编码将字符转换为可通过因特网传输的格式。</li>
<li>URL只能使用 ASCII 字符集通过因特网进行发送。</li>
<li>由于URL通常包含 ASCII 集之外的字符，因此必须将URL转换为有效的 ASCII 格式。</li>
<li>URL编码使用后跟⼗六进制数字的 “%” 替代不安全的 ASCII 字符。</li>
<li>URL不能包含空格。URL 编码通常使用加号(+)或 %20 替代空格。</li>
</ul>
<h2 id="4-超文本Hypertext"><a href="#4-超文本Hypertext" class="headerlink" title="4 超文本Hypertext"></a>4 超文本Hypertext</h2><ul>
<li>超文本是用超链接的方法，将各种不同空间的文字信息组织在⼀起的网状文本。</li>
<li>超链接是Web页面区别于其他媒体的重要特征之⼀，网页浏览者只要单击网页中的超链接就可以自动跳转到超链接的目标对象，且超链接的数量是不受限制的。</li>
<li>用标签<code>&lt;a&gt;</code>来实现</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114235831918.png" alt="image-20221114235831918"></p>
<h3 id="4-1-种类"><a href="#4-1-种类" class="headerlink" title="4.1 种类"></a>4.1 种类</h3><ul>
<li>网页上的超链接⼀般分为三种：<ul>
<li>绝对URL的超链接</li>
<li>相对URL的超链接</li>
<li>同⼀网页的超链接，锚点链接/书签链接。</li>
</ul>
</li>
</ul>
<h1 id="1-2-WWW"><a href="#1-2-WWW" class="headerlink" title="1.2 WWW"></a>1.2 WWW</h1><h2 id="1-Web"><a href="#1-Web" class="headerlink" title="1 Web"></a>1 Web</h2><h3 id="1-1-Web服务器和浏览器"><a href="#1-1-Web服务器和浏览器" class="headerlink" title="1.1 Web服务器和浏览器"></a>1.1 Web服务器和浏览器</h3><ul>
<li><p>Web服务器</p>
<ul>
<li>Apache</li>
<li>Microsoft Internet Information Server (IIS) (part of Windows)</li>
</ul>
</li>
<li><p>Web浏览器: 从Web服务器获取/显示文档</p>
<ul>
<li>Microsoft Internet Explorer (IE)</li>
<li>Mozilla Firefox</li>
<li>Apple Safari</li>
<li>Google Chrome</li>
<li>Opera</li>
</ul>
</li>
</ul>
<h3 id="1-2-Web的表现形式"><a href="#1-2-Web的表现形式" class="headerlink" title="1.2 Web的表现形式"></a>1.2 Web的表现形式</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116234212980.png" alt="image-20221116234212980" style="zoom:80%;" /></p>
<h3 id="1-3-互联网的影响"><a href="#1-3-互联网的影响" class="headerlink" title="1.3 互联网的影响"></a>1.3 互联网的影响</h3><ul>
<li>改变生活方式、改变交流方式、改变购物方式、改变娱乐方式、改变教育方式、改变医疗方式</li>
</ul>
<h3 id="1-4-Web发展历程"><a href="#1-4-Web发展历程" class="headerlink" title="1.4 Web发展历程"></a>1.4 Web发展历程</h3><p>Text -&gt; Web 1.0 -&gt;  Web 2.0 -&gt;  Web 3.0</p>
<h2 id="2-Web1-0-Web2-0-Web3-0"><a href="#2-Web1-0-Web2-0-Web3-0" class="headerlink" title="2 Web1.0 Web2.0 Web3.0"></a>2 Web1.0 Web2.0 Web3.0</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117000428194.png" alt="image-20221117000428194" style="zoom:80%;" /></p>
<h3 id="2-1-演变"><a href="#2-1-演变" class="headerlink" title="2.1 演变"></a>2.1 演变</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117000444817.png" alt="image-20221117000444817" style="zoom:80%;" /></p>
<h3 id="2-2-Web-2-0"><a href="#2-2-Web-2-0" class="headerlink" title="2.2 Web 2.0"></a>2.2 Web 2.0</h3><h4 id="2-2-1-Web-2-0特点"><a href="#2-2-1-Web-2-0特点" class="headerlink" title="2.2.1 Web 2.0特点"></a>2.2.1 Web 2.0特点</h4><ul>
<li>Web2.0是⼀个架构在知识上的环境，人与人之间交互而产生出的内容，经由在服务导向的架构中的程序，在这个环境中被发布、管理和使用。</li>
</ul>
<h4 id="2-2-2-Web-2-0典型应用"><a href="#2-2-2-Web-2-0典型应用" class="headerlink" title="2.2.2 Web 2.0典型应用"></a>2.2.2 Web 2.0典型应用</h4><ul>
<li>Facebook，Wiki百科，豆瓣，土豆网，微博</li>
</ul>
<h4 id="2-2-3-Web-2-0的局限性"><a href="#2-2-3-Web-2-0的局限性" class="headerlink" title="2.2.3 Web 2.0的局限性"></a>2.2.3 Web 2.0的局限性</h4><ul>
<li>传播端过剩，过度饱和</li>
<li>概念偏差</li>
<li>时间</li>
<li>互动模式</li>
<li>数据确权和授权</li>
</ul>
<h4 id="2-2-4-用户缺乏自主权"><a href="#2-2-4-用户缺乏自主权" class="headerlink" title="2.2.4 用户缺乏自主权"></a>2.2.4 用户缺乏自主权</h4><ul>
<li>用户对数字身份缺乏自主权<ul>
<li>不同账户体系间相互独⽴</li>
<li>联邦身份管理模式，减少重复开户的次数</li>
</ul>
</li>
<li>用户对个人数据缺乏自主权<ul>
<li>弱势，“要么同意，要么不服务”的选择</li>
<li>被采集甚至过度采集</li>
</ul>
</li>
<li>用户在算法面前缺乏自主权<ul>
<li>算法滥用、算法作恶，比如大数据杀熟</li>
<li>滥用人性弱点，过度激励、诱导用户消费</li>
</ul>
</li>
</ul>
<h3 id="2-3-Web-3-0"><a href="#2-3-Web-3-0" class="headerlink" title="2.3 Web 3.0"></a>2.3 Web 3.0</h3><blockquote>
<p>Tim Berners-Lee: </p>
<p>“人们不停地质问Web 3.0到底是什么。我认为当可缩放矢量图形在 Web 2.0的基础上大面积使用——所有东西都起波纹、被折叠并且看起来没有棱角——以及⼀整张语义网涵盖著大量的数据，你就可以访问这难以置信的数据资源。</p>
<p>Google CEO 埃里克施密特定义是：</p>
<p>Web 3.0是⼀系列组合在⼀起的应用，对于个人用户来讲互联网将更具有可管理性，也意味着，互联网将由⼀系列的标准化Web组件拼装起来。</p>
<p>以太坊的联合创始人加文·伍德(Gavin Wood)：</p>
<p>“Web3.0是⼀组兼容的协议。这些协议为用户提供了强大并且可验证的保证，保护他们接收和发送的信息以及他们的支付信息。通过授权用户在低门槛市场中为自己行动，我们可以确保审查和垄断机会的减少。”</p>
</blockquote>
<h4 id="2-3-1-Web-3-0特征"><a href="#2-3-1-Web-3-0特征" class="headerlink" title="2.3.1 Web 3.0特征"></a>2.3.1 Web 3.0特征</h4><ul>
<li>语义化、3D、人工智能、去中心化</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/Web前端开发/">Web前端开发</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/前端/">前端</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/11/10/计算机操作系统-4-设备管理/"><span>计算机操作系统(4) 设备管理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/11/10/计算机操作系统-4-设备管理/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-10T06:05:58.000Z">
          2022-11-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="第四章-设备管理"><a href="#第四章-设备管理" class="headerlink" title="第四章 设备管理"></a>第四章 设备管理</h1><h2 id="4-1-设备管理基础"><a href="#4-1-设备管理基础" class="headerlink" title="4.1 设备管理基础"></a>4.1 设备管理基础</h2><h3 id="4-1-1-设备管理概述"><a href="#4-1-1-设备管理概述" class="headerlink" title="4.1.1 设备管理概述"></a>4.1.1 设备管理概述</h3><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a><strong>I/O设备</strong></h4><ul>
<li>I/O设备，又称输入输出设备、外围设备、外部设备、外设<ul>
<li>用于计算机系统与外部世界(如用户、其它计算机或设备)的信息交换或存储</li>
</ul>
</li>
<li>I/O操作：内存和I/O设备之间的信息传送操作<ul>
<li>影响计算机的通用性和可扩充性</li>
<li>影响计算机系统综合处理能力及性价比的重要因素</li>
</ul>
</li>
</ul>
<h4 id="I-O设备的分类"><a href="#I-O设备的分类" class="headerlink" title="I/O设备的分类"></a><strong>I/O设备的分类</strong></h4><ul>
<li>信息传输视角<ul>
<li>输入设备：将外界信息输入计算机<ul>
<li>例如：键盘，鼠标，扫描仪等</li>
</ul>
</li>
<li>输出设备：将计算结果输出<ul>
<li>例如：显示器，打印机等</li>
</ul>
</li>
<li>输入输出设备：输入信息并输出信息<ul>
<li>例如：磁盘驱动器，网卡等</li>
</ul>
</li>
</ul>
</li>
<li><p>交互功能视角</p>
<ul>
<li>人机交互设备：用于用户与计算机间的交互通信<ul>
<li>例如：鼠标，键盘，显示器等</li>
</ul>
</li>
<li>存储设备：存储大量信息并快速检索<ul>
<li>例如：磁盘驱动器，光盘驱动器等</li>
</ul>
</li>
<li>机机通信设备：用于计算机间通信<ul>
<li>例如：网卡，调制解调器等</li>
</ul>
</li>
</ul>
</li>
<li><p>设备管理视角</p>
<ul>
<li>字符设备：以字符为单位进行信息交换，例如鼠标、显示器</li>
<li>块设备：以固定大小的数据块为单位进行信息交换，例如磁盘<ul>
<li>块是存储介质上连续信息组成的一个区域</li>
</ul>
</li>
<li>网络设备：机机通信设备，例如网卡等<ul>
<li>可抽象为传送字符流的字符设备，也可以抽象为传送连续小块数据的块设备</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="设备管理的目标"><a href="#设备管理的目标" class="headerlink" title="设备管理的目标"></a><strong>设备管理的目标</strong></h4><ul>
<li><p><strong>解决设备和CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率</strong></p>
</li>
<li><p>屏蔽设备的物理细节和操作过程，配置驱动程序，提供统一界面</p>
<ul>
<li>抽象为裸设备</li>
<li>抽象为设备文件</li>
</ul>
</li>
<li>操作系统将所有设备(如磁带机、打印机、显示器和终端等)都定义为文件，统一在文件系统之下，赋予文件属性，对设备的操作就类似于对文件的操作，其优点:<ul>
<li>尽可能统一文件和设备的I/O处理</li>
<li>尽可能把设备文件和普通文件纳入同一保护机制下</li>
<li>为了方便用户或高层进程使用，设备管理还对各种设备进行抽象，配置驱动程序，提供统一界面，屏蔽设备的物理细节和操作过程</li>
</ul>
</li>
</ul>
<h4 id="设备管理的功能"><a href="#设备管理的功能" class="headerlink" title="设备管理的功能"></a><strong>设备管理的功能</strong></h4><ul>
<li>设备中断管理</li>
<li>缓冲区管理</li>
<li>设备的分配和去配</li>
<li>设备驱动调度</li>
<li>虚拟设备的实现</li>
</ul>
<h4 id="设备管理的层次"><a href="#设备管理的层次" class="headerlink" title="设备管理的层次"></a><strong>设备管理的层次</strong></h4><ul>
<li>I/O硬件<ul>
<li>I/O设备及其接口线路</li>
<li>控制部件</li>
<li>通道</li>
</ul>
</li>
<li>I/O软件<ul>
<li>系统I/O软件</li>
<li>用户空间I/O软件</li>
</ul>
</li>
</ul>
<h3 id="4-1-2-I-O控制方式"><a href="#4-1-2-I-O控制方式" class="headerlink" title="4.1.2 I/O控制方式"></a>4.1.2 I/O控制方式</h3><h4 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a><strong>设备控制器</strong></h4><ul>
<li>为达到模块化和通用性的设计目标，通常分开设置设备中的机械部件和电子部件</li>
<li>电子部件称为设备控制器、又称为设备适配器、I/O控制器、I/O控制接口、I/O模块、I/O接口</li>
<li>系统与控制器交互，而非与设备交互</li>
<li>设备控制器具体控制设备进行I/O</li>
</ul>
<h4 id="设备控制器的功能"><a href="#设备控制器的功能" class="headerlink" title="设备控制器的功能"></a><strong>设备控制器的功能</strong></h4><ul>
<li>设备控制器是CPU与设备之间的接口<ul>
<li>接收和识别CPU或通道发来的命令</li>
<li>实现数据交换</li>
<li>发现和记录设备及自身的状态信息，供CPU处理时使用</li>
<li>当连接多台设备时，识别设备地址</li>
</ul>
</li>
</ul>
<h4 id="设备控制器的组成示意"><a href="#设备控制器的组成示意" class="headerlink" title="设备控制器的组成示意"></a><strong>设备控制器的组成示意</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110145307845.png" alt="image-20221110145307845"></p>
<h4 id="I-O控制的轮询方式"><a href="#I-O控制的轮询方式" class="headerlink" title="I/O控制的轮询方式"></a><strong>I/O控制的轮询方式</strong></h4><ul>
<li>处理器向控制器发送I/O命令，轮询I/O结果</li>
<li>如果设备未就绪，则重复测试过程，直至设备就绪</li>
<li>执行内存数据交换</li>
<li>等待I/O操作完成后，处理器才可以继续其它操作</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110145630241.png" alt="image-20221110145630241" style="zoom:80%;" /></p>
<h4 id="I-O控制的中断方式"><a href="#I-O控制的中断方式" class="headerlink" title="I/O控制的中断方式"></a><strong>I/O控制的中断方式</strong></h4><ul>
<li>处理器向控制器发出具体I/O命令，然后继续执行后续指令<ul>
<li>若该进程支持异步I/O，后续指令可以仍是该进程中的指令</li>
<li>否则，该进程在这个中断上挂起，处理器执行其他工作</li>
</ul>
</li>
<li>控制器检查设备状态，就绪后发出中断</li>
<li>CPU响应中断，进行中断处理</li>
<li>中断处理执行内存数据交换</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110150514138.png" alt="image-20221110150514138" style="zoom:80%;" /></p>
<h4 id="I-O控制的DMA方式"><a href="#I-O控制的DMA方式" class="headerlink" title="I/O控制的DMA方式"></a><strong>I/O控制的DMA方式</strong></h4><ul>
<li>直接存储器访问(Direct Memory Access)</li>
<li>DMA模块<ul>
<li>能够替代处理器来控制主存和设备控制器之间的数据交换</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110150658729.png" alt="image-20221110150658729" style="zoom:80%;" /></p>
<h4 id="DMA的工作流程"><a href="#DMA的工作流程" class="headerlink" title="DMA的工作流程"></a><strong>DMA的工作流程</strong></h4><ul>
<li>处理器向DMA模块发出I/O命令</li>
<li>处理器继续执行其它工作，DMA模块负责传送全部数据</li>
<li>数据传送结束后，DMA中断处理器</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110150908940.png" alt="image-20221110150908940" style="zoom:80%;" /></p>
<h4 id="DMA方式中的周期窃取"><a href="#DMA方式中的周期窃取" class="headerlink" title="DMA方式中的周期窃取"></a><strong>DMA方式中的周期窃取</strong></h4><ul>
<li>当DMA和CPU同时经总线访问内存时，CPU会把总线的占有权让给DMA一个或几个主存周期</li>
<li>周期窃取对CPU与主存的数据交换影响不大<ul>
<li>数据传送过程是不连续的和不规则的</li>
<li>CPU大部分情况下与Cache进行数据交换，直接访问内存较少</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110151301200.png" alt="image-20221110151301200"></p>
<h4 id="I-O控制方式的总结"><a href="#I-O控制方式的总结" class="headerlink" title="I/O控制方式的总结"></a><strong>I/O控制方式的总结</strong></h4><ul>
<li><strong>轮询</strong>方式：CPU等待设备就绪，且参与内存数据交换</li>
<li><strong>中断</strong>方式：CPU无需等待设备就绪，响应中断后参与内存数据交换</li>
<li><strong>DMA</strong>方式：CPU只在I/O开始和结束时参与，不参与主存数据交换</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110151553359.png" alt="image-20221110151553359" style="zoom:80%;" /></p>
<h4 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a><strong>I/O通道</strong></h4><ul>
<li>又称为通道控制器、I/O处理器，用于完成逻辑上独立的I/O任务</li>
<li>采用四级连接：处理器，通道，控制器，设备<ul>
<li>通道可控制多台同类或不同类的设备</li>
</ul>
</li>
<li>处理器不再执行I/O指令，而是在主存中组织通道程序，由I/O通道执行</li>
<li>为获得CPU和外围设备间更高的并行工作能力，为让种类繁多，物理特性各异的外围设备能以标准的接口连接到系统中，计算机系统引入了自成独立体系的通道结构</li>
</ul>
<h4 id="I-O通道的工作流程"><a href="#I-O通道的工作流程" class="headerlink" title="I/O通道的工作流程"></a><strong>I/O通道的工作流程</strong></h4><ol>
<li><p>CPU遇到I/O任务，组织通道程序，置通道程序地址字CAW，启动指定通道</p>
</li>
<li><p>通道从CAW获取通道程序，控制I/O设备进行操作。CPU执行其他任务</p>
</li>
<li><p>I/O操作完成后，I/O通道发出中断，CPU处理中断，并从通道程序状态字CSW获得通道执行情况，处理I/O操作</p>
</li>
</ol>
<ul>
<li><strong>CPU与通道高度并行工作</strong></li>
</ul>
<h3 id="4-1-3-总线与I-O"><a href="#4-1-3-总线与I-O" class="headerlink" title="4.1.3 总线与I/O"></a>4.1.3 总线与I/O</h3><h4 id="总线：解决I-O速度不匹配问题"><a href="#总线：解决I-O速度不匹配问题" class="headerlink" title="总线：解决I/O速度不匹配问题"></a><strong>总线：解决I/O速度不匹配问题</strong></h4><ul>
<li>I/O与CPU速度、各设备I/O速度不匹配</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110154228960.png" alt="image-20221110154228786" style="zoom:80%;" /></p>
<ul>
<li>使主机和设备充分并行，提高系统效率</li>
</ul>
<h4 id="单总线结构模型"><a href="#单总线结构模型" class="headerlink" title="单总线结构模型"></a><strong>单总线结构模型</strong></h4><ul>
<li>将CPU、主存和I/O模块连接到同一总线</li>
<li>优点：结构简单，易于扩充</li>
<li>缺点：共用总线；设备多时总线压力大，传输时延长，且慢速外设占用带宽多</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110154610295.png" alt="image-20221110154610295" style="zoom:80%;" /></p>
<h4 id="三级总线模型"><a href="#三级总线模型" class="headerlink" title="三级总线模型"></a><strong>三级总线模型</strong></h4><ul>
<li>主存和Cache通过主存总线连接，主存总线和扩展总线上的I/O设备间通过扩展总线接口缓冲</li>
<li>优点：主存与I/O之间的数据传送、处理器的内存活动分离；可以支持更多的I/O设备</li>
<li>缺点：不适用于I/O设备数据速率相差太大的情形</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110154559310.png" alt="image-20221110154559310" style="zoom:80%;" /></p>
<h4 id="南桥与北桥"><a href="#南桥与北桥" class="headerlink" title="南桥与北桥"></a><strong>南桥与北桥</strong></h4><ul>
<li>通过存储总线、PCI总线、E(ISA)总线分别连接主存、高速I/O设备和低速I/O设备</li>
<li>优点：可以支持不同数据速率的I/O设备</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221110154634521.png" alt="image-20221110154634521" style="zoom:80%;" /></p>
<h4 id="一种基于通道的服务器总线模型"><a href="#一种基于通道的服务器总线模型" class="headerlink" title="一种基于通道的服务器总线模型"></a><strong>一种基于通道的服务器总线模型</strong></h4><ul>
<li>支持CPU、主存和多个I/O通道之间的数据传送</li>
<li>支持I/O通道和I/O控制器，以及I/O控制器和设备之间的数据传送</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114145214381.png" alt="image-20221114145214381"></p>
<h2 id="4-2-设备管理软件"><a href="#4-2-设备管理软件" class="headerlink" title="4.2 设备管理软件"></a>4.2 设备管理软件</h2><h3 id="4-2-1-I-O软件的实现层次"><a href="#4-2-1-I-O软件的实现层次" class="headerlink" title="4.2.1 I/O软件的实现层次"></a>4.2.1 I/O软件的实现层次</h3><h4 id="I-O软件的设计目标"><a href="#I-O软件的设计目标" class="headerlink" title="I/O软件的设计目标"></a><strong>I/O软件的设计目标</strong></h4><ul>
<li>设计目标<ul>
<li>高效率：改善设备效率，尤其是磁盘I/O操作的效率</li>
<li>通用性：用统一的标准来管理所有设备</li>
</ul>
</li>
<li>设计思路<ul>
<li>把软件组织成层次结构，低层软件用来屏蔽硬件细节，高层软件向用户提供简洁、友善、统一的界面</li>
</ul>
</li>
</ul>
<h4 id="I-O软件设计要考虑的问题"><a href="#I-O软件设计要考虑的问题" class="headerlink" title="I/O软件设计要考虑的问题"></a><strong>I/O软件设计要考虑的问题</strong></h4><ul>
<li>设备无关性：访问设备的程序与具体设备无关</li>
<li>出错处理：低层软件能处理的错误不让高层软件感知</li>
<li>同步/异步传输：支持<strong>同步</strong>(阻塞)和<strong>异步</strong>(中断驱动)两种工作方式</li>
<li>缓冲技术：建立内存数据缓冲区，提高吞吐率</li>
</ul>
<h4 id="I-O软件的层次结构"><a href="#I-O软件的层次结构" class="headerlink" title="I/O软件的层次结构"></a><strong>I/O软件的层次结构</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114145459495.png" alt="image-20221114145459495"></p>
<h3 id="4-2-2-I-O软件的实现"><a href="#4-2-2-I-O软件的实现" class="headerlink" title="4.2.2 I/O软件的实现"></a>4.2.2 I/O软件的实现</h3><h4 id="I-O中断处理程序"><a href="#I-O中断处理程序" class="headerlink" title="I/O中断处理程序"></a><strong>I/O中断处理程序</strong></h4><ul>
<li>位于OS底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系</li>
<li>进程请求I/O操作时，通常被阻塞</li>
<li>数据传输结束后产生I/O中断</li>
<li>CPU响应请求并转入中断处理程序</li>
</ul>
<h4 id="I-O中断处理程序的功能"><a href="#I-O中断处理程序的功能" class="headerlink" title="I/O中断处理程序的功能"></a><strong>I/O中断处理程序的功能</strong></h4><ul>
<li>检查设备状态寄存器内容，判断中断原因，根据I/O操作的完成情况进行相应的处理<ul>
<li>如果数据传输有错，向上层软件报告设备的出错信息，实施重新执行</li>
<li>如果正常结束，唤醒等待传输的进程，使其转换为就绪态</li>
<li>如果有等待传输的I/O命令，通知相关软件启动下一个I/O请求</li>
</ul>
</li>
</ul>
<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a><strong>设备驱动程序</strong></h4><ul>
<li>包括与设备密切相关的所有代码</li>
<li><p>从独立于设备的软件中接收抽象的I/O请求</p>
<ul>
<li><p>一条典型的请求是读第 n 块</p>
</li>
<li><p>如果请求到来时驱动程序空闲，则立即执行。</p>
</li>
<li><p>如果它正在处理另一条请求，它将该请求挂在等待队列中。</p>
</li>
</ul>
</li>
<li><p>把用户提交的逻辑I/O请求转化为物理I/O操作的启动和执行</p>
<ul>
<li>如设备名-&gt;端口地址、逻辑记录-&gt;物理记录、逻辑操作-&gt;物理操作等</li>
</ul>
</li>
<li><p>监督设备是否正确执行，访问数据缓冲区，进行必要的纠错处理</p>
</li>
</ul>
<blockquote>
<p>例如，磁盘驱动程序包含：计算出所请求块的物理地址、检查马达驱动器是否在运转、检测磁头臂是否定位在正确的柱面位置等</p>
<ul>
<li>简而言之，它必须确定需要哪些控制器命令及命令的执行次序，然后就向控制器的设备寄存器写入这些命令和相应参数。</li>
<li>某些控制器一次只能接收一条命令(如DMA)，另一些可接收一串命令并自动进行处理(如通道方式)</li>
</ul>
</blockquote>
<h4 id="设备驱动程序的功能"><a href="#设备驱动程序的功能" class="headerlink" title="设备驱动程序的功能"></a><strong>设备驱动程序的功能</strong></h4><ul>
<li>设备初始化：在设备传输数据时，预置设备、控制器以及通道状态</li>
<li>执行设备驱动例程：负责启动设备，进行数据传输；对于通道，还负责组织通道程序，启动通道工作</li>
<li>执行与设备相关的具体中断处理：负责处理设备、控制器及通道所发出的各种具体中断</li>
</ul>
<h4 id="设备驱动程序的层次"><a href="#设备驱动程序的层次" class="headerlink" title="设备驱动程序的层次"></a><strong>设备驱动程序的层次</strong></h4><ul>
<li><p>每个设备驱动程序原则上只处理一种设备，或者一类紧密相关的设备</p>
</li>
<li><p>设备驱动程序可以分层实现</p>
<ul>
<li>高层/处理类设备，底层/处理具体设备</li>
<li>系统建立栈，接到I/O请求时先调用栈顶的驱动程序，然后继续向下调用低层驱动程序，直到所有物理操作被处理</li>
<li>这一方式使设备驱动的实现结构清晰、便于移植，但会增加一部分系统开销</li>
</ul>
</li>
</ul>
<h4 id="独立于设备的I-O软件"><a href="#独立于设备的I-O软件" class="headerlink" title="独立于设备的I/O软件"></a>独立于设备的I/O软件</h4><ul>
<li>执行适用于所有设备的常用I/O功能，并向用户层软件提供一致性接口，包括：<ul>
<li>设备命名：通过路径名寻址设备</li>
<li>设备保护：用户是否有权访问设备</li>
<li>提供与设备无关的数据单位：字符/块</li>
<li>缓冲技术：调整CPU与I/O速度不匹配</li>
<li>分配和状态跟踪：分配设备</li>
<li>错误处理/报告：驱动无法处理的错误</li>
</ul>
</li>
</ul>
<h4 id="用户空间的I-O软件"><a href="#用户空间的I-O软件" class="headerlink" title="用户空间的I/O软件"></a>用户空间的I/O软件</h4><ul>
<li>库函数：一部分I/O软件可以使用库函数实现，放在操作系统内核之外，运行时与应用程序链接</li>
<li>虚拟设备软件：用一类设备模拟另一类设备的仿真I/O软件</li>
</ul>
<h3 id="4-2-3-I-O缓冲"><a href="#4-2-3-I-O缓冲" class="headerlink" title="4.2.3 I/O缓冲"></a>4.2.3 I/O缓冲</h3><h4 id="设置I-O缓冲的目的"><a href="#设置I-O缓冲的目的" class="headerlink" title="设置I/O缓冲的目的"></a>设置I/O缓冲的目的</h4><ul>
<li>解决CPU与设备之间速度不匹配的矛盾</li>
<li>协调逻辑记录大小和物理记录大小不一致的问题</li>
<li>提高CPU和设备的并行性</li>
<li>减少I/O操作对CPU的中断次数</li>
<li>放宽对CPU中断响应时间的要求</li>
</ul>
<h4 id="I-O缓冲区"><a href="#I-O缓冲区" class="headerlink" title="I/O缓冲区"></a>I/O缓冲区</h4><ul>
<li>I/O缓冲区：在内存中开辟的存储区，专门用于临时存放I/O操作的数据</li>
<li>操作过程：<ul>
<li>写操作：将数据送至缓冲区，直到装满或需要写出，待适当时候系统将缓冲区内容写到设备上</li>
<li>读操作：系统将设备上的物理记录读至缓冲区，根据要求将当前所需要的数据从缓冲区中读出并传送给进程</li>
</ul>
</li>
</ul>
<h4 id="单缓冲技术"><a href="#单缓冲技术" class="headerlink" title="单缓冲技术"></a>单缓冲技术</h4><ul>
<li><p>操作系统在主存系统区中开设一个缓冲区</p>
<ul>
<li><p>输入：先把数据读至缓冲区，再把缓冲区数据送至用户区，应用程序处理数据；如此往复，系统继续读入后继数据</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114150708546.png" alt="image-20221114150708546" style="zoom:80%;" /></p>
</li>
<li><p>输出：把数据从用户区传送到缓冲区，再将数据输出到设备，应用程序继续请求输出</p>
</li>
</ul>
</li>
</ul>
<h4 id="双缓冲技术"><a href="#双缓冲技术" class="headerlink" title="双缓冲技术"></a>双缓冲技术</h4><ul>
<li><p>操作系统在主存系统区开设两个缓冲区</p>
<ul>
<li><p>输入：先把数据输入缓冲区1，再从缓冲区1把数据传到用户区，供应用程序处理；(同时设备可将数据传送到缓冲区2)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114150830354.png" alt="image-20221114150830354" style="zoom:80%;" /></p>
</li>
<li><p>输出：先将数据从用户区传送到缓冲区1，再将数据传送到设备；(同时应用程序可 将数据传送到缓冲区2)</p>
</li>
</ul>
</li>
</ul>
<h4 id="循环缓冲技术"><a href="#循环缓冲技术" class="headerlink" title="循环缓冲技术"></a>循环缓冲技术</h4><ul>
<li><p>OS分配一组缓冲区，每个缓冲区有指向下个缓冲区的链接指针，构成循环缓冲</p>
<ul>
<li><p>继续调节设备和进程速度不匹配问题</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114150905161.png" alt="image-20221114150905161" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-3-独占型外围设备的分配"><a href="#4-3-独占型外围设备的分配" class="headerlink" title="4.3 独占型外围设备的分配"></a>4.3 独占型外围设备的分配</h2><h3 id="4-3-1-设备独立性"><a href="#4-3-1-设备独立性" class="headerlink" title="4.3.1 设备独立性"></a>4.3.1 设备独立性</h3><h4 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a><strong>问题的提出</strong></h4><ul>
<li>作业执行前对设备提出申请时，指定某台具体物理设备会让设备分配变得简单<ul>
<li>微型计算机OS多采用这种方式</li>
</ul>
</li>
<li>缺点：但如果所指定设备出现故障，即便计算机系统中有同类设备也不能运行</li>
</ul>
<h4 id="设备独立性及其实现"><a href="#设备独立性及其实现" class="headerlink" title="设备独立性及其实现"></a><strong>设备独立性及其实现</strong></h4><ul>
<li>设备独立性：用户通常不指定物理设备，而是指定逻辑设备，使得用户作业和物理设备分离开来，再通过其它途径建立逻辑设备和物理设备之间的映射</li>
<li>设备管理中需要将逻辑设备名转换为物理设备名，为此系统需要提供<strong>逻辑设备名和物理设备名的对应表</strong>以供转换使用</li>
</ul>
<h4 id="设备独立性的优点"><a href="#设备独立性的优点" class="headerlink" title="设备独立性的优点"></a><strong>设备独立性的优点</strong></h4><ul>
<li>应用程序与具体物理设备无关，系统增减或变更设备时不需要修改源程序</li>
<li>易于应对I/O设备故障，提高系统可靠性</li>
<li>增加设备分配的灵活性，有利于更加有效地利用设备资源，实现多道程序设计</li>
</ul>
<h3 id="4-3-2-独占型外围设备的分配"><a href="#4-3-2-独占型外围设备的分配" class="headerlink" title="4.3.2 独占型外围设备的分配"></a>4.3.2 独占型外围设备的分配</h3><h4 id="设备分配方式"><a href="#设备分配方式" class="headerlink" title="设备分配方式"></a><strong>设备分配方式</strong></h4><ul>
<li><p>独占型外围设备：一次只能由一个进程独占使用</p>
</li>
<li><p>分配方式：</p>
<ul>
<li><p>静态分配：进程运行前申请</p>
<ul>
<li>实现简单，能够防止系统发生死锁，但会降低设备利用率</li>
</ul>
</li>
<li><p>动态分配：进程随用随申请</p>
<ul>
<li>提高设备利用率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a><strong>设备分配的数据结构</strong></h4><ul>
<li>设备类表<ul>
<li>每类设备对应于设备类表中的一栏</li>
<li>包括：设备类，总台数，空闲台数，设备表起始地址等</li>
<li>支持设备独立性时才会使用</li>
</ul>
</li>
<li>设备表<ul>
<li>每类设备都有各自的设备表，用来登记这类设备中的每台物理设备</li>
<li>包括：物理设备名，逻辑设备名，占有设备的进程，分配标志，好/坏标志等</li>
</ul>
</li>
</ul>
<h2 id="4-4-共享型外围设备的驱动"><a href="#4-4-共享型外围设备的驱动" class="headerlink" title="4.4 共享型外围设备的驱动"></a>4.4 共享型外围设备的驱动</h2><h3 id="4-4-1-磁盘的物理结构"><a href="#4-4-1-磁盘的物理结构" class="headerlink" title="4.4.1 磁盘的物理结构"></a>4.4.1 磁盘的物理结构</h3><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a><strong>磁盘结构</strong></h4><ul>
<li>磁盘一般由多个<strong>盘片</strong>组成</li>
<li>每个盘片一般有两个<strong>盘面</strong></li>
<li>盘面包括多个同心圆结构的<strong>磁道</strong>，不同盘面上位于相同位置的磁道构成<strong>柱面</strong></li>
<li><p>每个磁道分为固定的多个<strong>扇区</strong>，相邻扇区组合成<strong>簇</strong></p>
</li>
<li><p>物理块地址</p>
<ol>
<li>柱面号、磁头号、扇区号</li>
<li>0 道 0 面 1 扇区：面指磁头/不是柱面</li>
</ol>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114113818848.png" alt="image-20221114113818848"></p>
<h4 id="磁盘读写数据的方式"><a href="#磁盘读写数据的方式" class="headerlink" title="磁盘读写数据的方式"></a>磁盘读写数据的方式</h4><ul>
<li>读写数据时，磁头必须定位到指定磁道上的指定扇区的开始处。过程如下：<ul>
<li>寻道：控制移动臂到达指定柱面</li>
<li>旋转：等待要读写的扇区旋转到磁头下</li>
<li>选择磁头号，进行数据传送</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114151950130.png" alt="image-20221114151950130" style="zoom:80%;" /></p>
<h4 id="磁盘存取时间"><a href="#磁盘存取时间" class="headerlink" title="磁盘存取时间"></a>磁盘存取时间</h4><ul>
<li><p>磁盘完成数据读写所需要的时间</p>
<ul>
<li><p>寻道时间、旋转延迟、传送时间的总和</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114152040233.png" alt="image-20221114152040233"></p>
</li>
</ul>
</li>
<li><p>为了读或者写，磁头必须定位到指定的磁道(track)和该磁道中指定的扇区(sector)的开始处</p>
</li>
<li>寻道时间 (记为Ts)<ul>
<li>将磁盘磁头臂移动指定磁道所需要的时间</li>
</ul>
</li>
<li>旋转延迟 (Rotational delay or rotational latency)<ul>
<li>要读写的扇区到达磁头的旋转时间</li>
</ul>
</li>
<li>传送时间</li>
</ul>
<h3 id="4-4-2-磁盘的驱动调度"><a href="#4-4-2-磁盘的驱动调度" class="headerlink" title="4.4.2 磁盘的驱动调度"></a>4.4.2 磁盘的驱动调度</h3><h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h4><ul>
<li>磁盘可能同时接收到若干I/O请求<ul>
<li>随机响应I/O请求，会得到很坏的性能</li>
</ul>
</li>
<li>驱动调度：OS的磁盘调度策略，即按照最佳次序执行处理访问磁盘的多个I/O请求，以减少磁盘访问的总处理时间</li>
<li>驱动调度策略包括<ul>
<li>移臂调度</li>
<li>旋转调度</li>
</ul>
</li>
</ul>
<h4 id="移臂调度及算法"><a href="#移臂调度及算法" class="headerlink" title="移臂调度及算法"></a>移臂调度及算法</h4><ul>
<li><p>目的：使移动臂的移动时间最短，从而减少寻道总时间</p>
</li>
<li><p>移臂调度算法</p>
<ul>
<li>先来先服务：移臂距离大，性能不好</li>
<li>最短查找时间优先(最小短距法)<ul>
<li>先执行查找时间最短的请求，具有较好的寻道性能</li>
<li>存在“饥饿”现象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="移臂调度的扫描算法"><a href="#移臂调度的扫描算法" class="headerlink" title="移臂调度的扫描算法"></a>移臂调度的扫描算法</h4><ul>
<li>单向扫描：移动臂向一个方向扫描，归途不提供服务，适用于不断有均匀分布的大量柱面请求的情形</li>
<li>双向扫描，移动臂每次向一个方向移动，遇到最近的I/O请求便进行处理，到达最后一个柱面后再向相反方向移动</li>
<li>电梯调度：双向扫描的改进，当前移动方向没有访问请求时，就改变移动方向</li>
</ul>
<h4 id="旋转调度"><a href="#旋转调度" class="headerlink" title="旋转调度"></a>旋转调度</h4><ul>
<li>目的：使得旋转延迟的总时间最少</li>
<li>循环排序<ul>
<li>通过优化I/O请求排序，在最少旋转圈数内完成位于同一柱面的访问请求</li>
<li>旋转位置测定硬件和多磁头同时读写技术有利于提高旋转调度的效率</li>
</ul>
</li>
</ul>
<h4 id="优化分布"><a href="#优化分布" class="headerlink" title="优化分布"></a>优化分布</h4><ul>
<li><p>通过信息在存储空间的排列方式来减少旋转延迟</p>
</li>
<li><p>交替排序：由于磁盘匀速运转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，如交叉因子为 n:1 表示相邻编号间会间隔 n-1 个扇区</p>
</li>
<li>把相邻扇区集中成簇读写</li>
<li>按柱面集中存储数据(另一种集簇方式)，可以减少数据读写时的移臂操作</li>
</ul>
<h2 id="4-5-虚拟设备"><a href="#4-5-虚拟设备" class="headerlink" title="4.5 虚拟设备"></a>4.5 虚拟设备</h2><h3 id="4-5-1-SPOOLing系统"><a href="#4-5-1-SPOOLing系统" class="headerlink" title="4.5.1 SPOOLing系统"></a>4.5.1 SPOOLing系统</h3><h4 id="虚拟设备技术"><a href="#虚拟设备技术" class="headerlink" title="虚拟设备技术"></a>虚拟设备技术</h4><ul>
<li>使用一类物理设备模拟另一类物理设备的技术</li>
<li>通常是使用共享型外围设备模拟独占型外围设备</li>
<li>示例<ul>
<li>内存卡模拟磁盘</li>
<li>块设备模拟字符设备</li>
<li>输入输出重定向</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="一个经典的SPOOLing系统"><a href="#一个经典的SPOOLing系统" class="headerlink" title="一个经典的SPOOLing系统"></a>一个经典的SPOOLing系统</h4><ul>
<li><p>SPOOLing(外部设备联机并行操作)，即 Simultaneous Peripheral Operations On-Line 的缩写，它是关于慢速字符设备如何与计算机主机交换信息一种技术，通常称为“假脱机技术”。</p>
</li>
<li><p>用<strong>高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间</strong></p>
</li>
<li>慢速输出设备先输出到(输出井)</li>
<li>进程运行过程中只从输入井读入数据，只向输出井输出信息，使得全部 I/O 都基于磁盘</li>
<li>加快进程周转时间，提高系统吞吐量</li>
</ul>
<h4 id="该SPOOLing系统的软件组成"><a href="#该SPOOLing系统的软件组成" class="headerlink" title="该SPOOLing系统的软件组成"></a>该SPOOLing系统的软件组成</h4><ul>
<li>预输入程序：预先把数据从输入设备传送到磁盘输入井</li>
<li>缓输出程序：把数据从磁盘输出井传送到输出设备</li>
<li>井管理程序：控制进程和井之间的数据交换(事实上是 I/O 重定向)</li>
</ul>
<h4 id="SPOOLing系统的示意图"><a href="#SPOOLing系统的示意图" class="headerlink" title="SPOOLing系统的示意图"></a>SPOOLing系统的示意图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221119135159446.png" alt="image-20221119135159446" style="zoom:80%;" /></p>
<h4 id="打印SPOOLing系统"><a href="#打印SPOOLing系统" class="headerlink" title="打印SPOOLing系统"></a>打印SPOOLing系统</h4><ul>
<li>打印机守护进程和 SPOOLing 打印目录<ul>
<li>守护进程是唯一有特权使用打印机设备的进程</li>
<li>打印文件前，用户进程先产生完整的待输出文件，并存放在打印目录下</li>
<li>打印机空闲时，启动守护进程，打印待输出文件</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221119135834798.png" alt="image-20221119135834798" style="zoom:80%;" /></p>
<h3 id="4-5-2-批处理系统的作业管理"><a href="#4-5-2-批处理系统的作业管理" class="headerlink" title="4.5.2 批处理系统的作业管理"></a>4.5.2 批处理系统的作业管理</h3><h4 id="SPOOLing系统与作业管理"><a href="#SPOOLing系统与作业管理" class="headerlink" title="SPOOLing系统与作业管理"></a>SPOOLing系统与作业管理</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221119135931778.png" alt="image-20221119135931778" style="zoom:80%;" /></p>
<h4 id="多道批处理OS的作业管理"><a href="#多道批处理OS的作业管理" class="headerlink" title="多道批处理OS的作业管理"></a>多道批处理OS的作业管理</h4><ul>
<li>作业说明语言：用于作业控制的语言</li>
<li>作业说明书：刻画具体作业的控制方式</li>
<li>作业状态：输入状态(预输入)、后备状态(空闲)、运行状态(运行)、完成状态(缓输出)</li>
<li>作业调度：从后备状态作业中选择部分进入运行状态(前提是资源满足)</li>
<li>作业调度算法：优先数、短作业、响应比、设备搭配、等等</li>
</ul>
<h4 id="作业调度与进程调度的关系"><a href="#作业调度与进程调度的关系" class="headerlink" title="作业调度与进程调度的关系"></a>作业调度与进程调度的关系</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221119140301989.png" alt="image-20221119140301989" style="zoom:80%;" /></p>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="1-I-O硬件"><a href="#1-I-O硬件" class="headerlink" title="1. I/O硬件"></a>1. I/O硬件</h3><h4 id="I-O设备控制器"><a href="#I-O设备控制器" class="headerlink" title="I/O设备控制器"></a>I/O设备控制器</h4><ul>
<li>控制器(或适配器) 是用于操作端口、总线或设备的一组电子器件，它是可插入主板扩充槽的印刷电路板，机械部件则是设备本身</li>
<li>例如，IDE接口设备、SCSI接口设备</li>
<li><strong>操作系统与控制器打交道</strong>，微机和小型机采用单总线模型，实现CPU和控制器间的数据传送，中、大型机则采用多总线结构和多通道方式，以提高并行操作程度</li>
<li><strong>如果没有控制器，复杂操作必须由操作系统来解决，引入控制器后，通过传递简单参数就可进行I/O操作，大大简化系统的设计，有利于计算机系统对各类控制器和设备的兼容性</strong></li>
</ul>
<h4 id="PC中的设备I-O的端口位置-部分"><a href="#PC中的设备I-O的端口位置-部分" class="headerlink" title="PC中的设备I/O的端口位置(部分)"></a>PC中的设备I/O的端口位置(部分)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126162631176.png" alt="image-20221126162631176" style="zoom:80%;" /></p>
<h4 id="I-O模块框图"><a href="#I-O模块框图" class="headerlink" title="I/O模块框图"></a>I/O模块框图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126162654937.png" alt="image-20221126162654937" style="zoom:80%;" /></p>
<h4 id="Pentium处理器的中断向量表"><a href="#Pentium处理器的中断向量表" class="headerlink" title="Pentium处理器的中断向量表"></a>Pentium处理器的中断向量表</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126163416861.png" alt="image-20221126163416861" style="zoom:80%;" /></p>
<h4 id="I-O功能的演化"><a href="#I-O功能的演化" class="headerlink" title="I/O功能的演化"></a>I/O功能的演化</h4><ul>
<li>处理器直接控制外围设备</li>
<li>增加了控制器或者I/O模块<ul>
<li>处理器使用非中断的可编程I/O</li>
<li>处理器开始从外围设备接口的具体细节中分离出来</li>
</ul>
</li>
<li>采用中断方式的控制器或者I/O模块<ul>
<li>处理器无需花费等待执行一个I/O操作所需的时间，因而提高了效率</li>
</ul>
</li>
<li>I/O模块通过DMA直接控制存储器<ul>
<li>可以在没有处理器参与的情况下，从主存中移出或者往主存中移入一块数据，仅仅在传送开始和结束时需要用到处理器</li>
</ul>
</li>
<li>I/O模块被增强为单独的处理器，有专门为I/O设计的指令集<ul>
<li>I/O处理器在没有CPU干涉的情况下取指令并执行这些指令，使得CPU可以指定一系列I/O活动，并只有当整个序列执行完成后CPU才被中断</li>
</ul>
</li>
<li>I/O模块有自己的局部存储器，其本身就是一台计算机</li>
</ul>
<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><ul>
<li>替代 CPU, DMA 控制内存与磁盘之间数据传输</li>
<li>周期窃取是指利用 CPU 不访问存储器的那些周期来实现 DMA 操作，此时 DMA 可以使用总线而不用通知 CPU 也不会妨碍 CPU 的工作<ul>
<li>周期挪用并不减慢 CPU 的操作，但可能需要复杂的时序电路，而且数据传送过程是不连续的和不规则的</li>
<li>在这种方法中，每当I/O设备发出DMA请求时，I/O设备便挪用或窃取总线占用权一个或几个主存周期，而DMA不请求时，CPU仍继续访问主存</li>
</ul>
</li>
<li>不发生中断<ul>
<li>不保存上下文</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126165455669.png" alt="image-20221126165455669" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126165606238.png" alt="image-20221126165606238" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126165619121.png" alt="image-20221126165619121" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126165636899.png" alt="image-20221126165636899" style="zoom:80%;" /></p>
<h4 id="指令周期中DMA和中断的断点"><a href="#指令周期中DMA和中断的断点" class="headerlink" title="指令周期中DMA和中断的断点"></a>指令周期中DMA和中断的断点</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126165519386.png" alt="image-20221126165519386" style="zoom:80%;" /></p>
<h4 id="具有通道的I-O系统"><a href="#具有通道的I-O系统" class="headerlink" title="具有通道的I/O系统"></a>具有通道的I/O系统</h4><ul>
<li>具有通道的计算机系统，I/O程序设计涉及：<ul>
<li>CPU执行I/O指令</li>
<li>通道执行通道命令</li>
<li>CPU和通道之间的通信</li>
</ul>
</li>
<li>通道状态字(CSW, Channel Status Word)<ul>
<li>通道状态字是存放在内存固定单元的控制字，专门用于记录通道和设备执行操作的情况</li>
</ul>
</li>
<li>输入输出中断</li>
<li>输入输出指令<ul>
<li>启动输入输出指令(SIO)</li>
<li>查询输入输出指令(TIO)</li>
<li>查询通道指令(TCH)</li>
<li>停止输入输出指令(HIO)</li>
<li>停止设备指令(HDV)</li>
</ul>
</li>
<li><p>通道地址字(CAW)</p>
<ul>
<li>通道地址字是存放在内存固定单元的控制字，专门用于存放通道程序首地址</li>
</ul>
</li>
<li><p>处理步骤</p>
<ul>
<li>组织通道程序，通道程序首地址送CAW</li>
<li>执行启动输入输出指令，启动通道工作</li>
<li>通道根据自身状态形成条件码；<strong>若通道可用</strong>，从CAW中取得通道程序首地址，得到第一条通道指令，启动设备控制器；设备控制器再检查设备状态；<strong>若设备不忙</strong>，则告知通道释放CPU</li>
<li>通道独立执行通道程序，控制外设进行输入输出</li>
<li>通道完成输入输出后，形成CSW和置中断字寄存器，发出输入输出中断，请求CPU处理</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126170402254.png" alt="image-20221126170402254" style="zoom:80%;" /></p>
<h4 id="通道命令和通道程序"><a href="#通道命令和通道程序" class="headerlink" title="通道命令和通道程序"></a>通道命令和通道程序</h4><h5 id="通道命令"><a href="#通道命令" class="headerlink" title="通道命令"></a>通道命令</h5><ul>
<li>通道，具有自己的指令系统，它的指令常称通道命令。</li>
<li>通道命令字CCW (Channel Command Word)是通道<strong>从主存取出并控制I/O设备执行I/O操作的命令字</strong>，用通道命令编写的程序称<em>通道程序</em>，通道程序由多条通道命令组成，每次启动可以完成复杂的I/O控制</li>
<li>IBM370及后继产品IBM S/390均采用通道技术，IBM370系统的通道命令为双字长</li>
</ul>
<h5 id="IBM370系统的通道命令"><a href="#IBM370系统的通道命令" class="headerlink" title="IBM370系统的通道命令"></a>IBM370系统的通道命令</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126170113147.png" alt="image-20221126170113147" style="zoom:80%;" /></p>
<ul>
<li>命令码<ul>
<li>数据传输类(读、反读、写、取状态)，通道转移类(转移)，设备控制类(随设备类不同执行不同控制)</li>
</ul>
</li>
<li>数据主存地址<ul>
<li>对数据传输类命令，规定本条通道命令访问的主存数据区起始或末尾；而“传送字节个数”指出数据区的大小；对通道转移类命令，用来规定转移地址</li>
</ul>
</li>
<li>标志码<ul>
<li>用来定义通道程序的链接方式或标志通道命令的特点</li>
</ul>
</li>
<li>传送字节个数<ul>
<li>对数据传输类命令，规定本次交换的字节个数；对通道转移类命令，规定填一个非0数</li>
</ul>
</li>
</ul>
<h3 id="2-I-O缓冲"><a href="#2-I-O缓冲" class="headerlink" title="2. I/O缓冲"></a>2. I/O缓冲</h3><h4 id="I-O缓冲"><a href="#I-O缓冲" class="headerlink" title="I/O缓冲"></a>I/O缓冲</h4><ul>
<li>使用缓冲的原因<ul>
<li>进程经常需要等I/O完成才能继续后续的执行</li>
<li>在存储管理中使用分页机制，那么需要将包括目标地址单元的页锁定在主存中</li>
</ul>
</li>
<li>面向块 (Block-oriented)<ul>
<li>数据存储和传送以块为单位，块的大小通常是固定的</li>
<li>通常可以通过块号访问数据</li>
<li>例如：磁盘和磁带</li>
</ul>
</li>
<li>面向流 (Stream-oriented)<ul>
<li>设备以字节流的方式传输数据</li>
<li>例如：终端、打印机、通信端口、鼠标和其他指示设备以及大多数非辅存的其他设备</li>
</ul>
</li>
</ul>
<h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><ul>
<li>操作系统在主存中为I/O请求分配一个缓冲区</li>
<li>面向块 (Block-oriented)<ul>
<li>输入传送的数据被放到缓冲区中</li>
<li>当传送完成时，进程把该块移动到用户空间，并立即请求另一块，这种方式成为超前(预先输入)</li>
</ul>
</li>
<li>面向流 (Stream-oriented)<ul>
<li>单缓冲方案可以以每次传送一行的方式或者每次传送一个字节的方式使用</li>
<li>每次传送一行的方式适合于滚动方式的终端(哑终端)</li>
<li>对于这类终端，用户每次输入一行，用回车符表示到达行尾，并且输出到终端时也是类似的每次输出一行</li>
<li>行式打印机是这类设备的另一个例子</li>
<li>还有其他许多外设，如传感器和控制器都属于这种类型</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126171855798.png" alt="image-20221126171855798" style="zoom:80%;" /></p>
<h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><ul>
<li>最多两个缓冲</li>
<li>在一个进程往一个缓冲区中传送数据(从这个缓冲区取数据)的同时，操作系统正在清空(或者填充)另一个缓冲区</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126172040024.png" alt="image-20221126172040024" style="zoom:80%;" /></p>
<h4 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h4><ul>
<li>使用两个以上的缓冲区</li>
<li>使得I/O操作能跟得上进程的执行</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126172102931.png" alt="image-20221126172102931" style="zoom:80%;" /></p>
<h3 id="3-独占型外围设备的分配"><a href="#3-独占型外围设备的分配" class="headerlink" title="3. 独占型外围设备的分配"></a>3. 独占型外围设备的分配</h3><h4 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h4><ul>
<li>从设备的特性来看，可以把设备分成独占设备、共享设备和虚拟设备三类</li>
<li>相应的管理和分配外围设备的技术可分成：独占方式、共享方式和虚拟方式</li>
</ul>
<h4 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h4><ol>
<li>根据设备类查设备类表</li>
<li>若无空闲设备则等待设备</li>
<li>取得设备表首地址</li>
<li>查设备表发现空闲设备栏</li>
<li>若未发现空闲设备栏则等待设备</li>
<li>填占用进程号，逻辑设备名，分配设备</li>
</ol>
<h3 id="4-共享型设备的驱动调度"><a href="#4-共享型设备的驱动调度" class="headerlink" title="4. 共享型设备的驱动调度"></a>4. 共享型设备的驱动调度</h3><h4 id="磁盘调度策略"><a href="#磁盘调度策略" class="headerlink" title="磁盘调度策略"></a>磁盘调度策略</h4><ul>
<li><p>先进先出 First-in, first-out (FIFO)</p>
<ul>
<li>按顺序处理请求</li>
<li>对于所有进程是公平的</li>
</ul>
</li>
<li><p>优先级 (Priority)</p>
<ul>
<li>这种方法并不会优化磁盘的使用率，但可以满足操作系统的其他目标</li>
<li>通常比较短的批作业和交互作业的优先级较高，而较长计算时间的长作业优先级低，这就使得大量短作业能够迅速地通过系统，并且可以提供比较好的交互响应时间</li>
<li>但是长作业不得不等待很长的时间</li>
</ul>
</li>
<li><p>后进先出(Last-in, first-out)</p>
<ul>
<li>在事务处理系统中，把设备资源提供给最近的用户，会导致磁头臂<strong>在一个顺序文件中移动时移动得很少，甚至不移动</strong></li>
<li><strong>利用这种局部性可以提高吞吐量，减少队列长度</strong></li>
<li>只要一个作业积极地使用文件系统，它就可以尽可能快地得到处理</li>
<li>如果由于工作量大而磁盘保持忙状态，就有可能出现饿死的情况</li>
<li>当一个作业已经往队列中送入一个I/O请求，并且错过了可以提供服务的位置时，该作业就有可能永远得不到服务，除非它之前的队列变为空</li>
</ul>
</li>
<li><p>最短服务时间优先(SSTF, Shortest ServiceTimeFirst)</p>
<ul>
<li>选择使磁头臂从当前位置开始移动最少的磁盘I/O请求，因此SSTF策略总是选择导致最小寻道时间的请求</li>
<li>总是选择最小寻道时间并不能保证平均寻道时间最小，但是，它的性能比FIFO更好</li>
</ul>
</li>
<li><p>扫描 (SCAN)</p>
<ul>
<li>要求磁头臂仅仅沿一个方向移动，并在途中满足所有为完成的请求，直到它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止，后一种改进有时候称为LOOK策略 (又称为电梯调度算法)</li>
<li>接着反转服务方向，沿着相反方向扫描，同样按顺序完成所有请求</li>
</ul>
</li>
<li><p>电梯调度算法</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126173435634.png" alt="image-20221126173435634" style="zoom:80%;" /></p>
</li>
<li><p>循环扫描 (C-SCAN)</p>
<ul>
<li>把扫描限定在一个方向</li>
<li>当访问到沿某个方向的最后一个磁道时，磁头臂返回到磁盘相反方向磁道的末端，并再次开始扫描</li>
</ul>
</li>
<li><p>N-step-SCAN</p>
<ul>
<li>进程<strong>重复请求同一磁道会垄断整个设备，”造成磁头臂的粘性”</strong>，采用分步扫描可避免这类问题</li>
<li><strong>把磁盘请求队列分成长度为 N 的子队列，每一次用SCAN处理一个子队列</strong></li>
<li>在处理一个队列时，新请求必须添加到其他某个队列中</li>
<li>如果在扫描的最后剩下的请求数小于N，则它们全部将在下一次扫描时处理</li>
<li>当N很大时，N-step-SCAN的性能接近SCAN；当N=1时，实际上是FIFO</li>
</ul>
</li>
<li><p>FSCAN</p>
<ul>
<li>使用两个子队列</li>
<li>当开始扫描时，所有请求都在一个队列中，而另一个队列为空</li>
<li>在扫描过程中，所有新到的请求都被放入另一个队列中</li>
<li>因此，对新请求的服务延迟到处理完成所有老请求之后</li>
</ul>
</li>
</ul>
<h4 id="旋转调度-Rotation-Schedule"><a href="#旋转调度-Rotation-Schedule" class="headerlink" title="旋转调度(Rotation Schedule)"></a>旋转调度(Rotation Schedule)</h4><ul>
<li>循环排序：在最少旋转圈数内完成位于同一柱面的访问请求；旋转位置测定硬件和多磁头同时读写技术有利于提高旋转调度的效率</li>
<li>优化分布</li>
<li>交替地址</li>
</ul>
<h4 id="循环排序"><a href="#循环排序" class="headerlink" title="循环排序"></a>循环排序</h4><blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126174051812.png" alt="image-20221126174051812" style="zoom:80%;" /></p>
<ul>
<li>方法1：按照I/O请求次序读记录4、3、2、1，平均用1/2周定位，再加上1/4周读出记录，总处理时间等于1/2 + 1/4 + 3 * 3/4 = 3周，即60毫秒</li>
<li>方法2：如果次序为读记录1、2、3、4，总处理时间等于1/2 + 1/4 + 3 * 1/4 = 1.5周，即30毫秒。</li>
<li>方法3：如果知道当前读位置是记录3，则采用次序为读记录4、1、2、3，总处理时间等于4 * 1/4＝1周，即20毫秒。</li>
</ul>
</blockquote>
<h4 id="优化分布-1"><a href="#优化分布-1" class="headerlink" title="优化分布"></a>优化分布</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126174438942.png" alt="image-20221126174438942" style="zoom:80%;" /></p>
<p><strong>按照下面方式对信息优化分布</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126174539407.png" alt="image-20221126174539407" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126174555625.png" alt="image-20221126174555625" style="zoom:80%;" /></p>
<h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><ul>
<li><p>RAID 0</p>
<ul>
<li>RAID0-连续的数据条带(每个条带可规定为1个或多个扇区)以轮转方式写到全部磁盘上，然后采用并行交叉存取，减少I/O请求排队时间，适用于大数据量的I/O请求，但并<strong>无冗余校验功能，可靠性较差</strong></li>
</ul>
</li>
<li><p>RAID 1 (镜像)</p>
<ul>
<li>RAID1-采用镜像盘双份所有数据来提高容错性，读请求拥有最小寻道时间，写请求可并行完成。<strong>缺点是容量下降一半，故成本很高</strong></li>
</ul>
</li>
<li><p>RAID 2 (通过海明码冗余)</p>
<ul>
<li>RAID2-采用数据字或字节交叉存放，<strong>并行存取获得高性能</strong>，使用<strong>海明校验码</strong>，适合大量顺序数据访问。<strong>由于使用多个冗余盘，成本较高</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126174832320.png" alt="image-20221126174832320" style="zoom:80%;" /></p>
</li>
<li><p>RAID 3 (交错位奇偶校验)</p>
<ul>
<li>RAID3是RAID2的简化版本，差别是它<strong>仅用一只冗余盘，采用奇偶校验技术</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126174914755.png" alt="image-20221126174914755" style="zoom:80%;" /></p>
</li>
<li><p>RAID 4 (块奇偶校验)</p>
<ul>
<li>RAID 4 采用<strong>独立存取磁盘阵列，数据条带交叉存放</strong>，访问请求可并行地获得满足，适合有较高I/O请求速度的应用场合，使用一只冗余盘存放奇偶校验码</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126174946605.png" alt="image-20221126174946605" style="zoom:80%;" /></p>
</li>
<li><p>RAID 5 (块分布奇偶校验)</p>
<ul>
<li>RAID5与RAID4的组织类似，但<strong>奇偶校验码循环分布在每个盘上使容错性更好</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126175049593.png" alt="image-20221126175049593" style="zoom:80%;" /></p>
</li>
<li><p>RAID 6 (双重冗余)</p>
<ul>
<li>RAID 6 采用<strong>双重冗余技术</strong>，P和Q是两种不同的数据校验算法，其中一种是 RAID 4 和 RAID 5 所使用是异或计算，另一种是独立数据校验算法，<strong>即使有两个数据磁盘发生错误，也可重新生成数据</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126175135137.png" alt="image-20221126175135137" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="磁盘-Cache"><a href="#磁盘-Cache" class="headerlink" title="磁盘 Cache"></a>磁盘 Cache</h4><ul>
<li>磁盘高速缓存是主存中为磁盘扇区设置的一个缓冲区</li>
<li>包含磁盘中某些扇区的副本</li>
<li>利用局部性原理，可以减少平均存储器存取时间</li>
</ul>
<h4 id="替换策略-LRU"><a href="#替换策略-LRU" class="headerlink" title="替换策略.LRU"></a>替换策略.LRU</h4><ul>
<li>替换在高速缓存中未被访问的时间最长的块</li>
<li>逻辑上，高速缓存有一个关于块的栈组成，最近访问过的块在栈顶，当高速缓存中的一个块被访问到时，它从栈中当前的位置移到栈顶</li>
<li>当一个块从辅存中取入时，把位于栈顶的那一块移出，并把新到来的块压入栈顶</li>
<li>并不需要在主存中真正移动这些块，有一个栈指针与高速缓存相关联</li>
</ul>
<h4 id="替换策略-LFU"><a href="#替换策略-LFU" class="headerlink" title="替换策略.LFU"></a>替换策略.LFU</h4><ul>
<li>替换集合中被访问次数最少的块</li>
<li>LFU可以通过给每个块关联一个计数器来实现</li>
<li>当一个块被读入时，它的计数器被指定为1；当每次访问到这一块时，它的计数器增1</li>
<li>当需要替换时，选择计数器值最小的块</li>
<li>直觉上，LFU比LRU更适合，因为LFU使用了关于每个块的更多的相关信息</li>
</ul>
<h3 id="5-虚拟设备"><a href="#5-虚拟设备" class="headerlink" title="5. 虚拟设备"></a>5. 虚拟设备</h3><ul>
<li>脱机同时外围设备操作</li>
<li>井是用作缓冲的存储区域，采用井的技术能调节供求之间的矛盾，消除人工干预带来的损失</li>
<li>预输入程序<ul>
<li>操作系统将一批作业从输入设备上预先输入到磁盘的输入缓冲区中暂时保存，这称为“预输入”，此后，由作业调度程序调度作业执行，作业使用数据时不必再启动输入设备，只要从磁盘的输入缓冲区中读入</li>
</ul>
</li>
<li>缓输出程序<ul>
<li>作业执行中不必直接启动输出设备，只要将作业的输出数据暂时保存到磁盘的输出缓冲区，当作业执行完毕后，由操作系统组织信息成批输出</li>
</ul>
</li>
<li>井管理程序</li>
</ul>
<h3 id="6-I-O设备管理的实现与层次"><a href="#6-I-O设备管理的实现与层次" class="headerlink" title="6. I/O设备管理的实现与层次"></a>6. I/O设备管理的实现与层次</h3><h4 id="I-O软件的设计目标和原则"><a href="#I-O软件的设计目标和原则" class="headerlink" title="I/O软件的设计目标和原则"></a>I/O软件的设计目标和原则</h4><ul>
<li>设备无关性。<ul>
<li>访问文件数据的程序时，与具体的物理设备无关</li>
</ul>
</li>
<li>出错处理。<ul>
<li>数据传输中的错误应该在尽可能靠近硬件的地方处理，低层软件能够解决的错误就不让高层软件感知。</li>
</ul>
</li>
<li>同步(阻塞)—异步(中断驱动)传输。<ul>
<li>异步传输: CPU在启动I/O操作后既可继续执行其他工作，直到中断到达；</li>
<li>同步传输: 阻塞方式，让启动I/O操作的进程阻塞等待，直到数据传输完成。</li>
</ul>
</li>
<li>独占性外围设备和共享性外围设备。<ul>
<li>建立数据缓冲区，让数据到达与离去率相匹配，以提高系统吞吐率。</li>
</ul>
</li>
</ul>
<h4 id="阻塞与非阻塞I-O"><a href="#阻塞与非阻塞I-O" class="headerlink" title="阻塞与非阻塞I/O"></a>阻塞与非阻塞I/O</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126213439497.png" alt="image-20221126213439497" style="zoom:80%;" /></p>
<h4 id="独立于设备的I-O软件-1"><a href="#独立于设备的I-O软件-1" class="headerlink" title="独立于设备的I/O软件"></a>独立于设备的I/O软件</h4><ul>
<li><p>功能</p>
<ul>
<li><p>对设备驱动程序的统一接口</p>
</li>
<li><p>设备命名和设备保护</p>
</li>
<li><p>提供与设备无关的块尺寸</p>
</li>
<li><p>缓冲区管理</p>
</li>
<li><p>块设备的存储分配</p>
</li>
<li><p>独占性外围设备的分配和释放</p>
</li>
<li><p>出错处理和报告</p>
</li>
</ul>
</li>
<li><p>设备命名和设备保护</p>
<ul>
<li><p>设备都被看作文件，通过路径名进行寻址，<strong>每个设备具有一个文件名、inode、文件所有者、权限位等属性</strong></p>
</li>
<li><p>设备不仅具有文件名，且<strong>支持与文件相关的所有系统调用</strong>,如open、close、read、write、stat及lseek等</p>
</li>
<li><p>设备文件依赖于inode来实现，文件目录并不能区分文件名是代表一个磁盘文件或设备文件，但inode的内容是不同的，磁盘文件的inode包含指向数据块的指针，而设备文件的inode则包含指向内核设备驱动程序的指针，用来控制设备的I/O。</p>
</li>
<li><p>设备保护需要检查用户是否有权访问所申请的设备，多数大中型计算机系统中，<strong>用户进程对I/O设备的直接访问是绝对禁止的，I/O指令定义为特权指令，通过系统调用的方式间接地供用户使用</strong></p>
</li>
<li><p>此外，在UNIX/Linux中还使用一种灵活的方法，<strong>对应于I/O设备的特别文件采用rwx保护机制，以判断文件所有者和组成员是否有权向设备发送和读取数据的权限。</strong>Windows中设备作为命名对象出现在文件系统中，对文件的保护规则也适用于I/O设备。</p>
</li>
</ul>
</li>
<li><p>提供与设备无关的块尺寸</p>
<ul>
<li>屏蔽不同磁盘扇区大小并向高层软件提供统一大小的逻辑块</li>
</ul>
</li>
<li>缓冲区管理<ul>
<li>通过缓冲区来消除填满速率和清空速率之间的影响，块设备和字符设备都需要缓冲技术，可通过在主存建立缓冲区的方法来解决</li>
</ul>
</li>
<li>设备分配和状态跟踪<ul>
<li>静态、动态、虚拟分配</li>
</ul>
</li>
<li>错误处理和报告<ul>
<li>错误处理多数由驱动程序完成。低层软件处理不了的情况，交给高层软件处理，在许多情况下，错误恢复可在低层透明地得到解决，而高层软件甚至不知道存在错误。</li>
</ul>
</li>
</ul>
<h4 id="用户空间的I-O软件-1"><a href="#用户空间的I-O软件-1" class="headerlink" title="用户空间的I/O软件"></a>用户空间的I/O软件</h4><ul>
<li>库函数实现的I/O系统调用<ul>
<li>I/O系统调用通常先是库函数调用</li>
<li><code>count=write(fd，buffer，nbytes);</code></li>
</ul>
</li>
<li>所调用的库函数write将与应用程序链接在一起，形成可执行代码装入主存，这些库函数显然也是I/O系统的一部分。</li>
<li><strong>库函数所做的工作只是将系统调用时所用的参数放在合适的位置，然后执行访管指令来陷入内核，再由内核函数实现真正的I/O操作。</strong></li>
</ul>
<h4 id="I-O操作执行步骤"><a href="#I-O操作执行步骤" class="headerlink" title="I/O操作执行步骤"></a>I/O操作执行步骤</h4><ol>
<li>进程对已打开文件的文件描述符执行读库函数</li>
<li>与设备无关的I/O软件检查参数正确性。<strong>高速缓存中有要读的信息块</strong>，从缓冲区直接读到用户区，完成I/O请求</li>
<li>若数据不在缓冲区，执行物理I/O，实现将设备逻辑名转换成物理名，检查对设备操作的权限，将I/O请求排队，阻塞进程且等待I/O完成</li>
<li>内核启动<strong>设备驱动程序</strong>，<strong>分配存放读出块的缓冲区，准备接收数据</strong>，且向设备控制寄存器发启动命令，或建立DMA传输，启动I/O</li>
<li>设备控制器操作设备，执行数据传输</li>
<li>DMA控制器控制一块传输完成，硬件产生I/O结束中断</li>
<li>CPU响应中断，转向磁盘中断处理程序</li>
<li>当应用进程被再次调度执行时，从I/O系统调用的断点恢复执行。</li>
</ol>
<h4 id="Windows的I-O管理"><a href="#Windows的I-O管理" class="headerlink" title="Windows的I/O管理"></a>Windows的I/O管理</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126230317718.png" alt="image-20221126230317718" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126230326027.png" alt="image-20221126230326027" style="zoom:80%;" /></p>
<h4 id="Windows的设备管理"><a href="#Windows的设备管理" class="headerlink" title="Windows的设备管理"></a>Windows的设备管理</h4><ul>
<li>设备驱动程序</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126230352046.png" alt="image-20221126230352046" style="zoom:80%;" /></p>
<ul>
<li>即插即用结构</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126230418275.png" alt="image-20221126230418275" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126230446414.png" alt="image-20221126230446414" style="zoom:80%;" /></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/计算机操作系统/">计算机操作系统</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/11/10/计算机操作系统-3-存储管理/"><span>计算机操作系统(3) 存储管理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/11/10/计算机操作系统-3-存储管理/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-10T06:05:57.000Z">
          2022-11-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="第三章-存储管理"><a href="#第三章-存储管理" class="headerlink" title="第三章 存储管理"></a>第三章 存储管理</h1><h2 id="3-1-存储管理基础"><a href="#3-1-存储管理基础" class="headerlink" title="3.1 存储管理基础"></a>3.1 存储管理基础</h2><h3 id="3-1-1-存储管理的主要模式"><a href="#3-1-1-存储管理的主要模式" class="headerlink" title="3.1.1 存储管理的主要模式"></a>3.1.1 存储管理的主要模式</h3><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a><strong>逻辑地址</strong></h4><ul>
<li><strong>逻辑地址</strong>：又称相对地址，即用户编程所使用的地址空间</li>
<li>逻辑地址从0开始编号，有两种形式<ul>
<li>一维逻辑地址(地址)</li>
<li>二维逻辑地址(段号:段内地址)</li>
</ul>
</li>
</ul>
<h4 id="段式程序设计"><a href="#段式程序设计" class="headerlink" title="段式程序设计"></a><strong>段式程序设计</strong></h4><ul>
<li>把一个程序设计成多个段<ul>
<li>代码段、数据段、堆栈段、等等</li>
</ul>
</li>
<li>用户可以自己应用<strong>段覆盖技术</strong>扩充内存空间使用量<ul>
<li>段覆盖技术：用户在程序设计时包括主程序段、堆栈段、多个子程序段和数据段，而执行程序时只调入主程序段、堆栈段与需要的子程序段和数据段，并<strong>根据执行的需要</strong>，由程序设计者预先设计的代码<strong>动态决定哪些段调入内存</strong></li>
<li>这一技术是程序设计技术，不是OS存储管理的功能</li>
</ul>
</li>
</ul>
<h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a><strong>物理地址</strong></h4><ul>
<li><strong>物理地址</strong>：又称绝对地址，即程序执行所使用的地址空间</li>
<li>处理器执行指令时按照物理地址进行</li>
</ul>
<h4 id="主存储器的复用"><a href="#主存储器的复用" class="headerlink" title="主存储器的复用"></a><strong>主存储器的复用</strong></h4><ul>
<li>多道程序设计需要复用主存</li>
<li>按照分区复用：<ul>
<li>主存划分为多个固定/可变尺寸的分区</li>
<li>一个程序/程序段占用一个分区</li>
</ul>
</li>
<li>按照页架(页框)复用：<ul>
<li>主存划分成多个固定大小的页架</li>
<li>一个程序/程序段占用多个页架</li>
</ul>
</li>
</ul>
<h4 id="存储管理的基本模式"><a href="#存储管理的基本模式" class="headerlink" title="存储管理的基本模式"></a><strong>存储管理的基本模式</strong></h4><ul>
<li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定分区或可变分区</li>
<li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li>
<li>页式存储管理：一维逻辑地址空间的程序占用多个主存页架区</li>
<li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区</li>
</ul>
<h4 id="存储管理模式示意图"><a href="#存储管理模式示意图" class="headerlink" title="存储管理模式示意图"></a><strong>存储管理模式示意图</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221024112034401.png" alt="image-20221024112034401" style="zoom:80%;" /></p>
<h3 id="3-1-2-存储管理的功能"><a href="#3-1-2-存储管理的功能" class="headerlink" title="3.1.2 存储管理的功能"></a>3.1.2 存储管理的功能</h3><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a><strong>地址转换</strong></h4><ul>
<li><strong>地址转换</strong>：又称重定位，即把逻辑地址转换成绝对地址</li>
<li><p><strong>静态重定位</strong>：在程序装入内存时进行地址转换</p>
<ul>
<li>由装入程序执行，早期小型OS使用</li>
</ul>
</li>
<li><p><strong>动态重定位</strong>：在CPU执行程序时进行地址转换</p>
<ul>
<li>从效率出发，依赖硬件地址转换机构</li>
</ul>
</li>
</ul>
<h4 id="主存储器空间的分配与去配"><a href="#主存储器空间的分配与去配" class="headerlink" title="主存储器空间的分配与去配"></a><strong>主存储器空间的分配与去配</strong></h4><ul>
<li><strong>分配</strong>：进程装入主存时，存储管理软件进行具体的主存分配操作，并设置一个表格记录主存空间的分配情况</li>
<li><strong>去配</strong>：当某个进程撤离或主动归还主存资源时，存储管理软件要收回它所占用的全部或者部分存储空间，调整主存分配表信息</li>
</ul>
<h4 id="主存储器空间的共享"><a href="#主存储器空间的共享" class="headerlink" title="主存储器空间的共享"></a><strong>主存储器空间的共享</strong></h4><ul>
<li><strong>多个进程共享主存储器资源</strong>：多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器</li>
<li><strong>多个进程共享主存储器的某些区域</strong>：若干个协作进程有共同的主存程序块或者主存数据块</li>
</ul>
<h4 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a><strong>存储保护</strong></h4><ul>
<li>为<strong>避免</strong>主存中的多个进程<strong>相互干扰</strong>，必须<strong>对主存中的程序和数据进行保护</strong><ul>
<li>私有主存区中的信息：可读可写</li>
<li>公共区中的共享信息：根据授权</li>
<li>非本进程信息：不可读写</li>
</ul>
</li>
<li>这一功能需要软硬件协同完成<ul>
<li>CPU检查是否允许访问，不允许则<strong>产生地址保护异常</strong>，由OS进行相应处理</li>
</ul>
</li>
</ul>
<h4 id="主存储器空间的扩充"><a href="#主存储器空间的扩充" class="headerlink" title="主存储器空间的扩充"></a><strong>主存储器空间的扩充</strong></h4><ul>
<li><strong>主存扩充</strong>：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存<ol>
<li>对换技术：把部分不运行的进程调出</li>
<li>虚拟技术：只调入进程的部分内容</li>
</ol>
</li>
<li>这一工作需要软硬件协作完成<ol>
<li>对换进程决定对换，硬件机构调入</li>
<li>CPU处理到不在主存的地址，发出<strong>虚拟地址异常</strong>，OS将其调入，重执指令</li>
</ol>
</li>
</ul>
<h3 id="3-1-3-虚拟存储器的概念"><a href="#3-1-3-虚拟存储器的概念" class="headerlink" title="3.1.3 虚拟存储器的概念"></a>3.1.3 虚拟存储器的概念</h3><h4 id="虚拟存储器思想的提出"><a href="#虚拟存储器思想的提出" class="headerlink" title="虚拟存储器思想的提出"></a><strong>虚拟存储器思想的提出</strong></h4><ul>
<li>主存容量限制带来诸多不便<ul>
<li>用户编写程序必须考虑主存容量限制</li>
<li>多道程序设计的道数受到限制</li>
</ul>
</li>
<li>用户编程行为分析<ul>
<li>全面考虑各种情况，执行时有互斥性</li>
<li>顺序性和循环性等空间局部性行为</li>
<li>某一阶段执行的时间局部性行为</li>
</ul>
</li>
<li>因此可以考虑部分调入进程内容</li>
</ul>
<h4 id="虚拟存储器的基本思想"><a href="#虚拟存储器的基本思想" class="headerlink" title="虚拟存储器的基本思想"></a><strong>虚拟存储器的基本思想</strong></h4><ul>
<li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为<strong>随用随调入</strong></li>
<li>如主存中没有足够的空闲空间，存储管理需要根据执行行为把主存中暂时不用的信息<strong>调出</strong>到辅存上去</li>
</ul>
<h4 id="虚拟存储器的实现思路"><a href="#虚拟存储器的实现思路" class="headerlink" title="虚拟存储器的实现思路"></a><strong>虚拟存储器的实现思路</strong></h4><ul>
<li>需要建立与自动管理两个地址空间<ul>
<li>(辅存)虚拟地址空间：容纳进程装入</li>
<li>(主存)实际地址空间：承载进程执行</li>
</ul>
</li>
<li>对于用户，计算机系统具有一个容量大得多的主存空间，即<strong>虚拟存储器</strong></li>
<li>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能的程序设计</li>
</ul>
<h4 id="虚拟存储器示意"><a href="#虚拟存储器示意" class="headerlink" title="虚拟存储器示意"></a><strong>虚拟存储器示意</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221024120103491.png" alt="image-20221024120103491" style="zoom:80%;" /></p>
<h3 id="3-1-4-存储管理的硬件支撑"><a href="#3-1-4-存储管理的硬件支撑" class="headerlink" title="3.1.4 存储管理的硬件支撑"></a>3.1.4 存储管理的硬件支撑</h3><h4 id="存储器的组织层次"><a href="#存储器的组织层次" class="headerlink" title="存储器的组织层次"></a><strong>存储器的组织层次</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027141452301.png" alt="image-20221027141452301" style="zoom:80%;" /></p>
<h4 id="存储管理涉及的存储对象"><a href="#存储管理涉及的存储对象" class="headerlink" title="存储管理涉及的存储对象"></a><strong>存储管理涉及的存储对象</strong></h4><ul>
<li>存储管理是OS管理主存储器的软件部分</li>
<li>为获得更好的处理性能，部分主存程序与数据（特别是关键性能数据）被调入Cache，存储管理需要对其进行管理，甚至包括对联想存储器的管理</li>
<li>为获得更大的虚拟地址空间，存储管理需要对存放在硬盘、固态硬盘、甚至网络硬盘上的虚拟存储器文件进行管理</li>
</ul>
<h4 id="高速缓存存储器-Cache"><a href="#高速缓存存储器-Cache" class="headerlink" title="高速缓存存储器(Cache)"></a><strong>高速缓存存储器(Cache)</strong></h4><ul>
<li>Cache是介于CPU和主存储器间的高速小容量存储器，由静态存储芯片SRAM组成，容量较小但比主存DRAM技术更加昂贵而快速，接近于CPU的速度</li>
<li>CPU往往需要重复读取同样的数据块，Cache的引入与缓存容量的增大，可以大幅提升CPU内部读取数据的命中率，从而提高系统性能</li>
</ul>
<h4 id="高速缓存存储器的构成"><a href="#高速缓存存储器的构成" class="headerlink" title="高速缓存存储器的构成"></a><strong>高速缓存存储器的构成</strong></h4><ul>
<li>高速缓存存储器通常由高速存储器、联想存储器、地址转换部件、替换逻辑等组成</li>
<li>联想存储器：根据内容进行寻址的存储器</li>
<li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换。命中时直接访问Cache；未命中时从内存中读取放入Cache</li>
<li>替换部件：在缓存已满时按一定策略进行数据块替换，并修改地址转换部件</li>
</ul>
<h4 id="高速缓存存储器的组织"><a href="#高速缓存存储器的组织" class="headerlink" title="高速缓存存储器的组织"></a><strong>高速缓存存储器的组织</strong></h4><ul>
<li>由于CPU芯片面积和成本，Cache很小</li>
<li>根据成本控制，划分为L1、L2、L3三级</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027143738934.png" alt="image-20221027143738934" style="zoom:80%;" /></p>
<h4 id="高速缓存存储器的分级"><a href="#高速缓存存储器的分级" class="headerlink" title="高速缓存存储器的分级"></a><strong>高速缓存存储器的分级</strong></h4><ul>
<li>L1 Cache：分为数据缓存和指令缓存；内置；其成本最高，对CPU的性能影响最大；通常在32KB-256KB之间</li>
<li>L2 Cache：分内置和外置两种，后者性能低一些；通常在512KB-8MB之间</li>
<li>L3 Cache：多为外置，在游戏和服务器领域有效；但对很多应用来说，<strong>总线改善</strong>比<strong>设置L3</strong>更加有利于提升系统性能</li>
</ul>
<h4 id="各类处理器架构"><a href="#各类处理器架构" class="headerlink" title="各类处理器架构"></a><strong>各类处理器架构</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027143949652.png" alt="image-20221027143949652" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027144502096.png" alt="image-20221027144502096" style="zoom:80%;" /></p>
<h4 id="地址转换-存储保护的硬件支撑"><a href="#地址转换-存储保护的硬件支撑" class="headerlink" title="地址转换/存储保护的硬件支撑"></a><strong>地址转换/存储保护的硬件支撑</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027144710152.png" alt="image-20221027144710152" style="zoom:80%;" /></p>
<h4 id="存储管理与硬件支撑"><a href="#存储管理与硬件支撑" class="headerlink" title="存储管理与硬件支撑"></a><strong>存储管理与硬件支撑</strong></h4><ul>
<li>鉴于程序执行与数据访问的局部性原理，存储管理软件使用Cache可以大幅度提升程序执行效率</li>
<li><p>动态重定位、存储保护等，若无硬件支撑在效率上是无意义的，即无实现价值</p>
</li>
<li><p>无虚拟地址中断，虚拟存储器无法实现</p>
</li>
<li>无页面替换等硬件支撑机制，虚拟存储器在效率上是无意义的</li>
</ul>
<h2 id="3-2-单连续分区存储管理"><a href="#3-2-单连续分区存储管理" class="headerlink" title="3.2 单连续分区存储管理"></a>3.2 单连续分区存储管理</h2><h3 id="3-2-1-单连续分区存储管理"><a href="#3-2-1-单连续分区存储管理" class="headerlink" title="3.2.1 单连续分区存储管理"></a>3.2.1 单连续分区存储管理</h3><h4 id="单连续分区存储管理"><a href="#单连续分区存储管理" class="headerlink" title="单连续分区存储管理"></a><strong>单连续分区存储管理</strong></h4><ul>
<li>每个进程占用一个物理上完全连续的存储空间(区域)</li>
<li>单用户连续存储管理</li>
<li>固定分区存储管理</li>
<li>可变分区存储管理</li>
</ul>
<h4 id="单用户连续分区存储管理"><a href="#单用户连续分区存储管理" class="headerlink" title="单用户连续分区存储管理"></a><strong>单用户连续分区存储管理</strong></h4><ul>
<li>主存区域划分为<strong>系统区</strong>与<strong>用户区</strong></li>
<li>设置一个<strong>栅栏寄存器</strong>界分两个区域，硬件用它在执行时进行存储保护</li>
<li>一般采用<strong>静态重定位</strong>进行地址转换</li>
<li>硬件实现代价低</li>
<li>适用于单用户单任务操作系统，如DOS</li>
</ul>
<h4 id="单用户连续分区存储管理示意"><a href="#单用户连续分区存储管理示意" class="headerlink" title="单用户连续分区存储管理示意"></a><strong>单用户连续分区存储管理示意</strong></h4><ul>
<li>静态重定位：在装入一个作业时，把该作业中程序的指令地址和数据地址<strong>全部转换成绝对地址</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150255136.png" alt="image-20221027150255136" style="zoom:80%;" /></p>
<h4 id="固定分区存储管理的基本思想"><a href="#固定分区存储管理的基本思想" class="headerlink" title="固定分区存储管理的基本思想"></a><strong>固定分区存储管理的基本思想</strong></h4><ul>
<li>支持多个分区</li>
<li>分区数量固定</li>
<li>分区大小固定</li>
<li>可用静态重定位</li>
<li>硬件实现代价低</li>
<li>早期OS采用</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150427931.png" alt="image-20221027150427931" style="zoom:50%;" /></p>
<h4 id="固定分区方式的主存分配"><a href="#固定分区方式的主存分配" class="headerlink" title="固定分区方式的主存分配"></a><strong>固定分区方式的主存分配</strong></h4><ul>
<li><p>主存分配表</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150540542.png" alt="image-20221027150540542" style="zoom:80%;" /></p>
</li>
<li><p>主存分配与去配</p>
</li>
</ul>
<h4 id="固定分区方式的地址转换"><a href="#固定分区方式的地址转换" class="headerlink" title="固定分区方式的地址转换"></a><strong>固定分区方式的地址转换</strong></h4><ul>
<li><p>硬件实现机制与动态重定位</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027151008590.png" alt="image-20221027151008590" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="可变分区存储管理概述"><a href="#可变分区存储管理概述" class="headerlink" title="可变分区存储管理概述"></a><strong>可变分区存储管理概述</strong></h4><ul>
<li><p>固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存<strong>内零头</strong>，有浪费</p>
</li>
<li><p>能否按照进程实际内存需求<strong>动态划分分区</strong>，并允许<strong>分区个数可变</strong></p>
</li>
<li><p>这就是可变分区存储管理</p>
</li>
</ul>
<h3 id="3-2-2-可变分区存储管理"><a href="#3-2-2-可变分区存储管理" class="headerlink" title="3.2.2 可变分区存储管理"></a>3.2.2 可变分区存储管理</h3><h4 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a><strong>可变分区存储管理</strong></h4><ul>
<li>按进程的内存需求来动态划分分区</li>
<li>创建一个进程时，根据进程所需主存量查看主存中是否有足够的空闲空间<ul>
<li>若有，则按需要量分割一个分区</li>
<li>若无，则令该进程等待主存资源</li>
</ul>
</li>
<li>由于分区大小按照进程实际需要量来确定，因此分区个数是随机变化的</li>
</ul>
<h4 id="可变分区方式的内存分配示例"><a href="#可变分区方式的内存分配示例" class="headerlink" title="可变分区方式的内存分配示例"></a><strong>可变分区方式的内存分配示例</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027151836071.png" alt="image-20221027151836071" style="zoom:80%;" /></p>
<h4 id="可变分区方式的主存分配表"><a href="#可变分区方式的主存分配表" class="headerlink" title="可变分区方式的主存分配表"></a><strong>可变分区方式的主存分配表</strong></h4><ul>
<li>已分配区表与未分配区表，采用链表</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027152126219.png" alt="image-20221027152126219" style="zoom:80%;" /></p>
<h4 id="可变分区方式的内存分配"><a href="#可变分区方式的内存分配" class="headerlink" title="可变分区方式的内存分配"></a><strong>可变分区方式的内存分配</strong></h4><ul>
<li>最先适应分配算法<ul>
<li>从低地址向高地址扫描，所查找到的第一个可以容纳该进程的空闲区就分配给进程</li>
</ul>
</li>
<li>邻近适应分配算法<ul>
<li>从上一次分配的地址开始向高地址查找符合要求的空闲区，所查找到的第一个满足要求的空闲区就分配给进程。</li>
</ul>
</li>
<li>最优适应分配算法<ul>
<li>选择内存空闲区中最适合进程大小的分配。</li>
</ul>
</li>
<li>最坏适应分配算法<ul>
<li>挑选最大的空闲区</li>
</ul>
</li>
</ul>
<h4 id="可变分区方式的内存回收"><a href="#可变分区方式的内存回收" class="headerlink" title="可变分区方式的内存回收"></a><strong>可变分区方式的内存回收</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153045763.png" alt="image-20221027153045763" style="zoom:80%;" /></p>
<h4 id="地址转换与存储保护"><a href="#地址转换与存储保护" class="headerlink" title="地址转换与存储保护"></a><strong>地址转换与存储保护</strong></h4><ul>
<li>硬件实现机制与动态重定位</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153115917.png" alt="image-20221027153115917" style="zoom:80%;" /></p>
<h4 id="可变分区方式的内存零头"><a href="#可变分区方式的内存零头" class="headerlink" title="可变分区方式的内存零头"></a><strong>可变分区方式的内存零头</strong></h4><ul>
<li>固定分区方式会产生内存<strong>内零头</strong></li>
<li>可变分区方式也会随着进程的内存分配产生一些小的不可用的内存分区，称为<strong>内存外零头</strong></li>
<li>最优适配算法最容易产生外零头</li>
<li>任何适配算法都<strong>不能避免</strong>产生外零头</li>
</ul>
<h4 id="移动技术-程序浮动技术"><a href="#移动技术-程序浮动技术" class="headerlink" title="移动技术(程序浮动技术)"></a><strong>移动技术(程序浮动技术)</strong></h4><ul>
<li>移动分区以解决内存外零头</li>
<li>需要动态重定位支撑</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153332243.png" alt="image-20221027153332243" style="zoom:80%;" /></p>
<h4 id="移动技术的工作流程"><a href="#移动技术的工作流程" class="headerlink" title="移动技术的工作流程"></a><strong>移动技术的工作流程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153402167.png" alt="image-20221027153402167" style="zoom:80%;" /></p>
<h2 id="3-3-页式存储管理"><a href="#3-3-页式存储管理" class="headerlink" title="3.3 页式存储管理"></a>3.3 页式存储管理</h2><h3 id="3-3-1-页式存储管理的基本原理"><a href="#3-3-1-页式存储管理的基本原理" class="headerlink" title="3.3.1 页式存储管理的基本原理"></a>3.3.1 页式存储管理的基本原理</h3><h4 id="页式存储管理的基本原理"><a href="#页式存储管理的基本原理" class="headerlink" title="页式存储管理的基本原理"></a><strong>页式存储管理的基本原理</strong></h4><ul>
<li><p>分页存储器将主存划分成多个大小相等的<strong>页架</strong></p>
</li>
<li><p>受页架尺寸限制，程序的逻辑地址也自然分成<strong>页</strong></p>
</li>
<li><p>不同的页可以放在不同页架中，不需要连续</p>
</li>
<li><p><strong>页表</strong>用于维系进程的主存<strong>完整性</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154114015.png" alt="image-20221027154114015" style="zoom:67%;" /></p>
</li>
</ul>
<h4 id="页式存储管理中的地址"><a href="#页式存储管理中的地址" class="headerlink" title="页式存储管理中的地址"></a><strong>页式存储管理中的地址</strong></h4><ul>
<li><p>页式存储管理的<strong>逻辑地址</strong>由两部分组成，<strong>页号和单元号(页内偏移量 offset)</strong>，逻辑地址形式：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154312547.png" alt="image-20221027154312547" style="zoom:50%;" /></p>
</li>
<li><p>页式存储管理的<strong>物理地址</strong>也有两部分组成：<strong>页架号和单元号</strong>，物理地址形式：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154358621.png" alt="image-20221027154358621" style="zoom:50%;" /></p>
</li>
<li><p>地址转换可以通过查页表完成</p>
</li>
<li>页内地址逐一连续对应<ul>
<li>所以地址转换时只需要从页号映射到页框号</li>
</ul>
</li>
</ul>
<h4 id="页式存储管理的地址转换思路"><a href="#页式存储管理的地址转换思路" class="headerlink" title="页式存储管理的地址转换思路"></a><strong>页式存储管理的地址转换思路</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154436828.png" alt="image-20221027154436828" style="zoom:80%;" /></p>
<h4 id="页式存储管理的内存分配-去配"><a href="#页式存储管理的内存分配-去配" class="headerlink" title="页式存储管理的内存分配/去配"></a><strong>页式存储管理的内存分配/去配</strong></h4><ul>
<li>可用一张<strong>位示图</strong>来记录主存分配情况</li>
<li>建立进程页表维护主存逻辑完整性</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154908427.png" alt="image-20221027154908427" style="zoom:80%;" /></p>
<h4 id="页的共享"><a href="#页的共享" class="headerlink" title="页的共享"></a><strong>页的共享</strong></h4><ul>
<li><p>页式存储管理能够实现多个进程共享程序和数据</p>
</li>
<li><p><strong>数据共享</strong>：不同进程可以使用<strong>不同</strong>页号共享数据页</p>
<ul>
<li>允许不同进程对共享的数据页用不同的页号，只要让各自页表中的有关表项<strong>指向共享的数据页框</strong></li>
</ul>
</li>
<li><p><strong>程序共享</strong>：不同进程必须使用<strong>相同</strong>页号共享代码页</p>
<ul>
<li>共享代码页中的(<strong>JMP &lt;页内地址&gt;</strong>)指令，使用不同页号是做不到</li>
<li>由于指令包含指向其他指令或数据的地址，进程依赖于这些地址才能执行，不同进程中正确执行共享代码页面，必须为它们在所有逻辑地址空间中指定同样页号</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-页式存储管理的地址转换"><a href="#3-3-2-页式存储管理的地址转换" class="headerlink" title="3.3.2 页式存储管理的地址转换"></a>3.3.2 页式存储管理的地址转换</h3><h4 id="页式存储管理的地址转换代价"><a href="#页式存储管理的地址转换代价" class="headerlink" title="页式存储管理的地址转换代价"></a><strong>页式存储管理的地址转换代价</strong></h4><ul>
<li><p><strong>页表放在主存</strong>: 每次地址转换必须访问两次主存</p>
<ol>
<li><p>按页号读出页表中的相应页架号</p>
</li>
<li><p>按计算出来的绝对地址进行读写</p>
</li>
</ol>
</li>
<li><p><strong>存在问题</strong>：降低了存取速度</p>
</li>
<li><p><strong>解决办法</strong>：利用Cache存放部分页表</p>
</li>
</ul>
<h4 id="页式存储管理的快表"><a href="#页式存储管理的快表" class="headerlink" title="页式存储管理的快表"></a><strong>页式存储管理的快表</strong></h4><ul>
<li>为提高地址转换速度，设置一个专用的高速存储器，用来存放页表的一部分</li>
<li><strong>快表</strong>：存放在高速存储器中的页表部分</li>
<li>快表表项：<strong>页号，页架号</strong></li>
<li>这种高速存储器是<strong>联想存储器</strong>，即<strong>按照内容寻址</strong>，而非按照地址访问</li>
</ul>
<h4 id="引入快表后的地址转换代价"><a href="#引入快表后的地址转换代价" class="headerlink" title="引入快表后的地址转换代价"></a><strong>引入快表后的地址转换代价</strong></h4><ul>
<li>采用<strong>快表</strong>后，可以加快地址转换速度</li>
<li>假定主存访问时间为200毫微秒，快表访问时间为40毫微秒，查快表的命中率是90%，平均地址转换代价为 (200+40)*90%+(200+200+40)*10%=260毫微秒</li>
<li>比两次访问主存的时间（400毫微秒）<strong>下降了35%</strong></li>
</ul>
<h4 id="基于快表的地址转换流程"><a href="#基于快表的地址转换流程" class="headerlink" title="基于快表的地址转换流程"></a><strong>基于快表的地址转换流程</strong></h4><ul>
<li>按逻辑地址中的页号查快表</li>
<li>若该页<strong>已在快表</strong>中，则由页架号和单元号形成绝对地址</li>
<li>若该页<strong>不在快表</strong>中，则再查主存页表形成绝对地址，同时将该页登记到快表中</li>
<li>当<strong>快表填满</strong>后，又要登记新页时，则需在快表中按一定策略<strong>淘汰</strong>一个旧登记项</li>
</ul>
<h4 id="多道程序环境下的进程表"><a href="#多道程序环境下的进程表" class="headerlink" title="多道程序环境下的进程表"></a><strong>多道程序环境下的进程表</strong></h4><ul>
<li>进程表中登记了每个进程的页表</li>
<li>进程占有处理器运行时，其<strong>页表起始地址和长度</strong>送入<strong>页表控制寄存器</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031104352984.png" alt="image-20221031104352984" style="zoom:80%;" /></p>
<h4 id="多道程序环境下的地址转换"><a href="#多道程序环境下的地址转换" class="headerlink" title="多道程序环境下的地址转换"></a><strong>多道程序环境下的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031104727130.png" alt="image-20221031104727130" style="zoom:80%;" /></p>
<h3 id="3-3-3-页式虚拟存储管理"><a href="#3-3-3-页式虚拟存储管理" class="headerlink" title="3.3.3 页式虚拟存储管理"></a>3.3.3 页式虚拟存储管理</h3><h4 id="页式虚拟存储管理的基本思想"><a href="#页式虚拟存储管理的基本思想" class="headerlink" title="页式虚拟存储管理的基本思想"></a><strong>页式虚拟存储管理的基本思想</strong></h4><ul>
<li>把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后，根据执行行为，动态调入不在主存的页，同时进行必要的页面调出</li>
<li>现代OS的<strong>主流存储管理技术</strong></li>
<li>首次只把进程第一页信息装入主存，称为<strong>请求页式存储管理</strong></li>
</ul>
<h4 id="页式虚拟存储管理的页表"><a href="#页式虚拟存储管理的页表" class="headerlink" title="页式虚拟存储管理的页表"></a><strong>页式虚拟存储管理的页表</strong></h4><ul>
<li>需要扩充页表项，指出：<ul>
<li>每页的虚拟地址、实际地址</li>
<li>主存驻留标志、写回标志、保护标志、引用标志、可移动标志</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031105524974.png" alt="image-20221031105524974" style="zoom: 67%;" /></p>
<h4 id="页式虚拟存储管理的实现"><a href="#页式虚拟存储管理的实现" class="headerlink" title="页式虚拟存储管理的实现"></a><strong>页式虚拟存储管理的实现</strong></h4><ul>
<li>CPU处理地址<ul>
<li>若页驻留，则获得块号形成绝对地址</li>
<li>若页不在内存，则CPU发出缺页中断</li>
</ul>
</li>
<li>OS处理缺页中断<ul>
<li>若有空闲页架，则根据辅存地址调入页，更新页表与快表等</li>
<li>若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表</li>
</ul>
</li>
</ul>
<h4 id="页式虚拟存储管理的地址转换"><a href="#页式虚拟存储管理的地址转换" class="headerlink" title="页式虚拟存储管理的地址转换"></a><strong>页式虚拟存储管理的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031111641724.png" alt="image-20221031111641724" style="zoom:80%;" /></p>
<h4 id="缺页中断的处理流程"><a href="#缺页中断的处理流程" class="headerlink" title="缺页中断的处理流程"></a><strong>缺页中断的处理流程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031111843806.png" alt="image-20221031111843806" style="zoom: 67%;" /></p>
<h4 id="补充：TLB-快表"><a href="#补充：TLB-快表" class="headerlink" title="补充：TLB(快表)"></a><strong>补充：TLB(快表)</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031112900090.png" alt="image-20221031112900090" style="zoom: 67%;" /></p>
<h4 id="补充：Paging-Hardware-With-TLB"><a href="#补充：Paging-Hardware-With-TLB" class="headerlink" title="补充：Paging Hardware With TLB"></a><strong>补充：Paging Hardware With TLB</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031112932254.png" alt="image-20221031112931920" style="zoom:80%;" /></p>
<h3 id="3-3-4-页面调度"><a href="#3-3-4-页面调度" class="headerlink" title="3.3.4 页面调度"></a>3.3.4 页面调度</h3><h4 id="页面调度"><a href="#页面调度" class="headerlink" title="页面调度"></a><strong>页面调度</strong></h4><ul>
<li>当主存空间已满而又需要装入新页时，页式虚拟存储管理必须按照一定的算法把已在主存的一些页调出去</li>
<li>选择淘汰页的工作称为<strong>页面调度</strong></li>
<li>选择淘汰页的算法称为<strong>页面调度算法</strong></li>
<li>页面调度算法设计不当，会出现（刚被淘汰的页面立即又要调入，并如此反复）</li>
<li>这种现象称为<strong>抖动</strong>或<strong>颠簸</strong></li>
</ul>
<h4 id="缺页中断率"><a href="#缺页中断率" class="headerlink" title="缺页中断率"></a><strong>缺页中断率</strong></h4><ul>
<li>假定进程P共 n 页，系统分配页架数 m 个</li>
<li>P运行中成功访问次数为S，不成功访问次数为F，总访问次数 A=S+F</li>
<li><strong>缺页中断率</strong>定义为：f=F/A</li>
<li>缺页中断率是衡量存储管理性能和用户编程水平的重要依据</li>
</ul>
<h4 id="影响缺页中断率的因素"><a href="#影响缺页中断率的因素" class="headerlink" title="影响缺页中断率的因素"></a><strong>影响缺页中断率的因素</strong></h4><ul>
<li>分配给进程的页架数：可用页架数越多，则缺页中断率就越低</li>
<li>页面的大小：页面尺寸越大，则缺页中断率就越低</li>
<li>用户的程序编制方法：在大数据量情况下，对缺页中断率也有很大影响</li>
</ul>
<h4 id="用户编程的例子"><a href="#用户编程的例子" class="headerlink" title="用户编程的例子"></a><strong>用户编程的例子</strong></h4><ul>
<li>程序将数组置为“0”，假定仅分得一个主存页架，页面尺寸为128个字，数组元素按行存放，开始时第一页在主存</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031113150739.png" alt="image-20221031113150739" style="zoom:67%;" /></p>
<h4 id="OPT页面调度算法"><a href="#OPT页面调度算法" class="headerlink" title="OPT页面调度算法"></a><strong>OPT页面调度算法</strong></h4><ul>
<li>理想的调度算法是：当要调入新页面时，首先淘汰以后不再访问的页，然后选择距现在最长时间后再访问的页</li>
<li>该算法由Belady出，称Belady算法，又称最佳算法(OPT)</li>
<li>OPT只可模拟，不可实现</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115319441.png" alt="image-20221031115319441" style="zoom:80%;" /></p>
<h4 id="先进先出FIFO页面调度算法"><a href="#先进先出FIFO页面调度算法" class="headerlink" title="先进先出FIFO页面调度算法"></a><strong>先进先出FIFO页面调度算法</strong></h4><ul>
<li>总是淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页(常驻的除外)</li>
<li>模拟的是程序执行的顺序性，有一定合理性</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115356690.png" alt="image-20221031115356690" style="zoom:80%;" /></p>
<h4 id="最近最少用LRU页面调度算法"><a href="#最近最少用LRU页面调度算法" class="headerlink" title="最近最少用LRU页面调度算法"></a><strong>最近最少用LRU页面调度算法</strong></h4><ul>
<li>淘汰最近一段时间较久未被访问的那一页，即那些刚被使用过的页面，可能马上还要被使用到</li>
<li>模拟了程序执行的局部属性，既考虑了循环性又兼顾了顺序性</li>
<li>严格实现的代价大(需要维持特殊队列)</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115610482.png" alt="image-20221031115610482" style="zoom:80%;" /></p>
<h4 id="LRU算法的模拟实现"><a href="#LRU算法的模拟实现" class="headerlink" title="LRU算法的模拟实现"></a><strong>LRU算法的模拟实现</strong></h4><ul>
<li>每页建一个引用标志，供硬件使用</li>
<li>设置一个时间间隔中断：中断时页引用标志置0</li>
<li>地址转换时，页引用标志置1</li>
<li>淘汰页面时，从页引用标志为0的页中间随机选择</li>
<li>时间间隔多长是个难点</li>
</ul>
<h4 id="最不常用LFU页面调度算法"><a href="#最不常用LFU页面调度算法" class="headerlink" title="最不常用LFU页面调度算法"></a><strong>最不常用LFU页面调度算法</strong></h4><ul>
<li>淘汰最近一段时间内访问次数较少的页面，对OPT的模拟性比LRU更好</li>
<li>基于时间间隔中断，并给每一页设置一个计数器</li>
<li>时间间隔中断发生后，所有计数器清0</li>
<li>每访问页1次就给计数器加1</li>
<li>选择计数值最小的页面淘汰</li>
</ul>
<h4 id="时钟CLOCK页面调度算法"><a href="#时钟CLOCK页面调度算法" class="headerlink" title="时钟CLOCK页面调度算法"></a><strong>时钟CLOCK页面调度算法</strong></h4><ul>
<li>采用循环队列机制构造页面队列，形成了一个类似于钟表面的环形表</li>
<li>队列指针则相当于钟表面上的表针，指向可能要淘汰的页面</li>
<li>使用页引用标志位</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115733235.png" alt="image-20221031115733235" style="zoom:80%;" /></p>
<h4 id="CLOCK算法的工作流程"><a href="#CLOCK算法的工作流程" class="headerlink" title="CLOCK算法的工作流程"></a><strong>CLOCK算法的工作流程</strong></h4><ul>
<li>页面调入主存时，其引用标志位置1</li>
<li>访问主存页面时，其引用标志位置1</li>
<li>淘汰页面时，从指针当前指向的页面开始扫描循环队列<ul>
<li>把所遇到的引用标志位是1的页面的引用标志位清0，并跳过</li>
<li>把所遇到的引用标志位是0的页面淘汰，指针推进一步</li>
</ul>
</li>
</ul>
<h3 id="3-3-5-反置页表-详见补充4"><a href="#3-3-5-反置页表-详见补充4" class="headerlink" title="3.3.5 反置页表(详见补充4)"></a>3.3.5 反置页表(详见补充4)</h3><h4 id="反置页表的提出"><a href="#反置页表的提出" class="headerlink" title="反置页表的提出"></a><strong>反置页表的提出</strong></h4><ul>
<li>页表及相关硬件机制在地址转换、存储保护、虚拟地址访问中发挥了<strong>关键作用</strong></li>
<li>为页式存储管理设置专门硬件机构</li>
<li>内存管理单元MMU：CPU管理虚拟/物理存储器的控制线路，把虚拟地址映射为物理地址，并提供存储保护，必要时确定淘汰页面</li>
<li>反置页表IPT：MMU用的数据结构</li>
</ul>
<h4 id="反置页表的基本思想"><a href="#反置页表的基本思想" class="headerlink" title="反置页表的基本思想"></a><strong>反置页表的基本思想</strong></h4><ul>
<li>针对内存中的每个页架建立一个页表，按照块号排序</li>
<li>表项包含：正在访问该页框的进程标识、页号及特征位，和哈希链指针等</li>
<li>用来完成内存页架到访问进程页号的对应，即物理地址到逻辑地址的转换</li>
</ul>
<h4 id="反置页表的页表项"><a href="#反置页表的页表项" class="headerlink" title="反置页表的页表项"></a><strong>反置页表的页表项</strong></h4><ul>
<li>页号：虚拟地址页号</li>
<li>进程标志符：使用该页的进程号（页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页）</li>
<li>标志位：有效、引用、修改、保护和锁定等标志信息</li>
<li>链指针：哈希链</li>
</ul>
<h4 id="基于反置页表的地址转换过程"><a href="#基于反置页表的地址转换过程" class="headerlink" title="基于反置页表的地址转换过程"></a><strong>基于反置页表的地址转换过程</strong></h4><ul>
<li>MMU通过哈希表把进程标识和虚页号转换成一个哈希值，指向IPT的一个表目</li>
<li>MMU遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，通过拼接位移便可生成物理地址</li>
<li>若遍历整个反置页表中未能找到匹配页表项，说明该页不在内存，产生缺页中断，请求操作系统调入</li>
</ul>
<h4 id="反置页表下的地址转换示意"><a href="#反置页表下的地址转换示意" class="headerlink" title="反置页表下的地址转换示意"></a><strong>反置页表下的地址转换示意</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107145644332.png" alt="image-20221107145644332" style="zoom:80%;" /></p>
<h2 id="3-4-段式存储管理"><a href="#3-4-段式存储管理" class="headerlink" title="3.4 段式存储管理"></a>3.4 段式存储管理</h2><h3 id="3-4-1-段式存储管理"><a href="#3-4-1-段式存储管理" class="headerlink" title="3.4.1 段式存储管理"></a>3.4.1 段式存储管理</h3><h4 id="段式程序设计-1"><a href="#段式程序设计-1" class="headerlink" title="段式程序设计"></a><strong>段式程序设计</strong></h4><ul>
<li>每个程序可由若干段组成，每一段都可以从“0”开始编址，段内的地址是连续的</li>
<li>分段存储器的逻辑地址由两部分组成<ul>
<li>段号：单元号</li>
</ul>
</li>
</ul>
<h4 id="程序的分段结构"><a href="#程序的分段结构" class="headerlink" title="程序的分段结构"></a><strong>程序的分段结构</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107115819595.png" alt="image-20221107115819595" style="zoom:80%;" /></p>
<h4 id="段式存储管理的基本思想"><a href="#段式存储管理的基本思想" class="headerlink" title="段式存储管理的基本思想"></a><strong>段式存储管理的基本思想</strong></h4><ul>
<li>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区</li>
<li>硬件需要增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段，附加段），供地址转换使用 </li>
<li>存储管理需要增加设置一个段表，每个段占用一个段表项，包括：段始址、段限长，以及存储保护、可移动、可扩充等标志位</li>
</ul>
<h4 id="段式存储管理的地址转换流程"><a href="#段式存储管理的地址转换流程" class="headerlink" title="段式存储管理的地址转换流程"></a><strong>段式存储管理的地址转换流程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107115940791.png" alt="image-20221107115940791" style="zoom:80%;" /></p>
<h4 id="段的共享"><a href="#段的共享" class="headerlink" title="段的共享"></a><strong>段的共享</strong></h4><ul>
<li>通过不同进程段表中的项指向同一个段基址来实现</li>
<li>对共享段的信息必须进行保护，如规定只能读出不能写入，不满足保护条件则产生保护中断</li>
</ul>
<h3 id="3-4-2-段式虚拟存储管理"><a href="#3-4-2-段式虚拟存储管理" class="headerlink" title="3.4.2 段式虚拟存储管理"></a>3.4.2 段式虚拟存储管理</h3><h4 id="段式虚拟存储管理的基本思想"><a href="#段式虚拟存储管理的基本思想" class="headerlink" title="段式虚拟存储管理的基本思想"></a><strong>段式虚拟存储管理的基本思想</strong></h4><ul>
<li>把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入</li>
<li>段式虚拟存储管理中段的调进调出是由OS自动实现的，对用户透明</li>
<li>与段覆盖技术不同，它是用户控制的主存扩充技术，OS不感知</li>
</ul>
<h4 id="段式虚拟存储管理的段表扩充"><a href="#段式虚拟存储管理的段表扩充" class="headerlink" title="段式虚拟存储管理的段表扩充"></a><strong>段式虚拟存储管理的段表扩充</strong></h4><ul>
<li>段表的扩充<ul>
<li>特征位: 00(不在内存)01(在内存)11(共享段)</li>
<li>存取权限: 00(可执行)01(可读)11(可写)</li>
<li>扩充位: 0(固定长)1(可扩充)</li>
<li>标志位: 00(未修改)01(已修改)11(不可移动)</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120307367.png" alt="image-20221107120307367" style="zoom:80%;" /></p>
<h4 id="段式虚拟存储管理的地址转换"><a href="#段式虚拟存储管理的地址转换" class="headerlink" title="段式虚拟存储管理的地址转换"></a><strong>段式虚拟存储管理的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120330137.png" alt="image-20221107120330137" style="zoom:80%;" /></p>
<h3 id="3-4-3-段页式存储管理"><a href="#3-4-3-段页式存储管理" class="headerlink" title="3.4.3 段页式存储管理"></a>3.4.3 段页式存储管理</h3><h4 id="段页式存储管理的基本思想"><a href="#段页式存储管理的基本思想" class="headerlink" title="段页式存储管理的基本思想"></a><strong>段页式存储管理的基本思想</strong></h4><ul>
<li>段式存储管理可以基于页式存储管理实现</li>
<li>每一段不必占据连续的存储空间，可存放在不连续的主存页架中</li>
<li>能够扩充为段页式虚拟存储管理 </li>
<li>装入部分段，或者装入段中部分页面</li>
</ul>
<h4 id="段页式存储管理的段表和页表"><a href="#段页式存储管理的段表和页表" class="headerlink" title="段页式存储管理的段表和页表"></a><strong>段页式存储管理的段表和页表</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120528299.png" alt="image-20221107120528299" style="zoom:80%;" /></p>
<h4 id="段页式存储管理的地址转换"><a href="#段页式存储管理的地址转换" class="headerlink" title="段页式存储管理的地址转换"></a><strong>段页式存储管理的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150325303.png" alt="image-20221107150325303" style="zoom:80%;" /></p>
<h4 id="段页式虚拟存储管理的地址转换"><a href="#段页式虚拟存储管理的地址转换" class="headerlink" title="段页式虚拟存储管理的地址转换"></a><strong>段页式虚拟存储管理的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150517462.png" alt="image-20221107150517462" style="zoom:80%;" /></p>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="补充1：虚拟存储器的概念-补充局部性特征"><a href="#补充1：虚拟存储器的概念-补充局部性特征" class="headerlink" title="补充1：虚拟存储器的概念(补充局部性特征)"></a>补充1：虚拟存储器的概念(补充局部性特征)</h3><h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a><strong>抖动</strong></h4><ul>
<li>如果一块正好将要被用到之前扔出，操作系统有不得不很快把它取回来，太多的这类操作会导致一种称为系统抖动的情况</li>
<li>在处理缺页中断期间，处理器的大部分时间都用于交换块，而不是用户进程的执行指令</li>
</ul>
<h4 id="程序局部性原理-1"><a href="#程序局部性原理-1" class="headerlink" title="程序局部性原理(1)"></a><strong>程序局部性原理(1)</strong></h4><ul>
<li>指程序在执行过程中的一个较短时间内，所执行的<strong>指令地址或操作数地址分别局限于一定的存储区域中</strong>。又可细分时间局部性和空间局部性</li>
<li>早在1968年P. Denning研究程序执行时的局部性原理，对此进行研究的还有Knuth(分析一组学生的Fortran程序)、Tanenbaum (分析操作系统的过程)、Huck(分析通用科学计算程序)，<strong>发现程序和数据的访问都有聚集成群的倾向</strong></li>
<li>某存储单元被使用，其<strong>相邻存储单元很快也被使用(称空间局部性spatial locality)</strong></li>
<li>或者<strong>最近访问过的程序代码和数据，很快又被访问(称时间局部性temporal locality)</strong></li>
</ul>
<h4 id="分页下的运行情况"><a href="#分页下的运行情况" class="headerlink" title="分页下的运行情况"></a><strong>分页下的运行情况</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150916487.png" alt="image-20221107150916487" style="zoom:80%;" /></p>
<h4 id="程序局部性原理-2"><a href="#程序局部性原理-2" class="headerlink" title="程序局部性原理(2)"></a><strong>程序局部性原理(2)</strong></h4><ul>
<li>程序中只有少量分支和过程调用，存在很多顺序执行的指令</li>
<li>程序含有若干循环结构，由少量代码组成，而被多次执行</li>
<li>过程调用的深度限制在小范围内，因而，指令引用通常被局限在少量过程中</li>
<li>涉及数组、记录之类的数据结构，对它们的连续引用是对位置相邻的数据项的操作</li>
<li>程序中有些部分彼此互斥，不是每次运行时都用到</li>
</ul>
<h4 id="程序局部性原理-3"><a href="#程序局部性原理-3" class="headerlink" title="程序局部性原理(3)"></a><strong>程序局部性原理(3)</strong></h4><p>经验与分析表明，程序具有局部性，进程执行时<strong>没有必要把全部信息调入主存，只需装入一部分的假设是合理的，部分装入的情况下，只要调度得当</strong>，不仅可正确运行，而且能在主存中放置更多进程，充分利用处理器和存储空间</p>
<h4 id="虚拟内存的技术需要"><a href="#虚拟内存的技术需要" class="headerlink" title="虚拟内存的技术需要"></a><strong>虚拟内存的技术需要</strong></h4><ul>
<li>必须有对所采用的分页或分段方案的硬件支持</li>
<li>操作系统必须有管理页或者段在主存和辅助存储器之间移动的软件。</li>
</ul>
<h3 id="补充2：伙伴系统"><a href="#补充2：伙伴系统" class="headerlink" title="补充2：伙伴系统"></a>补充2：伙伴系统</h3><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a><strong>伙伴系统</strong></h4><ul>
<li><p>伙伴系统(Knuth，1973)，又称buddy算法，是一种固定分区和可变分区折中的主存管理算法，基本原理是：任何尺寸为$2^{i}$的空闲块都可被分为两个尺寸为$2^{i-1}$的空闲块，这两个空闲块称作伙伴，它们可以被合并成尺寸为$2^{i}$的原先空闲块。</p>
</li>
<li><p>伙伴通过对大块的物理主存划分而获得</p>
<ul>
<li><p>假如从第0个页面开始到第3个页面结束的主存</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151309031.png" alt="image-20221107151309031"></p>
</li>
<li><p>每次都对半划分，那么第一次划分获得大小为2页的伙伴，如0、1和2、3</p>
</li>
<li><p>进一步划分，可以获得大小为1页的伙伴，例如0和1，2和3</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151347710.png" alt="image-20221107151347710" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151402680.png" alt="image-20221107151402680" style="zoom:80%;" /></p>
<h4 id="Linux伙伴系统"><a href="#Linux伙伴系统" class="headerlink" title="Linux伙伴系统"></a><strong>Linux伙伴系统</strong></h4><ol>
<li>以page结构为数组元素的mem_map[]数组</li>
<li>以free_area_struct结构为数组元素的free_area数组</li>
<li>位图数组(bitmap)</li>
</ol>
<h4 id="Linux基于伙伴的slab分配器"><a href="#Linux基于伙伴的slab分配器" class="headerlink" title="Linux基于伙伴的slab分配器"></a><strong>Linux基于伙伴的slab分配器</strong></h4><ul>
<li><p>为什么要使用slab分配器?</p>
<ul>
<li>伙伴系统以页框为基本分配单位，内核在很多情况下，<strong>需要的主存量远远小于页框大小</strong>，如inode、vma、task_struct等，为了更经济地使用内核主存资源，引入<strong>SunOS操作系统中首创的基于伙伴系统的slab分配器</strong>，其基本思想是：为经常使用的小对象建立缓存，小对象的申请与释放都通过slab分配器来管理，仅当缓存不够用时才向伙伴系统申请更多空间。//页内可以按2的幂次拆分。</li>
<li>优点：<strong>充分利用主存，减少内部碎片</strong>，对象管理局部化，尽可能少地与伙伴系统打交道，从而提高效率。</li>
</ul>
</li>
<li><p>slab的结构</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151727699.png" alt="image-20221107151727548" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151742038.png" alt="image-20221107151742038" style="zoom:80%;" /></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/">https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/</a></li>
<li>Linux还提供十三种通用缓存，其存储对象的大小分别为32B、64B、128B、256B、512B、1KB、2KB、4KB、8KB、16KB、32KB、64KB和128KB，这些缓存用来满足特定对象之外的普通主存需求，单位的大小呈2的幂数增长，保证内部碎片率不超过50％。</li>
</ul>
</li>
<li><p>slab举例</p>
<p>例子task_struct slab</p>
<ul>
<li>内核用全局变量存放指向task_struct slab的指针：kmem_struct_t *task_struct_cachep；初始化时，在fork_init()中调用kmem_cache_create()函数创建高速缓存，存放类型为task_struct的对象。</li>
<li>每当进程调用fork()时，调用内核函数do_fork()，它再使用kmem_cache_alloc()函数在对应slab中建立一个task_struct对象。</li>
<li>进程执行结束后，task_struct对象被释放，返还给task_struct_cachep slab</li>
</ul>
</li>
<li><p>slab分配器主要操作</p>
<ul>
<li>kmem_cache_create()函数：创建专用cache，规定对象的大小和slab的构成，并加入cache管理队列；</li>
<li>kmem_cache_alloc()与kmem_cache_free()函数：分别用于分配和释放一个拥有专用slab队列的对象；</li>
<li>kmem_cache_grow()与kmem_cache_reap()函数：kmem_cache_grow()它向伙伴系统申请向cache增加一个slab；kmem_cache_reap()用于定时回收空闲slab；</li>
<li>kmem_cache_destroy()与kmem_cache_shrink()：用于cache的销毁和收缩；</li>
<li>kmalloc()与kfree()函数：用来从通用的缓冲区队列中申请和释放空间；</li>
<li>kmem_getpages()与kmem_freepages()函数：slab与页框级分配器的接口，当slab分配器要创建新的slab或cache时，通过kmem_getpages()向内核提供的伙伴算法来获得一组连续页框。如果释放分配给slab分配器的页框，则调用kmem_freepages()函数。</li>
</ul>
</li>
</ul>
<h3 id="补充3：分段和分页的寻址计算"><a href="#补充3：分段和分页的寻址计算" class="headerlink" title="补充3：分段和分页的寻址计算"></a>补充3：分段和分页的寻址计算</h3><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a><strong>分段</strong></h4><ul>
<li>采用分段法</li>
<li>某个分段的逻辑地址的段号为2, 段内偏移量为100, 计算它的物理地址</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152412373.png" alt="image-20221107152412373" style="zoom:80%;" /></p>
<h4 id="分页和分段的比较"><a href="#分页和分段的比较" class="headerlink" title="分页和分段的比较"></a><strong>分页和分段的比较</strong></h4><ul>
<li>分段<ul>
<li>分段是信息的逻辑单位，由源程序的逻辑结构所决定，用户可见</li>
<li>长可根据用户需要来规定，段起始地址可从任何主存地址开始。</li>
<li>分段方式中，源程序(段号，段内位移)经连结装配后地址仍保持二维结构。</li>
</ul>
</li>
<li>分页<ul>
<li>分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见</li>
<li>页长由系统确定，页面只能以页大小的整倍数地址开始</li>
<li>分页方式中，源程序(页号，页内位移)经连结装配后地址变成了一维结构</li>
</ul>
</li>
</ul>
<h4 id="分页：逻辑地址-gt-物理地址"><a href="#分页：逻辑地址-gt-物理地址" class="headerlink" title="分页：逻辑地址-&gt;物理地址"></a><strong>分页：逻辑地址-&gt;物理地址</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152637357.png" alt="image-20221107152637357" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152213784.png" alt="image-20221107152213784"></p>
<p>分页：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152747958.png" alt="image-20221107152747958" style="zoom:80%;" /></p>
<p>分段：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152336480.png" alt="image-20221107152336480" style="zoom:80%;" /></p>
<h4 id="分页地址转换"><a href="#分页地址转换" class="headerlink" title="分页地址转换"></a><strong>分页地址转换</strong></h4><ul>
<li>页面与页框的大小为1024字节, 指令 MOV 2100, 3100</li>
<li>求MOV指令中两个操作数的物理地址</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152935682.png" alt="image-20221107152935682" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152945691.png" alt="image-20221107152945691" style="zoom:80%;" /></p>
<h3 id="补充4：多级页表与反置页表"><a href="#补充4：多级页表与反置页表" class="headerlink" title="补充4：多级页表与反置页表"></a>补充4：多级页表与反置页表</h3><h4 id="4-1-多级页表"><a href="#4-1-多级页表" class="headerlink" title="4.1 多级页表"></a>4.1 多级页表</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h5><p>现代计算机普遍支持$2^{32}～2^{64}$容量的逻辑地址空间，采用分页存储管理时，页表相当大，以Windows为例，其运行的Intel x86平台具有32位地址，规定页面4KB($2^{12}$)时，那么，4GB($2^{32}$)的逻辑地址空间由1兆($2^{20}$)个页组成，若每个页表项占用4个字节，则需要占用4MB($2^{22}$)连续主存空间存放页表。系统中有许多进程，因此页表存储开销很大。</p>
<h5 id="多级页表的概念"><a href="#多级页表的概念" class="headerlink" title="多级页表的概念"></a><strong>多级页表的概念</strong></h5><ul>
<li>系统为每个进程建一张页目录表,它的每个表项对应一个页表页,<strong>而页表页的每个表项给出了页面和页框的对应关系</strong>,页目录表是一级页表,页表页是二级页表。</li>
<li>逻辑地址结构有三部分组成：页目录、页表页和位移</li>
</ul>
<h5 id="两级页表-32位地址"><a href="#两级页表-32位地址" class="headerlink" title="两级页表(32位地址)"></a><strong>两级页表(32位地址)</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105149441.png" alt="image-20221107105149441" style="zoom:80%;" /></p>
<h5 id="多级页表的地址转换过程"><a href="#多级页表的地址转换过程" class="headerlink" title="多级页表的地址转换过程"></a><strong>多级页表的地址转换过程</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105221507.png" alt="image-20221107105221507" style="zoom:80%;" /></p>
<h5 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a><strong>二级页表</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105351296.png" alt="image-20221107105351296" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105402628.png" alt="image-20221107105402628" style="zoom:80%;" /></p>
<h5 id="SUN-SPARC计算机三级分页结构"><a href="#SUN-SPARC计算机三级分页结构" class="headerlink" title="SUN SPARC计算机三级分页结构"></a><strong>SUN SPARC计算机三级分页结构</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105453288.png" alt="image-20221107105453288" style="zoom:80%;" /></p>
<ul>
<li>问题：增加了寻址时间，在计算机系统中时间与空间总是存在一些矛盾，因此经常会采取折中的方案，以时间换空间，或者以空间换取时间。</li>
</ul>
<h5 id="多级页表的本质"><a href="#多级页表的本质" class="headerlink" title="多级页表的本质"></a><strong>多级页表的本质</strong></h5><ul>
<li>多级不连续导致多级索引。</li>
<li>以二级页表为例，用户程序的页面不连续存放，要有页面地址索引，该索引是进程页表；进程页表又是不连续存放的多个页表页，故页表页也要页表页地址索引，该索引就是页目录。</li>
<li>页目录项是页表页的索引，而页表页项是进程程序的页面索引。</li>
</ul>
<h4 id="4-2-反置页表-Inverted-Page-Table"><a href="#4-2-反置页表-Inverted-Page-Table" class="headerlink" title="4.2 反置页表(Inverted Page Table)"></a>4.2 反置页表(Inverted Page Table)</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h5><ul>
<li>页表设计的一个重要缺陷是页表的大小与虚拟地址空间的大小成正比</li>
<li>在反向页表方法中，虚拟地址的页号部分使用一个简单散列函数映射到哈希表中。哈希表包含一个指向反向表的指针，而反向表中含有页表项。</li>
<li>通过这个结构，哈希表和反向表中只有一项对应于一个<strong>实存页(面向实存)</strong>，而不是<strong>虚拟页(面向虚存)</strong>。</li>
<li>因此，不论有多少进程、支持多少虚拟页，页表都只需要实存中的一个固定部分。</li>
<li>用于PowerPC, UltraSPARC, IA-64架构</li>
</ul>
<h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a><strong>组成</strong></h5><ul>
<li><strong>页号</strong>：虚拟地址页号部分。</li>
<li><strong>进程标志符</strong>：使用该页的进程。页号和进程标志符结合起来标志一个特定的进程的虚拟地址空间的一页。</li>
<li><strong>控制位</strong>：该域包含一些标记，比如有效、访问和修改，以及保护和锁定的信息。</li>
<li><strong>链指针</strong>：如果某个项没有链项，则该域为空(允许用一个单独的位来表示)。</li>
</ul>
<h5 id="线性反置页表的结构"><a href="#线性反置页表的结构" class="headerlink" title="线性反置页表的结构"></a><strong>线性反置页表的结构</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107110729262.png" alt="image-20221107110729262" style="zoom:80%;" /></p>
<ul>
<li>问题：线性查找，效率低，有可能遍历完才发现缺页中断</li>
</ul>
<h5 id="改进-引入hash"><a href="#改进-引入hash" class="headerlink" title="改进(引入hash)"></a><strong>改进(引入hash)</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107110812406.png" alt="image-20221107110812406" style="zoom:80%;" /></p>
<h5 id="反置页表地址转换过程"><a href="#反置页表地址转换过程" class="headerlink" title="反置页表地址转换过程"></a><strong>反置页表地址转换过程</strong></h5><p>逻辑地址<strong>给出进程标识和页号,用它们去比较IPT</strong>,若整个反置页表中<strong>未能找到匹配的页表项,说明该页不在主存,产生缺页中断</strong>,请求操作系统调入;否则，该表项的序号便是页框号,块号加上位移,便形成物理地址。</p>
<h5 id="线性反置页表"><a href="#线性反置页表" class="headerlink" title="线性反置页表"></a><strong>线性反置页表</strong></h5><p>pid是隐含的</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107111844378.png" alt="image-20221107111844378" style="zoom:80%;" /></p>
<h5 id="哈希线性反置页表"><a href="#哈希线性反置页表" class="headerlink" title="哈希线性反置页表"></a><strong>哈希线性反置页表</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112035238.png" alt="image-20221107112035238" style="zoom:80%;" /></p>
<p><strong>页表的结构称为“反向”是因为它使用帧号而不是虚拟页号来索引页表项</strong></p>
<h5 id="主存分配的位示图和链表方法"><a href="#主存分配的位示图和链表方法" class="headerlink" title="主存分配的位示图和链表方法"></a><strong>主存分配的位示图和链表方法</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112234403.png" alt="image-20221107112234403" style="zoom:80%;" /></p>
<h5 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a><strong>段页式存储管理</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112533727.png" alt="image-20221107112533727" style="zoom:80%;" /></p>
<h3 id="补充5：页的大小设计"><a href="#补充5：页的大小设计" class="headerlink" title="补充5：页的大小设计"></a>补充5：页的大小设计</h3><ul>
<li>页越小, 内存碎片越少</li>
<li>页越小, 每个进程需要页数越多</li>
<li>每个进程的页越多就意味着页表更大，而页表大意味着在虚拟内存中占据更多的空间</li>
<li>辅存设计用于有效传输大数据块，因此页面大小越大越好</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112722467.png" alt="image-20221107112722467" style="zoom:80%;" /></p>
<ul>
<li>多种页面大小提供了有效使用TLB所需的灵活性</li>
<li>大多数操作系统只支持一种页面大小</li>
</ul>
<h3 id="补充6：页面替换算法"><a href="#补充6：页面替换算法" class="headerlink" title="补充6：页面替换算法"></a>补充6：页面替换算法</h3><p>OPT、FIFO、LRU、CLOCK算法见3.3.4</p>
<h4 id="CLOCK"><a href="#CLOCK" class="headerlink" title="CLOCK"></a><strong>CLOCK</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107154512018.png" alt="image-20221107154512018" style="zoom: 67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107154528175.png" alt="image-20221107154528175" style="zoom: 67%;" /></p>
<h4 id="Belady’s-Anomaly-Belady异常"><a href="#Belady’s-Anomaly-Belady异常" class="headerlink" title="Belady’s Anomaly(Belady异常)"></a><strong>Belady’s Anomaly(Belady异常)</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160528527.png" alt="image-20221107160528527" style="zoom:80%;" /></p>
<h4 id="FIFO算法的Belady异常"><a href="#FIFO算法的Belady异常" class="headerlink" title="FIFO算法的Belady异常"></a><strong>FIFO算法的Belady异常</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160611184.png" alt="image-20221107160611184" style="zoom:80%;" /></p>
<h4 id="Comparison-of-Placement-Algorithms"><a href="#Comparison-of-Placement-Algorithms" class="headerlink" title="Comparison of Placement Algorithms"></a><strong>Comparison of Placement Algorithms</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160636982.png" alt="image-20221107160636982" style="zoom:80%;" /></p>
<h4 id="Basic-Replacement-Algorithms"><a href="#Basic-Replacement-Algorithms" class="headerlink" title="Basic Replacement Algorithms"></a><strong>Basic Replacement Algorithms</strong></h4><ul>
<li>Page Buffering<ul>
<li>Replaced page is added to one of two lists<ul>
<li>free page list if page has not been modified</li>
<li>modified page list</li>
</ul>
</li>
<li>Replaced page remains in memory<ul>
<li>If referenced again, it is returned at little cost</li>
<li>Modified pages are written out in cluster</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Resident-Set-Size-驻留集规模"><a href="#Resident-Set-Size-驻留集规模" class="headerlink" title="Resident Set Size(驻留集规模)"></a><strong>Resident Set Size(驻留集规模)</strong></h4><ul>
<li>Fixed-allocation<ul>
<li>gives a process a fixed number of pages within which to execute</li>
<li>when a page fault occurs, one of the pages of that process must be replaced</li>
</ul>
</li>
<li>Variable-allocation<ul>
<li>number of pages allocated to a process varies over the lifetime of the process</li>
</ul>
</li>
</ul>
<p><strong>Fixed Allocation, Local Scope</strong></p>
<ul>
<li>Number of frames allocated to process is fixed</li>
<li>Page to be replaced is chosen from among the frames allocated to the process</li>
</ul>
<p><strong>Variable Allocation, Global Scope</strong></p>
<ul>
<li>Number of frames allocated to process is variable</li>
<li>Page to be replaced is chosen from all frames</li>
<li>Easiest to implement</li>
<li>Adopted by many operating systems</li>
<li>Operating system keeps list of free frames</li>
<li>Free frame is added to resident set of process when a page fault occurs</li>
</ul>
<p><strong>Variable Allocation, Local Scope</strong></p>
<ul>
<li>Number of frames allocated to process is variable</li>
<li>Page to be replaced is chosen from among the frames allocated to the process</li>
<li>When new process added, allocate number of page frames based on application type, program request, or other criteria</li>
<li>When page fault occurs, select page from among the resident set of the process that suffers the fault</li>
<li>Reevaluate allocation from time to time</li>
</ul>
<blockquote>
<p>根据页面置换算法可借用的外界条件，将页面置换算法分为:</p>
<p>局部页面置换算法：置换页面的选择范围仅限于当前进程占用的内存页面</p>
<p>全局页面置换算法：置换页面的选择范围是所有可换出的内存页面(并不是所有的内存页面都可以换出内存，比如内核关键代码所在内存页面；因此对这些页面，会将其页表项的锁定位置1，从而操作系统在换出内存页面时就不会考虑这些页面)。</p>
</blockquote>
<h4 id="局部页面替换算法"><a href="#局部页面替换算法" class="headerlink" title="局部页面替换算法"></a><strong>局部页面替换算法</strong></h4><ol>
<li>局部最佳页面替换算法</li>
<li>工作集模型和工作集置换算法</li>
</ol>
<h4 id="局部最佳页面替换算法"><a href="#局部最佳页面替换算法" class="headerlink" title="局部最佳页面替换算法"></a><strong>局部最佳页面替换算法</strong></h4><ul>
<li>1976年Prieve提出一种局部最佳页面替换算法MIN(Local Minimum)，它与全局最佳替换算法类似，需事先知道程序的页面引用串，再根据进程行为改变驻留页面数量</li>
<li>实现思想：进程在时刻 t 访问某页面，如果该页面不在主存中，导致一次缺页，把该页面装入一个空闲页框</li>
<li><p>不论发生缺页与否，算法在每一步要考虑引用串，<strong>如果该页面在时间间隔(t, t+τ)内未被再次引用，那么就移出；否则，该页被保留在进程驻留集中</strong> (<strong>看未来</strong>)</p>
</li>
<li><p>τ为一个系统常量，间隔(t, t+τ)称作滑动窗口。例子中τ=3</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108015614001.png" alt="image-20221108015614001" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108015707685.png" alt="image-20221108015707685" style="zoom:80%;" /></p>
<p>缺页总数为5次，驻留集大小在1-2之间变化，任何时刻至多两个页框被占用，通过增加τ值，缺页数目可减少，但代价是花费更多页框。 </p>
<h4 id="工作集模型和工作集置换算法"><a href="#工作集模型和工作集置换算法" class="headerlink" title="工作集模型和工作集置换算法"></a><strong>工作集模型和工作集置换算法</strong></h4><ul>
<li>进程工作集指“在某一段时间间隔内进程运行所需访问的页面集合”</li>
<li>实现思想：工作集模型用来对局部最佳页面替换算法进行模拟实现，<strong>不向前查看页面引用串，而是基于程序局部性原理向后看</strong></li>
<li>任何给定时刻，<strong>进程不久的将来所需主存页框数，可通过考查其过去最近的时间内的主存需求做出估计</strong></li>
</ul>
<h4 id="进程工作集"><a href="#进程工作集" class="headerlink" title="进程工作集"></a><strong>进程工作集</strong></h4><ul>
<li>指“在某一段时间间隔内进程运行所需访问的页面集合”，<strong>W(t，Δ)表示在时刻 t-Δ 到时刻 t 之间( (t-Δ，t))所访问的页面集合，进程在时刻 t 的工作集</strong></li>
<li><p>Δ 是系统定义的一个常量。变量 Δ 称为“工作集窗口尺寸”，可通过窗口来观察进程行为，还把工作集中所包含的页面数目称为“工作集尺寸”</p>
</li>
<li><p>Δ=3</p>
</li>
</ul>
<h4 id="Working-set-model"><a href="#Working-set-model" class="headerlink" title="Working-set model"></a><strong>Working-set model</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020047797.png" alt="image-20221108020047797" style="zoom:80%;" /></p>
<h4 id="工作集替换示例"><a href="#工作集替换示例" class="headerlink" title="工作集替换示例"></a><strong>工作集替换示例</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020225281.png" alt="image-20221108020225281" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020242078.png" alt="image-20221108020242078" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020302415.png" alt="image-20221108020302415" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020317071.png" alt="image-20221108020317071" style="zoom: 67%;" /></p>
<h4 id="The-Page-Fault-Frequency-Strategy"><a href="#The-Page-Fault-Frequency-Strategy" class="headerlink" title="The Page-Fault Frequency Strategy"></a><strong>The Page-Fault Frequency Strategy</strong></h4><ul>
<li>Define an upper bound U and lower bound L for page fault rates</li>
<li>Allocate more frames to a process if fault rate is higher than U</li>
<li>Allocate less frames if fault rate is &lt; L</li>
<li>The <strong>resident set size should be close to the working set size W</strong></li>
<li>We suspend the process if the PFF &gt; U and no more free frames are available</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020434064.png" alt="image-20221108020434064" style="zoom:67%;" /></p>
<h4 id="通过工作集确定驻留集大小"><a href="#通过工作集确定驻留集大小" class="headerlink" title="通过工作集确定驻留集大小"></a><strong>通过工作集确定驻留集大小</strong></h4><ol>
<li>监视每个进程的工作集，只有属于工作集的页面才能留在主存；</li>
<li>定期地从进程驻留集中删去那些不在工作集中的页面；</li>
<li>仅当一个进程的工作集在主存时，进程才能执行。</li>
</ol>
<h3 id="补充7：TLB快表，页表，缺页"><a href="#补充7：TLB快表，页表，缺页" class="headerlink" title="补充7：TLB快表，页表，缺页"></a>补充7：TLB快表，页表，缺页</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134658588.png" alt="image-20221114134658588"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134717530.png" alt="image-20221114134717530"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134738142.png" alt="image-20221114134738142"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134854425.png" alt="image-20221114134854425" style="zoom:80%;" /></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/计算机操作系统/">计算机操作系统</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/11/10/计算机操作系统-2-处理器管理/"><span>计算机操作系统(2) 处理器管理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/11/10/计算机操作系统-2-处理器管理/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-10T06:05:56.000Z">
          2022-11-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="第二章-处理器管理"><a href="#第二章-处理器管理" class="headerlink" title="第二章 处理器管理"></a>第二章 处理器管理</h1><h2 id="2-1-处理器"><a href="#2-1-处理器" class="headerlink" title="2.1 处理器"></a>2.1 处理器</h2><h3 id="2-1-1-处理器与寄存器"><a href="#2-1-1-处理器与寄存器" class="headerlink" title="2.1.1 处理器与寄存器"></a>2.1.1 处理器与寄存器</h3><h4 id="处理器部件"><a href="#处理器部件" class="headerlink" title="处理器部件"></a><strong>处理器部件</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220924225621225.png" alt="image-20220924225621225"></p>
<h4 id="用户程序可见寄存器"><a href="#用户程序可见寄存器" class="headerlink" title="用户程序可见寄存器"></a><strong>用户程序可见寄存器</strong></h4><ul>
<li>可以使程序员减少访问主存储器的次数，提高指令执行的效率</li>
<li>所有程序可使用，包括应用程序和系统程序<ul>
<li>数据寄存器：又称通用寄存器，用于存取数据</li>
<li>地址寄存器：索引、栈指针、段地址等寄存器</li>
</ul>
</li>
</ul>
<h4 id="控制与状态寄存器"><a href="#控制与状态寄存器" class="headerlink" title="控制与状态寄存器"></a><strong>控制与状态寄存器</strong></h4><ul>
<li>用于控制处理器的操作；主要被具有特权的操作系统程序使用，以控制程序的执行</li>
<li>程序计数器PC：存储将取指令的地址</li>
<li>指令寄存器IR：存储最近使用的指令</li>
<li>条件码CC：CPU为指令操作结果设置的位，标志正/负/零/溢出等结果</li>
<li>标志位：中断位、中断允许位、中断屏蔽位、处理器模式位、内存保护位等</li>
</ul>
<h4 id="程序状态字PSW"><a href="#程序状态字PSW" class="headerlink" title="程序状态字PSW"></a><strong>程序状态字PSW</strong></h4><ul>
<li>PSW既是操作系统的概念，指记录当前程序运行的动态信息，通常包含：<ul>
<li>程序计数器，指令寄存器，条件码</li>
<li>中断字，中断允许/禁止，中断屏蔽，处理器模式，内存保护，调试控制</li>
</ul>
</li>
<li>PSW也是计算机系统的寄存器<ul>
<li>通常设置一组控制与状态寄存器</li>
<li>也可以专设一个PSW寄存器</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-指令与处理器模式"><a href="#2-1-2-指令与处理器模式" class="headerlink" title="2.1.2 指令与处理器模式"></a>2.1.2 指令与处理器模式</h3><h4 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a><strong>机器指令</strong></h4><ul>
<li>机器指令是计算机系统执行的基本命令，是中央处理器执行的基本单位</li>
<li>指令由一个或多个字节组成，包括操作码字段、一个或多个操作数地址字段、以及一些表征机器状态的状态字以及特征码</li>
<li>指令完成各种算术逻辑运算、数据传输、控制流跳转</li>
</ul>
<h4 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a><strong>指令执行过程</strong></h4><ul>
<li>CPU根据PC取出指令，放入IR，并对指令译码，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行</li>
<li>一种指令执行步骤如下：<ul>
<li>取指：根据PC从存储器或高速缓冲存储器中取指令到IR</li>
<li>解码：解译IR中的指令来决定其执行行为</li>
<li>执行：连接到CPU部件，执行运算，产生结果并写回，同时在CC里设置运算结论标志；跳转指令操作PC，其他指令递增PC值</li>
</ul>
</li>
</ul>
<h4 id="指令执行周期与指令流水线"><a href="#指令执行周期与指令流水线" class="headerlink" title="指令执行周期与指令流水线"></a><strong>指令执行周期与指令流水线</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220925220906643.png" alt="image-20220925220906643"></p>
<h4 id="特权指令与非特权指令"><a href="#特权指令与非特权指令" class="headerlink" title="特权指令与非特权指令"></a><strong>特权指令与非特权指令</strong></h4><ul>
<li>用户程序并非能够使用全部机器指令，那些与计算机核心资源相关的特殊指令会被保护<ul>
<li>如：启动I/O指令、置PC指令、等等</li>
<li>核心资源相关的指令只能被操作系统程序使用</li>
</ul>
</li>
<li>特权指令：只能被操作系统内核使用的指令</li>
<li>非特权指令：能够被所有程序使用的指令</li>
</ul>
<h4 id="处理器模式"><a href="#处理器模式" class="headerlink" title="处理器模式"></a><strong>处理器模式</strong></h4><ul>
<li>计算机通过设置处理器模式实现特权指令管理</li>
<li>计算机一般设置0、1、2、3等四种运行模式，建议分别对应：0操作系统内核、1系统调用、2共享库程序、3用户程序等保护级别</li>
<li>0模式可以执行全部指令；3模式只能执行非特权指令；其他每种运行模式可以规定执行的指令子集</li>
<li>一般来说，现代操作系统只使用0和3两种模式，对应于内核模式和用户模式</li>
</ul>
<h4 id="处理器模式的切换"><a href="#处理器模式的切换" class="headerlink" title="处理器模式的切换"></a><strong>处理器模式的切换</strong></h4><ul>
<li>简称模式切换，包括”用户模式 -&gt; 内核模式”和”内核模式 -&gt; 用户模式”的转换</li>
<li>中断、异常或系统异常等事件导致用户程序向OS内核切换，触发：用户模式 -&gt; 内核模式<ul>
<li>程序请求操作系统服务</li>
<li>程序运行时发生异常</li>
<li>程序运行时发生并响应中断</li>
</ul>
</li>
<li>OS内核处理完成后，调用中断返回指令（如Intel的iret）触发：内核模式 -&gt; 用户模式</li>
</ul>
<h4 id="用户栈与核心栈"><a href="#用户栈与核心栈" class="headerlink" title="用户栈与核心栈"></a><strong>用户栈与核心栈</strong></h4><ul>
<li>用户栈是操作系统在用户进程空间开辟的一块区域，用于保存应用程序的子程序(函数)间相互调用的参数、返回值、返回点以及子程序的局部变量</li>
<li>核心栈也叫系统栈或内核栈，是主存中属于操作系统内核空间的一块区域，用途包括<ul>
<li>保存中断现场，对于嵌套中断，将被中断程序的现场信息依次压入核心栈，中断返回时逆序弹出</li>
<li>保存操作系统程序(函数)间相互调用的参数、返回值、返回点、以及程序局部变量</li>
</ul>
</li>
<li><p>每个进程被创建时捆绑一个核心栈，具有可读、可写、不可执行的属性，一般有大小限制</p>
</li>
<li><p>进程有用户栈和核心栈，但硬件栈指针只有一个</p>
</li>
</ul>
<h2 id="2-2-中断"><a href="#2-2-中断" class="headerlink" title="2.2 中断"></a>2.2 中断</h2><h3 id="2-2-1-中断的概念"><a href="#2-2-1-中断的概念" class="headerlink" title="2.2.1 中断的概念"></a>2.2.1 中断的概念</h3><h4 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a><strong>中断的概念</strong></h4><ul>
<li>中断是指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程</li>
<li>操作系统是“中断驱动”的；换言之，中断是激活操作系统的唯一方式</li>
<li>中断有广义和狭义之分，上述中断是指广义的中断</li>
</ul>
<h4 id="中断、异常与系统异常"><a href="#中断、异常与系统异常" class="headerlink" title="中断、异常与系统异常"></a><strong>中断、异常与系统异常</strong></h4><ul>
<li>广义中断可以划分为狭义中断、异常和系统异常</li>
<li>狭义的中断指来源于处理器之外的中断事件，即与当前运行指令无关的中断事件，如I/O中断、时钟中断、外部信号中断等</li>
<li>异常指当前运行指令引起的中断事件，如地址异常、算术异常、处理器硬件故障等</li>
<li>系统异常指执行陷入指令而触发系统调用引起的中断事件，如请求设备、请求I/O、创建进程等</li>
</ul>
<h4 id="Linux中断的分类"><a href="#Linux中断的分类" class="headerlink" title="Linux中断的分类"></a><strong>Linux中断的分类</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018134733871.png" alt="image-20221018134733871"></p>
<p>中断可分为同步(synchronous)中断和异步(asynchronous)中断</p>
<ul>
<li>同步中断是当指令执行时由 CPU 控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后 CPU 才会发出中断，而不是发生在代码指令执行期间，比如系统调用。</li>
<li><p>异步中断是指由其他硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生，例如键盘中断。</p>
</li>
<li><p>同步中断称为异常(exception),异常可分为故障(fault)、陷阱(trap)、终止(abort)三类。</p>
</li>
<li>异步中断被称为中断(interrupt)。中断可分为可屏蔽中断(Maskable interrupt)和非屏蔽中断(Nomaskable interrupt)。</li>
</ul>
<h3 id="2-2-2-中断源"><a href="#2-2-2-中断源" class="headerlink" title="2.2.2 中断源"></a>2.2.2 中断源</h3><h4 id="中断源的概念"><a href="#中断源的概念" class="headerlink" title="中断源的概念"></a><strong>中断源的概念</strong></h4><p>通常把引起中断的事件，即中断请求信号的来源，统称为中断源</p>
<h4 id="硬件故障中断事件"><a href="#硬件故障中断事件" class="headerlink" title="硬件故障中断事件"></a><strong>硬件故障中断事件</strong></h4><ul>
<li>由处理器、内存储器、总线等硬件故障引起</li>
<li>处理原则为：保护现场，停止设备，停止CPU，向操作员报告，等待人工干预</li>
</ul>
<h4 id="程序性中断事件"><a href="#程序性中断事件" class="headerlink" title="程序性中断事件"></a><strong>程序性中断事件</strong></h4><ul>
<li>处理器执行机器指令引起<ul>
<li>除数为零、操作数溢出等算术异常：简单处理，报告用户；也可以由用户编写中断续元程序处理</li>
<li>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程</li>
<li>终止进程指令：终止进程</li>
<li>虚拟地址异常：调整内存后重新执行指令</li>
</ul>
</li>
</ul>
<h4 id="自愿性中断事件"><a href="#自愿性中断事件" class="headerlink" title="自愿性中断事件"></a><strong>自愿性中断事件</strong></h4><ul>
<li>处理器执行陷入指令请求OS服务引起；在操作系统中，它一般又被称作系统调用<ul>
<li>请求分配外设、请求I/O、等等</li>
<li>处理流程是：陷入OS，保护现场，根据功能号查入口地址，跳转具体处理程序</li>
</ul>
</li>
<li>陷入指令包括操作码和功能号两部分，前者表示是陷入指令，后者指示系统调用</li>
</ul>
<h4 id="I-O中断事件"><a href="#I-O中断事件" class="headerlink" title="I/O中断事件"></a><strong>I/O中断事件</strong></h4><ul>
<li>来源于外围设备报告I/O状态的中断事件<ul>
<li>I/O完成：调整进程状态，释放等待进程</li>
<li>I/O出错：等待人工干预</li>
<li>I/O异常：等待人工干预</li>
</ul>
</li>
</ul>
<h4 id="外部中断事件"><a href="#外部中断事件" class="headerlink" title="外部中断事件"></a><strong>外部中断事件</strong></h4><ul>
<li>由外围设备发出的信号引起的中断事件<ul>
<li>时钟中断、间隔时钟中断：记时与时间片处理</li>
<li>设备报告与结束中断：调整设备表</li>
<li>键盘/鼠标信号中断：根据信号作出相应反应</li>
<li>关机/重启动中断：写回文件，停止设备与CPU</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-中断系统"><a href="#2-2-3-中断系统" class="headerlink" title="2.2.3 中断系统"></a>2.2.3 中断系统</h3><h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a><strong>中断系统</strong></h4><ul>
<li>中断系统是计算机系统中响应和处理中断的系统，包括硬件子系统和软件子系统两部分</li>
<li>中断响应由硬件子系统完成</li>
<li>中断处理由软件子系统完成</li>
</ul>
<h4 id="中断响应处理与指令执行周期"><a href="#中断响应处理与指令执行周期" class="headerlink" title="中断响应处理与指令执行周期"></a><strong>中断响应处理与指令执行周期</strong></h4><ul>
<li>在指令执行周期最后增加一个微操作，以响应中断</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928231054181.png" alt="image-20220928231054181"></p>
<h4 id="中断装置"><a href="#中断装置" class="headerlink" title="中断装置"></a><strong>中断装置</strong></h4><ul>
<li>计算机系统中发现并响应中断/异常的硬件装置称为中断装置</li>
<li>由于中断源的多样性，硬件实现的中断装置有多种，分别处理不同类型的中断</li>
<li>这些中断装置因计算机而异，通常有：<ul>
<li>处理器外的异步中断：由中断控制器发现和响应</li>
<li>处理器内的异常：由指令的控制逻辑和实现线路发现和响应，相应机制称为陷阱</li>
<li>请求OS服务的系统异常：处理器执行陷入指令时直接触发，相应机制称为系统陷阱</li>
</ul>
</li>
</ul>
<h4 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a><strong>中断控制器</strong></h4><ul>
<li>中断控制器：CPU中的一个控制部件，包括中断控制逻辑线路和中断寄存器<ul>
<li>外部设备向其发出中断请求IRQ，在中断寄存器中设置已发生的中断，记录了中断的来源</li>
<li>中断逻辑电路则是形成中断的一个通路</li>
<li>指令处理结束前，会检查中断寄存器，若有不被屏蔽的中断产生，则改变处理器内操作的顺序，引出操作系统中的中断处理程序</li>
</ul>
</li>
</ul>
<h4 id="陷阱与系统陷阱"><a href="#陷阱与系统陷阱" class="headerlink" title="陷阱与系统陷阱"></a><strong>陷阱与系统陷阱</strong></h4><ul>
<li>陷阱与系统陷阱：指令的逻辑和实现线路的一部分<ul>
<li>执行指令出现异常后，会根据异常情况转向操作系统的异常处理程序</li>
<li>出现虚拟地址异常后，需要重新执行指令，往往越过陷阱独立设置页面异常处理程序</li>
<li>执行陷入指令后，越过陷阱处理，触发系统陷阱，激活系统调用处理程序</li>
</ul>
</li>
</ul>
<h4 id="中断响应过程"><a href="#中断响应过程" class="headerlink" title="中断响应过程"></a><strong>中断响应过程</strong></h4><ul>
<li>发现中断源，提出中断请求<ul>
<li>发现中断寄存器中记录的中断</li>
<li>决定这些中断是否应该屏蔽</li>
<li>当有多个要响应的中断源时，根据规定的优先级选择一个</li>
</ul>
</li>
<li>中断当前程序的执行<ul>
<li>保存当前程序的PSW/PC到核心栈</li>
</ul>
</li>
<li>从用户态切换至内核态，调出响应中断处理程序的PSW和PC，转向操作系统的中断处理程序</li>
</ul>
<h4 id="中断的处理"><a href="#中断的处理" class="headerlink" title="中断的处理"></a><strong>中断的处理</strong></h4><ul>
<li>中断处理程序<ul>
<li>操作系统处理中断事件的控制程序, 主要任务是处理中断和恢复正常工作</li>
</ul>
</li>
<li>中断处理过程<ul>
<li>保护未被硬件保护的处理器状态(保护处理器现场)<ul>
<li>核心栈只保存了PSW、PC，其他现场信息(CPU中所有寄存器和高级别Cache的内容)应由中断处理程序来完成保存</li>
</ul>
</li>
<li>分析被中断进程的PSW中断码字段，识别中断源</li>
<li>分别处理发生的中断事件</li>
<li>恢复正常操作</li>
</ul>
</li>
</ul>
<h4 id="恢复正常操作"><a href="#恢复正常操作" class="headerlink" title="恢复正常操作"></a><strong>恢复正常操作</strong></h4><ul>
<li>情况一：对于某些能被快速处理的中断，在处理完毕后，直接返回刚刚被中断的进程</li>
<li>情况二：对于其他一些中断，需要中断当前进程的运行，调整进程队列，启动进程调度，选择下一个执行的进程并恢复其执行<ul>
<li>例如自愿性中断、虚拟地址中断等，相关进程不具备立即恢复执行的条件</li>
<li>时间片中断、高优先级抢占进程出现等，正在运行的进程需要让出CPU</li>
</ul>
</li>
</ul>
<h4 id="中断系统处理流程"><a href="#中断系统处理流程" class="headerlink" title="中断系统处理流程"></a><strong>中断系统处理流程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928232637028.png" alt="image-20220928232637028"></p>
<h3 id="2-2-4-多中断的响应与处理"><a href="#2-2-4-多中断的响应与处理" class="headerlink" title="2.2.4 多中断的响应与处理"></a>2.2.4 多中断的响应与处理</h3><h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a><strong>中断屏蔽</strong></h4><ul>
<li>当计算机检测到中断时, 中断装置通过中断屏蔽位决定是否响应已发生的中断</li>
<li>中断屏蔽指禁止CPU响应中断或者禁止产生中断<ul>
<li>前者指硬件产生中断请求后，CPU暂时不予处理</li>
<li>后者指当引起中断的事件发生后，硬件不允许提出中断请求</li>
</ul>
</li>
<li>有选择的响应中断</li>
</ul>
<h4 id="中断屏蔽的作用"><a href="#中断屏蔽的作用" class="headerlink" title="中断屏蔽的作用"></a><strong>中断屏蔽的作用</strong></h4><ul>
<li>延迟或禁止某些中断的响应，系统程序执行过程中不希望产生干扰事件，以免共享数据结构受到破坏</li>
<li>协调中断响应与中断处理的关系，确保高优先级中断可以打断低优先级中断</li>
<li>防止同级中断相互干扰</li>
</ul>
<h4 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a><strong>中断优先级</strong></h4><ul>
<li>当计算机同时检测到多个中断时, 中断装置响应中断的顺序</li>
<li>有优先度的响应中断</li>
<li>一种可能的处理次序：<br>处理机硬件故障中断事件、自愿性中断事件、程序性中断事件、时钟中断等外部中断事件、I/O中断事件、重启动和关机中断事件</li>
<li>不同类型的操作系统有不同的中断优先级</li>
<li>可以使用硬件或者软件方法按照顺序予以响应<ul>
<li>硬件：根据排定的优先级顺序形成一个硬件链式排队器，当产生中断事件时，首先响应排在队列最前面的中断事件</li>
<li>软件：编写一个查询程序，依据优先级顺序从高到低进行查询，一旦发现有中断请求便转入相应的中断事件处理程序入口</li>
</ul>
</li>
</ul>
<h4 id="中断的嵌套处理"><a href="#中断的嵌套处理" class="headerlink" title="中断的嵌套处理"></a><strong>中断的嵌套处理</strong></h4><ul>
<li>当计算机响应中断后，在中断处理过程中，可以再响应其他中断</li>
<li>操作系统是性能攸关程序系统，且中断响应处理有硬件要求，考虑系统效率和实现代价问题，中断的嵌套处理应限制在一定层数内，如3层</li>
<li>中断的嵌套处理改变中断处理次序，先响应的有可能后处理</li>
</ul>
<h4 id="多中断的响应与处理"><a href="#多中断的响应与处理" class="headerlink" title="多中断的响应与处理"></a><strong>多中断的响应与处理</strong></h4><ul>
<li>决定中断处理次序的因素<ul>
<li>中断屏蔽可以使中断装置不响应某些中断</li>
<li>中断优先级决定了中断装置响应中断的次序</li>
<li>中断可以嵌套处理, 但嵌套的层数应有限制</li>
<li>中断的嵌套处理改变了中断处理的次序</li>
</ul>
</li>
</ul>
<h4 id="多重中断处理"><a href="#多重中断处理" class="headerlink" title="多重中断处理"></a><strong>多重中断处理</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220929151402615.png" alt="image-20220929151402615"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220929151411941.png" alt="image-20220929151411941"></p>
<h2 id="2-3-进程管理"><a href="#2-3-进程管理" class="headerlink" title="2.3 进程管理"></a>2.3 进程管理</h2><h3 id="2-3-1-进程及其状态"><a href="#2-3-1-进程及其状态" class="headerlink" title="2.3.1 进程及其状态"></a>2.3.1 进程及其状态</h3><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a><strong>进程的概念</strong></h4><ul>
<li>进程是具有独立功能的程序在某个数据集合上的一次运行活动</li>
<li><p>进程是操作系统进行资源分配和调度的一个独立单位</p>
</li>
<li><p>一个进程包括 5 个实体部分</p>
<ul>
<li>(OS管理运行程序的)数据结构 P</li>
<li>(运行程序的)主存或虚拟主存代码 C</li>
<li>(运行程序的)主存或虚拟主存数据 D</li>
<li>(运行程序的)通用寄存器信息 R</li>
<li>(OS控制程序执行的)程序状态字信息 PSW</li>
</ul>
</li>
</ul>
<h4 id="进程举例"><a href="#进程举例" class="headerlink" title="进程举例"></a><strong>进程举例</strong></h4><ul>
<li>不同程序在不同数据集上运行：构成两个无关进程</li>
<li>不同程序在相同数据集上运行：构成两个共享数据的交往进程</li>
<li>相同代码在不同数据集上运行：构成两个共享代码的无关进程</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220929153007206.png" alt="image-20220929153007206" style="zoom:50%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220929153101799.png" alt="image-20220929153101799" style="zoom:50%;" /></p>
<ul>
<li>共享的代码称为<strong>可再入程序</strong>，如编辑器、编译器</li>
<li>可再入程序是<strong>纯代码</strong>的</li>
<li>前述的程序与数据集均是内存级的</li>
<li>那么，在不同时段中针对(同一个外存数据文件)运行(同一个外存程序文件)，意味着完全不同的(P, C, D, R, PSW)</li>
<li>所以两次运行构成两个不同的进程</li>
</ul>
<h4 id="概念级的进程状态"><a href="#概念级的进程状态" class="headerlink" title="概念级的进程状态"></a><strong>概念级的进程状态</strong></h4><ul>
<li><strong>运行态</strong>(running)：进程占有处理器运行</li>
<li><strong>就绪态</strong>(ready)：进程具备运行条件，等待系统分配处理器以便运行</li>
<li><strong>等待态</strong>(waiting)/<strong>阻塞态</strong>(blocked)/睡眠态(sleep)：进程由于等待资源、输入输出、信号等而不具备运行条件</li>
</ul>
<h4 id="进程三态模型"><a href="#进程三态模型" class="headerlink" title="进程三态模型"></a><strong>进程三态模型</strong></h4><ol>
<li><p>运行态 -&gt; 等待态</p>
<p>等待资源、I/O、信号</p>
</li>
<li><p>等待态 -&gt; 就绪态</p>
<p>资源满足、I/O结束、信号完成</p>
</li>
<li><p>就绪态 -&gt; 运行态</p>
<p>处理器空闲时选择、更高优先权进程抢占</p>
</li>
<li><p>运行态 -&gt; 就绪态</p>
<p>运行时间片到、有更高优先权进程导致被抢占</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220929153710285.png" alt="image-20220929153710285"></p>
<ul>
<li>时间片用完，时间间隔中断激活OS内核，运行 -&gt; 就绪</li>
<li>时间片周期内发生中断或者系统调用，激活OS内核，运行 -&gt; 等待</li>
<li>时间片周期内进程完整地执行完，return，激活OS内核，运行 -&gt; 终止</li>
</ul>
<h4 id="新建态和终止态"><a href="#新建态和终止态" class="headerlink" title="新建态和终止态"></a><strong>新建态和终止态</strong></h4><ul>
<li>新建态(new)对应于进程被创建时所处的状态，尚未进入就绪队列</li>
<li>创建进程包括两个步骤：<ul>
<li>为新进程分配所需资源</li>
<li>建立必要的管理信息，设置该进程为就绪态并等待被调度执行</li>
</ul>
</li>
<li>终止态(exit)是指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。<ul>
<li>处于终止态的进程不再被调度，下一步将被系统撤销，最终从系统中消失</li>
</ul>
</li>
<li>终止进程也包括两个步骤：<ul>
<li>等待操作系统或相关进程进行后续处理</li>
<li>回收占用的资源并被系统删除</li>
</ul>
</li>
</ul>
<h4 id="进程挂起的概念"><a href="#进程挂起的概念" class="headerlink" title="进程挂起的概念"></a><strong>进程挂起的概念</strong></h4><ul>
<li>OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况</li>
<li>运行资源不足表现为<strong>性能低</strong>和<strong>死锁</strong>两种情况</li>
<li>解决办法：剥夺某些进程的内存及其他资源，调入OS管理的磁盘对换区，不参加进程调度，待<br>适当时候再调入内存、恢复资源、参与运行</li>
<li>这就是<strong>进程挂起</strong>(suspend)</li>
<li>挂起态与等待态有着本质区别，后者占有已申请到的资源处于等待，前者没有任何资源</li>
</ul>
<h4 id="进程挂起的选择与恢复"><a href="#进程挂起的选择与恢复" class="headerlink" title="进程挂起的选择与恢复"></a><strong>进程挂起的选择与恢复</strong></h4><ul>
<li>一般选择<strong>等待态</strong>进程进入<strong>挂起等待态</strong>(blocked suspend)</li>
<li>也可选择<strong>就绪态</strong>进程进入<strong>挂起就绪态</strong>(ready suspend)</li>
<li><strong>运行态</strong>进程还可以挂起自己</li>
<li>等待事件结束后，<strong>挂起等待态</strong>进入<strong>挂起就绪态</strong></li>
<li>一般选择<strong>挂起就绪态</strong>进程予以恢复</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221016164253509.png" alt="image-20221016164253509"></p>
<h3 id="2-3-2-进程的数据描述"><a href="#2-3-2-进程的数据描述" class="headerlink" title="2.3.2 进程的数据描述"></a>2.3.2 进程的数据描述</h3><h4 id="进程控制块-Process-Control-Block-PCB"><a href="#进程控制块-Process-Control-Block-PCB" class="headerlink" title="进程控制块(Process Control Block,PCB)"></a><strong>进程控制块(Process Control Block,PCB)</strong></h4><ul>
<li>进程控制块PCB是OS用于记录和刻画进程状态及环境信息的数据结构</li>
<li>借助PCB，OS可以全面管理进程的物理实体，刻画进程的执行现状，控制进程的执行</li>
<li>系统在创建进程时就为它建立了进程控制块，进程结束时回收PCB空间</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221016223541187.png" alt="image-20221016223541187" style="zoom: 67%;" /></p>
<h4 id="进程控制块-标识信息"><a href="#进程控制块-标识信息" class="headerlink" title="进程控制块-标识信息"></a><strong>进程控制块-标识信息</strong></h4><ul>
<li><p>分为用户使用的外部标识符和系统使用的内部标识号</p>
</li>
<li><p>用于存放唯一标识该进程的信息</p>
<ul>
<li>系统分配的标识号</li>
<li>系统分配的进程组标识号</li>
<li>用户定义的进程名</li>
<li>用户定义的进程组名</li>
</ul>
</li>
</ul>
<h4 id="进程控制块-现场信息"><a href="#进程控制块-现场信息" class="headerlink" title="进程控制块-现场信息"></a><strong>进程控制块-现场信息</strong></h4><ul>
<li>用于存放该进程运行时的处理器现场信息<ul>
<li>用户可见寄存器内容：数据寄存器、地址寄存器</li>
<li>控制与状态寄存器内容：PC、IR、PSW</li>
<li>栈指针内容：核心栈与用户栈指针</li>
<li>程序状态字：PSW</li>
</ul>
</li>
</ul>
<h4 id="进程控制块-控制信息"><a href="#进程控制块-控制信息" class="headerlink" title="进程控制块-控制信息"></a><strong>进程控制块-控制信息</strong></h4><ul>
<li>用于存放与管理、调度进程相关的信息<ul>
<li>调度相关信息：状态、等待事件/原因、进程优先级、队列指针</li>
<li>进程组成信息：代码/数据地址、外存映像地址</li>
<li>队列指引元：进程队列指针、父子兄弟进程指针</li>
<li>通信相关信息：消息队列、信号量、锁</li>
<li>进程段/页表、进程映像在外存中的地址</li>
<li>进程特权信息：如内存访问权限、处理器特权</li>
<li>处理器使用信息：占用的处理器、时间片、处理器使用时间/已执行总时间、记账信息</li>
<li>资源清单信息：如正占有的资源、已使用的资源</li>
<li>文件传输和I/O信息</li>
</ul>
</li>
</ul>
<h4 id="进程映像-Process-Image"><a href="#进程映像-Process-Image" class="headerlink" title="进程映像(Process Image)"></a><strong>进程映像(Process Image)</strong></h4><ul>
<li>某一时刻进程的内容及其执行状态集合：<ul>
<li>进程控制块: 保存进程的标识信息、处理器状态信息和进程控制信息</li>
<li>进程程序块: 进程执行的程序空间</li>
<li>进程数据块: 进程处理的数据空间，包括数据、处理函数的<strong>用户栈</strong>和可修改的程序</li>
<li>进程核心栈: 每个进程捆绑一个，进程在内核模式下运行时使用的堆栈，中断或系统过程使用。保存内核函数调用的参数、局部变量和返回地址</li>
</ul>
</li>
<li>进程映像是内存级的物理实体，又称为进程的内存映像</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221016224824079.png" alt="image-20221016224824079"></p>
<h4 id="进程上下文-Process-Context"><a href="#进程上下文-Process-Context" class="headerlink" title="进程上下文(Process Context)"></a><strong>进程上下文(Process Context)</strong></h4><ul>
<li>进程的执行需要环境支持，包括CPU现场和Cache中的执行信息</li>
<li>OS中的进程物理实体和支持进程运行的环境合成进程上下文，包括以下：<ul>
<li>用户级上下文(user level context)：<ul>
<li>用户程序块(可执行的机器指令序列)</li>
<li>用户数据区(进程可访问的信息)</li>
<li>用户栈(存放函数调用过程中的信息)</li>
<li>用户共享内存(进程通信所使用的主存区)</li>
</ul>
</li>
<li>寄存器上下文(register context)：<ul>
<li>处理器状态寄存器(进程当前状态)，PSW</li>
<li>指令计数器(下一条执行的指令地址)</li>
<li>栈指针(指向用户栈或核心栈当前地址)</li>
<li>通用寄存器</li>
</ul>
</li>
<li>系统级上下文(system level context)：<ul>
<li>PCB(进程的状态)</li>
<li>主存管理信息(进程页表或段表)</li>
<li>核心栈(进程内核态运行时的工作区)</li>
</ul>
</li>
</ul>
</li>
<li>进程上下文刻画了进程的执行情况</li>
</ul>
<h3 id="2-3-3-进程管理的实现"><a href="#2-3-3-进程管理的实现" class="headerlink" title="2.3.3 进程管理的实现"></a>2.3.3 进程管理的实现</h3><h4 id="概念级的OS进程管理软件"><a href="#概念级的OS进程管理软件" class="headerlink" title="概念级的OS进程管理软件"></a><strong>概念级的OS进程管理软件</strong></h4><ul>
<li>关键的进程管理软件包括：<ul>
<li>系统调用/中断/异常处理程序</li>
<li>队列管理模块</li>
<li>进程控制程序</li>
<li>进程调度程序（独立进程居多）</li>
<li>进程通信程序（多个程序包）</li>
<li>终端登录与作业控制程序、性能监控程序、审计程序等外围程序</li>
</ul>
</li>
</ul>
<h4 id="进程实现的队列模型"><a href="#进程实现的队列模型" class="headerlink" title="进程实现的队列模型"></a><strong>进程实现的队列模型</strong></h4><ul>
<li>运行态的进程最终会在处理器上通过执行一条系统调用进入结束终止的完成状态</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221016230527018.png" alt="image-20221016230527018"></p>
<h4 id="队列管理模块"><a href="#队列管理模块" class="headerlink" title="队列管理模块"></a><strong>队列管理模块</strong></h4><ul>
<li>队列管理模块是操作系统实现进程管理的核心模块</li>
<li>操作系统建立多个进程队列，包括就绪队列和等待队列</li>
<li>按需组织为先进先出队列与优先队列</li>
<li>队列中的进程可以通过PCB中的队列指引元采用单/双指引元或索引连接</li>
<li>出队和入队操作</li>
<li>进程与资源调度围绕进程队列展开</li>
</ul>
<h4 id="进程的控制与管理"><a href="#进程的控制与管理" class="headerlink" title="进程的控制与管理"></a><strong>进程的控制与管理</strong></h4><p>往往被抽象成一组系统调用</p>
<ul>
<li>进程创建：进程表加一项，从PCB池申请空白PCB并初始化，生成标识，建立映像，分配资源，移入就绪队列</li>
<li>进程撤销：从队列中移除，归还资源，撤销子进程，撤销标识，回收PCB，移除进程表项</li>
<li>进程阻塞：保存现场信息，修改PCB，移入等待队列，调度其他进程执行</li>
<li>进程唤醒：等待队列中移出，修改PCB，移入就绪队列（该进程优先级高于运行进程触发抢占）</li>
<li>进程挂起：修改状态并出入相关队列，收回内存等资源送至对换区</li>
<li>进程激活：分配内存，修改状态并出入相关队列<ul>
<li>挂起操作可由进程自己或其他进程调用，激活操作只能由其他进程调用</li>
</ul>
</li>
<li>其他：如修改进程特权</li>
</ul>
<h4 id="原语与进程控制原语"><a href="#原语与进程控制原语" class="headerlink" title="原语与进程控制原语"></a><strong>原语与进程控制原语</strong></h4><ul>
<li>进程控制过程中涉及对OS核心数据结构(进程表/PCB池/队列/资源表)的修改</li>
<li>为防止与时间有关的错误，应使用<strong>原语</strong></li>
<li>原语是<strong>由若干条指令构成</strong>的完成某种特定功能的程序，执行上具有<strong>不可分割性</strong></li>
<li>原语的执行可以通过关闭中断实现(进入原语前关闭,退出原语前打开)</li>
<li>不是进程控制的整个流程都用原语实现，而是在进程控制当中对核心数据结构进行操作的关键代码段用原语来实现</li>
<li>进程控制使用的原语称为进程控制原语</li>
<li>另一类常用原语是进程通信原语</li>
</ul>
<h3 id="2-3-4-进程切换与模式切换"><a href="#2-3-4-进程切换与模式切换" class="headerlink" title="2.3.4 进程切换与模式切换"></a>2.3.4 进程切换与模式切换</h3><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a><strong>进程切换</strong></h4><ul>
<li>进程切换指从正在运行的进程中收回处理器，让待运行进程来占有处理器运行</li>
<li>内核获得处理器控制权之后，如果需要就可以实现进程切换，因此进程切换必定在内核态</li>
<li>进程切换实质上就是被中断运行进程与待运行进程的<strong>上下文切换</strong>，处理过程是：<ul>
<li>保存被中断进程的上下文</li>
<li>转向进程调度</li>
<li>恢复待运行进程的上下文</li>
</ul>
</li>
<li>工作过程：<ol>
<li>(中断/异常等触发)<strong>正向模式切换</strong>并<strong>压入 PSW/PC</strong></li>
<li><strong>保存</strong>被中断进程的<strong>现场信息</strong></li>
<li>处理具体中断/异常</li>
<li>把被中断进程的系统堆栈指针<strong>SP值保存到PCB</strong></li>
<li><strong>调整</strong>被中断进程的<strong>PCB</strong>信息，如进程状态</li>
<li>把被中断进程的PCB<strong>加入相关队列</strong></li>
<li>选择下一个占用CPU运行的进程</li>
<li><strong>修改</strong>被选中进程的<strong>PCB</strong>信息，如进程状态</li>
<li><strong>设置</strong>被选中进程的<strong>地址空间</strong>，<strong>恢复存储管理信息</strong></li>
<li><strong>恢复</strong>被选中进程的<strong>SP</strong>值到处理器寄存器SP</li>
<li><strong>恢复</strong>被选中进程的<strong>现场信息</strong>进入处理器</li>
<li>(中断返回指令触发)<strong>逆向模式转换</strong>并<strong>弹出 PSW/PC</strong></li>
</ol>
</li>
</ul>
<h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a><strong>模式切换</strong></h4><ul>
<li>进程切换必须在操作系统内核模式下完成，这就需要模式切换</li>
<li>模式切换又称处理器状态切换，包括：<ul>
<li>用户模式到内核模式由中断/异常/系统调用中断用户进程执行而触发</li>
<li>内核模式到用户模式OS执行中断返回指令将控制权交还用户进程而触发</li>
</ul>
</li>
</ul>
<h4 id="模式切换的基本工作任务"><a href="#模式切换的基本工作任务" class="headerlink" title="模式切换的基本工作任务"></a><strong>模式切换的基本工作任务</strong></h4><ul>
<li>中断装置完成正向模式切换，包括：<ul>
<li>处理器模式转为内核模式</li>
<li>保存当前进程的PC/PSW值到核心栈</li>
<li>转向中断/异常/系统调用处理程序</li>
</ul>
</li>
<li>中断返回指令完成逆向模式转换，包括：<ul>
<li>从待运行进程核心栈中弹出PSW/PC值</li>
<li>处理器模式转为用户模式</li>
</ul>
</li>
</ul>
<h4 id="进程切换的发生时机"><a href="#进程切换的发生时机" class="headerlink" title="进程切换的发生时机"></a><strong>进程切换的发生时机</strong></h4><ul>
<li>进程切换一定发生在<strong>中断/异常/系统调用</strong>处理过程中，常见的情况是：<ul>
<li>阻塞式系统调用、虚拟地址异常导致被中断进程进入等待态</li>
<li>时间片中断、I/O中断后发现更高优先级进程，导致被中断进程转入就绪态</li>
<li>终止用系统调用、不能继续执行的异常，导致被中断进程进入终止态</li>
</ul>
</li>
</ul>
<h4 id="进程切换与模式切换"><a href="#进程切换与模式切换" class="headerlink" title="进程切换与模式切换"></a><strong>进程切换与模式切换</strong></h4><ul>
<li>一些中断/异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程，处理流程是：<ul>
<li>(中断/异常触发)正向模式切换压入PSW/PC</li>
<li>保存被中断进程的现场信息</li>
<li>处理中断/异常</li>
<li>恢复被中断进程的现场信息</li>
<li>(中断返回指令触发)逆向模式转换弹出PSW/PC</li>
</ul>
</li>
</ul>
<h3 id="2-3-5-操作系统的执行模式"><a href="#2-3-5-操作系统的执行模式" class="headerlink" title="2.3.5 操作系统的执行模式"></a>2.3.5 操作系统的执行模式</h3><ul>
<li>在操作系统支持下，大多数运行程序可以作为进程进行管理。但是一部分操作系统的核心功能却不可能用进程实现，这组体现核心功能的基本程序就构成了内核最小集。</li>
<li>内核是一个由中断驱动的程序，至少应包含中断管理、时钟管理、原语管理、进程切换、消息传递等功能，而大多数操作系统服务例程可以在内核外执行</li>
</ul>
<h4 id="操作系统服务例程嵌入应用进程中运行"><a href="#操作系统服务例程嵌入应用进程中运行" class="headerlink" title="操作系统服务例程嵌入应用进程中运行"></a><strong>操作系统服务例程嵌入应用进程中运行</strong></h4><ul>
<li><p><strong>概念介绍</strong></p>
<ul>
<li><p>把操作系统服务例程放在内核中实现</p>
</li>
<li><p>发生中断、异常或系统调用时，处理器转为内核态，保存模式上下文并进行模式切换，转向提供服务的服务例程工作</p>
</li>
<li><p>它利用应用进程的核心栈，作为系统调用的工作栈</p>
</li>
<li><p>此时，仅仅是处理器转为内核态，服务例程仍然运行于当前应用进程，作为扩展的应用进程的一部分，但在内核执行，形成服务例程嵌入应用进程中执行的模式</p>
</li>
</ul>
</li>
<li><p><strong>特点</strong></p>
<ul>
<li>在这种运行方式下，操作系统服务例程只是使用了应用进程的核心栈</li>
<li>操作系统的地址空间独立于应用进程的地址空间，并不重叠</li>
<li>服务例程完成任务后，只需进行逆向模式切换并恢复应用程序现场，就可以返回被打断的应用进程继续执行</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>一个应用程序被中断以执行某些操作系统例程时不需要执行两次进程切换</li>
<li>如果确定需要发生进程切换而不是返回先前执行程序，可将控制权转交给进程切换函数</li>
</ul>
</li>
</ul>
<h4 id="操作系统服务例程作为独立进程运行"><a href="#操作系统服务例程作为独立进程运行" class="headerlink" title="操作系统服务例程作为独立进程运行"></a><strong>操作系统服务例程作为独立进程运行</strong></h4><ul>
<li><p><strong>概念介绍</strong></p>
<ul>
<li>把操作系统服务例程组织为一组在用户态工作的系统进程，也称服务器进程</li>
<li>应用进程的系统调用服务请求和服务器进程的服务响应通过内核的消息传递机制实现，形成客户机/服务器工作方式</li>
</ul>
</li>
<li><p><strong>特点</strong></p>
<ul>
<li>在这种运行方式下，操作系统的核心功能，如进程切换和消息传递、中断处理等，依然在内核态运行，只是服务例程组织为用户态系统进程</li>
<li>进程切换则是这一运行模式必须付出的代价，性能的下降不可避免</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>可采用模块化的操作系统实现方法，模块间具有最少和最简洁的接口，有利于操作系统的实现、替换和扩充</li>
</ul>
</li>
</ul>
<h2 id="2-4-多线程技术"><a href="#2-4-多线程技术" class="headerlink" title="2.4 多线程技术"></a>2.4 多线程技术</h2><h3 id="2-4-1-多线程环境概述"><a href="#2-4-1-多线程环境概述" class="headerlink" title="2.4.1 多线程环境概述"></a>2.4.1 多线程环境概述</h3><h4 id="单线程结构进程"><a href="#单线程结构进程" class="headerlink" title="单线程结构进程"></a><strong>单线程结构进程</strong></h4><ul>
<li><p>传统进程是单线程结构进程</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013141541780.png" alt="image-20221013141541780"></p>
</li>
<li><p><strong>进程是处理器调度和资源分配的基本单位</strong></p>
</li>
<li><p>在并发程序设计上存在的问题：</p>
<ul>
<li>进程切换开销大</li>
<li>进程通信开销大</li>
<li>限制了进程并发的粒度</li>
<li>降低了并行计算的效率</li>
</ul>
</li>
<li><p>解决问题的思路</p>
<ul>
<li>把进程的两项功能，即”独立分配资源”与”被调度分派执行”分离开来</li>
<li>进程作为系统资源分配和保护的独立单位，不需要频繁地切换</li>
<li>线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地调度和切换</li>
<li>线程的出现会减少进程并发执行所付出的时空开销，使得并发粒度更细、并发性更好</li>
</ul>
</li>
</ul>
<h4 id="多线程结构进程"><a href="#多线程结构进程" class="headerlink" title="多线程结构进程"></a><strong>多线程结构进程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013144217979.png" alt="image-20221013144217979"></p>
<ul>
<li><p>多线程环境下<strong>进程</strong>的概念</p>
<ul>
<li><p>在多线程环境下，<strong>进程是操作系统中进行保护和资源分配的独立单位</strong>，具有：</p>
<ul>
<li>用来容纳进程映像的虚拟地址空间</li>
<li>对进程、文件和设备的存取保护机制</li>
</ul>
</li>
<li><p>进程可以分为资源集合和线程集合。进程要支撑线程运行，为线程提供虚拟地址空间和各种资源</p>
</li>
<li>进程封装管理信息：对指令代码、全局数据、打开的文件和信号量等共享部分的管理</li>
</ul>
</li>
<li>多线程环境下<strong>线程</strong>的概念<ul>
<li><strong>线程是进程的一条执行路径，是调度的基本单位</strong>，同一个进程中的所有线程<strong>共享进程获得的主存空间和资源</strong>。它具有<ul>
<li>线程执行状态</li>
<li>受保护的线程上下文，当线程不运行时，用于存储现场信息</li>
<li>独立的程序指令计数器</li>
<li>执行堆栈</li>
<li>容纳局部变量的静态存储器</li>
</ul>
</li>
<li>线程封装执行信息：对状态信息、寄存器、执行栈(用户栈和核心栈)和局部变量、过程调用参数、返回值等私有部分的管理</li>
</ul>
</li>
</ul>
<h4 id="多线程环境下的线程状态"><a href="#多线程环境下的线程状态" class="headerlink" title="多线程环境下的线程状态"></a><strong>多线程环境下的线程状态</strong></h4><ul>
<li>线程状态有：<ul>
<li>运行、就绪和睡眠，无挂起</li>
</ul>
</li>
<li>挂起状态：与资源相关，<strong>属于进程</strong></li>
<li>与线程状态变化有关的线程操作有：<ul>
<li>孵化、封锁、活化、剥夺、指派、结束</li>
</ul>
</li>
</ul>
<h4 id="多线程环境下的线程调度"><a href="#多线程环境下的线程调度" class="headerlink" title="多线程环境下的线程调度"></a><strong>多线程环境下的线程调度</strong></h4><ul>
<li>OS感知线程环境下：<ul>
<li>处理器调度对象是线程</li>
<li>进程没有三状态(或者说只有挂起状态)</li>
</ul>
</li>
<li>OS不感知线程状态下：<ul>
<li>处理器调度对象仍是进程</li>
<li>用户空间中的用户调度程序调度线程</li>
</ul>
</li>
</ul>
<h4 id="一个进程中的线程组织方式"><a href="#一个进程中的线程组织方式" class="headerlink" title="一个进程中的线程组织方式"></a><strong>一个进程中的线程组织方式</strong></h4><ul>
<li>调度者/工作者模式：进程中的一个线程担任调度员，接收和处理工作请求，其他线程是工作者线程，由调度员线程分配任务并唤醒工作者线程</li>
<li>组模式：进程中的各个线程看作同一组，都可以取得并处理工作请求，不存在调度员线程。有时候每个线程被设计成专门执行特定的任务，同时建立相应的任务队列</li>
<li>流水线模式：线程排成某个次序，第一个线程所产生的数据传送给下一个线程进行处理，以此类推；数据按照排定次序由线程依次传递以完成被请求的任务</li>
</ul>
<h4 id="并发多线程程序设计的优点"><a href="#并发多线程程序设计的优点" class="headerlink" title="并发多线程程序设计的优点"></a><strong>并发多线程程序设计的优点</strong></h4><ul>
<li>快速线程切换</li>
<li>减少(系统)管理开销</li>
<li>(线程)通信易于实现</li>
<li>并行程度提高</li>
<li>节省内存空间</li>
</ul>
<h4 id="多线程技术的应用"><a href="#多线程技术的应用" class="headerlink" title="多线程技术的应用"></a><strong>多线程技术的应用</strong></h4><ul>
<li>前台和后台工作</li>
<li>C/S应用模式</li>
<li>加快执行速度</li>
<li>设计用户接口</li>
</ul>
<h3 id="2-4-2-多线程的实现技术"><a href="#2-4-2-多线程的实现技术" class="headerlink" title="2.4.2 多线程的实现技术"></a>2.4.2 多线程的实现技术</h3><h4 id="内核级线程KLT-Kernel-Level-Threads"><a href="#内核级线程KLT-Kernel-Level-Threads" class="headerlink" title="内核级线程KLT(Kernel-Level Threads)"></a><strong>内核级线程KLT(Kernel-Level Threads)</strong></h4><ul>
<li>线程管理的所有工作由OS内核来做</li>
<li>OS提供了一个应用程序设计接口API，供开发者使用KLT</li>
<li>OS直接调度KLT</li>
<li>当任务提交操作系统执行时，内核为其创建进程和一个<strong>基线程</strong>，线程执行过程中可通过内核的创建线程原语来创建其他线程</li>
<li>内核需要为进程及进程中的单个线程维护现场信息，所以应在内核空间中建立和维护进程控制块和线程控制块(thread control block,TCB)</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013151327647.png" alt="image-20221013151327647"></p>
<h4 id="内核级线程的特点"><a href="#内核级线程的特点" class="headerlink" title="内核级线程的特点"></a><strong>内核级线程的特点</strong></h4><ul>
<li>进程中的一个线程被阻塞了，内核能调度同一进程的其他线程占有处理器运行</li>
<li>多处理器环境中，内核能同时调度同一进程中多个线程并行执行</li>
<li>内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率</li>
<li>内核级线程只有很小的数据结构和堆栈，切换速度快</li>
<li>应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，系统开销较大</li>
</ul>
<h4 id="用户级线程ULT-User-Level-Threads"><a href="#用户级线程ULT-User-Level-Threads" class="headerlink" title="用户级线程ULT(User-Level Threads)"></a><strong>用户级线程ULT(User-Level Threads)</strong></h4><ul>
<li>用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境</li>
<li>任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行</li>
<li>线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013151128314.png" alt="image-20221013151128314"></p>
<h4 id="用户级线程的特点"><a href="#用户级线程的特点" class="headerlink" title="用户级线程的特点"></a><strong>用户级线程的特点</strong></h4><ul>
<li>所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能节省模式切换开销和内核的宝贵资源</li>
<li>允许进程按应用特定需要选择调度算法，甚至根据应用需求裁剪调度算法</li>
<li>能运行在任何OS上，内核在支持ULT方面不需要做任何工作</li>
<li>不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行</li>
<li>一个ULT的阻塞，将引起整个进程的阻塞</li>
</ul>
<h4 id="Jacketing技术"><a href="#Jacketing技术" class="headerlink" title="Jacketing技术"></a><strong>Jacketing技术</strong></h4><ul>
<li>把阻塞式系统调用改造成非阻塞式的</li>
<li>当线程陷入系统调用时，执行Jacketing程序</li>
<li>由Jacketing程序来检查资源使用情况，以决定是否执行<strong>进程切换</strong>或<strong>传递控制权给另一个线程</strong></li>
</ul>
<h4 id="用户级线程-vs-内核级线程"><a href="#用户级线程-vs-内核级线程" class="headerlink" title="用户级线程 vs. 内核级线程"></a><strong>用户级线程 vs. 内核级线程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018152645596.png" alt="image-20221018152645596"></p>
<ul>
<li>ULT适用于解决逻辑并行性问题</li>
<li>KLT适用于解决物理并行性问题</li>
</ul>
<h4 id="多线程实现的混合式策略"><a href="#多线程实现的混合式策略" class="headerlink" title="多线程实现的混合式策略"></a><strong>多线程实现的混合式策略</strong></h4><ul>
<li>线程创建是完全在用户空间做的</li>
<li>单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018153247134.png" alt="image-20221018153247134"></p>
<h4 id="多线程实现混合式策略的特点"><a href="#多线程实现混合式策略的特点" class="headerlink" title="多线程实现混合式策略的特点"></a><strong>多线程实现混合式策略的特点</strong></h4><ul>
<li>组合用户级线程/内核级线程设施，可以提供各种复杂语义</li>
<li>线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行</li>
<li>一个应用中的多个用户级线程被映射到一些(小于等于用户级线程数目)内核级线程上</li>
<li>程序员可以针对特定应用和机器调节内核级线程的数目，以达到整体最佳结果</li>
<li>有效利用物理并行性和逻辑并行性</li>
<li>该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点</li>
</ul>
<h4 id="线程混合式策略下的线程状态"><a href="#线程混合式策略下的线程状态" class="headerlink" title="线程混合式策略下的线程状态"></a><strong>线程混合式策略下的线程状态</strong></h4><ul>
<li>KLT三态，系统调度负责</li>
<li>ULT三态，用户调度负责</li>
<li>活跃态ULT代表绑定KLT的三态</li>
<li>活跃态ULT运行时可激活用户调度</li>
<li>非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018155356855.png" alt="image-20221018155356855"></p>
<h4 id="多线程实现的各种策略总结"><a href="#多线程实现的各种策略总结" class="headerlink" title="多线程实现的各种策略总结"></a><strong>多线程实现的各种策略总结</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018155540846.png" alt="image-20221018155540846"></p>
<h4 id="Solaris多线程技术补充"><a href="#Solaris多线程技术补充" class="headerlink" title="Solaris多线程技术补充"></a><strong>Solaris多线程技术补充</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018155604627.png" alt="image-20221018155604627"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018155621246.png" alt="image-20221018155621246"></p>
<h2 id="2-5-处理器调度"><a href="#2-5-处理器调度" class="headerlink" title="2.5 处理器调度"></a>2.5 处理器调度</h2><h3 id="2-5-1-处理器调度的层次"><a href="#2-5-1-处理器调度的层次" class="headerlink" title="2.5.1 处理器调度的层次"></a>2.5.1 处理器调度的层次</h3><h4 id="处理器调度的层次"><a href="#处理器调度的层次" class="headerlink" title="处理器调度的层次"></a><strong>处理器调度的层次</strong></h4><ul>
<li>高级调度：又称长程调度，作业调度<ul>
<li>决定能否加入到执行的进程池中</li>
</ul>
</li>
<li>中级调度，又称平衡负载调度<ul>
<li>决定主存中的可用进程集合(考虑挂起就绪态、挂起阻塞态)</li>
</ul>
</li>
<li>低级调度：又称短程调度，进程调度<ul>
<li>决定哪个可用进程占用处理器执行</li>
</ul>
</li>
</ul>
<h4 id="处理器调度层次与进程状态转换"><a href="#处理器调度层次与进程状态转换" class="headerlink" title="处理器调度层次与进程状态转换"></a><strong>处理器调度层次与进程状态转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221017104012282.png" alt="image-20221017104012282"></p>
<h4 id="处理器调度层次与关键状态转换"><a href="#处理器调度层次与关键状态转换" class="headerlink" title="处理器调度层次与关键状态转换"></a><strong>处理器调度层次与关键状态转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221017104730305.png" alt="image-20221017104730305"></p>
<h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a><strong>高级调度</strong></h4><ul>
<li>分时OS中，高级调度决定：<ul>
<li>是否接受一个终端用户的连接</li>
<li>命令能否被系统接纳并构成进程</li>
<li>新建态进程是否加入就绪进程队列</li>
</ul>
</li>
<li>批处理OS中，高级调度又称为作业调度<ul>
<li>功能是按照某种原则从后备作业队列中选取作业进入主存，并为作业做好运行前的准备工作和完成后的善后工作</li>
</ul>
</li>
</ul>
<h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a><strong>中级调度</strong></h4><ul>
<li>引进中级调度是为了提高内存利用率和作业吞吐量</li>
<li>中级调度决定那些进程被允许驻留在主存中参与竞争处理器及其他资源，起到短期调整系统负荷的作用</li>
<li>中级调度把一些进程换出主存，从而使之进入“挂起”状态，不参与进程调度，以平顺系统的负载</li>
</ul>
<h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a><strong>低级调度</strong></h4><ul>
<li>低级调度：又称处理器调度、进程/线程调度、短程调度，按照某种原则把处理器分配给就绪态进程或内核级线程</li>
<li>进程调度程序：又称分派程序，操作系统中实现处理器调度的程序，是操作系统的最核心部分</li>
<li>处理器调度策略的优劣直接影响到整个系统的性能</li>
</ul>
<h4 id="低级调度的主要功能"><a href="#低级调度的主要功能" class="headerlink" title="低级调度的主要功能"></a><strong>低级调度的主要功能</strong></h4><ul>
<li>记住进程或内核级线程的状态</li>
<li>决定某个进程或内核级线程什么时候获得处理器，以及占用多长时间</li>
<li>把处理器分配给进程或内核级线程</li>
<li>收回处理器</li>
</ul>
<h3 id="2-5-2-处理器调度算法"><a href="#2-5-2-处理器调度算法" class="headerlink" title="2.5.2 处理器调度算法"></a>2.5.2 处理器调度算法</h3><h4 id="选择处理器调度算法的原则"><a href="#选择处理器调度算法的原则" class="headerlink" title="选择处理器调度算法的原则"></a><strong>选择处理器调度算法的原则</strong></h4><ul>
<li><strong>资源利用率</strong>：使得CPU或其他资源的使用率尽可能高且能够并行工作</li>
<li><strong>响应时间</strong>：使交互式用户的响应时间尽可能小，或尽快处理实时任务</li>
<li><strong>周转时间</strong>：提交给系统开始到执行完成获得结果为止的这段时间间隔称周转时间，应该使周转时间或平均周转时间尽可能短<ul>
<li>归一化周转时间 = 周转时间 / CPU服务时间 &gt; 1，目标不断接近1</li>
</ul>
</li>
<li><strong>吞吐量</strong>：单位时间处理的进程数尽可能多</li>
<li><strong>公平性</strong>：确保每个用户每个进程获得合理的CPU份额或其他资源份额</li>
</ul>
<h4 id="优先数调度算法"><a href="#优先数调度算法" class="headerlink" title="优先数调度算法"></a><strong>优先数调度算法</strong></h4><ul>
<li>根据分配给进程的优先数决定运行进程<ul>
<li>抢占式优先数调度算法</li>
<li>非抢占式优先数调度算法<ul>
<li><strong>没有运行态 -&gt; 就绪态的跳转</strong></li>
</ul>
</li>
</ul>
</li>
<li>优先数的确定准则<ul>
<li>进程负担任务的紧迫程度</li>
<li>进程的交互性</li>
<li>进程使用外设的频度</li>
<li>进程进入系统的时间长短</li>
</ul>
</li>
</ul>
<h4 id="非抢占式优先数调度算法"><a href="#非抢占式优先数调度算法" class="headerlink" title="非抢占式优先数调度算法"></a><strong>非抢占式优先数调度算法</strong></h4><ul>
<li>没有运行态 -&gt; 就绪态的跳转</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221017110647416.png" alt="image-20221017110647416"></p>
<h4 id="与使用处理器的服务时间长短相关的优先数"><a href="#与使用处理器的服务时间长短相关的优先数" class="headerlink" title="与使用处理器的服务时间长短相关的优先数"></a><strong>与使用处理器的服务时间长短相关的优先数</strong></h4><ul>
<li><strong>计算时间短(SJF)</strong>(作业/进程)优先</li>
<li><strong>剩余计算时间短(SRTF)</strong>进程优先</li>
<li><strong>响应比高者(HRRF)</strong>(作业/进程)优先<ul>
<li>响应比 = $\frac{等待时间 + 期待(预估)处理器的服务时间}{期待(预估)处理器的服务时间}$</li>
</ul>
</li>
<li><strong>先来先服务(FCFS)</strong>：先进队先被选择(常用于非抢占式)<ul>
<li>多用于高级调度；低级调度中，以计算为主的进程过于优越，即容易造成长时间占用处理器</li>
</ul>
</li>
</ul>
<h4 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a><strong>时间片轮转调度算法</strong></h4><ul>
<li><strong>根据各个进程进入就绪队列的时间先后轮流占有CPU一个时间片</strong></li>
<li>时间片中断</li>
<li><strong>时间片长度的确定</strong>：选择长短合适的时间片, 过长则退化为先来先服务算法, 过短则调度开销大</li>
<li>单时间片，多时间片和动态时间片</li>
</ul>
<h4 id="分级调度算法-feedback"><a href="#分级调度算法-feedback" class="headerlink" title="分级调度算法(feedback)"></a><strong>分级调度算法(feedback)</strong></h4><ul>
<li>又称多队列策略，反馈循环队列，多级反馈队列调度算法</li>
<li>基本思想<ul>
<li><strong>建立多个不同优先级的就绪进程队列</strong></li>
<li><strong>多个就绪进程队列间按照优先数调度</strong></li>
<li><strong>高优先级就绪进程</strong>，分配的时间片短</li>
<li>单个就绪进程队列中进程的优先数和时间片相同</li>
</ul>
</li>
<li>举例：</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221017112203432.png" alt="image-20221017112203432" style="zoom:80%;" /></p>
<h4 id="分级调度算法的分级原则"><a href="#分级调度算法的分级原则" class="headerlink" title="分级调度算法的分级原则"></a><strong>分级调度算法的分级原则</strong></h4><ul>
<li>一般分级原则<ul>
<li>外设访问，交互性，时间紧迫程度，系统效率，用户立场，…</li>
</ul>
</li>
<li>现代操作系统的实现模型<ul>
<li>多个高优先级的实时进程队列，如：硬实时、网络、软实时</li>
<li>多个分时任务的进程队列，根据基准优先数和执行行为调整</li>
<li>队列数可能多达32-128个</li>
</ul>
</li>
</ul>
<h4 id="彩票调度算法"><a href="#彩票调度算法" class="headerlink" title="彩票调度算法"></a><strong>彩票调度算法</strong></h4><ul>
<li><p>基本思想：为进程发放针对系统各种资源（如CPU时间）的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源</p>
</li>
<li><p>合作进程之间的彩票交换</p>
</li>
</ul>
<h3 id="2-5-3-具体调度算法-补充"><a href="#2-5-3-具体调度算法-补充" class="headerlink" title="2.5.3 具体调度算法(补充)"></a>2.5.3 具体调度算法(补充)</h3><h4 id="1-短程调度准测"><a href="#1-短程调度准测" class="headerlink" title="1.短程调度准测"></a><strong>1.短程调度准测</strong></h4><p>与性能相关</p>
<ul>
<li>面向用户<ul>
<li>周转时间</li>
<li>响应时间</li>
<li>最后期限</li>
</ul>
</li>
<li>面向系统<ul>
<li>吞吐量</li>
<li>处理器利用率</li>
</ul>
</li>
</ul>
<p>与性能无关</p>
<ul>
<li>面向用户<ul>
<li>可预测性</li>
</ul>
</li>
<li>面向系统<ul>
<li>公平</li>
<li>强制优先级</li>
<li>平衡资源</li>
</ul>
</li>
</ul>
<h4 id="2-优先级调度"><a href="#2-优先级调度" class="headerlink" title="2.优先级调度"></a><strong>2.优先级调度</strong></h4><ul>
<li>调度器总是选择优先级较高的进程</li>
<li>提供多个就绪队列(一组就绪队列)代表各个级别的优先级</li>
<li>问题：低优先级有可能饥饿<ul>
<li><strong>一个进程的优先级应该随着它的时间或执行的历史而变化</strong></li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018161936990.png" alt="image-20221018161936990" style="zoom:80%;" /></p>
<h4 id="3-调度的模式"><a href="#3-调度的模式" class="headerlink" title="3.调度的模式"></a><strong>3.调度的模式</strong></h4><ul>
<li>非抢占式<ul>
<li>一个进程一旦处于运行态，它就不断执行直到终止，或者为等待I/O或请求某些操作系统服务而阻塞自己</li>
</ul>
</li>
<li>抢占式<ul>
<li>当前正在运行的进程可能被操作系统中断，并转移到就绪态，关于抢占的决策可能是在一个进程到达时，或者在一个中断发生后把一个被阻塞的进程置为就绪态时，或者基于周期性的时间中断</li>
<li>与非抢占式相比，抢占式可能会导致较大的开销，但是可能对所有进程提供更好的服务，可以避免任何一个进程独占处理器太长时间</li>
</ul>
</li>
</ul>
<h4 id="4-调度算法"><a href="#4-调度算法" class="headerlink" title="4.调度算法"></a><strong>4.调度算法</strong></h4><ul>
<li><strong>FCFS</strong>(<em>先来先服务</em>) <strong>非抢占</strong></li>
<li><strong>RR</strong>(<em>时间片轮转</em>) <strong>抢占</strong></li>
<li><strong>SPN</strong>(<em>最短进程优先</em>) <strong>非抢占</strong></li>
<li><strong>SRT</strong>(<em>最短剩余时间优先</em>) <strong>抢占</strong></li>
<li><strong>HRRF</strong>(<em>最高响应比优先</em>) <strong>非抢占</strong></li>
<li><strong>Feedback</strong>(<em>多级反馈调度</em>) <strong>抢占</strong>   //RR+优先级</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162324280.png" alt="image-20221018162324280"></p>
<h5 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS(先来先服务)"></a><strong>FCFS(先来先服务)</strong></h5><ul>
<li>非抢占</li>
<li>当某个进程就绪时，加入就绪队列(ready queue)</li>
<li>当前正在运行的进程停止执行时，选择在就绪队列中存在时间最长的进程运行</li>
<li>一个短进程可能不得不等待很长时间才能获得执行</li>
<li>偏袒计算为主的进程<ul>
<li>I/O多的进程不得不等待计算为主的进程做完</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162512311.png" alt="image-20221018162512311" style="zoom:67%;" /></p>
<h5 id="RR-时间片轮转"><a href="#RR-时间片轮转" class="headerlink" title="RR(时间片轮转)"></a><strong>RR(时间片轮转)</strong></h5><ul>
<li>基于时钟做抢占式调度</li>
<li>以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列中，然后基于FCFS策略选择下一个就绪进程运行</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162745148.png" alt="image-20221018162745148" style="zoom:67%;" /></p>
<h5 id="SPN-最短进程优先"><a href="#SPN-最短进程优先" class="headerlink" title="SPN(最短进程优先)"></a><strong>SPN(最短进程优先)</strong></h5><ul>
<li>非抢占式调度</li>
<li>选择所需处理时间最短的进程</li>
<li>短进程将会越过长进程，优先获得调度</li>
<li>问题：只要持续不断地提供更短的进程，长进程就有可能饿死</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018162854427.png" alt="image-20221018162854427" style="zoom:67%;" /></p>
<h5 id="SPT-最短剩余时间优先"><a href="#SPT-最短剩余时间优先" class="headerlink" title="SPT(最短剩余时间优先)"></a><strong>SPT(最短剩余时间优先)</strong></h5><ul>
<li>抢占式调度</li>
<li>调度器总是选择预期剩余时间更短的进程</li>
<li>当一个新进程加入就绪队列，他可能比当前运行的进程具有更短的剩余时间，只要该新进程就绪，调度器就可能抢占当前正在运行的进程</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018163124447.png" alt="image-20221018163124447" style="zoom:67%;" /></p>
<h5 id="HRRN-最高响应比优先"><a href="#HRRN-最高响应比优先" class="headerlink" title="HRRN(最高响应比优先)"></a><strong>HRRN(最高响应比优先)</strong></h5><ul>
<li>非抢占</li>
<li>选择响应比最高的<ul>
<li>响应比 = $\frac{等待时间 + 期待(预估)处理器的服务时间}{期待(预估)处理器的服务时间}$</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018163320945.png" alt="image-20221018163320945" style="zoom:67%;" /></p>
<h5 id="Feedback-多级反馈调度"><a href="#Feedback-多级反馈调度" class="headerlink" title="Feedback(多级反馈调度)"></a><strong>Feedback(多级反馈调度)</strong></h5><ul>
<li>抢占式</li>
<li>RR + 优先级</li>
<li>基本思想<ul>
<li>建立多个不同优先级的就绪进程队列</li>
<li>多个就绪进程队列之间按照优先数调度</li>
<li>高优先级的就绪进程, 分配的时间片短</li>
<li>单个就绪进程队列中的进程的优先数和时间片相同, 按照先来先服务算法调度</li>
</ul>
</li>
<li>分级原则：外设访问, 交互性, 时间紧迫程度, 系统效率, 用户立场, …</li>
<li>当一个进程第一次进入系统时，它被放置在RQ0，当它第一次被抢占后并返回就绪状态时，它被放置在RQ1。在随后的时间里，每当它被抢占时，它被降级到下一个低优先级队列中。<strong>一个短进程</strong>很快会执行完，<strong>不会在就绪队列中降很多级。</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018163513176.png" alt="image-20221018163513176" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018163829039.png" alt="image-20221018163829039" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164114444.png" alt="image-20221018164114444" style="zoom:67%;" /></p>
<h5 id="对比RR与Feedback-q-1"><a href="#对比RR与Feedback-q-1" class="headerlink" title="对比RR与Feedback(q=1)"></a><strong>对比RR与Feedback(q=1)</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018163943191.png" alt="image-20221018163943191"></p>
<h5 id="q-2-i"><a href="#q-2-i" class="headerlink" title="q=2^i"></a><strong>q=2^i</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164320210.png" alt="image-20221018164320210" style="zoom: 67%;" /></p>
<p><strong>低优先级队列给予更长的处理时间</strong></p>
<h3 id="2-5-4-现代操作系统调度算法"><a href="#2-5-4-现代操作系统调度算法" class="headerlink" title="2.5.4 现代操作系统调度算法"></a>2.5.4 现代操作系统调度算法</h3><h4 id="传统Unix系统的调度"><a href="#传统Unix系统的调度" class="headerlink" title="传统Unix系统的调度"></a><strong>传统Unix系统的调度</strong></h4><ul>
<li>多级反馈队列，每个优先级队列使用时间片轮转</li>
<li>每秒重新计算每个进程的优先级</li>
<li>给每个进程赋予基本优先级的目的是把所有进程划分成固定的优先级区</li>
<li>可控调节因子</li>
</ul>
<h4 id="Unix-SVR4调度算法"><a href="#Unix-SVR4调度算法" class="headerlink" title="Unix SVR4调度算法"></a><strong>Unix SVR4调度算法</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164522256.png" alt="image-20221018164522256" style="zoom: 80%;" /></p>
<ul>
<li>多级反馈队列，每一个优先数都对应于一个就绪进程队列</li>
<li>实时优先级层次：优先数和时间片都是固定的，在抢占点执行抢占</li>
<li>分时优先级层次：优先数和时间片是可变的，从0优先数的100ms到59优先数的10ms</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018164826010.png" alt="image-20221018164826010" style="zoom:80%;" /></p>
<h4 id="Bands"><a href="#Bands" class="headerlink" title="Bands"></a><strong>Bands</strong></h4><ul>
<li>优先级递减<ul>
<li>对换</li>
<li>块I/O设备控制</li>
<li>文件操作</li>
<li>字符I/O设备控制</li>
<li>用户进程</li>
</ul>
</li>
</ul>
<h4 id="Windows调度算法"><a href="#Windows调度算法" class="headerlink" title="Windows调度算法"></a><strong>Windows调度算法</strong></h4><ul>
<li>主要设计目标：基于内核级线程的可抢占式调度，向单个用户提供交互式的计算环境，并支持各种服务器程序</li>
<li>优先级和优先数<ul>
<li>实时优先级层次(优先数为31-16)：用于通信任务和实时任务，优先数不可变</li>
<li>可变优先级层次(优先数为15-0)：用于用户提交的交互式任务，优先数可动态调整</li>
</ul>
</li>
<li>多级反馈队列，每一个优先数都对应于一个就绪进程队列</li>
<li><p>优先数可动态调整原则</p>
<ul>
<li>线程所属的进程对象有一个进程基本优先数，取值范围从0到15</li>
<li>线程对象有一个线程基本优先数，取值范围从-2到2</li>
<li>线程的初始优先数为进程基本优先数加上线程基本优先数，但必须在0到15的范围内</li>
<li>线程的动态优先数必须在初始优先数到15的范围内</li>
</ul>
</li>
<li><p>当存在N个处理器时，N-1个处理器上将运行N-1个最高优先级的线程，其他线程将共享剩下的一个处理器</p>
</li>
</ul>
<h4 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a><strong>fork系统调用</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018165121959.png" alt="image-20221018165121959" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018165132183.png" alt="image-20221018165132183" style="zoom:67%;" /></p>
<h4 id="Addition-of-Medium-Term-Scheduling"><a href="#Addition-of-Medium-Term-Scheduling" class="headerlink" title="Addition of Medium Term Scheduling"></a><strong>Addition of Medium Term Scheduling</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018165246398.png" alt="image-20221018165246398" style="zoom:80%;" /></p>
<h3 id="2-5-5-批处理作业的调度"><a href="#2-5-5-批处理作业的调度" class="headerlink" title="2.5.5 批处理作业的调度"></a>2.5.5 批处理作业的调度</h3><h4 id="批处理作业的管理"><a href="#批处理作业的管理" class="headerlink" title="批处理作业的管理"></a><strong>批处理作业的管理</strong></h4><ul>
<li>作业说明语言和作业说明书</li>
<li>脱机控制方式(批处理控制方式)</li>
<li>作业控制块JCB</li>
<li>作业状态<ul>
<li>输入状态：作业正在从输入设备上预输入信息</li>
<li>后备状态：作业预输入结束但尚未被选中执行</li>
<li>执行状态：作业已经被选中并<strong>构成进程</strong>去竞争处理器资源以获得运行</li>
<li>完成状态：作业运行结束，正在等待缓输出</li>
</ul>
</li>
</ul>
<h4 id="批处理作业的状态，作业调度与进程调度"><a href="#批处理作业的状态，作业调度与进程调度" class="headerlink" title="批处理作业的状态，作业调度与进程调度"></a><strong>批处理作业的状态，作业调度与进程调度</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018165431583.png" alt="image-20221018165431583" style="zoom: 80%;" /></p>
<h4 id="批处理作业的调度"><a href="#批处理作业的调度" class="headerlink" title="批处理作业的调度"></a><strong>批处理作业的调度</strong></h4><ul>
<li>作业调度：按一定的策略选取若干个作业让它们进入内存、构成进程去竞争处理器以获得运行机会</li>
<li>用户立场：自己作业的周转时间尽可能的小</li>
<li>系统立场：希望进入系统的作业的平均周转时间尽可能的小</li>
<li>适当的作业调度算法必须既考虑用户的要求又有利于系统效率的提高</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/计算机操作系统/">计算机操作系统</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/11/10/计算机操作系统-1-概述/"><span>计算机操作系统(1) 计算机操作系统概述</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/11/10/计算机操作系统-1-概述/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-10T06:05:55.000Z">
          2022-11-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="第一章-计算机操作系统概述"><a href="#第一章-计算机操作系统概述" class="headerlink" title="第一章 计算机操作系统概述"></a>第一章 计算机操作系统概述</h1><h2 id="1-1-计算机系统"><a href="#1-1-计算机系统" class="headerlink" title="1.1 计算机系统"></a>1.1 计算机系统</h2><h3 id="1-1-1-计算机系统概述"><a href="#1-1-1-计算机系统概述" class="headerlink" title="1.1.1 计算机系统概述"></a>1.1.1 计算机系统概述</h3><h4 id="电子计算机"><a href="#电子计算机" class="headerlink" title="电子计算机"></a>电子计算机</h4><p>电子数字计算机，是一种能够自行<strong>按照已设定的程序</strong>进行<strong>数据处理</strong>的电子设备</p>
<p>电子数字计算机，是软件与硬件相结合、面向系统、侧重应用的自动化求解工具</p>
<h4 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915144230717.png" alt="image-20220915144230717" style="zoom:80%;" /></p>
<p>1945年6月冯·诺伊曼等发表了著名的“101页报告”，指出计算机分为运算器、逻辑控制器、存储器、输入设备和输出设备五大部件，发展至今，大多数机器结构并未突破冯·诺依曼结构。</p>
<h4 id="计算机发展历史"><a href="#计算机发展历史" class="headerlink" title="计算机发展历史"></a>计算机发展历史</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915144320055.png" alt="image-20220915144320055" style="zoom:80%;" /></p>
<h4 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h4><ul>
<li>计算机系统：包括硬件子系统和软件子系统</li>
<li>硬件：借助电、磁、光、机械等原理构成的各种物理部件的有机组合，是系统工作的实体<ul>
<li>CPU，主存储器，I/O控制系统，外围设备</li>
</ul>
</li>
<li>软件：各种程序和文件，用于指挥计算机系统按指定的要求进行协同工作<ul>
<li>包括系统软件、支撑软件和应用软件</li>
<li>关键系统软件是：操作系统与语言处理程序</li>
</ul>
</li>
</ul>
<h4 id="计算机系统的用户视图"><a href="#计算机系统的用户视图" class="headerlink" title="计算机系统的用户视图"></a>计算机系统的用户视图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915144440410.png" alt="image-20220915144440410" style="zoom:80%;" /></p>
<h3 id="1-1-2-计算机硬件系统"><a href="#1-1-2-计算机硬件系统" class="headerlink" title="1.1.2 计算机硬件系统"></a>1.1.2 计算机硬件系统</h3><h4 id="计算机硬件系统的组成"><a href="#计算机硬件系统的组成" class="headerlink" title="计算机硬件系统的组成"></a>计算机硬件系统的组成</h4><ul>
<li>中央处理器<ul>
<li>运算单元</li>
<li>控制单元</li>
</ul>
</li>
<li>主存储器</li>
<li>外围设备<ul>
<li>输入设备</li>
<li>输出设备</li>
<li>存储设备</li>
<li>网络通信设备</li>
</ul>
</li>
<li>总线</li>
</ul>
<h4 id="存储程序计算机"><a href="#存储程序计算机" class="headerlink" title="存储程序计算机"></a>存储程序计算机</h4><ul>
<li>冯·诺伊曼等人在1946年总结并明确提出，被称为冯·诺伊曼计算机模型</li>
<li>存储程序计算机在体系结构上主要特点<ul>
<li>以运算单元为中心，控制流由指令流产生</li>
<li>采用存储程序原理，面向主存组织数据流</li>
<li>主存是按地址访问、线性编址的空间</li>
<li>指令由操作码和地址码组成</li>
<li>数据以二进制编码</li>
</ul>
</li>
</ul>
<h4 id="存储程序计算机的结构"><a href="#存储程序计算机的结构" class="headerlink" title="存储程序计算机的结构"></a>存储程序计算机的结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915145542231.png" alt="image-20220915145542231" style="zoom:80%;" /></p>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><ul>
<li>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是CPU、内存、输入输出设备传递信息的公用通道</li>
<li>计算机的各个部件通过总线相连接，外围设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统</li>
</ul>
<h4 id="总线的组成"><a href="#总线的组成" class="headerlink" title="总线的组成"></a>总线的组成</h4><ul>
<li>总线是传输各类通信信号的线路</li>
<li>按照所传输的信息种类，总线包括：<ul>
<li>一组控制线</li>
<li>一组数据线</li>
<li>一组地址线</li>
</ul>
</li>
</ul>
<h4 id="总线类型"><a href="#总线类型" class="headerlink" title="总线类型"></a>总线类型</h4><ul>
<li>内部总线：用于CPU芯片内部连接各元件</li>
<li>系统总线：用于连接CPU、存储器和各种I/O模块等主要部件</li>
<li>通信总线：用于计算机系统之间通信</li>
</ul>
<h4 id="系统总线实例-南北桥"><a href="#系统总线实例-南北桥" class="headerlink" title="系统总线实例: 南北桥"></a>系统总线实例: 南北桥</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915152426064.png" alt="image-20220915152426064" style="zoom:80%;" /></p>
<h4 id="片上系统-SoC"><a href="#片上系统-SoC" class="headerlink" title="片上系统(SoC)"></a>片上系统(SoC)</h4><ul>
<li>片上系统(SoC, System on a Chip)</li>
<li>在单个芯片上集成一个完整的系统，对所有或部分必要的电子电路进行包分组的技术</li>
<li>所谓完整的系统一般包括中央处理器(CPU)、存储器、以及外围电路等</li>
<li>SoC是与其它技术并行发展的，如绝缘硅(SOI)，它可以提供增强的时钟频率，从而降低微芯片的功耗</li>
</ul>
<h4 id="中央处理器-CPU"><a href="#中央处理器-CPU" class="headerlink" title="中央处理器(CPU)"></a>中央处理器(CPU)</h4><p>中央处理器是计算机的运算核心(Core)和控制单元(Control Unit)，主要包括：</p>
<ul>
<li>运算逻辑部件: 一个或多个运算器</li>
<li>寄存器部件: 包括通用寄存器、控制与状态寄存器，以及高速缓冲存储器(Cache)</li>
<li>控制部件: 实现各部件间联系的数据、控制及状态的内部总线；负责对指令译码、发出为完成每条指令所要执行操作的控制信号、实现数据传输等功能的部件</li>
</ul>
<h4 id="处理器与寄存器"><a href="#处理器与寄存器" class="headerlink" title="处理器与寄存器"></a>处理器与寄存器</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915154154788.png" alt="image-20220915154154788" style="zoom:80%;" /></p>
<h4 id="存储器的组织层次"><a href="#存储器的组织层次" class="headerlink" title="存储器的组织层次"></a>存储器的组织层次</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915154421311.png" alt="image-20220915154421311" style="zoom: 67%;" /></p>
<ul>
<li>L1 Cache与CPU同频，与寄存器一样连接在内部总线，访问速度也与寄存器同步，可用来存储最关键的数据，对CPU性能影响最大</li>
<li>L2 Cache多用在CPU现场，连接在内部总线上，考虑实现成本也可连接在系统总线上，用于存储最频繁访问的主存储器数据，加快处理速度</li>
<li>L3 Cache一般用于存放游戏数据，或多媒体计算机/虚拟现实系统的数据</li>
</ul>
<h4 id="外围设备及其分类"><a href="#外围设备及其分类" class="headerlink" title="外围设备及其分类"></a>外围设备及其分类</h4><ul>
<li>输入/输出设备</li>
<li>存储设备</li>
<li>网络设备(机机通信设备)</li>
</ul>
<h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h4><ul>
<li>轮询: CPU忙式控制I/O，CPU执行内存数据交换</li>
<li>中断: CPU启动I/O设备，设备进行I/O，设备中断CPU以善后，CPU执行内存数据交换</li>
<li>DMA: CPU启动DMA，DMA独立进行I/O和内存数据交换，DMA中断CPU以善后，并行程度更高</li>
</ul>
<h3 id="1-1-3-计算机软件系统"><a href="#1-1-3-计算机软件系统" class="headerlink" title="1.1.3 计算机软件系统"></a>1.1.3 计算机软件系统</h3><h4 id="计算机软件系统的组成"><a href="#计算机软件系统的组成" class="headerlink" title="计算机软件系统的组成"></a>计算机软件系统的组成</h4><ul>
<li>系统软件: 操作系统、实用程序、语言处理程序、数据库管理系统、专用文件系统<ul>
<li>操作系统实施对各种软硬件资源的管理控制</li>
<li>实用程序为方便用户所设，如文本编辑工具、调试工具等</li>
<li>语言处理程序把把用汇编语言/高级语言编写的程序，翻译成可执行的机器语言程序</li>
</ul>
</li>
<li>支撑软件: 接口软件、工具软件、环境数据库<ul>
<li>支持用户操作计算机的环境，提供软件开发工具</li>
<li>也可以看作是系统软件的一部分</li>
</ul>
</li>
<li>应用软件: 用户按其需要自行编写的专用程序</li>
</ul>
<h4 id="软件扩充计算机系统功能"><a href="#软件扩充计算机系统功能" class="headerlink" title="软件扩充计算机系统功能"></a>软件扩充计算机系统功能</h4><ul>
<li>操作系统为程序员增加了一个叫做系统调用的访问集合，它们屏蔽了程序访问硬件的细节</li>
<li>系统调用加上允许用户使用的机器指令子集，构成了一个扩展的机器指令集，使程序员的编程可以侧重于CPU的计算和具体任务的解决</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915195804272.png" alt="image-20220915195804272"></p>
<h4 id="软件开发的不同层次"><a href="#软件开发的不同层次" class="headerlink" title="软件开发的不同层次"></a>软件开发的不同层次</h4><ul>
<li>计算机硬件系统：机器语言</li>
<li>操作系统之资源管理：机器语言+广义指令（扩充了硬件资源管理）</li>
<li>操作系统之文件系统：机器语言+系统调用（扩充了信息资源管理）</li>
<li>数据库管理系统：+数据库语言（扩充了功能更强的信息资源管理）</li>
<li>语言处理程序：面向问题的语言</li>
</ul>
<h4 id="计算机程序的解译执行过程"><a href="#计算机程序的解译执行过程" class="headerlink" title="计算机程序的解译执行过程"></a>计算机程序的解译执行过程</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915195853406.png" alt="image-20220915195853406"></p>
<p>可执行程序是指在操作系统环境下可执行的程序</p>
<p>图中给出的是裸机上计算机程序的解译执行过程，现代计算机系统在实现上往往是基于虚拟机的，即基于一个汇编指令集合提供计算功能。这种情况下，目标代码变成了单纯的汇编指令，而汇编程序的功能则变成了程序优化</p>
<h2 id="1-2-计算机操作系统"><a href="#1-2-计算机操作系统" class="headerlink" title="1.2 计算机操作系统"></a>1.2 计算机操作系统</h2><h3 id="1-2-1-计算机操作技术的发展"><a href="#1-2-1-计算机操作技术的发展" class="headerlink" title="1.2.1 计算机操作技术的发展"></a>1.2.1 计算机操作技术的发展</h3><h4 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h4><ul>
<li><p>开关表示，按钮控制，亮灯显示</p>
<ul>
<li>问题: 手工操作速度与电子计算速度不匹配</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915201607061.png" alt="image-20220915201607061" style="zoom:80%;" /></p>
</li>
<li><p>装入程序的引进</p>
<ul>
<li>引入卡片和纸带描述程序指令和数据</li>
<li>引入装入程序(Loader)<ul>
<li>自动化执行程序装入，必要时进行地址转换</li>
<li>通常存放在ROM中</li>
</ul>
</li>
<li>计算机开机后自动导入主存，装入程序从纸带机或卡片机上读取程序和数据，然后循环装入程序</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915201841585.png" alt="image-20220915201841585" style="zoom:80%;" /></p>
</li>
<li><p>引入汇编语言</p>
<ul>
<li><p>实现机器指令的符号化</p>
</li>
<li><p>对计算机的操作变为汇编和执行两个阶段</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915202348248.png" alt="image-20220915202348248" style="zoom:80%;" /></p>
</li>
</ul>
</li>
<li><p>引入高级语言</p>
<ul>
<li><p>操作扩展为编译、链接、执行</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915202455494.png" alt="image-20220915202455494" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
<h4 id="半自动化控制方式"><a href="#半自动化控制方式" class="headerlink" title="半自动化控制方式"></a>半自动化控制方式</h4><ul>
<li>简单批处理系统的操作控制<ul>
<li>引入<strong>作业控制语言</strong>，用户编写<strong>作业说明书</strong>，描述一次对计算机求解作业控制的过程</li>
<li>操作员控制计算机成批输入作业，然后排队执行</li>
<li>这一方式明显缩短了手工操作时间，提高了计算机系统的使用效率</li>
</ul>
</li>
<li>简单批处理系统的操作进展<ul>
<li>初步的资源管理程序出现，屏蔽了硬件处理细节</li>
<li>I/O中断技术已使CPU与外围设备具备了并行工作的能力，支持了概念上多道程序设计实现的可能性</li>
<li>磁带设备出现<ul>
<li>卡片与纸带等机械输入方式得以提高</li>
<li>磁盘文件系统形成</li>
<li>I/O效率还是无法支撑多道程序切换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="操作系统与自动化操作控制"><a href="#操作系统与自动化操作控制" class="headerlink" title="操作系统与自动化操作控制"></a>操作系统与自动化操作控制</h4><ul>
<li>I/O机械速度与CPU电子速度不匹配的矛盾<ul>
<li>“设备在慢慢输,CPU在等”</li>
</ul>
</li>
<li>在程序执行过程中能否同时输入作业，重叠时间<ul>
<li>需要多道程序同时执行</li>
<li>程序切换需要高速的外存储设备</li>
</ul>
</li>
<li>磁盘设备出现<ul>
<li>计算机操作系统从此出现，实现了对计算机系统的自动化控制</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-操作系统及其分类"><a href="#1-2-2-操作系统及其分类" class="headerlink" title="1.2.2 操作系统及其分类"></a>1.2.2 操作系统及其分类</h3><h4 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h4><p>OS是计算机系统最基础的系统软件，它统一管理软硬件资源、控制程序执行，改善人机界面，合理组织计算机工作流程，为用户使用计算机提供良好的运行环境</p>
<p><strong>OS是计算机系统的公共软件基础设施，所有应用程序共用OS服务，且OS内核是反应式reactive机制(中断驱动的)</strong></p>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>操作系统是方便用户、管理和控制计算机软硬件资源的系统程序集合，在整个计算机系统中具有承上启下的地位</p>
<ul>
<li>从用户角度看，OS管理计算机系统的各种资源，扩充硬件的功能，控制程序的执行</li>
<li>从人机交互看，OS是用户与机器的接口，提供良好的人机界面，方便用户使用计算机</li>
<li>从系统结构看，OS是一个大型软件系统，其功能复杂，体系庞大，采用层次式、模块化的程序结构</li>
</ul>
<h4 id="操作系统的组成"><a href="#操作系统的组成" class="headerlink" title="操作系统的组成"></a>操作系统的组成</h4><ul>
<li>进程调度子系统</li>
<li>进程通信子系统</li>
<li>内存管理子系统</li>
<li>设备管理子系统</li>
<li>文件管理子系统</li>
<li>网络通信子系统</li>
<li>作业控制子系统</li>
</ul>
<h4 id="操作系统的类型"><a href="#操作系统的类型" class="headerlink" title="操作系统的类型"></a>操作系统的类型</h4><p>从操作控制方式看</p>
<ul>
<li>多道批处理操作系统，脱机控制方式<ul>
<li>把批中的作业预先输入作业队列中，由操作系统按照作业说明书的要求来调度和控制作业执行，大幅减少人工干预，形成自动转接和连续处理的作业流</li>
<li>最先采用多道程序设计技术，根据预先设定的调度策略选择若干作业并发地执行</li>
</ul>
</li>
<li>分时操作系统，交互式控制方式<ul>
<li>多个联机用户同时使用一个计算机系统，在各自终端上进行交互式会话，程序、数据和命令均在会话过程中提供，以问答方式控制程序运行</li>
<li>系统把处理器的时间划分成时间片轮流分配给各个联机终端，若时间片用完则产生时钟中断，将控制权转至操作系统并重新进行调度</li>
</ul>
</li>
<li>实时操作系统<ul>
<li>当外部事件或数据产生时，能够及时对其予以接受并以足够快的速度进行处理</li>
<li>可以提供及时响应和高可靠性</li>
</ul>
</li>
</ul>
<p>从应用领域看</p>
<ul>
<li>服务器操作系统</li>
<li>并行操作系统</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>个人机操作系统</li>
<li>手机操作系统</li>
<li>嵌入式操作系统</li>
<li>传感器操作系统</li>
</ul>
<h2 id="1-3-深入观察操作系统"><a href="#1-3-深入观察操作系统" class="headerlink" title="1.3 深入观察操作系统"></a>1.3 深入观察操作系统</h2><h3 id="1-3-1-资源管理的角度"><a href="#1-3-1-资源管理的角度" class="headerlink" title="1.3.1 资源管理的角度"></a>1.3.1 资源管理的角度</h3><h4 id="计算机系统的资源"><a href="#计算机系统的资源" class="headerlink" title="计算机系统的资源"></a>计算机系统的资源</h4><ul>
<li>硬件资源: 处理器、内存、外设</li>
<li>信息资源: 数据、程序</li>
</ul>
<h4 id="管理计算机系统的软硬件资源"><a href="#管理计算机系统的软硬件资源" class="headerlink" title="管理计算机系统的软硬件资源"></a>管理计算机系统的软硬件资源</h4><p>问题:</p>
<ul>
<li>处理器资源：哪个驻留主存的程序占有处理器运行？</li>
<li>内存资源：程序/数据在主存中如何分布？</li>
<li>设备管理：如何在各个正在运行的程序之间分配、去配和协调使用设备？</li>
<li>信息资源管理：如何访问文件信息？</li>
<li>信号量资源：如何管理进程之间的通信？</li>
</ul>
<h4 id="屏蔽资源使用的底层细节"><a href="#屏蔽资源使用的底层细节" class="headerlink" title="屏蔽资源使用的底层细节"></a>屏蔽资源使用的底层细节</h4><ul>
<li>驱动程序：最底层的、直接控制和监视各类硬件(或文件、通信)资源的系统程序部分</li>
<li>职责是隐藏底层硬件的具体细节，并向上层使用者提供一个抽象的、通用的接口，简化上层程序的开发</li>
<li>比如说：打印一段文字或一个文件，既不需知道文件信息存储在硬盘上的细节，也不必知道具体打印机类型和控制细节</li>
</ul>
<h4 id="资源的共享方式"><a href="#资源的共享方式" class="headerlink" title="资源的共享方式"></a>资源的共享方式</h4><ul>
<li>独占使用方式<ul>
<li>如: 打印机在一个时间段内只能被一个进程独立使用</li>
<li><strong>资源分配方式</strong><ul>
<li>静态分配: 进程运行前一次性拿到全部独占资源<ul>
<li>资源使用率低</li>
</ul>
</li>
<li>动态分配: 使用资源前临时申请<ul>
<li>可能产生竞争资源的死锁</li>
</ul>
</li>
<li>资源抢占式分配: 操作系统可以根据需求剥夺正在被使用的资源<ul>
<li>被抢夺资源的进程需要执行回滚，实现代价大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>并发使用方式<ul>
<li>如: 一个文件可以同时被多个进程一起读</li>
</ul>
</li>
</ul>
<h4 id="资源管理技术"><a href="#资源管理技术" class="headerlink" title="资源管理技术"></a>资源管理技术</h4><p><strong>复用、虚拟和抽象</strong>是三种基本的资源管理技术</p>
<ul>
<li>复用技术可以创建虚拟资源以解决物理资源数量不足的问题，包括空分复用共享和时分复用共享</li>
<li>虚拟技术是对资源进行转化、模拟或整合，把一个或多个物理资源转变成一个或多个逻辑上的对应物</li>
<li>操作系统可以对物理资源进行抽象，任何一种特定的硬件资源都有一个接口和一组复杂的基本操作<ul>
<li>资源抽象是指通过编制软件来屏蔽硬件资源的物理特性和实现细节，简化对硬件资源的操作、控制和使用</li>
</ul>
</li>
</ul>
<h4 id="三个基础抽象"><a href="#三个基础抽象" class="headerlink" title="三个基础抽象"></a>三个基础抽象</h4><p>基于资源，现代操作系统引入了三个核心概念: <strong>进程、虚存、文件</strong>，形成了三个最基础的抽象</p>
<ul>
<li><strong>进程抽象</strong>—是对已进入主存正在运行的程序在处理器上操作的状态集的抽象<ul>
<li>操作系统提供进程调度和上下文切换功能</li>
</ul>
</li>
<li><strong>虚存抽象</strong>—是对物理主存的抽象，进程可获得一个硕大的连续地址空间来存放可执行程序和数据，可使用虚拟地址来引用物理主存单元</li>
<li><strong>文件抽象</strong>—是对设备(磁盘)的抽象，通过将文件中的字节映射到存储设备的物理块中来实现文件抽象</li>
</ul>
<h3 id="1-3-2-程序控制的角度"><a href="#1-3-2-程序控制的角度" class="headerlink" title="1.3.2 程序控制的角度"></a>1.3.2 程序控制的角度</h3><h4 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h4><ul>
<li>CPU速度与I/O速度不匹配的矛盾非常突出</li>
<li>多道程序设计(multiprogramming)允许多个程序同时进入计算机系统的主存，通过竞争处理器资源获得交替执行</li>
<li>是操作系统的核心功能，中断技术和硬盘为其实现提供了支撑</li>
</ul>
<h4 id="多道程序设计的特点"><a href="#多道程序设计的特点" class="headerlink" title="多道程序设计的特点"></a>多道程序设计的特点</h4><ul>
<li>CPU与外部设备充分并行</li>
<li>外部设备之间充分并行</li>
<li>发挥CPU的使用效率</li>
<li>提高单位时间的算题量</li>
<li>但是，单道程序的运算时间会增加</li>
</ul>
<h4 id="多道程序系统的实现"><a href="#多道程序系统的实现" class="headerlink" title="多道程序系统的实现"></a>多道程序系统的实现</h4><ul>
<li>为进入内存执行的程序建立管理实体：<strong>进程</strong></li>
<li>OS应能管理与控制进程程序的执行</li>
<li>OS协调管理各类资源在进程间的使用<ul>
<li>处理器的管理和调度</li>
<li>主存储器的管理和调度</li>
<li>其他资源的管理和调度</li>
</ul>
</li>
</ul>
<h4 id="多道程序系统的实现要点"><a href="#多道程序系统的实现要点" class="headerlink" title="多道程序系统的实现要点"></a>多道程序系统的实现要点</h4><ul>
<li>如何使用资源：运行程序执行硬件提供的陷入指令调用操作系统提供的服务例程(如何陷入操作系统)</li>
<li>如何复用CPU：调度程序(在CPU空闲时让其他程序运行)</li>
<li>如何使CPU与I/O设备充分并行：硬件的设备控制器与通道(专用的I/O处理器)独立完成I/O</li>
<li>如何让正在运行的程序让出CPU：中断(中断正在执行的程序，引入OS处理)</li>
</ul>
<h3 id="1-3-3-操作控制计算机的角度"><a href="#1-3-3-操作控制计算机的角度" class="headerlink" title="1.3.3 操作控制计算机的角度"></a>1.3.3 操作控制计算机的角度</h3><h4 id="计算机操作控制方式"><a href="#计算机操作控制方式" class="headerlink" title="计算机操作控制方式"></a>计算机操作控制方式</h4><ul>
<li><p>OS规定了合理操作计算机的工作流程</p>
</li>
<li><p>OS的操作接口——系统程序</p>
<ul>
<li>为用户提供操作控制计算的所有服务</li>
</ul>
</li>
<li>OS的两类作业级接口<ul>
<li>脱机作业控制方式: 作业控制语言</li>
<li>联机作业控制方式: 操作控制命令</li>
</ul>
</li>
</ul>
<h4 id="脱机作业控制方式"><a href="#脱机作业控制方式" class="headerlink" title="脱机作业控制方式"></a>脱机作业控制方式</h4><ul>
<li>OS：提供作业说明语言</li>
<li>用户：编写作业说明书，确定作业加工控制的步骤，并于程序/数据一并提交</li>
<li>操作员：通过控制台成批输入作业</li>
<li>OS：通过作业控制程序自动控制、解释作业说明书，使得作业能够自动执行</li>
<li>例：批处理OS的作业控制方式、UNIX的Shell程序、DOS的bat文件</li>
</ul>
<h4 id="联机作业控制方式"><a href="#联机作业控制方式" class="headerlink" title="联机作业控制方式"></a>联机作业控制方式</h4><ul>
<li>计算机：提供<strong>终端</strong>(键盘/显示器)</li>
<li>用户：登陆系统</li>
<li>OS：提供<strong>命令解释程序</strong></li>
<li>用户：联机输入<strong>操作控制命令</strong>，直接控制作业步的执行</li>
<li>例：分时OS的交互控制方式</li>
</ul>
<h4 id="命令解释程序"><a href="#命令解释程序" class="headerlink" title="命令解释程序"></a>命令解释程序</h4><ul>
<li>命令解释程序：接受和执行一条用户提出的对作业的加工处理命令</li>
<li>当一个新的批作业被启动，或新的交互型用户登录进系统时，系统就自动地执行命令解释程序，负责读入控制卡或命令行，作出相应解释，并予以执行</li>
<li>会话语言：可编程的命令解释程序，例如Shell</li>
<li>图形化的命令控制方式</li>
<li>多通道交互的命令控制方式</li>
</ul>
<h4 id="命令解释程序的处理过程"><a href="#命令解释程序的处理过程" class="headerlink" title="命令解释程序的处理过程"></a>命令解释程序的处理过程</h4><ul>
<li>OS启动命令解释程序，输出命令提示符，等待键盘中断/行结束符/鼠标点击/多通道模式识别</li>
<li>每当用户输入一条命令(暂存在命令缓冲区)并按回车换行时，申请中断</li>
<li>CPU响应后，将控制权交给命令解释程序，接着读入命令缓冲区内容，分析命令、接受参数，执行处理代码</li>
</ul>
<h4 id="前台命令与后台命令"><a href="#前台命令与后台命令" class="headerlink" title="前台命令与后台命令"></a>前台命令与后台命令</h4><ul>
<li>前台命令执行结束后，再次输出命令提示符，等待下一条命令</li>
<li>后台命令处理启动后，即可接收下条命令</li>
</ul>
<h3 id="1-3-4-人机交互的角度"><a href="#1-3-4-人机交互的角度" class="headerlink" title="1.3.4 人机交互的角度"></a>1.3.4 人机交互的角度</h3><h3 id="1-3-5-程序接口的角度"><a href="#1-3-5-程序接口的角度" class="headerlink" title="1.3.5 程序接口的角度"></a>1.3.5 程序接口的角度</h3><h4 id="操作系统的程序接口"><a href="#操作系统的程序接口" class="headerlink" title="操作系统的程序接口"></a>操作系统的程序接口</h4><ul>
<li>操作系统的程序接口：操作系统为程序运行扩充的编程接口</li>
<li>系统调用：操作系统实现的完成某种特定功能的过程；为所有运行程序提供访问操作系统的接口</li>
<li>POSIX支持</li>
</ul>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>程序的运行空间分为内核空间和用户空间，程序各自按不同的特权运行</p>
<p>系统调用把应用程序的访问请求传送至内核，调用相应的服务例程完成所需处理，再将处理结果返回给应用程序</p>
<h4 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h4><ul>
<li>内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性</li>
<li>系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且使编程效率大大提高</li>
</ul>
<h4 id="系统调用的实现机制"><a href="#系统调用的实现机制" class="headerlink" title="系统调用的实现机制"></a>系统调用的实现机制</h4><ul>
<li>陷入处理机制：计算机系统中控制和实现系统调用的机制</li>
<li>陷入指令：也称访管指令，或异常中断指令，计算机系统为实现系统调用而引起处理器中断的指令</li>
<li>每个系统调用都事先规定了编号，称为<strong>功能号</strong>，并在约定寄存器中规定了传递给内部处理程序的参数</li>
</ul>
<h4 id="系统调用的实现要点"><a href="#系统调用的实现要点" class="headerlink" title="系统调用的实现要点"></a>系统调用的实现要点</h4><ul>
<li>编写系统调用处理程序</li>
<li>设计一张系统调用入口地址表，每个入口地址指向一个系统调用的处理程序，并包含系统调用自带参数的个数</li>
<li>陷入处理机制需开辟现场保护区，以保存发生系统调用时的处理器现场</li>
</ul>
<h4 id="系统调用的实现流程"><a href="#系统调用的实现流程" class="headerlink" title="系统调用的实现流程"></a>系统调用的实现流程</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220919105348293.png" alt="image-20220919105348293" style="zoom: 80%;" /></p>
<p>按号定位的前提</p>
<ul>
<li>各数据结构的尺寸相同</li>
<li>各数据结构按号连续排列</li>
</ul>
<h4 id="传递参数的方法"><a href="#传递参数的方法" class="headerlink" title="传递参数的方法"></a>传递参数的方法</h4><ul>
<li>陷入指令自带参数，可以规定陷入指令之后的若干单元存放参数，叫做直接参数；或者在指令之后紧邻的单元中存放参数的地址，叫做间接参数</li>
<li>通过CPU的通用寄存器传递参数，该方法不适用于传递大量参数，可以在主存的某个区或表中存放参数，将其首地址送入寄存器，实现参数传递</li>
<li>在主存中开辟专用堆栈区传递参数</li>
</ul>
<h4 id="Linux系统调用执行流程"><a href="#Linux系统调用执行流程" class="headerlink" title="Linux系统调用执行流程"></a>Linux系统调用执行流程</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220919110641932.png" alt="image-20220919110641932" style="zoom:67%;" /></p>
<h4 id="应用程序、库函数、系统调用的调用关系链"><a href="#应用程序、库函数、系统调用的调用关系链" class="headerlink" title="应用程序、库函数、系统调用的调用关系链"></a>应用程序、库函数、系统调用的调用关系链</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220919110743072.png" alt="image-20220919110743072" style="zoom: 50%;" /></p>
<p><strong>例：read系统调用的执行步骤</strong></p>
<p><code>int read(int fd, char *buf, int n)</code></p>
<p><code>read</code> 从文件描述符 <code>fd</code> 读 n 字节的内容写入 <code>buf</code>，返回值是成功读取的字节数。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220919111236909.png" alt="image-20220919111236909" style="zoom:67%;" /></p>
<h4 id="CPU进程间切换"><a href="#CPU进程间切换" class="headerlink" title="CPU进程间切换"></a>CPU进程间切换</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220919111438839.png" alt="image-20220919111438839" style="zoom:67%;" /></p>
<h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220919111530279.png" alt="image-20220919111530279" style="zoom: 80%;" /></p>
<h3 id="1-3-6-系统结构的角度"><a href="#1-3-6-系统结构的角度" class="headerlink" title="1.3.6 系统结构的角度"></a>1.3.6 系统结构的角度</h3><h4 id="操作系统软件的结构设计"><a href="#操作系统软件的结构设计" class="headerlink" title="操作系统软件的结构设计"></a>操作系统软件的结构设计</h4><ul>
<li>OS构件：内核、进程、线程、管程等</li>
<li>设计概念：模块化、层次化、虚拟化</li>
<li>内核设计时OS设计中最为复杂的部分</li>
</ul>
<h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><ul>
<li><p><strong>单内核</strong>：内核中各部件杂然混居的形态，始于1960年代，广泛使用；如Unix/Linux，及Windows(自称采用混合内核的CS结构)</p>
</li>
<li><p><strong>微内核</strong>：1980年代始，强调结构性部件与功能性部件的分离，大部分OS研究都集中在此</p>
</li>
<li><strong>混合内核</strong>：微内核和单内核的折中，较多组件在核心态中运行，以获得更快的执行速度</li>
<li><strong>外内核</strong>：尽可能减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化；部分嵌入式系统使用</li>
</ul>
<h4 id="操作系统实现的一种层次式结构"><a href="#操作系统实现的一种层次式结构" class="headerlink" title="操作系统实现的一种层次式结构"></a>操作系统实现的一种层次式结构</h4><div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220919113717873.png" alt="image-20220919113717873" style="zoom: 50%;" /></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220919113735045.png" alt="image-20220919113735045" style="zoom: 50%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/计算机操作系统/">计算机操作系统</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/11/08/编译原理-2-词法分析/"><span>编译原理(2) 词法分析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/11/08/编译原理-2-词法分析/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-08T15:51:56.000Z">
          2022-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="一、词法分析器生成器-ANTLR-v4"><a href="#一、词法分析器生成器-ANTLR-v4" class="headerlink" title="一、词法分析器生成器 ANTLR v4"></a>一、词法分析器生成器 ANTLR v4</h2><h3 id="1-输入与输出"><a href="#1-输入与输出" class="headerlink" title="1. 输入与输出"></a>1. 输入与输出</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108235621687.png" alt="image-20221108235621687" style="zoom:80%;" /></p>
<h3 id="2-词法分析器的三种设计方法"><a href="#2-词法分析器的三种设计方法" class="headerlink" title="2. 词法分析器的三种设计方法"></a>2. 词法分析器的三种设计方法</h3><p>由易到难</p>
<ul>
<li><p>词法分析器生成器:ANTLR</p>
<ul>
<li>输入规约(.g4)，自动生成词法分析器(lexer.java)</li>
<li>src —&gt; lexer —&gt; string of tokens</li>
</ul>
</li>
<li><p>手写词法分析器</p>
</li>
<li>自动化词法分析器</li>
</ul>
<blockquote>
<p>生产环境下的编译器 (如 gcc) 通常选择<strong>手写词法分析器</strong></p>
</blockquote>
<h3 id="3-ANTLR4"><a href="#3-ANTLR4" class="headerlink" title="3. ANTLR4"></a>3. ANTLR4</h3><h4 id="3-1-输入与输出"><a href="#3-1-输入与输出" class="headerlink" title="3.1 输入与输出"></a>3.1 输入与输出</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108235911855.png" alt="image-20221108235911855" style="zoom:80%;" /></p>
<h4 id="3-2-冲突解决规则"><a href="#3-2-冲突解决规则" class="headerlink" title="3.2 冲突解决规则"></a>3.2 冲突解决规则</h4><p>ANTLR v4 中两大<strong>冲突解决</strong>规则</p>
<ul>
<li><strong>最前优先匹配</strong>: 关键字 vs. 标识符</li>
<li><strong>最长优先匹配</strong>: &gt;=, ifhappy, thenext, 1.23</li>
</ul>
<h4 id="3-3-词法单元的规约"><a href="#3-3-词法单元的规约" class="headerlink" title="3.3 词法单元的规约"></a>3.3 词法单元的规约</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109000228279.png" alt="image-20221109000228279"></p>
<p>我们需要词法单元的<strong>形式化</strong>规约</p>
<blockquote>
<p>id: 字母开头的字母/数字串</p>
<p>id 定义了一个集合, 我们称之为<strong>语言 (Language)</strong></p>
<p>它使用了字母与数字等符号集合, 我们称之为<strong>字母表 (Alphabet)</strong></p>
<p>该语言中的每个元素 (即, 标识符) 称为<strong>串 (String)</strong></p>
</blockquote>
<h5 id="Definition-字母表"><a href="#Definition-字母表" class="headerlink" title="Definition (字母表)"></a>Definition (字母表)</h5><p>字母表 $\Sigma$ 是一个有限的符号集合。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109000640673.png" alt="image-20221109000640673" style="zoom: 80%;" /></p>
<h5 id="Definition-串"><a href="#Definition-串" class="headerlink" title="Definition (串)"></a>Definition (串)</h5><p>字母表 $\Sigma$ 上的串 ($s$) 是由 $\Sigma$ 中符号构成的一个<strong>有穷</strong>序列。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109000729588.png" alt="image-20221109000729588" style="zoom:80%;" /></p>
<h5 id="Definition-串上的-“连接”-运算"><a href="#Definition-串上的-“连接”-运算" class="headerlink" title="Definition (串上的 “连接” 运算)"></a>Definition (串上的 “连接” 运算)</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109000814846.png" alt="image-20221109000814846" style="zoom:80%;" /></p>
<h5 id="Definition-串上的-“指数”-运算"><a href="#Definition-串上的-“指数”-运算" class="headerlink" title="Definition (串上的 “指数” 运算)"></a>Definition (串上的 “指数” 运算)</h5><p>也是连接</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109000844290.png" alt="image-20221109000844290" style="zoom:80%;" /></p>
<h5 id="Definition-语言"><a href="#Definition-语言" class="headerlink" title="Definition (语言)"></a>Definition (语言)</h5><p>语言是给定字母表 $\Sigma$ 上一个任意的<strong>可数的</strong>串集合。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109160847077.png" alt="image-20221109160847077" style="zoom:80%;" /></p>
<p><strong>语言是串的集合</strong></p>
<p>因此, 我们可以通过集合操作<strong>构造</strong>新的语言。</p>
<h4 id="3-4-语言的集合操作"><a href="#3-4-语言的集合操作" class="headerlink" title="3.4 语言的集合操作"></a>3.4 语言的集合操作</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109161009360.png" alt="image-20221109161009360" style="zoom:80%;" /></p>
<p>$L^* = (L^0) ∪ (L^1) ∪ (L^2) ∪ (L^3)$…</p>
<p>$L^+ = (L^1) ∪ (L^2) ∪ (L^3)$…</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109161535054.png" alt="image-20221109161535054" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115163150026.png" alt="image-20221115163150026"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109161603205.png" alt="image-20221109161603205" style="zoom:80%;" /></p>
<h4 id="3-5-正则表达式"><a href="#3-5-正则表达式" class="headerlink" title="3.5 正则表达式"></a>3.5 正则表达式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153140556.png" alt="image-20221109153140556" style="zoom:80%;" /></p>
<h5 id="Definition-正则表达式"><a href="#Definition-正则表达式" class="headerlink" title="Definition (正则表达式)"></a>Definition (正则表达式)</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109153528379.png" alt="image-20221109153528379" style="zoom:80%;" /></p>
<h5 id="Definition-正则表达式对应的正则语言"><a href="#Definition-正则表达式对应的正则语言" class="headerlink" title="Definition (正则表达式对应的正则语言)"></a>Definition (正则表达式对应的正则语言)</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109163520346.png" alt="image-20221109163520214" style="zoom:80%;" /></p>
<p><strong>举例</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109163813902.png" alt="image-20221109163813902" style="zoom:80%;" /></p>
<h5 id="正则语法"><a href="#正则语法" class="headerlink" title="正则语法"></a>正则语法</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109170417873.png" alt="image-20221109170417873" style="zoom:80%;" /></p>
<p>antlr中 . 可以匹配换行</p>
<p>antlr中使用~[abc]而不是[^abc]</p>
<p>注意转义</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221109170509879.png" alt="image-20221109170509879"></p>
<blockquote>
<p>$(0|(1(01^*0)^∗1))^∗$ 匹配所有3的倍数(二进制表示)</p>
<p><a target="_blank" rel="noopener" href="https://regex101.com/r/ED4qgC/1">https://regex101.com/r/ED4qgC/1</a></p>
</blockquote>
<h2 id="二、手写词法分析器"><a href="#二、手写词法分析器" class="headerlink" title="二、手写词法分析器"></a>二、手写词法分析器</h2><p><strong>代码见：</strong><a target="_blank" rel="noopener" href="https://github.com/courses-at-nju-by-hfwei/2022-compilers-coding">https://github.com/courses-at-nju-by-hfwei/2022-compilers-coding</a></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115165313782.png" alt="image-20221115165313782"></p>
<h3 id="1-分支与循环"><a href="#1-分支与循环" class="headerlink" title="1. 分支与循环"></a>1. 分支与循环</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115171159071.png" alt="image-20221115171159071"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历所有Token</span><br><span class="hljs-type">Token</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> lexer.nextToken();<br><span class="hljs-keyword">while</span> (token != Token.EOF) &#123;<br>    <span class="hljs-keyword">if</span> (token != Token.WS) &#123;<br>        System.out.println(token);<br>    &#125;<br>    token = lexer.nextToken();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-状态转移图"><a href="#2-状态转移图" class="headerlink" title="2. 状态转移图"></a>2. 状态转移图</h3><h4 id="2-1-用于识别-ws-的状态转移图"><a href="#2-1-用于识别-ws-的状态转移图" class="headerlink" title="2.1 用于识别 ws 的状态转移图"></a>2.1 用于识别 ws 的状态转移图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115172525171.png" alt="image-20221115172525171" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 后面的示例省略nextToken中的分支代码</span><br><span class="hljs-keyword">public</span> Token <span class="hljs-title function_">nextToken</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">if</span> (Character.isWhitespace(peek)) &#123;<br>      	<span class="hljs-keyword">return</span> WS();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">WS</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (Character.isWhitespace(peek)) &#123;<br>      	advance();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Token.WS;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-用于识别-id-的状态转移图"><a href="#2-2-用于识别-id-的状态转移图" class="headerlink" title="2.2 用于识别 id 的状态转移图"></a>2.2 用于识别 id 的状态转移图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115172813225.png" alt="image-20221115172813225" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">ID</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">do</span> &#123;<br>      	sb.append(peek);<br>      	advance();<br>    &#125; <span class="hljs-keyword">while</span> (Character.isLetterOrDigit(peek));<br>	<span class="hljs-comment">// 判断是不是保留字</span><br>    <span class="hljs-type">Token</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.kwTable.getKeyword(sb.toString());<br>    <span class="hljs-keyword">if</span> (token == <span class="hljs-literal">null</span>) &#123;<br>      	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.ID, sb.toString());<br>    &#125;<br>    <span class="hljs-keyword">return</span> token;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-3-用于识别-int-的状态转移图"><a href="#2-3-用于识别-int-的状态转移图" class="headerlink" title="2.3 用于识别 int 的状态转移图"></a>2.3 用于识别 int 的状态转移图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115173217304.png" alt="image-20221115173217304" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">INT</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">do</span> &#123;<br>      	sb.append(peek);<br>     	advance();<br>    &#125; <span class="hljs-keyword">while</span> (Character.isDigit(peek));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.INT, sb.toString());<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-用于识别-relop-的状态转移图"><a href="#2-4-用于识别-relop-的状态转移图" class="headerlink" title="2.4 用于识别 relop 的状态转移图"></a>2.4 用于识别 relop 的状态转移图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115173556563.png" alt="image-20221115173556563" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>  	advance();<br>  	<span class="hljs-keyword">return</span> Token.EQ;<br>&#125;<br><br><span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;&gt;&#x27;</span>) &#123;<br>  	advance();<br>  	<span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>    	advance();<br>    	<span class="hljs-keyword">return</span> Token.GE;<br>  	&#125;<br>  	<span class="hljs-keyword">return</span> Token.GT;<br>&#125;<br><br><span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>  	advance();<br>  	<span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>    	advance();<br>    	<span class="hljs-keyword">return</span> Token.LE;<br>  	&#125;<br>  	<span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;&gt;&#x27;</span>) &#123;<br>    	advance();<br>    	<span class="hljs-keyword">return</span> Token.NE;<br>  	&#125;<br>  	<span class="hljs-keyword">return</span> Token.GT;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-5-错误处理"><a href="#2-5-错误处理" class="headerlink" title="2.5 错误处理"></a>2.5 错误处理</h4><p>识别字符串 $s$ 中符合某种词法单元模式的前缀词素(<code>nextToken()</code>)</p>
<p><strong>关键点：</strong>合并 22, 12, 9, 0, 根据<em>下一个字符</em>即可判定词法单元的类型。否则, 调用错误处理模块(对应 other), 报告<em>该字符有误</em>, 并忽略该字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// unknown tokens (characters)</span><br><span class="hljs-type">Token</span> <span class="hljs-variable">unknown</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.UNKNOWN, Character.toString(peek));<br>advance();<br><span class="hljs-keyword">return</span> unknown;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115173952384.png" alt="image-20221115173952384"></p>
<h4 id="2-6-用于识别-num-的状态转移图"><a href="#2-6-用于识别-num-的状态转移图" class="headerlink" title="2.6 用于识别 num 的状态转移图"></a>2.6 用于识别 num 的状态转移图</h4><h5 id="2-6-1-分为三个部分"><a href="#2-6-1-分为三个部分" class="headerlink" title="2.6.1 分为三个部分"></a>2.6.1 分为三个部分</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115174022886.png" alt="image-20221115174022886" style="zoom:80%;" /></p>
<h5 id="2-6-2-完整"><a href="#2-6-2-完整" class="headerlink" title="2.6.2 完整"></a>2.6.2 完整</h5><p>num: 整数部分[. 可选的小数部分][E[可选的 +-] 可选的指数部分]</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115174225767.png" alt="image-20221115174225767" style="zoom:80%;" /></p>
<p><strong>关键点</strong>: 合并 22, 12, 9, 0, 根据<em>下一个字符</em>即可判定词法单元的类型。否则, 调用错误处理模块 (对应 other), 报告<em>该字符有误</em>, 忽略该字符。</p>
<p>注意, 在 real 与 sci 中, 有时需要<strong>回退</strong>, 寻找最长匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Token <span class="hljs-title function_">NUMBER</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">intStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    intStr.append(peek);<br>    advance();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">intPos</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">realPos</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">realStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sciStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">13</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">switch</span> (state) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:<br>                intPos = pos;<br>                <span class="hljs-keyword">if</span> (Character.isDigit(peek)) &#123;<br>                    intStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">13</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    realStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">14</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;E&#x27;</span> || peek == <span class="hljs-string">&#x27;e&#x27;</span>) &#123;<br>                    sciStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">16</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.INT, intStr.toString());<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>:<br>                <span class="hljs-keyword">if</span> (Character.isDigit(peek)) &#123;<br>                    realStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">15</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">this</span>.reset(intPos);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.INT, intStr.toString());<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:<br>                realPos = pos;<br>                <span class="hljs-keyword">if</span> (Character.isDigit(peek)) &#123;<br>                    realStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">15</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;E&#x27;</span> || peek == <span class="hljs-string">&#x27;e&#x27;</span>) <br>                    sciStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">16</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.REAL, intStr.append(realStr).toString());<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>:<br>                <span class="hljs-keyword">if</span> (peek == <span class="hljs-string">&#x27;+&#x27;</span> || peek == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    sciStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">17</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isDigit(peek)) &#123;<br>                    sciStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">18</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">this</span>.reset(realPos);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.REAL, intStr.append(realStr).toString());<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>:<br>                <span class="hljs-keyword">if</span> (Character.isDigit(peek)) &#123;<br>                    sciStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">18</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">this</span>.reset(realPos);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.REAL, intStr.append(realStr).toString());<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>:<br>                <span class="hljs-keyword">if</span> (Character.isDigit(peek)) &#123;<br>                    sciStr.append(peek);<br>                    advance();<br>                    state = <span class="hljs-number">18</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Token</span>(TokenType.SCI, intStr.append(realStr).append(sciStr).toString());<br>                &#125;<br>            <span class="hljs-keyword">default</span>:<br>                System.err.println(<span class="hljs-string">&quot;Unreachable&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="三、自动机理论与词法分析器生成器"><a href="#三、自动机理论与词法分析器生成器" class="headerlink" title="三、自动机理论与词法分析器生成器"></a>三、自动机理论与词法分析器生成器</h2><h3 id="1-自动机"><a href="#1-自动机" class="headerlink" title="1. 自动机"></a>1. 自动机</h3><p>(Automaton 单数; Automata 复数)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115231221748.png" alt="image-20221115231221748" style="zoom:80%;" /></p>
<ul>
<li><p>两大要素：<strong>状态集</strong> $S$ 以及<strong>状态转移函数</strong> $\delta$</p>
</li>
<li><p>根据<strong>表达/计算能力</strong>的强弱, 自动机可以分为不同层次</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115231515551.png" alt="image-20221115231515551" style="zoom:80%;" /></p>
<h3 id="2-目标：正则表达式-RE-gt-词法分析器"><a href="#2-目标：正则表达式-RE-gt-词法分析器" class="headerlink" title="2. 目标：正则表达式 RE ==&gt; 词法分析器"></a>2. 目标：正则表达式 RE ==&gt; 词法分析器</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115231625992.png" alt="image-20221115231625992" style="zoom:80%;" /></p>
<blockquote>
<p>终点固然令人向往, 这一路上的风景更是美不胜收</p>
</blockquote>
<h4 id="2-1-Definition-NFA-Nondeterministic-Finite-Automaton"><a href="#2-1-Definition-NFA-Nondeterministic-Finite-Automaton" class="headerlink" title="2.1 Definition (NFA (Nondeterministic Finite Automaton))"></a>2.1 Definition (NFA (Nondeterministic Finite Automaton))</h4><ul>
<li><p>非确定性有穷自动机 $\mathcal{A}$ 是一个五元组 $\textcolor{red}{\mathcal{A} = (\Sigma, S, s_0, \delta, F)}$:</p>
<ol>
<li><p>字母表 $\Sigma (\epsilon \notin \Sigma)$</p>
</li>
<li><p><strong>有穷</strong>的状态集合 $S$</p>
</li>
<li><p><strong>唯一</strong>的初始状态 $s_0 \in S$</p>
</li>
<li><p>状态转移<strong>函数</strong> $\delta$</p>
<p>$\delta: S \times (\Sigma \cup \{ \textcolor{blue}{\epsilon} \}) \rightarrow \textcolor{blue}{2^S} $</p>
</li>
<li><p>接受状态集合 $F \subseteq S$</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115234212017.png" alt="image-20221115234212017" style="zoom:80%;" /></p>
<blockquote>
<p>非确定性的来源：$\delta: S \times (\Sigma \cup \{ \textcolor{blue}{\epsilon} \}) \rightarrow \textcolor{blue}{2^S} $</p>
<ul>
<li><p>$\epsilon$: 没有新来的字符也可能转移状态</p>
</li>
<li><p>接受同一个字符可能转移到不同的状态</p>
</li>
</ul>
<p>$2^S$ 表示 $S$ 的所有子集, 包括空集</p>
</blockquote>
<ul>
<li><strong>约定：</strong>所有没有对应出边的字符默认指向一个不存在的 <strong>“空状态”</strong> $\emptyset$</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115232743665.png" alt="image-20221115232743665" style="zoom:80%;" /></p>
<ul>
<li>提出</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115232932323.png" alt="image-20221115232932323" style="zoom:80%;" /></p>
<blockquote>
<p>“<em>which introduced the idea of <strong>nondeterministic machines</strong>, which has proved to be an enormously valuable concept.</em>”</p>
</blockquote>
<ul>
<li>(非确定性)有穷自动机是一类极其简单的<strong>计算</strong>装置</li>
<li>它可以<strong>识别</strong> (接受/拒绝) $\Sigma$ 上的字符串</li>
</ul>
<h4 id="2-2-Definition-接受-Accept"><a href="#2-2-Definition-接受-Accept" class="headerlink" title="2.2 Definition (接受 (Accept))"></a>2.2 Definition (接受 (Accept))</h4><ul>
<li><p>(非确定性)有穷自动机 $\mathcal{A}$ 接受字符串 $x$, 当且仅当<strong>存在</strong>一条从开始状态 $s_0$ 到<strong>某个</strong>接受状态 $f ∈ F$、标号为 $x$ 的路径。</p>
</li>
<li><p>因此 $\mathcal{A}$ 定义了一种<strong>语言</strong> $L(\mathcal{A})$: 它能接受的所有字符串构成的集合</p>
<blockquote>
<p>若该语言与某一 RE 定义的语言相等, 则表示该 RE 与该 NFA 等价</p>
</blockquote>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115234754835.png" alt="image-20221115234754835" style="zoom:80%;" /></p>
<h4 id="2-3-关于自动机-mathcal-A-的两个基本问题"><a href="#2-3-关于自动机-mathcal-A-的两个基本问题" class="headerlink" title="2.3 关于自动机 $\mathcal{A}$ 的两个基本问题"></a>2.3 关于自动机 $\mathcal{A}$ 的两个基本问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115234935877.png" alt="image-20221115234935877" style="zoom:80%;" /></p>
<ul>
<li><p>例1</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115235112210.png" alt="image-20221115235112210" style="zoom:80%;" /></p>
<ul>
<li>$aaa \in \mathcal{A}$: 接受</li>
<li><p>$aab \in \mathcal{A}$: 不接受</p>
</li>
<li><p>$\textcolor{red}{L(\mathcal{A})} = L((aa^{\ast} | bb^{\ast}))$</p>
</li>
</ul>
</li>
<li><p>例2</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115235502815.png" alt="image-20221115235502815" style="zoom:80%;" /></p>
<ul>
<li>$1011 \in L(\mathcal{A})$: 不接受</li>
<li>$0011 \in L(\mathcal{A})$: 接受</li>
<li>$L(\mathcal{A}) = \{包含偶数个 1 或偶数个 0 的 01 串\}$</li>
</ul>
</li>
</ul>
<h4 id="2-4-Definition-DFA-Deterministic-Finite-Automaton"><a href="#2-4-Definition-DFA-Deterministic-Finite-Automaton" class="headerlink" title="2.4 Definition (DFA (Deterministic Finite Automaton))"></a>2.4 Definition (DFA (Deterministic Finite Automaton))</h4><ul>
<li><p>确定性有穷自动机 $\mathcal{A}$ 是一个五元组 $\textcolor{red}{\mathcal{A} = (\Sigma, S, s_0, \delta, F)}$:</p>
<ol>
<li><p>字母表 $\Sigma (\epsilon \notin \Sigma)$</p>
</li>
<li><p><strong>有穷</strong>的状态集合 $S$</p>
</li>
<li><p><strong>唯一</strong>的初始状态 $s_0 \in S$</p>
</li>
<li><p>状态转移<strong>函数</strong> $\delta$</p>
<p>$\delta: S \times \textcolor{blue}{\Sigma} \rightarrow \textcolor{blue}{S} $</p>
</li>
<li><p>接受状态集合 $F \subseteq S$</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116000025625.png" alt="image-20221116000025625" style="zoom:80%;" /></p>
</li>
<li><p><strong>约定</strong>: 所有没有对应出边的字符默认指向一个不存在的 <strong>“死状态”</strong></p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116000213842.png" alt="image-20221116000213842" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116000313618.png" alt="image-20221116000313618" style="zoom:80%;" /></p>
<blockquote>
<p>上面的确定性自动机和非确定性自动机是等价的</p>
</blockquote>
<h4 id="2-5-归纳"><a href="#2-5-归纳" class="headerlink" title="2.5 归纳"></a>2.5 归纳</h4><ul>
<li>NFA 简洁易于理解, 便于描述语言 $\textcolor{blue}{L(\mathcal{A})}$</li>
<li>DFA 易于判断 $\textcolor{blue}{x \in L(\mathcal{A})}$, 适合产生词法分析器</li>
<li>用 NFA 描述语言, 用 DFA 实现词法分析器</li>
<li>$\textcolor{red}{RE \Rightarrow NFA \Rightarrow DFA \Rightarrow 词法分析器}$</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115231625992.png" alt="image-20221115231625992" style="zoom:80%;" /></p>
<h3 id="3-RE-Rightarrow-NFA"><a href="#3-RE-Rightarrow-NFA" class="headerlink" title="3. RE $\Rightarrow$ NFA"></a>3. RE $\Rightarrow$ NFA</h3><ul>
<li><p>$r \Rightarrow N(r)$</p>
</li>
<li><p>要求：$\textcolor{red}{L(N(r)) = L(r)}$</p>
</li>
<li><p>从 RE 到 NFA: <strong>Thompson 构造法</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116142610957.png" alt="image-20221116142610957" style="zoom:80%;" /></p>
</li>
<li><p>Thompson 构造法的基本思想: <strong>按结构归纳</strong></p>
</li>
</ul>
<h4 id="3-1-Definition-正则表达式"><a href="#3-1-Definition-正则表达式" class="headerlink" title="3.1 Definition (正则表达式)"></a>3.1 Definition (正则表达式)</h4><ul>
<li><p>给定字母表 $\Sigma$ , $\Sigma$ 上的正则表达式<strong>由且仅由</strong>以下规则定义:</p>
<ol>
<li>$\epsilon$ 是正则表达式</li>
<li>$\forall a \in \Sigma$, $a$ 是正则表达式</li>
<li>如果 $s$ 是正则表达式, 则 $(s)$ 是正则表达式</li>
<li>如果 $s$ 和 $t$ 是正则表达式, 则 $s|t, st, s^{*}$ 也是正则表达式</li>
</ol>
</li>
</ul>
<ul>
<li><p>$\epsilon$ 是正则表达式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116144106907.png" alt="image-20221116144106907" style="zoom:80%;" /></p>
</li>
<li><p>$a \in \Sigma$ 是正则表达式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116144202213.png" alt="image-20221116144202213" style="zoom:80%;" /></p>
</li>
<li><p>如果 $s$ 是正则表达式, 则 $(s)$ 是正则表达式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116144239653.png" alt="image-20221116144239653" style="zoom:80%;" /></p>
</li>
<li><p>如果 $s$, $t$ 是正则表达式, 则 $s|t$ 是正则表达式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116144408101.png" alt="image-20221116144408101" style="zoom:80%;" /></p>
<ul>
<li>如果 $N(s)$ 或 $N(t)$ 的开始状态或接受状态不唯一, 怎么办?<ul>
<li>根据<strong>归纳假设</strong>, $N(s)$ 与 $N(t)$ 的开始状态与接受状态均<strong>唯一</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>如果 $s$, $t$ 是正则表达式, 则 $st$ 是正则表达式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116144528037.png" alt="image-20221116144528037" style="zoom:80%;" /></p>
<ul>
<li>根据<strong>归纳假设</strong>, $N(s)$ 与 $N(t)$ 的开始状态与接受状态均<strong>唯一</strong></li>
</ul>
</li>
<li><p>如果 $s$ 是正则表达式, 则 $s^{*}$ 是正则表达式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116144724260.png" alt="image-20221116144724260" style="zoom:80%;" /></p>
<ul>
<li>根据<strong>归纳假设</strong>, $N(s)$ 的开始状态与接受状态均<strong>唯一</strong></li>
</ul>
</li>
</ul>
<h4 id="3-2-N-r-的性质以及-Thompson-构造法复杂度分析"><a href="#3-2-N-r-的性质以及-Thompson-构造法复杂度分析" class="headerlink" title="3.2 $N(r)$ 的性质以及 Thompson 构造法复杂度分析"></a>3.2 $N(r)$ 的性质以及 Thompson 构造法复杂度分析</h4><ul>
<li><p>$N(r)$ 的开始状态与接收状态均<strong>唯一</strong></p>
</li>
<li><p>开始状态没有入边, 接收状态没有出边</p>
</li>
<li><p>$N(r)$ 的<strong>状态数</strong> $|S| \le 2 \times |r|$</p>
<p>($|r|: r$ 中运算符与运算分量的总和)</p>
</li>
<li><p>每个状态最多有两个 $\epsilon$-入边与两个 $\epsilon$-出边</p>
</li>
<li>$\forall a \in \Sigma$, 每个状态最多有一个 $a$-入边与一个 $a$-出边</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116165020990.png" alt="image-20221116165020990" style="zoom:80%;" /></p>
<h3 id="4-NFA-Rightarrow-DFA"><a href="#4-NFA-Rightarrow-DFA" class="headerlink" title="4. NFA $\Rightarrow$ DFA"></a>4. NFA $\Rightarrow$ DFA</h3><ul>
<li><p>$N \Rightarrow D$</p>
</li>
<li><p>要求: $\textcolor{red}{L(D) = L(N)}$</p>
</li>
<li><p>从 NFA 到 DFA 的转换: <strong>子集构造法</strong>(Subset/Powerset Construction)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116165300828.png" alt="image-20221116165300828" style="zoom:80%;" /></p>
</li>
<li><p><strong>思想: 用 DFA 模拟 NFA</strong></p>
</li>
</ul>
<h4 id="4-1-用-DFA-模拟-NFA"><a href="#4-1-用-DFA-模拟-NFA" class="headerlink" title="4.1 用 DFA 模拟 NFA"></a>4.1 用 DFA 模拟 NFA</h4><p>$\textcolor{blue}{L(\mathcal{A}) = L((a|b)^{*}abb)}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116170259111.png" alt="image-20221116170259111" style="zoom:80%;" /></p>
<ul>
<li><p>过程</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116170337732.png" alt="image-20221116170337732" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="4-2-epsilon-闭包"><a href="#4-2-epsilon-闭包" class="headerlink" title="4.2 $\epsilon$-闭包"></a>4.2 $\epsilon$-闭包</h4><ul>
<li><p>从状态 $s$ 开始, 只通过 $\epsilon$-转移可达的状态集合</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116170523291.png" alt="image-20221116170523291" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116170532028.png" alt="image-20221116170532028" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116170546504.png" alt="image-20221116170546504" style="zoom:80%;" /></p>
</li>
<li><p><strong>闭包(Closure): $f$-closure($T$)</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116172358836.png" alt="image-20221116172358836" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="4-3-子集构造法-N-Rightarrow-D-的原理"><a href="#4-3-子集构造法-N-Rightarrow-D-的原理" class="headerlink" title="4.3 子集构造法($N \Rightarrow D$)的原理"></a>4.3 子集构造法($N \Rightarrow D$)的原理</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116170833733.png" alt="image-20221116170833733" style="zoom:80%;" /></p>
<h4 id="4-4-子集构造法的复杂度分析"><a href="#4-4-子集构造法的复杂度分析" class="headerlink" title="4.4 子集构造法的复杂度分析"></a>4.4 子集构造法的复杂度分析</h4><p>$(|S_{N}| = n)$</p>
<ul>
<li><p>$|S_{D}| = \Theta (2^{n})$</p>
</li>
<li><p>最坏情况下, $|S_{D}| = \Omega (2^{n})$</p>
</li>
<li><p>最坏情况举例</p>
<ul>
<li><p>$L_{n} = (a|b)^{*}a(a|b)^{n-1}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116172141260.png" alt="image-20221116172141260" style="zoom:80%;" /></p>
</li>
<li><p>当 n = 4</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116172204829.png" alt="image-20221116172204829" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
<h3 id="5-DFA-最小化"><a href="#5-DFA-最小化" class="headerlink" title="5. DFA 最小化"></a>5. DFA 最小化</h3><p>$\textcolor{blue}{L(\mathcal{A}) = L((a|b)^{*}abb)}$</p>
<ul>
<li><p>子集构造法得到的 DFA</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116172537563.png" alt="image-20221116172537563" style="zoom:80%;" /></p>
</li>
<li><p>最小化后的 DFA</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116172557173.png" alt="image-20221116172557173" style="zoom:80%;" /></p>
</li>
<li><p><strong>DFA 最小化算法</strong>基本思想: <strong>等价</strong>的状态可以合并</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116172644918.png" alt="image-20221116172644918" style="zoom:80%;" /></p>
<blockquote>
<p><em>“With Robert E. Tarjan, for fundamental achievements in the design and analysis of algorithms and data structures” — Turing Award, 1986</em></p>
</blockquote>
</li>
</ul>
<h4 id="5-1-如何定义等价状态"><a href="#5-1-如何定义等价状态" class="headerlink" title="5.1 如何定义等价状态"></a>5.1 如何定义等价状态</h4><blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116220414892.png" alt="image-20221116220414892" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116220456076.png" alt="image-20221116220456076" style="zoom:80%;" /></p>
<p>按照错误定义可得: $A \sim C \sim E$</p>
<p>但是, 接收状态与非接收状态必定不等价</p>
<p>空串 $\epsilon$ <strong>区分</strong>了这两类状态</p>
</blockquote>
<ul>
<li><p><strong>正确定义</strong>：</p>
<p>$s \sim t \iff \forall a \in \Sigma. \left((s \stackrel{a}{\rightarrow} s’) \land (t \stackrel{a}{\rightarrow} t’)\right) \implies (\textcolor{red}{s’ \sim t’})$</p>
<p>$s \nsim t \iff \exists a \in \Sigma. (s \stackrel{a}{\rightarrow} s’) \land (t \stackrel{a}{\rightarrow} t’) \land (\textcolor{red}{s’ \nsim t’})$</p>
</li>
</ul>
<h4 id="5-2-合并-or-划分"><a href="#5-2-合并-or-划分" class="headerlink" title="5.2 合并 or 划分"></a>5.2 合并 or 划分</h4><h5 id="5-2-1-合并"><a href="#5-2-1-合并" class="headerlink" title="5.2.1 合并"></a>5.2.1 合并</h5><ul>
<li><p>$s \sim t \iff \forall a \in \Sigma. \left((s \stackrel{a}{\rightarrow} s’) \land (t \stackrel{a}{\rightarrow} t’)\right) \implies (\textcolor{red}{s’ \sim t’})$</p>
</li>
<li><p>基于该定义, 不断<strong>合并</strong>等价的状态, 直到无法合并为止</p>
</li>
<li><p><strong>但是, 这是一个递归定义, 从哪里开始呢</strong></p>
<blockquote>
<p>Q: 所有的接收状态都是等价的吗？</p>
<p>A: 当然不</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116225047710.png" alt="image-20221116225047710" style="zoom:80%;" /></p>
</blockquote>
</li>
<li><p>缺少基础情况, 不知从何下手</p>
</li>
<li><strong>划分, 而非合并</strong></li>
</ul>
<h5 id="5-2-2-划分"><a href="#5-2-2-划分" class="headerlink" title="5.2.2 划分"></a>5.2.2 划分</h5><ul>
<li>$s \nsim t \iff \exists a \in \Sigma. (s \stackrel{a}{\rightarrow} s’) \land (t \stackrel{a}{\rightarrow} t’) \land (\textcolor{red}{s’ \nsim t’})$<ul>
<li>从哪里开始呢?</li>
</ul>
</li>
<li>$\Pi = \set{F, S \setminus F}$<ul>
<li><strong>接收状态与非接收状态必定不等价</strong></li>
<li>空串 $\epsilon$ <strong>区分</strong>了这两类状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>Definition (字符串 $x$ 区分状态 $s$ 与 $t$)</p>
<ul>
<li>如果分别从 $s$ 与 $t$ 出发, 沿着标号为 $x$ 的路径到达的两个状态中只有一个是接受状态, 则称 $x$ <strong>区分</strong>了状态 $s$ 与 $t$。</li>
</ul>
<p>Definition (可区分的 (Distinguishable))</p>
<ul>
<li>如果存在某个能区分状态 $s$ 与 $t$ 的字符串, 则称 $s$ 与 $t$ 是可区分的。</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116230131399.png" alt="image-20221116230131399" style="zoom:80%;" /></p>
<ul>
<li><p>划分步骤</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117131345963.png" alt="image-20221117131345963" style="zoom: 67%;" /></p>
</li>
<li><p><strong>合并</strong>等价状态 $A \sim C$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116230509789.png" alt="image-20221116230509789" style="zoom:80%;" /></p>
</li>
</ul>
<blockquote>
<p>Q: 合并后是否一定还是 DFA? 初始状态、接受状态是哪些?</p>
<p>A: 是, 包含原来初始状态与接收状态的状态</p>
</blockquote>
<h4 id="5-3-算法总览"><a href="#5-3-算法总览" class="headerlink" title="5.3 算法总览"></a>5.3 算法总览</h4><p>DFA 最小化<strong>等价状态划分</strong>方法</p>
<ul>
<li><p>$\Pi = \set{F, S \setminus F}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221116230748683.png" alt="image-20221116230748683" style="zoom:80%;" /></p>
</li>
<li><p>直到再也无法<strong>划分</strong>为止 (<strong>不动点!</strong>)</p>
</li>
<li><p>然后, 将同一等价类里的状态<strong>合并</strong></p>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>这是 <strong>DFA</strong> 最小化算法, 要保证状态图完整</li>
<li>要先检查是否需要补 “死状态” $\emptyset$</li>
</ul>
<blockquote>
<p>如何分析 DFA 最小化算法的复杂度?</p>
<p>为什么 DFA 最小化算法是正确的?</p>
<p>最小化 DFA 是唯一的吗?</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DFA_minimization">DFA Minimization @ wiki</a></p>
</blockquote>
<h3 id="6-DFA-Rightarrow-词法分析器"><a href="#6-DFA-Rightarrow-词法分析器" class="headerlink" title="6. DFA $\Rightarrow$ 词法分析器"></a>6. DFA $\Rightarrow$ 词法分析器</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124164547540.png" alt="image-20221124164547540" style="zoom:80%;" /></p>
<ul>
<li>最前优先匹配: $abb$ (比如<strong>关键字</strong>)</li>
<li>最长优先匹配: $aabbb$</li>
</ul>
<h4 id="6-1-根据正则表达式构造相应的-NFA"><a href="#6-1-根据正则表达式构造相应的-NFA" class="headerlink" title="6.1 根据正则表达式构造相应的 NFA"></a>6.1 根据正则表达式构造相应的 NFA</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124164702365.png" alt="image-20221124164702365" style="zoom:80%;" /></p>
<p>合并这三个 NFA, 构造 $a|abb|a^*b^+$ 对应的 NFA</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124164820073.png" alt="image-20221124164820073" style="zoom:80%;" /></p>
<h4 id="6-2-使用子集构造法将-NFA-转化为等价的-DFA"><a href="#6-2-使用子集构造法将-NFA-转化为等价的-DFA" class="headerlink" title="6.2 使用子集构造法将 NFA 转化为等价的 DFA"></a>6.2 使用子集构造法将 NFA 转化为等价的 DFA</h4><ul>
<li><strong>并消除 “死状态”</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124164922855.png" alt="image-20221124164922855" style="zoom:80%;" /></p>
<ul>
<li>注意：要保留各个 NFA 的<strong>接受状态</strong>信息, 并采用<strong>最前优先匹配</strong>原则</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124170335679.png" alt="image-20221124170335679" style="zoom:80%;" /></p>
<ul>
<li>$\forall a \in \Sigma.\delta(\emptyset, a) = \emptyset$<ul>
<li>需要<strong>消除</strong> “死状态”, 避免词法分析器徒劳消耗输入流</li>
</ul>
</li>
</ul>
<p>模拟运行该 DFA, <strong>直到无法继续为止</strong> (<em>输入结束或状态无转移</em>);</p>
<ul>
<li><p>假设此时状态为 $s$</p>
<ul>
<li><p>若 $s$ 为接受状态, 则识别成功;</p>
</li>
<li><p>否则, <strong>回溯</strong> (<em>包括状态与输入流</em>) 至最近一次经过的接受状态, 识别成功;</p>
</li>
<li><p>若没有经过任何接受状态, 则<strong>报错</strong> (<em>忽略第一个字符</em>)</p>
</li>
<li><p>无论成功还是失败, 都从<strong>初始状态</strong>开始继续识别下一个词法单元</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>$x = a$ 输入结束; 接受; 识别出 $a$</p>
<p>$x = abba$ 状态无转移; 回溯成功; 识别出 $abb$</p>
<p>$x = aaaa$ 输入结束; 回溯成功; 识别出 $a$</p>
<p>$x = cabb$ 状态无转移; 回溯失败; 报错 $c$</p>
</blockquote>
<h4 id="6-3-特定于词法分析器的-DFA-最小化方法"><a href="#6-3-特定于词法分析器的-DFA-最小化方法" class="headerlink" title="6.3 特定于词法分析器的 DFA 最小化方法"></a>6.3 特定于词法分析器的 DFA 最小化方法</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124164922855.png" alt="image-20221124164922855" style="zoom:80%;" /></p>
<ul>
<li>初始划分需要考虑不同的<strong>词法单元</strong><ul>
<li>不能直接把所有终止状态分为一类</li>
</ul>
</li>
</ul>
<blockquote>
<p>$\Pi_0 = \set{\set{0137,7}, \textcolor{red}{\set{247}, \set{8, 58}, \set{68}}, \textcolor{green}{\set{\emptyset}}}$</p>
<p>$\Pi_1 = \set{\textcolor{blue}{\set{0137}, \set{7}}, \set{247}, \textcolor{blue}{\set{8}, \set{58}}, \set{68}}$</p>
</blockquote>
<h3 id="7-DFA-Rightarrow-RE"><a href="#7-DFA-Rightarrow-RE" class="headerlink" title="7. DFA $\Rightarrow$ RE"></a>7. DFA $\Rightarrow$ RE</h3><ul>
<li>$D \Longrightarrow r$</li>
<li>要求: $\textcolor{red}{L(r) = L(D)}$</li>
</ul>
<h4 id="考虑下图-DFA"><a href="#考虑下图-DFA" class="headerlink" title="考虑下图 DFA"></a>考虑下图 DFA</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128162254029.png" alt="image-20221128162254029" style="zoom:80%;" /></p>
<ul>
<li>字符串 $x$ 对应于有向图中的路径</li>
<li>求有向图中所有 (从初始状态到接受状态的) 路径</li>
<li>$\textcolor{red}{但是, 如果有向图中含有\textbf{环}, 则存在无穷多条路径}$<ul>
<li>不要怕, 我们有 <strong>Kleene 闭包(*)</strong></li>
</ul>
</li>
</ul>
<h4 id="Floyd-Warshall-弗洛伊德算法"><a href="#Floyd-Warshall-弗洛伊德算法" class="headerlink" title="Floyd-Warshall(弗洛伊德算法)"></a>Floyd-Warshall(弗洛伊德算法)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128163359324.png" alt="image-20221128163359324" style="zoom:80%;" /></p>
<h4 id="如何初始化"><a href="#如何初始化" class="headerlink" title="如何初始化"></a>如何初始化</h4><ul>
<li><p>$R^{-1}_{ij}:$ 从节点 $i$ 到节点 $j$ 、且<strong>不经过中间节点</strong>的所有路径</p>
</li>
<li><p>可以分为四种情况</p>
<ol>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128163754963.png" alt="image-20221128163754963" style="zoom:80%;" /></li>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128163803715.png" alt="image-20221128163803715" style="zoom:80%;" /></li>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128163815739.png" alt="image-20221128163815739" style="zoom:80%;" /></li>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128163832278.png" alt="image-20221128163832278" style="zoom:80%;" /></li>
</ol>
</li>
<li><p>关于 $\textcolor{red}{\emptyset}$ (注意: 它不是正则表达式) 的规定</p>
<ul>
<li>$\emptyset r = r\emptyset = \emptyset$</li>
<li>$\emptyset\mid r = r$</li>
</ul>
</li>
</ul>
<h4 id="r-的最终结果是什么"><a href="#r-的最终结果是什么" class="headerlink" title="$r$ 的最终结果是什么"></a>$r$ 的最终结果是什么</h4><ul>
<li>求有向图中所有 (从初始状态到接受状态的) 路径</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128164117771.png" alt="image-20221128164117771" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128164145771.png" alt="image-20221128164145771" style="zoom:80%;" /></p>
<ul>
<li><p>应用到初始的 DFA</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128164252370.png" alt="image-20221128164252370" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128164304111.png" alt="image-20221128164304111" style="zoom:80%;" /></p>
<ol>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128164344214.png" alt="image-20221128164344214" style="zoom:80%;" /></li>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128164357884.png" alt="image-20221128164357884" style="zoom:80%;" /></li>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221128164415452.png" alt="image-20221128164415452" style="zoom:80%;" /></li>
</ol>
</li>
</ul>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="龙书"><a href="#龙书" class="headerlink" title="龙书"></a>龙书</h3><h4 id="2-6-词法分析"><a href="#2-6-词法分析" class="headerlink" title="2.6 词法分析"></a>2.6 词法分析</h4><p>构成一个词法单元的输入字符序列称为<em>词素</em>(lexem)，词法分析器使得语法分析器不需要考虑词法单元的词素表示方式。</p>
<p>词法分析器使用一个表来保存字符串，从而解决了如下两个问题：</p>
<ul>
<li><em>单一表示</em>。一个字符串表可以将编译器的其余部分和表中字符串的具体表示隔离开，因为编译器后面的步骤可以只使用指向表中字符串的指针或引用。操作引用要比操作字符串本身更加高效。</li>
<li><em>保留字</em>。要实现保留字，可以在初始化时在字符串表中加入保留的字符串以及它们对应的词法单元。当词法分析器读到一个可以组成标识符的字符串或词素时，它首先检查这个字符串表中是否有这个词素。如是，它就返回表中的词法单元，否则返回带有终结符号 id 的词法单元。</li>
</ul>
<h4 id="3-1-词法分析器的作用"><a href="#3-1-词法分析器的作用" class="headerlink" title="3.1 词法分析器的作用"></a>3.1 词法分析器的作用</h4><p>词法分析器的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元序列，每个词法单元对应于一个词素。</p>
<p>在某些情况下，词法分析器会从符号表中读取有关标识符种类的信息，以确定向语法分析器传送哪个词法单元。</p>
<p>词法分析器在编译器中负责读取源程序，因此它还会完成一些识别词素之外的其他任务。</p>
<ul>
<li>任务之一是过滤掉源程序中的注释和空白（空格、换行符、制表符以及在输入中用于分隔词法单元的其他字符）；</li>
<li>另一个任务是将编译器生成的错误消息与源程序的位置联系起来。</li>
</ul>
<p>有时，词法分析器可以分成两个级联的处理阶段</p>
<ul>
<li><strong>扫描阶段</strong>主要负责完成一些不需要生成词法单元的简单处理，比如删除注释和将多个连续的空白字符压缩成一个字符。</li>
<li><strong>词法分析阶段</strong>是较为复杂的部分,它处理扫描阶段的输出并生成词法单元。</li>
</ul>
<h5 id="3-1-1-词法分析及语法分析"><a href="#3-1-1-词法分析及语法分析" class="headerlink" title="3.1.1 词法分析及语法分析"></a>3.1.1 词法分析及语法分析</h5><p>把编译过程的分析部分划分为词法分析和语法分析阶段有如下几个原因：</p>
<ul>
<li>最重要的考虑是简化编译器的设计<ul>
<li>将词法分析和语法分析分离通常使我们至少可以简化其中的一项任务</li>
</ul>
</li>
<li><p>提高编译器的效率</p>
<ul>
<li>把词法分析器独立出来使我们能够使用专用于词法分析任务、不进行语法分析的技术</li>
<li>可以使用专门的用于读取输入字符的缓冲技术来显著提高编译器的速度</li>
</ul>
</li>
<li><p>增强编译器的可移植性</p>
<ul>
<li>输入设备相关的特殊性可以被限制在词法分析器中</li>
</ul>
</li>
</ul>
<h5 id="3-1-2-词法单元、模式和词素"><a href="#3-1-2-词法单元、模式和词素" class="headerlink" title="3.1.2 词法单元、模式和词素"></a>3.1.2 词法单元、模式和词素</h5><p><strong>词法单元</strong>由一个词法单元名和一个可选的属性值组成。</p>
<ul>
<li>词法单元名是一个表示某种词法单位的抽象符号，比如一个特定的关键字，或者代表一个标识符的输入字符序列。</li>
<li>词法单元名字是由语法分析器处理的输入符号。我们将使用词法单元的名字来引用一个词法单元。</li>
</ul>
<p><strong>模式</strong>描述了一个词法单元的词素可能具有的形式。</p>
<ul>
<li>当词法单元是一个关键字时，它的模式就是组成这个关键字的字符序列。</li>
<li>对于标识符和其他词法单元，模式是一个更加复杂的结构，它可以和很多符号串匹配</li>
</ul>
<p><strong>词素</strong>是源程序中的一个字符序列</p>
<ul>
<li>它和某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例。</li>
</ul>
<blockquote>
<p>在C语句 <code>printf(&quot;Total= % d\n&quot;,score);</code> 中</p>
<p>printf和score都是和词法单元id的模式匹配的词素，而“Total =% d\n”则是一个和 literal 匹配的词素。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221111153545862.png" alt="image-20221111153545862"></p>
</blockquote>
<p>在很多程序设计语言中，下面的类别覆盖了大部分或所有的词法单元:</p>
<ul>
<li>每个关键字有一个词法单元。一个关键字的模式就是该关键字本身</li>
<li>表示运算符的词法单元。它可以表示单个运算符，也可以像上图中的comparison表示一类运算符</li>
<li>一个表示所有标识符的词法单元</li>
<li>一个或多个表示常量的词法单元，比如数字和字面值字符串</li>
<li>每一个标点符号有一个词法单元，比如左右括号、逗号和分号</li>
</ul>
<h5 id="3-1-3-词法单元的属性"><a href="#3-1-3-词法单元的属性" class="headerlink" title="3.1.3 词法单元的属性"></a>3.1.3 词法单元的属性</h5><p>如果有多个词素可以和一个模式匹配，那么词法分析器必须向编译器的后续阶段提供有关被匹配词素的附加信息。</p>
<blockquote>
<p>例如，0和1都能和词法单元number的模式匹配，但是对于代码生成器而言，至关重要的是知道在源程序中找到了哪个词素。</p>
<p>因此，在很多情况下，词法分析器不仅仅向语法分析器返回一个词法单元名字，还会返回一个描述该词法单元的词素的属性值</p>
<p>词法单元的名字将影响语法分析过程中的决定，而这个属性则会影响语法分析之后对这个词法单元的翻译。</p>
</blockquote>
<p>我们假设一个词法单元至多有一个相关的属性值，这个属性值可能是一个<strong>组合了多种信息的结构化数据</strong>。</p>
<p>最重要的例子是词法单元id,我们通常会将很多信息和它关联。一般来说，和一个标识符有关的信息：例如它的词素、类型、它第一次出现的位置（在发出一个有关该标识符的错误消息时需要使用这个信息）<strong>都保存在符号表中</strong>。因此，<strong>一个标识符的属性值是一个指向符号表中该标识符对应条目的指针。</strong></p>
<blockquote>
<p>例如Fortran语句 <code>E = M * C ** 2</code> 中的词法单元名字和相关的属性值可写成如下的名字-属性对序列：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221112141117200.png" alt="image-20221112141117200"></p>
<p>在某些对中，特别是运算符、标点符号和关键字的对中，不需要有属性值</p>
<p>该例中，词法单元number有一个整数属性值。在实践中，编译器将<strong>保存一个代表该常量的字符串</strong>，并将一个<strong>指向该字符串的指针</strong>作为number的属性值。</p>
</blockquote>
<h5 id="3-1-4-词法错误"><a href="#3-1-4-词法错误" class="headerlink" title="3.1.4 词法错误"></a>3.1.4 词法错误</h5><p>假设出现所有词法单元的模式都无法和剩余输入的某个前缀相匹配的情况，此时词法分析器就不能继续处理输入。当出现这种情况时，最简单的错误恢复策略是<strong>“恐慌模式”</strong>恢复。 我们从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的词法单元为止。</p>
<p>这个恢复技术可能会给语法分析器带来混乱。但是在交互计算环境中，这个技术已经足够了。</p>
<p>可能采取的其他错误恢复动作包括：</p>
<ul>
<li>从剩余的输入中删除一个字符。</li>
<li>向剩余的输入中插入一个遗漏的字符。</li>
<li>用一个字符来替换另一个字符。</li>
<li>交换两个相邻的字符</li>
</ul>
<blockquote>
<p>这些变换可以在试图修复错误输入时进行。最简单的策略是看一下<strong>是否可以通过一次变换将剩余输入的某个前缀变成一个合法的词素</strong>。</p>
<p>这种策略还是有道理的，因为在实践中，大多数词法错误只涉及<strong>一个字符</strong>。另外一种更加通用的改正策略是计算出最少需要多少次变换才能够把一个源程序转换成为一个只包含合法词素的程序。但是在实践中发现这种方法的代价太高，不值得使用。</p>
</blockquote>
<h4 id="3-2-输入缓冲"><a href="#3-2-输入缓冲" class="headerlink" title="3.2 输入缓冲"></a>3.2 输入缓冲</h4><p>我们常常需要查看一个词素之后的若干字符才能够确定是否找到了正确的词素，比如，我们只有读取到一个非字母或数字的字符之后才能确定我们已经到达一个标识符的末尾</p>
<p>在C语言中，像 - 、= 或 ＜ 这样的单字符运算符也有可 能是-&gt;、==或 &lt;= 这样的双字符运算符的开始字符</p>
<h5 id="3-2-1-缓冲区对"><a href="#3-2-1-缓冲区对" class="headerlink" title="3.2.1 缓冲区对"></a>3.2.1 缓冲区对</h5><p>通过两个交替读入的缓冲区来减少用于处理单个输入字符的时间开销。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221112143331856.png" alt="image-20221112143331856"></p>
<p>每个缓冲区的容量都是 N 个字符，通常 N 是一个磁盘块的大小，如4096字节。我们可以使用系统读取命令一次将 N 个字符读入到缓冲区中，而不是每读入一个字符调用一次系统读取命令。如果输入文件中的剩余字符不足N个，那么就会有一个特殊字符(EOF)来标记源文件的结束。</p>
<p>程序为输入维护了两个指针:</p>
<ul>
<li><code>lexemeBegin</code>指针：该指针指向当前词素的开始处。当前我们正试图确定这个词素的结尾。</li>
<li><code>forward</code>指针：它一直向前扫描，直到发现某个模式被匹配为止。</li>
</ul>
<p>一旦确定了下一个词素，<code>forward</code>指针将指向该词素结尾的字符。词法分析器将这个词素作为某个返回给语法分析器的词法单元的属性值记录下来。然后使<code>lexemeBegin</code>指针指向刚刚找到的词素之后的第一个字符。</p>
<p>将<code>forward</code>指针前移要求我们首先检査是否已经到达某个缓冲区的末尾。如果是，我们必须将 N 个新字符读到另一个缓冲区中，且将<code>forward</code>指针指向这个新载入字符的缓冲区的头部。只要我们从不需要越过实际的词素向前看很远，以至于这个词素的长度加上我们向前看的距离大于 N, 我们就决不会在识别这个词素之前覆盖掉这个尚在缓冲区中的词素。</p>
<h5 id="3-2-2-哨兵标记"><a href="#3-2-2-哨兵标记" class="headerlink" title="3.2.2 哨兵标记"></a>3.2.2 哨兵标记</h5><p>如果我们采用上一节中描述的方案，那么在每次向前移动<code>forward</code>指针时，我们都必须检査是否到达了缓冲区的末尾。若是，那么我们必须加载另一个缓冲区。</p>
<p>因此每读入一个字符, 我们需要做两次测试：</p>
<ul>
<li>一次是检査是否到达缓冲区的末尾</li>
<li>另一次是确定读入的字符是什么(可能是一个多路分支选择语句)。</li>
</ul>
<p>如果我们扩展每个缓冲区，使它们在末尾包含一个“哨兵” (sentinel)字符，我们就可以把对缓冲区末端的测试和对当前字符的测试合二为一。这个哨兵字符必须是一个不会在源程序中出现的特殊字符，一个自然的选择就是字符EOF</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221112144545736.png" alt="image-20221112144545736"></p>
<ul>
<li>请注意，EOF仍然可以用来标记整个输入的结尾。任何不是出现在某个缓冲区末尾的EOF都表示到达了输入的结尾</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221112144649129.png" alt="image-20221112144649129"></p>
<h4 id="3-3-词法单元的规约-1"><a href="#3-3-词法单元的规约-1" class="headerlink" title="3.3 词法单元的规约"></a>3.3 词法单元的规约</h4><h5 id="3-3-1-串和语言"><a href="#3-3-1-串和语言" class="headerlink" title="3.3.1 串和语言"></a>3.3.1 串和语言</h5><blockquote>
<p>串的各部分的术语</p>
<ol>
<li>串 $s$ 的前缀(prefix)是从 $s$ 的尾部删除 0 个或多个符号后得到的串。例如,ban、banana 和 $\epsilon$ 是banana的前缀</li>
<li>串 $s$ 的后缀(suffix)是从 $s$ 的开始处删除 0 个或多个符号后得到的串。例如，nana、banana 和 $\epsilon$ 是banana的后缀。</li>
<li>串 $s$ 的子串(substring)是删除 $s$ 的某个前缀和某个后缀之后得到的串。例如，bnana、nan和 $\epsilon$ 是banana的子串。</li>
<li>串 $s$ 的真(true)前缀、真后缀、真子串分别是 $s$ 的既不等于 $\epsilon$ 也不等于 $s$ 本身的前缀、后缀和子串</li>
<li>串 $s$ 的子序列(subsequence)是从 $s$ 中删除 0 个或多个符号后得到的串，这些被删除的符号可能不相邻。例如，baan是banana的一个子序列</li>
</ol>
</blockquote>
<h5 id="3-3-3-正则表达式"><a href="#3-3-3-正则表达式" class="headerlink" title="3.3.3 正则表达式"></a>3.3.3 正则表达式</h5><p>可以用一个正则表达式定义的语言叫做<em>正则集合</em>(regular set)。如果两个正则表达式 $r$ 和 $s$ 表示相同的语言，则称 $r$ 和 $s$ <em>等价</em>(equivalent)，记作 $r$ = $s$ .</p>
<ul>
<li>例如 (a|b) = (b|a)</li>
</ul>
<p>正则表达式遵守一些代数定律，每个定律都断言两个具有不同形式的表达式等价</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221115164950975.png" alt="image-20221115164950975"></p>
<h3 id="自制编译器"><a href="#自制编译器" class="headerlink" title="自制编译器"></a>自制编译器</h3><h4 id="抽象语法树和节点"><a href="#抽象语法树和节点" class="headerlink" title="抽象语法树和节点"></a>抽象语法树和节点</h4><p>语法树和语法是完全对应的，所以例如 C 语言的终结符分号以及表达式两端的括号等都包含在真实的语法树中。</p>
<p>但是，保存分号和括号基本没有实际的意义，因此实际上大部分情况下会生成一开始就省略分号、括号等的抽象语法树。也就是说，解析器会跳过语法树，直接生成抽象语法树。</p>
<p>无论语法树还是抽象语法树，都是树形的数据结构，因此和普通的树结构相同，由称为节点（node）的数据结构组合而成。用 Java 来写的话，一个节点可以用一个节点对象来表示。</p>
<h4 id="解析器生成器"><a href="#解析器生成器" class="headerlink" title="解析器生成器"></a>解析器生成器</h4><p>生成扫描器的程序称为扫描器生成器（scanner generator），生成解析器的程序称为解析器生成器（parser generator）。只需指定需要解析的语法，扫描器生成器和解析器生成器就能生成解析相应语法的代码。</p>
<p>扫描器生成器都大体类似，解析器生成器则有若干个种类。现在具有代表性的解析器生成器可分为 <strong>LL 解析器生成器和 LALR 解析器生成器</strong>两类。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221112161342539.png" alt="image-20221112161342539"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221112161400838.png" alt="image-20221112161400838"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/编译原理/">编译原理</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编译原理/">编译原理</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/11/08/编译原理-1-概述/"><span>编译原理(1) 概述</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/11/08/编译原理-1-概述/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-08T15:51:55.000Z">
          2022-11-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="编译原理概述"><a href="#编译原理概述" class="headerlink" title="编译原理概述"></a>编译原理概述</h1><h3 id="1-什么是编译器"><a href="#1-什么是编译器" class="headerlink" title="1. 什么是编译器"></a>1. 什么是编译器</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107235732055.png" alt="image-20221107235732055"></p>
<ul>
<li>通常情况下是由高级语言编译到低级语言，但并不绝对，例如GopherJS</li>
</ul>
<h3 id="2-机器语言是如何跑起来的"><a href="#2-机器语言是如何跑起来的" class="headerlink" title="2. 机器语言是如何跑起来的"></a>2. 机器语言是如何跑起来的</h3><p>P1-P8：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EW411u7th">https://www.bilibili.com/video/BV1EW411u7th</a></p>
<h3 id="3-语言类应用程序"><a href="#3-语言类应用程序" class="headerlink" title="3. 语言类应用程序"></a>3. 语言类应用程序</h3><ul>
<li>配置文件解析 (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/.properties">.properties</a>)</li>
<li>CSV 文件 (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Comma-separated_values#/media/File:CsvDelimited001.svg">Comma-Separated Values</a>)</li>
<li>JSON 文件 (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON#Syntax">JavaScript Object Notation</a>)</li>
<li>SQL 引擎 (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SQL_syntax">Structured Query Language</a>)</li>
<li>TLA+/TLAPS (<a target="_blank" rel="noopener" href="https://github.com/Starydark/PaxosStore-tla/blob/master/theorem%20proving/TPaxos.tla">TPaxos.tla</a>)</li>
<li>(Java) 字节码解释器</li>
<li>C/C++ 语言编译器</li>
<li>排版工具 (<a target="_blank" rel="noopener" href="https://github.com/courses-at-nju-by-hfwei/compilers-lectures/blob/master/2021/0-overview/parts/overview.tex">LATEX</a>)</li>
<li>绘图工具 (<a target="_blank" rel="noopener" href="https://www.overleaf.com/learn/latex/TikZ_package">TikZ</a>, <a target="_blank" rel="noopener" href="https://renenyffenegger.ch/notes/tools/Graphviz/examples/index">Dot/Graphviz</a>)</li>
<li>L-System (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/L-system#Example_3:_Cantor_set">Cantor Set</a>)</li>
</ul>
<h3 id="4-IR-Intermediate-Representation-中间表示"><a href="#4-IR-Intermediate-Representation-中间表示" class="headerlink" title="4. IR: Intermediate Representation (中间表示)"></a>4. IR: Intermediate Representation (中间表示)</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108002915488.png" alt="image-20221108002915488"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108003013412.png" alt="image-20221108003013412"></p>
<p>机器无关的中间表示优化</p>
<p>前端(<strong>分析</strong>阶段)：分析源语言程序, 收集所有必要的信息</p>
<p>后端(<strong>综合</strong>阶段)：利用收集到的信息, 生成目标语言程序</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108003106641.png" alt="image-20221108003106641"></p>
<p>在设计实际生产环境中的编译器时, <strong>优化</strong>通常占用了大多数时间</p>
<h3 id="5-词法、语法、语义和物理定律"><a href="#5-词法、语法、语义和物理定律" class="headerlink" title="5. 词法、语法、语义和物理定律"></a>5. 词法、语法、语义和物理定律</h3><blockquote>
<p>作为一名程序员，你看到了什么？</p>
</blockquote>
<p>position = initial + rate ∗ 60</p>
<ol>
<li><strong>词法</strong>: 标识符、数字、运算符</li>
<li><strong>语法</strong>: 包含算术运算的赋值语句</li>
<li><strong>语义</strong>: position, initial, rate 是数值类型</li>
<li><strong>物理定律</strong>: 当前位置 = 初始位置 + 速度 × 时间</li>
</ol>
<p>我们希望编译器可以懂词法、语法、语义，但是作为编译器, 它仅仅看到了一个<strong>字符串</strong></p>
<h4 id="5-1-词法分析器"><a href="#5-1-词法分析器" class="headerlink" title="5.1 词法分析器"></a>5.1 词法分析器</h4><p>词法分析器 (Lexer/Scanner): 将<strong>字符</strong>流转化为<strong>词法单元</strong>(token)流。</p>
<p><code>&lt;id,1&gt;</code></p>
<ul>
<li>id：表示标识符(identifier)的抽象符号</li>
<li>1：指向符号表中position对应的条目。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108003702784.png" alt="image-20221108003702784" style="zoom:80%;" /></p>
<h4 id="5-2-语法分析器"><a href="#5-2-语法分析器" class="headerlink" title="5.2 语法分析器"></a>5.2 语法分析器</h4><p>语法分析器 (Parser): 构建<strong>词法单元</strong>之间的语法结构, 生成<strong>语法树</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108003810281.png" alt="image-20221108003810281" style="zoom:80%;" /></p>
<h4 id="5-3-语义分析器"><a href="#5-3-语义分析器" class="headerlink" title="5.3 语义分析器"></a>5.3 语义分析器</h4><p>语义分析器: 语义检查, 如<strong>类型检查、”先声明后使用”约束检查</strong></p>
<p>程序设计语言可能允许某些类型转换，这被称为<strong>自动类型转换</strong>(coercion)</p>
<blockquote>
<p>假设position、initial和rate已被声明为浮点数类型，而词素60本身形成一个整数。</p>
<p>语义分析器的类型检查程序发现运算符 * 被用于一个浮点数 rate 和一个整数 60。在这种情况下，这个整数可以被转换成为一个浮点数。</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108003908957.png" alt="image-20221108003908957" style="zoom:80%;" /></p>
<h4 id="5-4-中间代码生成器"><a href="#5-4-中间代码生成器" class="headerlink" title="5.4 中间代码生成器"></a>5.4 中间代码生成器</h4><p>中间代码生成器: 生成中间代码, 如 <strong>“三地址代码”</strong></p>
<blockquote>
<p>“三地址代码”，这种中间表示由一组类似于汇编语言的指令组成，每个指令具有三个运算分量。每个运算分量都像一个寄存器。</p>
<p>关于三地址指令，有几点是值得专门指出的。</p>
<p>首先，每个三地址赋值指令的右部最多只有一个运算符。因此这些指令确定了运算完成的顺序。在源程序中，乘法应该在加法之前完成。</p>
<p>第二，编译器应该生成一个临时名字以存放一个三地址指令计算得到的值。</p>
<p>第三，有些三地址指令的运算分量的少于三个(比如下面的序列中的第一个和最后一个指令)。</p>
</blockquote>
<p>中间代码类似目标代码, 但不含有机器相关信息 (如寄存器、指令格式)</p>
<p>中间表示应该具有两个重要的性质：</p>
<ul>
<li>易于生成</li>
<li>能够被轻松地翻译为目标机器上的语言。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108004056358.png" alt="image-20221108004056358" style="zoom:80%;" /></p>
<h4 id="5-5-中间代码优化器"><a href="#5-5-中间代码优化器" class="headerlink" title="5.5 中间代码优化器"></a>5.5 中间代码优化器</h4><p>编译时计算、消除冗余临时变量</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108004121768.png" alt="image-20221108004121768" style="zoom:80%;" /></p>
<h4 id="5-6-代码生成器"><a href="#5-6-代码生成器" class="headerlink" title="5.6 代码生成器"></a>5.6 代码生成器</h4><p>代码生成器: 生成目标代码, 主要任务包括<strong>指令选择、寄存器分配</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108004243070.png" alt="image-20221108004243070" style="zoom:80%;" /></p>
<h4 id="5-7-符号表"><a href="#5-7-符号表" class="headerlink" title="5.7 符号表"></a>5.7 符号表</h4><p>符号表: 收集并管理<strong>变量名/函数名</strong>相关的信息</p>
<ul>
<li><p>变量名: 类型、寄存器、内存地址、行号</p>
</li>
<li><p>函数名: 参数个数、参数类型、返回值类型</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108004430799.png" alt="image-20221108004430799"></p>
<p>符号表：红黑树(RB-Tree)、哈希表(Hashtable)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108004641433.png" alt="image-20221108004641433"></p>
<ul>
<li><p>为了方便表达<strong>嵌套结构与作用域</strong>, 可能需要维护多个符号表</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108004753885.png" alt="image-20221108004753885"></p>
</li>
</ul>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="龙书："><a href="#龙书：" class="headerlink" title="龙书："></a>龙书：</h3><h4 id="1-1-语言处理器"><a href="#1-1-语言处理器" class="headerlink" title="1.1 语言处理器"></a>1.1 语言处理器</h4><ul>
<li>解释器(interpreter)是另一种常见的语言处理器。它并不通过翻译的方式生成目标程序。<ul>
<li>从用户的角度看，解释器直接利用用户提供的输入执行源程序中指定的操作。</li>
<li>在把用户输入映射成为输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快很多。然而，解释器的错误诊断效果通常比编译器更好，因为它逐个语句地执行源程序。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Java语言处理器结合了编译和解释过程，一个Java源程序首先被<strong>编译成</strong>一个称为<strong>字节码</strong>(bytecode)的中间表示形式。然后由一个虚拟机<strong>对字节码加以解释执行</strong>。</p>
<p>为了更快地完成输入到输出的处理，有些被称为即时(just in time)编译器的Java编译器在运行中间程序处理输入的前一刻首先把字节码翻译成为机器语言，然后再执行程序</p>
</blockquote>
<ul>
<li><p>一个源程序可能被分割成为多个模块，并存放于独立的文件中。把源程序聚合在一起的任务有时会由一个被称为预处理器(preprocessor)的程序独立完成。预处理器还负责把那些称为宏的缩写形式转换为源语言的语句。</p>
</li>
<li><p>一个文件中的代码可能指向另一个文件中的位置，而链接器(linker)能够解决外部内存地址的问题。最后，加载器(loader)把所有的可执行目标文件放到内存中执行。</p>
</li>
</ul>
<h4 id="1-2-一个编译器的结构"><a href="#1-2-一个编译器的结构" class="headerlink" title="1.2 一个编译器的结构"></a>1.2 一个编译器的结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108230106768.png" alt="image-20221108230106768"></p>
<h3 id="自制编译器："><a href="#自制编译器：" class="headerlink" title="自制编译器："></a>自制编译器：</h3><h4 id="1-可执行文件"><a href="#1-可执行文件" class="headerlink" title="1. 可执行文件"></a>1. 可执行文件</h4><ul>
<li><p>现代的 Linux 上的可执行文件，通常是指符合 ELF(Executable and Linking Format)这种特定形式的文件。</p>
<ul>
<li>ls、cp 这些命令(command)对应的实体文件都是可执行文件，例如 /bin/ls 和 /bin/cp 等。</li>
<li>使用 file 命令能够查看文件是否符合 ELF 的形式。会显示 ELF……executable</li>
</ul>
</li>
<li><p>ELF 文件中包含了<strong>程序(代码)</strong>以及如何运行该程序的<strong>相关信息(元数据)</strong>。程序(代码)就是机器语言(machine language)的列表。</p>
</li>
<li>GCC 将 C 语言的程序转化为用机器语言(例如 486 的机器语言)描述的程序。<strong>将机器语言的程序按照 ELF 这种特定的文件格式注入文件，得到的就是可执行文件。</strong></li>
</ul>
<h4 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h4><blockquote>
<p>gcc 命令是如何将 hello.c 转换为可执行文件的呢？</p>
</blockquote>
<p>C 语言的代码经过预处理、编译、汇编、链接这 4 个阶段的处理，最终生成可执行文件。</p>
<p><strong>预处理</strong></p>
<p>先由<strong>预处理器</strong>(preprocessor)对 #include 和 #define 进行处理。</p>
<ul>
<li>具体来说，读入头文件，将所有的宏展开，这就是预处理(preprocess)</li>
<li>预处理的内容近似于 sed 命令和 awk 命令这样的纯文本操作，不考虑 C 语言语法的含义。</li>
</ul>
<p><strong>狭义的编译</strong></p>
<p>编译器对预处理器的输出进行编译，生成<strong>汇编语言</strong>(assemble language)的代码。一般来说，汇编语言的代码的文件扩展名是“.s”。</p>
<p><strong>汇编</strong></p>
<p>汇编语言的代码由<strong>汇编器</strong>(assembler)转换为机器语言，这个处理过程称为汇编(assemble)。</p>
<p>汇编器的输出称为<strong>目标文件</strong>(object file)。一般来说，目标文件的扩展名是“.o”。</p>
<blockquote>
<p>Linux 中，目标文件也是 ELF 文件。既然都是 ELF 文件，那么如何区分是目标文件还是可执行文件呢？</p>
<p>ELF 文件中有用于提示文件种类的标志。例如， 用 file 命令来查看目标文件，会显示 ELF…relocatable，据此就能够将其和可执行文件区分开。</p>
</blockquote>
<p><strong>链接</strong></p>
<p>目标文件本身还不能直接使用，无论是直接运行还是作为<strong>程序库</strong>(library)文件调用都不可以。</p>
<p>将目标文件转换为最终可以使用的形式的处理称为链接(link)。使用程序库的情况下，会在这个阶段处理程序库的加载</p>
<h4 id="3-程序运行环境"><a href="#3-程序运行环境" class="headerlink" title="3. 程序运行环境"></a>3. 程序运行环境</h4><p>链接的话题并非仅仅出现在 build 的过程中。如果使用了共享库，那么<strong>在开始运行程序时，链接才会发生</strong>。最近广泛使用的<strong>动态加载</strong>(dynamic load)，就是一种将所有链接处理放到程序运行时进行的手法。</p>
<p>在 Sun 的 Java VM 等具有代表性的 Java 的运行环境中，为了提高运行速度，采用了 <strong>JIT 编译器</strong>(Just In Time compiler)。JIT 编译器是在程序运行时进行处理，将程序转换为机器语言的编译器。也就是说，Java 语言是在运行时进行编译的。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/编译原理/">编译原理</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/编译原理/">编译原理</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/30/嵌入式系统概论/"><span>嵌入式系统概论</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/30/嵌入式系统概论/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-30T02:11:58.000Z">
          2022-10-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-嵌入式系统概述"><a href="#1-嵌入式系统概述" class="headerlink" title="1 嵌入式系统概述"></a>1 嵌入式系统概述</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><h4 id="1-1-1-IEEE-的定义"><a href="#1-1-1-IEEE-的定义" class="headerlink" title="1.1.1 IEEE 的定义"></a>1.1.1 IEEE 的定义</h4><blockquote>
<p>嵌入式系统是用于控制、监视或者辅助操作机器和设备的装置。</p>
<p>Devices used to control, monitor, or assist the operation of equipment, machinery or plants.</p>
</blockquote>
<p>此定义是从应用上考虑的，嵌入式系统是软件和硬件的综合体，还可以涵盖机电等附属装置。</p>
<h4 id="1-1-2-国内的定义"><a href="#1-1-2-国内的定义" class="headerlink" title="1.1.2 国内的定义"></a>1.1.2 国内的定义</h4><blockquote>
<p>嵌入式系统是<strong>以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统</strong>。</p>
<p>嵌入式系统就是一个具有特定功能或用途的隐藏在某种设备中的计算机软硬件集合体，没有固定的特征形状。</p>
</blockquote>
<h4 id="1-1-3-嵌入式系统三要素"><a href="#1-1-3-嵌入式系统三要素" class="headerlink" title="1.1.3 嵌入式系统三要素"></a>1.1.3 嵌入式系统三要素</h4><p><strong>嵌入性</strong>：嵌入到对象体系中，有对象环境要求</p>
<p><strong>专用性</strong>：软、硬件按对象要求设计、裁剪</p>
<p><strong>计算机</strong>：实现对象的智能化功能</p>
<h4 id="1-1-4-其他的定义"><a href="#1-1-4-其他的定义" class="headerlink" title="1.1.4 其他的定义"></a>1.1.4 其他的定义</h4><blockquote>
<p>嵌⼊封闭产品中的信息处理系统。</p>
<p>看不见的计算机，一般不能被用户编程, 它有一些专用的 I/O 设备, 对用户的接口是应用专用的。</p>
<p>An embedded system is a computer system contained within some larger device or product with the intent purpose of providing monitoring and control services to that device.</p>
<p>嵌入式系统是包含在某些较大的设备或产品中的计算机系统，其目的是为该设备提供<strong>监视和控制</strong>服务。</p>
<p>Any sort of device which includes a programmable computer but itself is not intended to be a general-purpose computer.</p>
<p>包括可编程计算机在内但本身<strong>不打算用作通用计算机</strong>的任何设备。</p>
<p>包含有计算机，但又不是通用计算机的计算机应用系统。</p>
</blockquote>
<h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul>
<li>嵌入式系统通常是<strong>形式多样、面向特定应用</strong>的</li>
<li>嵌入式系统得到<strong>多种类型的处理器和处理器体系结构</strong>的支持</li>
<li>嵌入式系统通常极其<strong>关注成本</strong></li>
<li>嵌入式系统有<strong>实时性和可靠性</strong>的要求</li>
<li>嵌入式系统使用的操作系统一般是<strong>适应多种处理器、可剪裁、轻量型、实时可靠、可固化</strong>的嵌入式操作系统</li>
<li>嵌入式系统开发需要<strong>专门工具和特殊方法</strong></li>
</ul>
<h3 id="1-3-分类"><a href="#1-3-分类" class="headerlink" title="1.3 分类"></a>1.3 分类</h3><h4 id="1-3-1-按嵌入式处理器的位数来分类"><a href="#1-3-1-按嵌入式处理器的位数来分类" class="headerlink" title="1.3.1 按嵌入式处理器的位数来分类"></a>1.3.1 按嵌入式处理器的位数来分类</h4><ul>
<li><p>4 位嵌入式系统：大量应用</p>
</li>
<li><p>8 位嵌入式系统：大量应用</p>
</li>
<li>16 位嵌入式系统：大量应用</li>
<li>32 位嵌入式系统：正成为主流发展趋势</li>
<li>64 位嵌入式系统：高度复杂的、高速的嵌入式系统已经开始采用</li>
</ul>
<h4 id="1-3-2-按应用来分类"><a href="#1-3-2-按应用来分类" class="headerlink" title="1.3.2 按应用来分类"></a>1.3.2 按应用来分类</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221030163439013.png" alt="image-20221030163439013"></p>
<h4 id="1-3-3-按速度分类"><a href="#1-3-3-按速度分类" class="headerlink" title="1.3.3 按速度分类"></a>1.3.3 按速度分类</h4><ul>
<li>强实时系统，其系统响应时间在毫秒或微秒级。</li>
<li>⼀般实时系统，其系统响应时间在几秒的数量级上，其实时性的要求比强实时系统要差⼀些。</li>
<li>弱实时系统，其系统响应时间约为数十秒或更长。这种系统的响应时间可能随系统负载的轻重⽽变化</li>
</ul>
<h4 id="1-3-4-按确定性来分类"><a href="#1-3-4-按确定性来分类" class="headerlink" title="1.3.4 按确定性来分类"></a>1.3.4 按确定性来分类</h4><p>根据确定性的强弱，可将嵌入式系统分为硬实时、软实时系统：</p>
<ul>
<li><p>硬实时：系统对系统响应时间有严格的要求，如果系统响应时间不能满⾜，就要引起系统崩溃或致命的错误。</p>
</li>
<li><p>软实时：系统对系统响应时间有要求，但是如果系统响应时间不能满⾜，不会导致系统出现致命的错误或崩溃。</p>
</li>
</ul>
<h4 id="1-3-5-按嵌入式系统软件复杂程度来分类"><a href="#1-3-5-按嵌入式系统软件复杂程度来分类" class="headerlink" title="1.3.5 按嵌入式系统软件复杂程度来分类"></a>1.3.5 按嵌入式系统软件复杂程度来分类</h4><ul>
<li>循环轮询系统</li>
<li>有限状态机系统</li>
<li>前后台系统</li>
<li>单处理器多任务系统</li>
<li>多处理器多任务系统</li>
</ul>
<h3 id="1-4-典型应用"><a href="#1-4-典型应用" class="headerlink" title="1.4 典型应用"></a>1.4 典型应用</h3><p>无线感知网络、CPS、IOT</p>
<ol>
<li>工控设备</li>
<li>军用电子设备</li>
<li>航天／航空</li>
<li>汽车电子</li>
<li>信息家电</li>
<li>通信</li>
<li>智能玩具</li>
<li>可穿戴</li>
</ol>
<h2 id="2-嵌入式系统、IOT、CPS的基本组成"><a href="#2-嵌入式系统、IOT、CPS的基本组成" class="headerlink" title="2 嵌入式系统、IOT、CPS的基本组成"></a>2 嵌入式系统、IOT、CPS的基本组成</h2><h3 id="2-1-嵌入式系统的组成"><a href="#2-1-嵌入式系统的组成" class="headerlink" title="2.1 嵌入式系统的组成"></a>2.1 嵌入式系统的组成</h3><p>嵌入式系统一般由<strong>嵌入式硬件和软件</strong>组成</p>
<ul>
<li><p>硬件以<strong>微处理器</strong>为核心集成存储器和系统专用的<strong>输入/输出设备</strong></p>
</li>
<li><p>软件包括：<strong>初始化代码及驱动、嵌入式操作系统和应用程序</strong>等，这些软件有机地结合在一起，形成系统特定的一体化软件。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221030164145573.png" alt="image-20221030164145573"></p>
<h3 id="2-2-IOT的组成"><a href="#2-2-IOT的组成" class="headerlink" title="2.2 IOT的组成"></a>2.2 IOT的组成</h3><p>物联网(IoT)是物理设备、车辆（也称为“连接设备”和“智能设备”）、建筑物和其他嵌入电子设备、软件、传感器、执行器和网络连接的项目的互联网络，使这些对象能够收集和交换数据。</p>
<h3 id="2-3-CPS的组成"><a href="#2-3-CPS的组成" class="headerlink" title="2.3 CPS的组成"></a>2.3 CPS的组成</h3><p>网络物理系统(CPS，Cyber-physical System)是一种由基于计算机的算法控制或监视的机制，与互联网及其用户紧密集成。</p>
<p>是计算进程与物理进程的集成</p>
<ul>
<li><p>更多地强调嵌⼊式系统与物理学的深度结合</p>
</li>
<li><p><strong>CPS=ES+Physics</strong></p>
</li>
</ul>
<p>⼈机物融合系统</p>
<p>深度融合了各类信息技术：传感器、嵌入式计算、云计算、网络通信、软件，使得各种信息化能⼒（3C：计算-Computer、通信-Communication和控制-Control）⾼度协同和⾃治，实现⽣产应⽤系统⾃主、智能、动态、系统化地监视并改变物理世界的性状。</p>
<h2 id="3-嵌入式系统设计"><a href="#3-嵌入式系统设计" class="headerlink" title="3 嵌入式系统设计"></a>3 嵌入式系统设计</h2><h3 id="3-1-嵌入式系统面临挑战"><a href="#3-1-嵌入式系统面临挑战" class="headerlink" title="3.1 嵌入式系统面临挑战"></a>3.1 嵌入式系统面临挑战</h3><ul>
<li>需要多少硬件？</li>
<li>如何满⾜时限要求，如何处理多项功能在时间上的协调⼀致关系？</li>
<li>如何降低系统的功耗？</li>
<li>如何设计以保证系统可升级？</li>
<li>如何保证系统可靠地⼯作？</li>
</ul>
<h3 id="3-2-传统开发过程"><a href="#3-2-传统开发过程" class="headerlink" title="3.2 传统开发过程"></a>3.2 传统开发过程</h3><p>传统软硬件设计过程的基本特征：</p>
<ul>
<li><p>系统在一开始就被划分为软件和硬件两大部分</p>
</li>
<li><p>软件和硬件独立进行行开发设计</p>
</li>
<li><p>经常采用“硬件优先”的方法</p>
</li>
</ul>
<p>隐含的一些问题：</p>
<ul>
<li><p>软硬件之间的交互受到很大限制：凭经验划分软硬件、软硬件之间的相互性能影响很难评估</p>
</li>
<li><p>系统集成相对滞后，NRE 较大，越后期发现的问题可能会导致越严重的开销</p>
</li>
</ul>
<p>因此：设计质量差、设计修改代价高、研制周期不能有保障</p>
<h3 id="3-3-软硬件协同设计"><a href="#3-3-软硬件协同设计" class="headerlink" title="3.3 软硬件协同设计 -"></a>3.3 软硬件协同设计 -</h3><ul>
<li><p>硬件/软件协同设计是指一种专用系统的设计，该系统由几个专用 IC 组成，这些 IC 与通用处理器上的软件过程配合使用（1994 年）</p>
</li>
<li><p>硬件/软件协同设计意味着通过并发设计来利用硬件和软件的协同作用，从而达到系统级目标（1997 年）</p>
</li>
<li><p>硬件/软件协同设计试图通过提供可以告诉设计人员系统是否满足其性能，功耗和尺寸目标的分析方法以及可以使设计人员快速评估许多潜在设计方法的综合方法，来提高嵌入式系统设计的可预测性（2003 年）</p>
</li>
<li><p>它从新兴学科（90 年代初）发展为主流技术（今天）</p>
</li>
</ul>
<h3 id="3-4-软硬件划分"><a href="#3-4-软硬件划分" class="headerlink" title="3.4 软硬件划分"></a>3.4 软硬件划分</h3><ul>
<li><p>嵌⼊式系统的设计涉及硬件与软件部件，设计中必须决定什么功能由硬件实现，什么功能由软件实现。</p>
</li>
<li><p>硬件和软件具有双重性</p>
</li>
<li>软硬件变动对系统的决策造成影响</li>
<li>划分和选择需要考虑多种因素</li>
<li>硬件和软件的双重性是划分决策的前提</li>
</ul>
<h4 id="3-4-1-通常由软件实现的部分"><a href="#3-4-1-通常由软件实现的部分" class="headerlink" title="3.4.1 通常由软件实现的部分"></a>3.4.1 通常由软件实现的部分</h4><ul>
<li>操作系统功能：任务调度、资源管理、设备驱动</li>
<li>协议栈：TCP/IP</li>
<li>应用软件框架</li>
<li>除基本系统、物理理接口、基本逻辑电路，许多由硬件实现的功能都可以由软件实现</li>
</ul>
<h4 id="3-4-2-双重性部分"><a href="#3-4-2-双重性部分" class="headerlink" title="3.4.2 双重性部分"></a>3.4.2 双重性部分</h4><ul>
<li>算法：加密/解密、编码/解码、压缩/解压。</li>
<li>数学运算：浮点运算、FFT。</li>
</ul>
<h4 id="3-4-3-软硬件技术对系统结构的影响"><a href="#3-4-3-软硬件技术对系统结构的影响" class="headerlink" title="3.4.3 软硬件技术对系统结构的影响"></a>3.4.3 软硬件技术对系统结构的影响</h4><p>硬软件设计的趋势：融合、渗透</p>
<ul>
<li><p>硬件设计的软件化：VHDL、Verilog、HANDL-C</p>
</li>
<li><p>软件实现的硬件化：各种算法的 ASIC</p>
</li>
</ul>
<p>对系统设计的影响：协同设计</p>
<ul>
<li>增加灵活性</li>
<li>增加了风险</li>
</ul>
<h2 id="4-嵌入式硬件系统基础"><a href="#4-嵌入式硬件系统基础" class="headerlink" title="4 嵌入式硬件系统基础"></a>4 嵌入式硬件系统基础</h2><h3 id="4-1-嵌入式微处理器基础"><a href="#4-1-嵌入式微处理器基础" class="headerlink" title="4.1 嵌入式微处理器基础"></a>4.1 嵌入式微处理器基础</h3><h4 id="4-1-1-冯诺伊曼结构与哈佛结构"><a href="#4-1-1-冯诺伊曼结构与哈佛结构" class="headerlink" title="4.1.1 冯诺伊曼结构与哈佛结构"></a>4.1.1 冯诺伊曼结构与哈佛结构</h4><p><strong>冯诺依曼结构</strong></p>
<ol>
<li>存储器保存数据、指令。</li>
<li>中央处理器（CPU）从内存中获取指令：分离的 CPU 和内存区分可编程计算机。</li>
<li>CPU 寄存器可提供帮助：程序计数器（PC），指令寄存器（IR），通用寄存器等。</li>
<li>嵌入式中两个版本的 CPU 都有</li>
</ol>
<p><strong>哈佛结构</strong></p>
<ol>
<li>Harvard 不能使用自我修改的代码。</li>
<li>Harvard 允许同时进行两次内存提取。</li>
<li>大多数 DSP（数据信号处理，Digital Signal Process）使用 Harvard 架构来传输数据：<ul>
<li>更大的内存带宽</li>
<li>更可预测的带宽</li>
</ul>
</li>
</ol>
<h4 id="4-1-2-CISC与RISC"><a href="#4-1-2-CISC与RISC" class="headerlink" title="4.1.2 CISC与RISC"></a>4.1.2 CISC与RISC</h4><ul>
<li><p>Complex instruction set computer (CISC): 复杂指令集计算机</p>
<ul>
<li>多种寻址模式、多种操作</li>
</ul>
</li>
<li><p>Reduced instruction set computer (RISC): 精简指令集计算机</p>
<ul>
<li>加载/存储、可传递指令</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221030173243340.png" alt="image-20221030173243340"></p>
<h4 id="4-1-3-流水线技术"><a href="#4-1-3-流水线技术" class="headerlink" title="4.1.3 流水线技术"></a>4.1.3 流水线技术</h4><h4 id="4-1-4-分类"><a href="#4-1-4-分类" class="headerlink" title="4.1.4 分类"></a>4.1.4 分类</h4><ul>
<li><p>嵌入式微处理器种类繁多，按位数可分为4位、8位、16位、32位和64位。</p>
</li>
<li><p>根据功能不同，嵌入式微处理器分为四种：</p>
<ol>
<li>嵌入式微处理单元(MPU)</li>
<li>嵌入式微控制器(MCU)</li>
<li>嵌入式DSP处理器</li>
<li>嵌入式SoC</li>
</ol>
</li>
</ul>
<h4 id="4-1-5-选型"><a href="#4-1-5-选型" class="headerlink" title="4.1.5 选型"></a>4.1.5 选型</h4><p><strong>选择微控制器的标准</strong></p>
<blockquote>
<p>如何选择一个适合的微服务控制器?<br>嵌入式系统都是实时系统，需要考虑效率</p>
</blockquote>
<ol>
<li><p>有效且经济地满足任务的计算需求</p>
<ul>
<li><p>速度，ROM和RAM的数量，I/O端口和计时器的数量，大小，包装，功耗</p>
</li>
<li><p>容易升级</p>
</li>
<li><p>单位成本</p>
</li>
</ul>
</li>
<li><p>软件开发工具的可用性：</p>
<ul>
<li>汇编器，调试器，C编译器，仿真器，模拟器，技术支持(开源框架可能没有多少人维护)</li>
</ul>
</li>
<li><p>微控制器的广泛可用性和可靠来源。</p>
</li>
</ol>
<h6 id="选择微控制器的-10-个步骤"><a href="#选择微控制器的-10-个步骤" class="headerlink" title="选择微控制器的 10 个步骤"></a>选择微控制器的 10 个步骤</h6><ol>
<li>列出所需的硬件接口（保证物理上，设备可以连接到微处理器上）</li>
<li>检查软件架构</li>
<li>选择架构</li>
<li>确定内存需求</li>
<li>开始寻找微控制器</li>
<li>检查成本和功率约束</li>
<li>检查零件可用性</li>
<li>选择开发套件</li>
<li>研究编译器和工具</li>
<li>开始实验</li>
</ol>
<h3 id="4-2-嵌入式系统的存储体系"><a href="#4-2-嵌入式系统的存储体系" class="headerlink" title="4.2 嵌入式系统的存储体系"></a>4.2 嵌入式系统的存储体系</h3><h4 id="4-2-1-存储器系统：存储器系统的层次结构"><a href="#4-2-1-存储器系统：存储器系统的层次结构" class="headerlink" title="4.2.1 存储器系统：存储器系统的层次结构"></a>4.2.1 存储器系统：存储器系统的层次结构</h4><ol>
<li>平面单空间（Flat single-space）</li>
<li>分段式（Segmented）</li>
<li>组切换（Bank-switched）</li>
<li>多空间存储区（Multiple-space）</li>
<li>虚拟内存（Virtual）</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>平面单空间内存</th>
<th>分段内存</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031153554918.png" alt=""></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031153610637.png" alt="image-20221031153610637"></td>
</tr>
<tr>
<td><strong>组切换内存</strong></td>
<td><strong>多空间内存</strong></td>
</tr>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031153636127.png" alt="image-20221031153636127"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031153652256.png" alt="image-20221031153652256"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-2-2-ROM的种类与选型"><a href="#4-2-2-ROM的种类与选型" class="headerlink" title="4.2.2 ROM的种类与选型"></a>4.2.2 ROM的种类与选型</h4><p>ROM 可以在工厂编程。</p>
<p>闪存(Flash)是现场可编程 ROM 的主要形式。</p>
<ul>
<li>电可擦除，只能块擦除。</li>
<li>随机访问，但是写入/擦除比读取慢得多。</li>
<li>NOR 闪存更加灵活。</li>
<li>NAND 闪存更密集。</li>
</ul>
<h4 id="4-2-3-Flash的种类与选型"><a href="#4-2-3-Flash的种类与选型" class="headerlink" title="4.2.3 Flash的种类与选型"></a>4.2.3 Flash的种类与选型</h4><ul>
<li>非易失性存储器：闪存可以在线（in-circuit）编程。</li>
<li>闪存可以被电擦除和重新编程。</li>
<li>轻便、紧凑、节能且更便宜。</li>
</ul>
<p>分类：</p>
<ul>
<li>NOR：字可读取，逐块擦除。</li>
<li>NAND：按页读取（512-4K字节），逐块擦除。<ul>
<li>NAND 相对便宜，擦除速度更快，顺序访问时间更短。</li>
</ul>
</li>
</ul>
<h4 id="4-2-4-RAM的种类与选型"><a href="#4-2-4-RAM的种类与选型" class="headerlink" title="4.2.4 RAM的种类与选型"></a>4.2.4 RAM的种类与选型</h4><p>动态RAM(DRAM)密集，需要刷新。</p>
<ul>
<li>同步 DRAM 是主要类型。</li>
<li>SDRAM 使用时钟来提高性能，以流水线方式访问存储器。</li>
</ul>
<p>静态RAM(SRAM)更快，密度更低，消耗更多功率。</p>
<h4 id="4-2-5-Cache"><a href="#4-2-5-Cache" class="headerlink" title="4.2.5 Cache-"></a>4.2.5 Cache-</h4><ul>
<li>并不是严格的内存架构</li>
<li>可能经常被程序员忽略</li>
<li>优化有效使用的关键</li>
</ul>
<h3 id="4-3-嵌入式系统总线"><a href="#4-3-嵌入式系统总线" class="headerlink" title="4.3 嵌入式系统总线"></a>4.3 嵌入式系统总线</h3><h4 id="4-3-1-总线结构，常见的总线及特点"><a href="#4-3-1-总线结构，常见的总线及特点" class="headerlink" title="4.3.1 总线结构，常见的总线及特点"></a>4.3.1 总线结构，常见的总线及特点</h4><p><strong>CPU总线</strong></p>
<ul>
<li><p>总线允许CPU，内存，设备进行通信：共享的通讯媒体。</p>
</li>
<li><p>总线是：</p>
<ul>
<li><p>一组电线</p>
</li>
<li><p>通信协议</p>
</li>
</ul>
</li>
</ul>
<p><strong>微处理器总线</strong></p>
<ul>
<li><p>时钟提供同步。</p>
</li>
<li><p>读时R/W为true(读时R/W’为false)。</p>
</li>
<li><p>地址是地址线的位捆绑。</p>
</li>
<li><p>数据是n位数据线束。</p>
</li>
<li><p>当n bit数据就绪时，数据就绪信号发出</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031161002670.png" alt="image-20221031161002670"></p>
<p><strong>系统总线配置</strong></p>
<ul>
<li><p>多个总线允许并行处理：</p>
<ul>
<li><p>一条总线上的设备慢。</p>
</li>
<li><p>快速设备位于单独的总线上。</p>
</li>
</ul>
</li>
<li><p>桥连接两条总线</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031221056726.png" alt="image-20221031221056726"></p>
<p><strong>ARM AMBA bus</strong></p>
<ul>
<li><p>两个类别:</p>
<ul>
<li><p>AHB是高性能的。</p>
</li>
<li><p>APB是低速，低成本的。</p>
</li>
</ul>
</li>
<li><p>AHB支持流水线，突发传输，拆分事务，多个总线主控。</p>
</li>
<li><p>所有设备都是APB上的从设备。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031221519490.png" alt="image-20221031221519490"></p>
<h4 id="4-3-2-输入输出编程：忙等IO和中断IO"><a href="#4-3-2-输入输出编程：忙等IO和中断IO" class="headerlink" title="4.3.2 输入输出编程：忙等IO和中断IO"></a>4.3.2 输入输出编程：忙等IO和中断IO</h4><p>peek and poke</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">(<span class="hljs-type">char</span> *location)</span> &#123;<br>   <span class="hljs-keyword">return</span> *location;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">poke</span><span class="hljs-params">(<span class="hljs-type">char</span> *location, <span class="hljs-type">char</span> newval)</span> &#123;<br>   (*location) = newval;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="4-3-2-1-忙等-busy-wait-输出"><a href="#4-3-2-1-忙等-busy-wait-输出" class="headerlink" title="4.3.2.1 忙等(busy/wait)输出"></a>4.3.2.1 忙等(busy/wait)输出</h5><p>对设备进行编程的最简单方法。使用指令测试设备何时准备就绪：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">current_char = mystring;<br><span class="hljs-keyword">while</span> (*current_char != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>   poke(OUT_CHAR, *current_char);<br>   <span class="hljs-keyword">while</span> (peek(OUT_STATUS) != <span class="hljs-number">0</span>);<br>   current_char++;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>同步忙等I/O</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (TRUE) &#123;<br>   <span class="hljs-comment">/* read */</span><br>   <span class="hljs-keyword">while</span> (peek(IN_STATUS) == <span class="hljs-number">0</span>);<br>   achar = (<span class="hljs-type">char</span>)peek(IN_DATA);<br>   <span class="hljs-comment">/* write */</span><br>   poke(OUT_DATA,achar);<br>   poke(OUT_STATUS,<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">while</span> (peek(OUT_STATUS) != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="4-3-2-2-中断I-O"><a href="#4-3-2-2-中断I-O" class="headerlink" title="4.3.2.2 中断I/O"></a>4.3.2.2 中断I/O</h5><p>忙等是非常低效的</p>
<ul>
<li><p>CPU 在测试设备时不能做其他工作。</p>
</li>
<li><p>很难实现同步 I/O</p>
</li>
</ul>
<p>中断允许设备更改 CPU 中的控制流</p>
<ul>
<li>导致子例程调用以处理设备。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031230125096.png" alt="image-20221031230125096"></p>
<h4 id="4-3-3-Programming-I-O：Independent-I-O-port-memory-mapped-I-O"><a href="#4-3-3-Programming-I-O：Independent-I-O-port-memory-mapped-I-O" class="headerlink" title="4.3.3 Programming I/O：Independent I/O port. memory-mapped I/O."></a>4.3.3 Programming I/O：Independent I/O port. memory-mapped I/O.</h4><p>通信期间选择控制寄存器或数据缓冲区的三种方法</p>
<ol>
<li>独立的 I/O 端口：需要专门的指令来完成。</li>
<li>内存映射的 I/O。</li>
<li>混合解决方案（统一编址）：混合模型包括内存映射的 I/O 数据缓冲区和用于控制寄存器的单独的 I/O 端口。</li>
</ol>
<p>英特尔 x86 提供了输入输出说明。大多数其他 CPU 使用内存映射的 I/O。</p>
<p>I/O 指令不排除内存映射的 I/O</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031224207967.png" alt="image-20221031224207967"></p>
<h5 id="4-3-3-1-内存映射的-I-O"><a href="#4-3-3-1-内存映射的-I-O" class="headerlink" title="4.3.3.1 内存映射的 I/O"></a>4.3.3.1 内存映射的 I/O</h5><p>优点：</p>
<ol>
<li>在内存映射的 I/O 模式下，设备控制寄存器只是内存中的变量，并且可以与其他变量一样用 C 寻址。因此，可以完全用 C 语言编写 I/O 设备驱动程序。</li>
<li>在这种模式下，不需要特殊的保护机制即可阻止用户进程执行 I/O 操作。</li>
</ol>
<p>缺点：</p>
<ol>
<li>当前大多数嵌入式处理器都支持内存缓存。缓存设备控制寄存器将导致灾难。为了防止这种情况，必须为硬件提供选择性禁用缓存的功能。这将增加嵌入式系统中硬件和软件的复杂性。</li>
<li>如果只有一个地址空间，则所有内存模块和所有 I/O 设备都必须检查所有内存引用，以便确定要响应的内存引用。这会严重影响系统性能。</li>
</ol>
<p><strong>ARM 内存映射的 I/O：</strong></p>
<ol>
<li>定义设备地址：<code>DEV1 EQU 0x1000</code></li>
<li>读写代码：</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r1</span>, <span class="hljs-symbol">#DEV1</span> 	<span class="hljs-comment">; set up device adrs</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>] 	<span class="hljs-comment">; read DEV1</span><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">#8</span> 		<span class="hljs-comment">; set up value to write</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>] 	<span class="hljs-comment">; write value to device</span><br></code></pre></td></tr></table></figure>
<h2 id="5-嵌入式系统软件知识"><a href="#5-嵌入式系统软件知识" class="headerlink" title="5 嵌入式系统软件知识"></a>5 嵌入式系统软件知识</h2><h3 id="5-1嵌入式软件基础知识"><a href="#5-1嵌入式软件基础知识" class="headerlink" title="5.1嵌入式软件基础知识"></a>5.1嵌入式软件基础知识</h3><h4 id="5-1-1嵌入式软件的特点"><a href="#5-1-1嵌入式软件的特点" class="headerlink" title="5.1.1嵌入式软件的特点"></a>5.1.1嵌入式软件的特点</h4><ul>
<li>内存：<ul>
<li>有限，影响编程语言的选择以及开发工具的使用（比如编译器优化）。</li>
</ul>
</li>
<li>CPU 处理能力：<ul>
<li>成本和功耗的考虑，ES 不得不采用保守的设计方案，其中的 CPU 往往只是恰好满足要求。</li>
</ul>
</li>
<li>操作系统：<ul>
<li>OS（Windows/Linux）、RTOS、专有 OS 或裸机</li>
</ul>
</li>
<li>实时行为：<ul>
<li>实时系统不一定会运行得很快，但一定是可预测的，通常的术语叫做确定性</li>
<li>实时性的要求对于 OS 的选择和程序设计都有影响</li>
</ul>
</li>
<li>开发流程：<ul>
<li>ES 往往没有足够的资源进行软件开发。交叉开发对于工具的选择有很大影响。</li>
<li>开发过程也不同，编辑/编译/调试的循环是一样的，但执行程序这一步却非常复杂，需要把代码转移到目标机上或者在某种环境下运行。</li>
</ul>
</li>
<li>执行流程：<ul>
<li>多数嵌入式设备从开机开始就会运行某个程序，该程序会一直运行到系统关机。这个程序可能存储在 ROM，也可能是从非易失性存储器转移到 RAM 中执行。</li>
</ul>
</li>
<li>每一个嵌入式设备都是不同的：<ul>
<li>可能是技术层面的：不同的 CPU 架构、内存、外设、应用程序和操作系统</li>
<li>也可能是商业运作层面的，比如手机开发、生产的商业模式就和核磁共振扫描仪完全不同。</li>
</ul>
</li>
<li>嵌入式软件工具和组件：<ul>
<li>与桌面软件开发一样，嵌入式软件工程师需要运用工具来构建和测试软件。同时，也很可能会引入可重用的软件组件</li>
</ul>
</li>
<li>开发工具：<ul>
<li>从表面上看，嵌入式软件的开发过程和桌面软件很像：编译代码模块，然后在调试器的控制下执行。然而，并不这么简单，有着显著的不同。</li>
<li>往往是使用交叉编译器来进行嵌入式软件的开发。</li>
<li>有时候嵌入式应用中会直接包含小部分的汇编代码：出于对性能的考量。</li>
<li>嵌入式链接器除了将多个对象模块和函数库例程整合在一起以外，链接器还负责在内存中正确定位代码和数据。嵌入式系统的内存映射十分复杂，对于精确性的要求也十分严格。链接器必需能够灵活地应对这些要求。</li>
<li>嵌入式调试器并不是一个单一的组件，而是一系列对应不同运行环境的工具。借由在本地或者指令集模拟器中运行代码，代码可以仅在宿主机上运行。调试器也可以和一个目标板相连接（JTAG 或其他方式，如以太网），并执行代码。</li>
<li>其他一些更有针对性的工具，典型的选项包括分析实时性能、代码执行时设备功耗情况的分析器。</li>
</ul>
</li>
<li>软件组件：<ul>
<li>最简单和显而易见的可重用的软件组件是库。一些库是由编译器提供的，嵌入式编译器提供的库应当是适合嵌入式环境的：可以重入、可以被存储在 ROM 中。</li>
<li>其他可用的库，特别是针对 C++ 的库，如标准模板库 STL。这些库可能并不适合嵌入式应用，在使用时要多加小心。</li>
<li>与硬件交互是难点之一。在 OS 内部设备驱动提供了这样的接口</li>
<li>ES 的互联性不断提高，需要不同的网络支持，TCP/IP 或总线 CAN\I2C，其他网络技术 SNMP、Zigbee、Bluetooth、WiFi 和 USB。最重要的是应该检查有效性，确保符合标准，并能和其他系统互通互联。</li>
<li>嵌入式设备对于有组织的数据存储是有需求的，比如能够应对电源故障和支持多线程。</li>
<li>LCD（往往是触摸式的）成本减低让其能够被应用到嵌入式设计中。软件于是迎来了一项挑战：支持复杂的图像和用户界面。</li>
</ul>
</li>
</ul>
<h4 id="5-1-2嵌入式软件的分类"><a href="#5-1-2嵌入式软件的分类" class="headerlink" title="5.1.2嵌入式软件的分类"></a>5.1.2嵌入式软件的分类</h4><ul>
<li><p>系统软件</p>
<ul>
<li>系统软件控制和管理嵌入式系统资源，为嵌入式应用提供支持的各种软件，如设备驱动程序、嵌入式操作系统、嵌入式中间件等。</li>
</ul>
</li>
<li><p>应用软件</p>
<ul>
<li>应用软件是嵌入式系统中的上层软件，它定义了嵌入式设备的主要功能和用途，并负责与用户进行交互。应用软件是嵌入式系统功能的体现，如飞行控制软件、手机软件、MP3播放软件、电子地图软件等，一般面向特定的应用领域。</li>
</ul>
</li>
<li><p>支撑软件</p>
<ul>
<li>支撑软件是指辅助软件开发的工具软件，如系统分析设计工具、在线仿真工具、交叉编译器、源程序模拟器和配置管理工具等。</li>
</ul>
</li>
</ul>
<h4 id="5-1-3-嵌入式软件体系结构"><a href="#5-1-3-嵌入式软件体系结构" class="headerlink" title="5.1.3 嵌入式软件体系结构"></a>5.1.3 嵌入式软件体系结构</h4><ol>
<li>轮询</li>
<li>有限状态机</li>
<li>带中断的轮询</li>
<li>仅有中断</li>
<li>函数队列调度</li>
<li>实时操作系统(RTOS)</li>
</ol>
<h5 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Round Robin / Control Loop</span><br><span class="hljs-comment">//Everything is a function call from the main loop</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   <span class="hljs-keyword">while</span>(TRUE) &#123;<br>      <span class="hljs-keyword">if</span> (device_A requires service)<br>         service device_A<br>      <span class="hljs-title function_">if</span> <span class="hljs-params">(device_B requires service)</span><br>         service device_B<br>      <span class="hljs-title function_">if</span> <span class="hljs-params">(device_C requires service)</span><br>         service device_C<br>      ... and so on until all devices have been serviced, then start over again<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>优先级: 无，一切按顺序进行。</li>
<li>响应时间: 所有任务的总和。</li>
<li>变更的影响: 重大。改变执行任务时间或添加任务会影响所有其他任务。</li>
<li>简单性: 没有共享数据问题</li>
</ol>
<h5 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>   <span class="hljs-keyword">switch</span>(state) &#123;<br>      <span class="hljs-keyword">case</span> IDLE:<br>         check_buttons();<br>         LEDisplay_hex(NUM1);<br>         <span class="hljs-keyword">if</span> (BUTTON1 | BUTTON2 | BUTTON3)<br>            state=SHOW;<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> SHOW:<br>         NUM1=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">if</span> (BUTTON1) NUM1 += <span class="hljs-number">0x0001</span>;<br>         <span class="hljs-keyword">if</span> (BUTTON2) NUM1 += <span class="hljs-number">0x0010</span>;<br>         <span class="hljs-keyword">if</span> (BUTTON3) NUM1 += <span class="hljs-number">0x0100</span>;<br>         state=IDLE;<br>         <span class="hljs-keyword">break</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>与轮询类似，但只有当前状态被执行.</li>
<li>每个状态决定下一个状态(非顺序执行)。</li>
<li>优先级: 每个状态确定下一个状态的优先级。</li>
<li>响应时间: 所有任务的总和。</li>
<li>变更的影响: 重大。更改任务的执行时间或添加任务会影响所有其他任务。</li>
<li>简单性: 没有共享数据问题。</li>
</ol>
<h5 id="带中断的轮询"><a href="#带中断的轮询" class="headerlink" title="带中断的轮询"></a>带中断的轮询</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">BOOL flag_A = FALSE; <span class="hljs-comment">/* Flag for device_A follow-up processing */</span><br><span class="hljs-comment">/* Interrupt Service Routine for high priority device_A */</span><br>ISR_A(<span class="hljs-type">void</span>) &#123;<br>   ... handle urgent requirements <span class="hljs-keyword">for</span> device_A in the ISR,<br>   then <span class="hljs-built_in">set</span> flag <span class="hljs-keyword">for</span> follow-up processing in the main loop ...<br>   flag_A = TRUE;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   <span class="hljs-keyword">while</span>(TRUE) &#123;<br>      <span class="hljs-keyword">if</span> (flag_A)<br>         <span class="hljs-comment">//中断任务优先</span><br>         flag_A = FALSE<br>         <span class="hljs-comment">//... do follow-up processing with data from device_A</span><br>      <span class="hljs-keyword">if</span> (device_B requires service)<br>         service device_B<br>      <span class="hljs-keyword">if</span> (device_C requires service)<br>         service device_C<br>      <span class="hljs-comment">//... and so on until all high and low priority devices have been serviced</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>优先级-中断优先于主循环:优先中断</li>
<li>响应时间：所有任务的总和以及中断执行时间</li>
<li>更改的影响：对于中断服务程序而言意义不大。与轮询作为主循环相同。</li>
<li>共享数据-必须处理与中断服务程序共享的数据</li>
</ol>
<h5 id="仅有中断"><a href="#仅有中断" class="headerlink" title="仅有中断"></a>仅有中断</h5><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">SET_VECTOR(P3AD, button_isr);<br>SET_VECTOR(TIMER1, display_isr);<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>如果ISR过多，可能会有问题</li>
<li>如果高优先级的中断执行所需的时间比低优先级的中断所需的时间长，那么某些中断将被错过，或者您需要处理嵌套中断。</li>
<li>优先级-中断优先</li>
<li>响应时间:中断执行时间</li>
<li>变化的影响-对于中断服务程序而言意义不大。</li>
<li>共享数据-必须处理与中断服务程序共享的数据</li>
</ol>
<h5 id="函数队列调度"><a href="#函数队列调度" class="headerlink" title="函数队列调度"></a>函数队列调度</h5><ol>
<li>函数指针被添加到队列中。</li>
<li>主循环在队列中循环并执行任务。</li>
<li>任务或中断将新任务添加到功能队列中。</li>
<li>最坏的时机</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TASKS 20</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span><span class="hljs-params">(*FuncPtr)</span><span class="hljs-params">()</span>;<br>FuncPtr tasks[MAX_TASKS]<br><span class="hljs-type">int</span> current_task = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">add_task</span><span class="hljs-params">(FuncPtr func)</span> &#123;<br>   <span class="hljs-type">int</span> n;<br>   <span class="hljs-keyword">for</span>(n=current_task+<span class="hljs-number">1</span>;n&lt;MAX_TASKS<span class="hljs-number">-1</span>;n++) &#123;<br>      <span class="hljs-keyword">if</span>(tasks[n]==<span class="hljs-literal">NULL</span>) &#123;<br>         tasks[n]=func;<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">for</span>(n=<span class="hljs-number">0</span>;n&lt;current_task;n++) &#123;<br>      <span class="hljs-keyword">if</span>(tasks[n]==<span class="hljs-literal">NULL</span>) &#123;<br>         tasks[n]=func;<br>         <span class="hljs-keyword">return</span>;<br>   &#125;<br>&#125;<br><br>id <span class="hljs-title function_">display_task</span><span class="hljs-params">()</span> &#123;<br>   LEDisplay_hex(NUM1);<br>   add_task(button_task);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">button_task</span><span class="hljs-params">()</span> &#123;<br>   check_buttons();<br>   NUM1=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">if</span> (BUTTON1) NUM1 += <span class="hljs-number">0x0001</span>;<br>   <span class="hljs-keyword">if</span> (BUTTON2) NUM1 += <span class="hljs-number">0x0010</span>;<br>   <span class="hljs-keyword">if</span> (BUTTON3) NUM1 += <span class="hljs-number">0x0100</span>;<br>   add_task(display_task);<br>&#125;<br><br>main() &#123;<br>   LEDisplay_init();<br>   LEDisplay_clear();<br>   init_buttons();<br><br>   add_task(button_task);<br><br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span>(tasks[current_task]==<span class="hljs-literal">NULL</span>) &#123;<br>      ;<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>         (*tasks[current_task])();<br>         tasks[current_task]=<span class="hljs-literal">NULL</span>;<br>      &#125;<br>      current_task++;<br>      <span class="hljs-keyword">if</span>(current_task&gt;=MAX_TASKS) current_task=<span class="hljs-number">0</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>优先级：中断优先。任务按顺序执行</li>
<li>响应时间：最长任务的执行时间</li>
<li>变更的影响：低。中断管理优先级功能。队列管理较低的优先级。</li>
<li>共享数据：必须处理与中断服务程序共享的数据</li>
</ol>
<p><strong>函数队列优化</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 添加时间队列</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span><span class="hljs-params">(*FuncPtr)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>   <span class="hljs-type">long</span> timer;<br>   <span class="hljs-type">int</span> status;<br>   FuncPtr;<br>&#125; Task;<br><br>Task task_list[MAX_TASKS];<br><br><span class="hljs-comment">// 添加任务优先级</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span><span class="hljs-params">(*FuncPtr)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>   <span class="hljs-type">int</span> priority;<br>   FuncPtr;<br>&#125; Task;<br><br>Task task_list[MAX_TASKS];<br></code></pre></td></tr></table></figure>
<h5 id="抢占式多任务或多线程"><a href="#抢占式多任务或多线程" class="headerlink" title="抢占式多任务或多线程"></a>抢占式多任务或多线程</h5><ol>
<li>在这种类型的系统中，低级代码段基于计时器(连接到中断)在任务或线程之间切换。这是通常认为系统具有”操作系统”内核的级别。根据所需的功能量，它或多或少地引入了管理在概念上并行运行的多个任务的复杂性。</li>
<li>要访问共享数据，必须通过某种同步策略来控制，例如消息队列，信号量或非阻塞同步方案。</li>
<li>由于这些复杂性，组织通常使用实时操作系统(RTOS)，从而使应用程序程序员可以专注于设备功能而不是操作系统服务。</li>
</ol>
<h3 id="5-2-嵌入式操作系统基础知识"><a href="#5-2-嵌入式操作系统基础知识" class="headerlink" title="5.2 嵌入式操作系统基础知识"></a>5.2 嵌入式操作系统基础知识</h3><h4 id="5-2-1-RTOS概念、特点、选型原则（商业化RTOS）"><a href="#5-2-1-RTOS概念、特点、选型原则（商业化RTOS）" class="headerlink" title="5.2.1 RTOS概念、特点、选型原则（商业化RTOS）"></a>5.2.1 RTOS概念、特点、选型原则（商业化RTOS）</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><strong>实时操作系统</strong>（Real-time operating system, RTOS）是指面向实时运行对象，并为其服务的操作系统<br>实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>可靠性</li>
<li>可预测性、确定性</li>
<li>性能</li>
<li>紧凑性</li>
<li>可扩展性</li>
</ul>
<h5 id="选型原则"><a href="#选型原则" class="headerlink" title="选型原则"></a>选型原则</h5><h4 id="5-2-2-任务管理"><a href="#5-2-2-任务管理" class="headerlink" title="5.2.2 任务管理"></a><strong>5.2.2</strong> 任务管理</h4><h5 id="进程、线程、任务的概念"><a href="#进程、线程、任务的概念" class="headerlink" title="进程、线程、任务的概念"></a>进程、线程、任务的概念</h5><p>进程是程序的执行</p>
<p>线程则是某一进程中一路单独运行的程序</p>
<p>任务是指由软件完成的一个活动</p>
<h5 id="任务的实现（任务的层次结构、任务控制块、任务的状态及状态转换、任务队列）"><a href="#任务的实现（任务的层次结构、任务控制块、任务的状态及状态转换、任务队列）" class="headerlink" title="任务的实现（任务的层次结构、任务控制块、任务的状态及状态转换、任务队列）"></a>任务的实现（任务的层次结构、任务控制块、任务的状态及状态转换、任务队列）</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221101150649119.png" alt="image-20221101150649119"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221101150737127.png" alt="image-20221101150737127"></p>
<h5 id="任务调度（可抢占调度、不可抢占调度、先来先服务、时间片轮转算法、优先级算法）"><a href="#任务调度（可抢占调度、不可抢占调度、先来先服务、时间片轮转算法、优先级算法）" class="headerlink" title="任务调度（可抢占调度、不可抢占调度、先来先服务、时间片轮转算法、优先级算法）"></a>任务调度（可抢占调度、不可抢占调度、先来先服务、时间片轮转算法、优先级算法）</h5><p><strong>抢占式调度</strong></p>
<ul>
<li>假设所有线程都有优先级<ul>
<li>静态分配的(在线程持续时间内恒定)</li>
<li>动态分配的(可能有所不同)</li>
</ul>
</li>
<li>进一步假设内核跟踪”启用”了哪些线程(能够执行，例如在等待信号量或互斥量或时间到期之前不会被阻塞)。</li>
<li>抢占式调度：<ul>
<li>在任何时候，具有最高优先级的已启用线程正在执行。</li>
<li>每当任何线程更改优先级或启用状态时，内核都可以分派新线程。</li>
</ul>
</li>
</ul>
<h5 id="实时系统及任务调度（RMS、EDF算法）"><a href="#实时系统及任务调度（RMS、EDF算法）" class="headerlink" title="实时系统及任务调度（RMS、EDF算法）"></a>实时系统及任务调度（RMS、EDF算法）</h5><p><strong>速率单调调度(RMS, Rate Monotonic Scheduling)</strong></p>
<ul>
<li>假设使用以下命令定期调用n个任务：<ul>
<li>周期T1，…，Tn(施加实时约束)</li>
<li>所有任务都是独立的。</li>
<li>最坏情况执行时间(WCET)C1，…，Cn：假定没有互斥请锁、信号量或阻塞的I/O</li>
<li>没有优先级限制</li>
<li>固定优先级</li>
<li>上下文切换所需的时间可以忽略不计</li>
<li>抢占式调度</li>
</ul>
</li>
<li>定理：如果任何优先级分配产生可行的时间表，则按时段排序的优先级(最小时段具有最高优先级)也产生可行的时间表。</li>
<li>就可行性而言，RMS是最佳的</li>
<li>周期越短，优先级越高</li>
</ul>
<p><strong>EDF，Earliest deadline first(1974)</strong></p>
<ol>
<li>通过允许任务随时”到达”(准备就绪)来扩展EDD。</li>
<li>最早截止时间优先(EDF)：给定n个独立任务的集合，它们具有任意的到达时间，任何在任意时刻执行所有到达任务中绝对截止时间最早的任务的算法都是最优的。最大程度地减少<strong>延迟</strong>。</li>
<li>证明使用类似的互换参数。</li>
</ol>
<p>截止时间最小优先级最高</p>
<p><strong>RMS和EDF哪个好</strong></p>
<ol>
<li>RMS优点:调度决策更简单(固定优先级与EDF所需的动态优先级。EDF调度程序必须维护按优先级排序的就绪任务列表。)</li>
<li>EDF优点:<ol>
<li>由于EDF是关于最大延迟的最优，也是关于可行性的最优选择。 RMS仅是关于可行性的最优选择。对于不可行的计划，RMS会完全阻止优先级较低的任务，从而导致无限的最大延迟。</li>
<li>如果RMS无法做到这一点，那么EDF可以充分利用</li>
<li>EDF实际上减少了抢占，因此减少了上下文切换的开销。</li>
<li>截止时间可能与周期不同。</li>
</ol>
</li>
</ol>
<h5 id="任务间通信（共享内存、消息、管道、信号）"><a href="#任务间通信（共享内存、消息、管道、信号）" class="headerlink" title="任务间通信（共享内存、消息、管道、信号）"></a>任务间通信（共享内存、消息、管道、信号）</h5><h5 id="同步与互斥（竞争条件、临界区、互斥、信号量、死锁）"><a href="#同步与互斥（竞争条件、临界区、互斥、信号量、死锁）" class="headerlink" title="同步与互斥（竞争条件、临界区、互斥、信号量、死锁）"></a>同步与互斥（竞争条件、临界区、互斥、信号量、死锁）</h5><ol>
<li>线程访问共享资源时，它们需要使用互斥对象以确保数据完整性。</li>
<li>互斥体也可能使调度复杂化。</li>
</ol>
<h4 id="5-2-3存储管理"><a href="#5-2-3存储管理" class="headerlink" title="5.2.3存储管理"></a>5.2.3存储管理</h4><p> 嵌入式系统静态和动态内存管理</p>
<h3 id="5-3-嵌入式系统程序设计"><a href="#5-3-嵌入式系统程序设计" class="headerlink" title="5.3 嵌入式系统程序设计"></a>5.3 嵌入式系统程序设计</h3><h4 id="5-3-1嵌入式软件开发基础知识"><a href="#5-3-1嵌入式软件开发基础知识" class="headerlink" title="5.3.1嵌入式软件开发基础知识"></a>5.3.1嵌入式软件开发基础知识</h4><h4 id="5-3-2嵌入式软件开发环境"><a href="#5-3-2嵌入式软件开发环境" class="headerlink" title="5.3.2嵌入式软件开发环境"></a>5.3.2嵌入式软件开发环境</h4><p>交叉开发（宿主机、目标机）</p>
<p>编辑器、编译器、链接器、调试器、模拟器</p>
<p>常用嵌入式开发工具</p>
<p>集成开发环境</p>
<p>开发辅助工具</p>
<h4 id="5-3-3嵌入式软件开发"><a href="#5-3-3嵌入式软件开发" class="headerlink" title="5.3.3嵌入式软件开发"></a>5.3.3嵌入式软件开发</h4><p>Ref: </p>
<p>嵌入式计算系统设计原理。</p>
<p>  嵌入式系统导论-CPS方法。</p>
<h2 id="6-嵌入式实时内核（结合µC-OS-II和freertos）"><a href="#6-嵌入式实时内核（结合µC-OS-II和freertos）" class="headerlink" title="6 嵌入式实时内核（结合µC/OS-II和freertos）"></a>6 嵌入式实时内核（结合µC/OS-II和freertos）</h2><h3 id="6-1-实时任务调度"><a href="#6-1-实时任务调度" class="headerlink" title="6.1 实时任务调度"></a>6.1 实时任务调度</h3><ul>
<li>μC/OS-II是可抢占实时多任务内核，它总是运⾏就绪任务中优先级最⾼的那⼀个。</li>
<li>μC/OS-II中不⽀持时间⽚轮转法，每个任务的优先级要求不⼀样且是唯⼀的，所以任务调度的⼯作就是：查找准备就绪的最⾼优先级的任务并进⾏上下⽂切换。</li>
<li>μC/OS-II任务调度所花的时间为常数，与应⽤程序中建⽴的任务数⽆关。</li>
<li>确定哪个任务的优先级最⾼，应该选择哪个任务去运⾏，这部分的⼯作是由调度器（Scheduler）来完成的。<ul>
<li>任务级的调度是由函数OSSched()完成的；</li>
<li>中断级的调度是由另⼀个函数OSIntExt()完成的。</li>
</ul>
</li>
</ul>
<p>FreeRTOS是⼀个实时操作系统，所奉⾏的调度规则：</p>
<ul>
<li>⾼优先级抢占低优先级任务，系统永远执⾏最⾼优先级的任务。</li>
<li>同等优先级的任务轮转调度。</li>
</ul>
<h3 id="6-2-中断与时钟"><a href="#6-2-中断与时钟" class="headerlink" title="6.2 中断与时钟"></a>6.2 中断与时钟</h3><p>μC/OS-II系统响应中断的过程为：</p>
<p>系统接收到中断请求后，这时如果CPU处于中断允许状态（即中断是开放的），系统就会中止正在运行的当前任务，而按照中断向量的指向转而去运行中断服务子程序；当中断服务子程序的运行结束后，系统将会根据情况返回到被中止的任务继续运行或者转向运行另一个具有更高优先级别的就绪任务。</p>
<ol>
<li>时钟节拍是⼀种特殊的中断；</li>
<li>μC/OS需要⽤户提供周期性信号源，⽤于实现时间延时和确认超时。节拍率应在10到100Hz之间，时钟节拍率越⾼，系统的额外负荷就越重；</li>
<li>时钟节拍的实际频率取决于⽤户应⽤程序的精度。时钟节拍源可以是专门的硬件定时器，或是来⾃50/60Hz交流电源的信号。</li>
</ol>
<h3 id="6-3-同步与通信"><a href="#6-3-同步与通信" class="headerlink" title="6.3 同步与通信"></a>6.3 同步与通信</h3><p>所有的通信信号都被看成是事件(event), μC/OS-II通过事件控制块(ECB)来管理每⼀个具体事件。</p>
<p>同步可以通过开关中断实现。互斥使用信号量。</p>
<p>通信可以使用邮箱和消息队列实现。</p>
<h3 id="6-4-存储管理（静态、动态）"><a href="#6-4-存储管理（静态、动态）" class="headerlink" title="6.4 存储管理（静态、动态）"></a>6.4 存储管理（静态、动态）</h3><p>μC/OS采⽤的是固定分区的存储管理⽅法</p>
<ul>
<li>µC/OS把连续的⼤块内存按分区来管理，每个分区 包含有整数个⼤⼩相同的块；</li>
<li>在⼀个系统中可以有多个内存分区，这样，⽤户的应⽤程序就可以从不同的内存分区中得到不同⼤⼩ 的内存块。但是，特定的内存块在释放时必须重新放回它以前所属于的内存分区；</li>
<li>采⽤这样的内存管理算法，上⾯的内存碎⽚问题就得到了解决。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221101160551985.png" alt="image-20221101160551985"></p>
<p>为了便于管理，在µC/OS中使⽤内存控制块MCB（Memory Control Block）来跟踪每⼀个内存分区，系统中的每个内存分区都有它⾃⼰的 MCB。</p>
<h2 id="7-bsp-bootloader"><a href="#7-bsp-bootloader" class="headerlink" title="7 bsp, bootloader"></a>7 bsp, bootloader</h2><h3 id="7-1-嵌入式系统的启动过程"><a href="#7-1-嵌入式系统的启动过程" class="headerlink" title="7.1 嵌入式系统的启动过程"></a>7.1 嵌入式系统的启动过程</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221101161059659.png" alt="image-20221101161059659"></p>
<h3 id="7-2-bsp，特点，与bios区别"><a href="#7-2-bsp，特点，与bios区别" class="headerlink" title="7.2 bsp，特点，与bios区别"></a>7.2 bsp，特点，与bios区别</h3><h4 id="7-2-1-bsp"><a href="#7-2-1-bsp" class="headerlink" title="7.2.1 bsp"></a>7.2.1 bsp</h4><p>BSP全称“板级⽀持包”（Board Support Packages），就是⼀段启动代码，和计算机主板的BIOS差不多，但提供的功能区别就相差很⼤。</p>
<h4 id="7-2-2-特点"><a href="#7-2-2-特点" class="headerlink" title="7.2.2 特点"></a>7.2.2 特点</h4><p>硬件相关性</p>
<ul>
<li>因为嵌⼊式实时系统的硬件环境具有应⽤相关性，所以，作为⾼层软件与硬件之间的接⼝，BSP必须为操作系统提供操作和控制具体硬件的⽅法。</li>
</ul>
<p>操作系统相关性</p>
<ul>
<li>不同的操作系统具有各⾃的软件层次结构，因此，不同的操作系统具有特定的硬件接⼝形式</li>
</ul>
<h4 id="7-2-3-区别"><a href="#7-2-3-区别" class="headerlink" title="7.2.3 区别"></a>7.2.3 区别</h4><p>BSP是和操作系统绑在⼀起运⾏，尽管BSP的开始部分和BIOS所做的⼯作类似，但是BSP还包含和系统有关的基本驱动。</p>
<p>BIOS程序是⽤户不能更改，编译编程的，只能对参数进⾏修改设置，但是程序员还可以编程修改BSP，在BSP中任意添加⼀些和系统⽆关的驱动或程序，甚⾄可以把上层开发的统统放到BSP中 。</p>
<h3 id="7-3-引导模式"><a href="#7-3-引导模式" class="headerlink" title="7.3 引导模式"></a>7.3 引导模式</h3><p>操作系统引导概念：将操作系统装⼊内存并开始执⾏的过程。</p>
<p>按时间效率和空间效率不同的要求，分为两种模式：</p>
<ul>
<li>不需要BootLoader的引导模式：时间效率⾼，系统快速启动，直接在NOR flash或ROM系列⾮易失性存储介质中运⾏，但不满⾜运⾏速度的要求。</li>
<li>需要BootLoader的引导模式：节省空间，牺牲时间，适⽤于硬件成本低，运⾏速度快，但启动速度 相对慢</li>
</ul>
<h3 id="7-4-bootloader及其启动过程"><a href="#7-4-bootloader及其启动过程" class="headerlink" title="7.4 bootloader及其启动过程"></a>7.4 bootloader及其启动过程</h3><p>嵌⼊式系统中的 OS 启动加载程序</p>
<p>引导加载程序</p>
<ul>
<li>包括固化在固件(firmware)中的 boot 代码(可选)，和 Boot Loader两⼤部分</li>
<li>是系统加电后运⾏的第⼀段软件代码</li>
</ul>
<p>相对于操作系统内核来说，它是⼀个硬件抽象层</p>
<p>BIOS 在完成硬件检测和资源分配后，将硬盘 MBR 中的 Boot Loader 读到系统的 RAM 中，然后将控制权交给 OS Boot Loader</p>
<p>Boot Loader 的主要运⾏任务就是将内核映象从硬盘上读到 RAM 中，然后跳转到内核的⼊⼝点去运⾏，即开始启动操作系统。</p>
<h2 id="8-建模"><a href="#8-建模" class="headerlink" title="8 建模"></a>8 建模</h2><p>有限状态机及其应用。</p>
<p>有限状态机的实现。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/嵌入式系统概论/">嵌入式系统概论</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/嵌入式系统概论/">嵌入式系统概论</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/29/云计算-6-分布式计算/"><span>云计算(6) 分布式系统:计算和存储</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/29/云计算-6-分布式计算/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-29T06:34:11.000Z">
          2022-10-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="六、分布式系统：计算和存储"><a href="#六、分布式系统：计算和存储" class="headerlink" title="六、分布式系统：计算和存储"></a>六、分布式系统：计算和存储</h1><h2 id="1-分布式计算"><a href="#1-分布式计算" class="headerlink" title="1 分布式计算"></a>1 分布式计算</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>集中式计算：完全依赖一台大型的中心计算机的处理能力，即主机，与其相连的终端设备具有各不相同非常低的计算能力。实际上大多数终端完全不具有处理能力，仅作为输入输出设备使用。</p>
<p>分布式计算：多个通过网络互联的计算机都具有一定的计算能力，他们相互之间传递数据，实现信息共享，协作共同完成一个处理任务。</p>
<ul>
<li><p>中国科学院：分布式计算就是在两个或多个软件互相共享信息，这些软件既可以在同一台计算机上，也可以在通过网络连接起来的多台计算机上运行</p>
</li>
<li><p>优势：稀有资源实现共享；在多台计算机上平衡计算负载；将程序放在最适合它的计算机上运行。</p>
</li>
</ul>
<p>分布式系统：将海量计算能力才能处理的问题拆分成许多小块，将小块分配给同一套系统中不同的计算机节点处理，最后将分开计算的结果合并得到最终结果的系统。</p>
<ul>
<li>通过网络消息实现数据通信与协调</li>
</ul>
<p>分布式计算的一般步骤</p>
<ul>
<li>设计分布式计算模型；分布式任务分配；编写并执行分布式程序【难点：计算任务划分 + 多节点通信】<ul>
<li><code>如何将复杂算法优化分解为适用于多个节点分别计算的小任务：特别是希望节点之间互不相干</code></li>
<li><code>多数还是要相互通信的：消息队列；分布式存储</code></li>
</ul>
</li>
</ul>
<h3 id="1-2-理论基础"><a href="#1-2-理论基础" class="headerlink" title="1.2 理论基础"></a>1.2 理论基础</h3><h4 id="1-2-1-ACID原则"><a href="#1-2-1-ACID原则" class="headerlink" title="1.2.1 ACID原则"></a>1.2.1 ACID原则</h4><p>ACID原则：数据库事务正常执行的四个原则</p>
<ul>
<li><p>原子性(Atomicity)-事务中所有操作要么全都做完，要么都不做；只要一个操作失败，事务就失败，要回滚</p>
</li>
<li><p>一致性(Consistency)-数据库要处于原本的一致性状态</p>
</li>
<li><p>独立性(Isolation)-并发的事务不会相互影响，读数据不受影响，写数据也不能受到影响</p>
</li>
<li><p>持久性(Durability)-一旦事务提交后，它所作的修改应该永久保存在数据库上，即使宕机也不会丢失</p>
</li>
</ul>
<p>在单台服务器能够完成数据库任务的时代，很容易实现ACID</p>
<p>但是随着单台服务器无法满足大规模数据存储，使用集群替代单台服务器，ACID难以得到高效的保证</p>
<h4 id="1-2-2-CAP理论"><a href="#1-2-2-CAP理论" class="headerlink" title="1.2.2 CAP理论"></a>1.2.2 CAP理论</h4><p>CAP理论：一个<strong>分布式系统</strong>最多能够同时满足一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)中的两项</p>
<ul>
<li><p>一致性——一次操作之后，所有节点同一时间的数据完全一致。从客户端角度看，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</p>
<blockquote>
<p>强一致性：更新过的数据，后续访问都能看到</p>
<p>弱一致性：能容忍后续的部分或者全部访问不到</p>
<p>最终一致性：如果经过一段时间后要求能访问到更新后的数据，称为最终一致性</p>
</blockquote>
</li>
<li><p>可用性——服务一直可用且在正常的响应时间内。</p>
</li>
<li><p>分区容错性——分布式系统遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。</p>
</li>
</ul>
<p>阐述与证明</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029163601575.png" alt="image-20221029163601575"></p>
<p><strong>如何取舍</strong></p>
<ul>
<li>CA：但是某些分区始终存在，保证子系统CA</li>
<li>CP：导致某些节点无法使用</li>
<li>AP：导致全局数据不一致，但是高可用</li>
</ul>
<p><code>对于大多数大型互联网服务而言，节点故障、网络故障是常态，均采取保证AP的策略，对于一致性退而求其次，只保证最终一致性</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029163737165.png" alt="image-20221029163737118" style="zoom:67%;" /></p>
<h4 id="1-2-3-BASE理论"><a href="#1-2-3-BASE理论" class="headerlink" title="1.2.3 BASE理论"></a>1.2.3 BASE理论</h4><p>BASE理论——追求最终一致性</p>
<ul>
<li>Basically Available：基本可用-系统出现故障时，允许损失部分可用性，保证核心可用</li>
<li>Soft State：软状态：允许系统存在中间状态，但中间状态不会影响系统的整体可用性</li>
<li>Eventual Consistency：最终一致性-所有数据副本经过一定时间后，能最终达到一致的状态</li>
</ul>
<h4 id="1-2-4-一致性算法"><a href="#1-2-4-一致性算法" class="headerlink" title="1.2.4 一致性算法"></a>1.2.4 一致性算法</h4><p>一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。</p>
<ul>
<li>一台机器中多个进程/线程达成数据一致；</li>
<li>分布式文件系统或者分布式数据库中多客户端并发读写数据；</li>
<li>分布式存储中多个副本响应读写请求的一致性。</li>
</ul>
<p>基于消息传递的一致性算法Paxos：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/linbingdong/p/6253479.html">https://www.cnblogs.com/linbingdong/p/6253479.html</a> </p>
<p>基于消息传递的一致性算法Raft： <a target="_blank" rel="noopener" href="https://raft.github.io/">https://raft.github.io/</a> </p>
<p><strong>Basic Paxos</strong></p>
<ul>
<li><p>提议者Proposer：向所有其他节点提出提案</p>
<ol>
<li>准备：向所有其他决策者发送提案ID，等待回复</li>
<li>收到多数决策者的回应后，再发送提案Value</li>
</ol>
</li>
<li><p>决策者Acceptor：回应提议者的提议</p>
<ul>
<li>如果已经收到过提议，则将ID和对应的Vaule返回</li>
<li>如果没有收到过提议，则返回空</li>
</ul>
</li>
<li>学习者Learner：不参与决策，只是从决策过程学习到最终的一致提案的Value</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029164103787.png" alt="image-20221029164103787"></p>
<p>过程：分为三个阶段</p>
<ol>
<li>Proposer发准备请求；Acceptors回应ID和Value，并许下承诺<ul>
<li>不再接收比当前提案ID小的或相同的提案的准备Prepare请求和Accept请求</li>
</ul>
</li>
<li>Proposer收到多数回应后，发出带Value的Accept请求；Acceptors进行Accept处理<ul>
<li>从应答中选择提案ID最大的那个提案的Value作为本次要发起的提案Value</li>
<li>如果所有应答都为空，则可以自己随意决定提案的Value</li>
</ul>
</li>
<li>Proposer收到多数回应后，表示提案成功，立即将决议发送给所有Learner</li>
</ol>
<p>能够有效解决选择主服务器的问题和保证大家都一致写入操作的问题</p>
<p><strong>一致性Hash</strong></p>
<p>一致性Hash——如何高效管理分布式存储集群，保证高容错和高可扩展性</p>
<ul>
<li><p>初始化：计算服务器在环上位置；使用：计算数据在环上位置。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.enjoyalgorithms.com/blog/consistent-hashing-in-system-design">https://www.enjoyalgorithms.com/blog/consistent-hashing-in-system-design</a> </p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029164406521.png" alt="image-20221029164406521"></p>
<h2 id="2-分布式系统"><a href="#2-分布式系统" class="headerlink" title="2 分布式系统"></a>2 分布式系统</h2><h3 id="2-1-特性"><a href="#2-1-特性" class="headerlink" title="2.1 特性"></a>2.1 特性</h3><p>容错性</p>
<ul>
<li><p>我们可能永远也造不出永远都不出故障的机器，更加难以开发出永不出错的软件，因为软件在一定程度上还依赖硬件的可靠性</p>
</li>
<li><p>在大规模分布式系统中完全检测和避免所有可能发生的故障是不可能的，因此需要系统能够在某些节点发生故障的情况下，利用容错机制避免整套系统服务都不可用</p>
</li>
</ul>
<p>高可扩展性</p>
<ul>
<li>能够在运行过程中自由地对系统内部节点或现有功能进行扩充，而不影响现有服务的运行</li>
</ul>
<p>开放性</p>
<ul>
<li>开放性决定给了一个系统是否具备自我扩展和与其他系统集成的能力；开放的接口+接口遵循协议=更好</li>
</ul>
<p>并发处理能力</p>
<ul>
<li>分布式系统必须保证对象的操作在并发环境中能够安全的使用，保证数据一致性和系统高可用性</li>
</ul>
<p>透明性</p>
<ul>
<li>不需要让用户知晓分布式系统的内部细节，暴露给用户访问资源和服务的方式即可，用户将系统看作是一个整体。</li>
</ul>
<h3 id="2-2-类型"><a href="#2-2-类型" class="headerlink" title="2.2 类型"></a>2.2 类型</h3><p><strong>分布式存储系统</strong></p>
<ul>
<li><p>结构化存储：事务处理系统或关系型数据库，数据划分为表、字段和表关系，如分布式MySQL</p>
</li>
<li><p>非结构化存储：强调很高的可扩展性，存储数据非常自由，典型代表是分布式文件系统，如HDFS，GFS等</p>
</li>
<li><p>半结构化存储：为了解决非结构化数据随机访问性能差的问题，例如NoSQL，Key-Value Store，对象存储</p>
</li>
<li><p>In-memory存储：基于内存的存储系统，利用内存实现极高读写性能，例如Memcached和Redis，做缓存</p>
</li>
<li><p>NewSQL：既具备结构化存储的ACID事务支持，又拥有NoSQL半结构化存储的强大可扩展能力</p>
</li>
</ul>
<p><strong>分布式计算系统</strong></p>
<ul>
<li><p>传统基于消息的系统：MPI（Message Passing Interface），非常灵活，对应用程序无约束</p>
</li>
<li><p>Dataflow系统：将计算抽象为高层算子，算子组合为有向无环图，由后端调度引擎并行化调度执行</p>
<ul>
<li>Hadoop：MapReduce；Spark：更多类型的算子</li>
<li>框架对程序的结构有严格的约束：算子、输入和输出等</li>
</ul>
</li>
<li><p>流式计算、图计算、分布式机器学习——Spark都实现了这些类型的分布式计算</p>
</li>
</ul>
<p><strong>分布式资源管理系统</strong>：支持多种计算框架、高可扩展、高容错、高资源利用率、细粒度资源分配</p>
<ul>
<li><p>Yarn：Hadoop 2.0版本，解决了原来Hadoop扩展性较差的问题，可以在框架下自定义算子</p>
</li>
<li><p>Apache Mesos：加州大学伯克利分校的一个研究项目，现在属于Apache基金会的一个项目</p>
</li>
<li><p>Spark Standalone：Spark自带的简单的资源管理系统，负责跟踪集群状态并调度计算任务</p>
</li>
<li><p>Kubernets：Google开发的一个强大的容器编排框架，用户通过Kubernets管理容器，不需要和底层交互</p>
</li>
</ul>
<h3 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h3><p><strong>网格系统（Grid）</strong></p>
<ul>
<li><p>一种能够整合的合作使用的由多家组织所拥有和管理的高端计算机、网络、数据库、实验设备等基础设施</p>
</li>
<li><p>网格是一类并行、分布式系统，能够在运行时动态分享、选择、聚合地理散布得自治资源，依据它们的可用性、能力、性能、代价以及用户对服务质量的需求，构建满足用户需求的设备组合</p>
</li>
<li><p>网格技术解决的主要问题是合作研究中的社会问题，包括：</p>
<ul>
<li>改善分布式管理，同时保持对本地资源的全面控制</li>
<li>改善数据可用性，识别问题和数据访问模式的解决方案</li>
<li>为学者提供友好的环境，能够访问更大范围的地理上分布的设备，提高产率</li>
</ul>
</li>
</ul>
<p><strong>P2P系统（对等网络系统，Peer-to-Peer）</strong></p>
<ul>
<li>是一种在对等者之间分配任务和工作负载的分布式应用架构的系统；所有参与者的角色相同，都对外共享它们拥有的一部分硬件资源，这些资源可以被系统内其他参与者访问。性质：<ul>
<li>高度分散化：节点地理位置分散，系统资源的管理和任务处理也高度分散在各个节点</li>
<li>自组织性：系统按照相互默契的规则，各尽其责而又协调地自动地形成有序结构；加入节点只需广播例如IP地址等必要的基本信息即可，无需额外操作。</li>
<li>多管理域：最夸张的是每一个节点都由不同的组织、个人管理，每一个节点就是一个管理域</li>
</ul>
</li>
<li>特点（优点）：部署门槛低；增长速度快；容错性高；资源的丰富性和多样性高</li>
<li>应用：共享及分发文件；流媒体；网络电话；志愿计算等</li>
</ul>
<p><strong>区块链（Block Chain）</strong></p>
<ul>
<li><p>一种去中心化、不可篡改、可追溯、多方共同维护的分布式数据库系统</p>
</li>
<li><p>集成了P2P协议、非对称加密技术、共识机制、块链结构等多种技术，解决数据的可信问题</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029171328737.png" alt="image-20221029171328737"></p>
<h3 id="2-4-分布式计算、存储、资源管理系统-Hadoop-2-0"><a href="#2-4-分布式计算、存储、资源管理系统-Hadoop-2-0" class="headerlink" title="2.4 分布式计算、存储、资源管理系统 Hadoop 2.0"></a>2.4 分布式计算、存储、资源管理系统 Hadoop 2.0</h3><p>Yarn做分布式资源管理；HDFS做分布式存储；MapReduce做分布式计算</p>
<p>为什么要分布式计算、存储系统呢？——单台机器无法解决问题，特别是大数据场景下</p>
<p><strong>分布式存储</strong></p>
<ul>
<li>将多台机器硬盘以某种方式连接到一起</li>
<li>取机器cSlave0，cSlave1和cMaster0，采用客户-服务器模式构建分布式存储集群</li>
<li>让cMaster0管理cSlave0，cSlave1。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029171454786.png" alt="image-20221029171454786"></p>
<p><strong>分布式计算</strong></p>
<p>假设现有一些配置完全相同的机器cSlave0~cSlaveN，cMaster0，cMaster1，并且每台机器都有1个双核CPU，5GB硬盘。现有两个大小都是2GB的文件file0和file1。将file0和file1存入两台不同机器，统计file0和file1这两个文件里每个单词出现的次数。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029171608829.png" alt="image-20221029171608829"></p>
<p>分布式计算——Hadoop MapReduce框架 大致如下：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029171658363.png" alt="image-20221029171658363"></p>
<p>冗余存储与冗余计算</p>
<ul>
<li>解决可靠性问题：不单纯依靠额外增加设备的备份</li>
<li>将每台机器上存储的数据同时存于集群中的另一台机器上</li>
<li>将每台机器上数据的计算也同时在冗余数据的机器上计算<ul>
<li>CMaster0明确知道每一份数据都存储在多个地方</li>
<li>CMaster1会要求存有待计算数据的机器都参与计算，并选择先结束的机器计算结果</li>
</ul>
</li>
<li>冗余存储不仅提高了分布式存储的可靠性，也提高了分布式计算的可靠性</li>
</ul>
<p><strong>资源管理</strong></p>
<p>Yarn：管理计算机资源、提供用户和程序访问系统资源的API</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029172002565.png" alt="image-20221029172002565"></p>
<p>任务调度策略是Yarn的核心问题，ResourceManager的Scheduler模块支持插拔，通过配置文件，用户可以个性化指定其调度策略。自带两种策略</p>
<ul>
<li>容量调度算法CapacityScheduler：按照配置好的资源配比为不同层级的用户分配最大可用资源</li>
<li>公平调度算法FairScheduler：任务公平使用集群资源，短任务在合理时间内完成；长任务不至于永远等待</li>
</ul>
<p>Yarn是可编程的，不仅仅支持自带的MapReduce，还可以自定义算子</p>
<p>一套编程协议</p>
<ul>
<li>Client负责提交任务，ApplicationMaster负责执行任务</li>
<li>Client中与RM通信；ApplicationMaster与RM通信；ApplicationMaster与NM通信</li>
<li>编写符合协议的Client和ApplicationMaster即可</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029172201728.png" alt="image-20221029172201728"></p>
<p>Hadoop默认实现了MapReduce的Client和ApplicationMaster</p>
<ul>
<li><p>MRClientService</p>
</li>
<li><p>MRAppMaster</p>
</li>
<li><p>Yarn处理MR程序时使用了各种默认的类</p>
</li>
</ul>
<p>Scheduler也是可编程的</p>
<h3 id="2-5-分布式计算和资源管理系统-Spark"><a href="#2-5-分布式计算和资源管理系统-Spark" class="headerlink" title="2.5 分布式计算和资源管理系统 Spark"></a>2.5 分布式计算和资源管理系统 Spark</h3><p>没有类似HDFS的分布式文件（存储）系统，但是有一套分布式内存管理系统——也是其核心</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029172403720.png" alt="image-20221029172403720"></p>
<p>Spark是建立在RDD(Resilient Distributed Datasets，弹性分布式数据集)之上的</p>
<p>RDD使得Spark可以用一致的方式处理大数据的不同应用场景</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029172559187.png" alt="image-20221029172559187"></p>
<p>解决的具体问题——不能基于内存共享数据，反复读写磁盘</p>
<ul>
<li>Hadoop的MapReduce对迭代式算法支持的效率不高，如图算法和机器学习算法</li>
<li>交互式数据挖掘工具中反复查询一个数据子集</li>
</ul>
<p>基于RDD的计算过程及相关术语</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029172743561.png" alt="image-20221029172743561"></p>
<p><strong>RDD的五大特性</strong></p>
<ol>
<li><p>分区列表：记录了数据块所在的分区位置；一个RDD对应的数据是切分为数据块存储在集群的不同节点上的</p>
</li>
<li><p>依赖列表：记录了当前这个RDD依赖于哪些其它的RDD</p>
</li>
<li><p>计算函数compute，用于计算RDD各个分区的值</p>
</li>
<li><p>可选：分区器，子类可以重新指定新的分区方式：Hash和Range</p>
</li>
<li><p>可选：计算各分区时优先的位置列表。例如从HDFS文件生成RDD时，HDFS文件所在位置就是对应生成的RDD分区所在位置的优先选择</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029172905204.png" alt="image-20221029172905204"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029172933311.png" alt="image-20221029172933311"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029172953063.png" alt="image-20221029172953063"></p>
<p>执行器 Executor——在Worker节点上运行，实际执行Task</p>
<ul>
<li>将发送到worker节点上的打包好的程序反序列化，解析出Task的代码，创建新线程调用Task run函数</li>
</ul>
<p>存储管理 Storage——分为通信层和存储层</p>
<ul>
<li><p>通信层用来管理多个Worker之间的通信，传输控制和状态信息</p>
</li>
<li><p>存储层用来实际与设备交互，读写内存、磁盘、堆外内存，为数据在远程节点生成副本</p>
</li>
</ul>
<p>Shuffle前后必不可少地需要网络I/O，通过数据序列化方法和压缩技术进行效率优化</p>
<ul>
<li>Spark中序列化方法和压缩算法的配置</li>
</ul>
<p>Spark 1.0：基于Hash的Shuffle机制</p>
<ul>
<li><p>每一个Mapper阶段的Task都会为Reduce阶段的每一个Task生成1个文件，M*R个</p>
</li>
<li><p>合并机制：每一个执行单位为Reduce阶段每一个Task生成1个文件</p>
</li>
</ul>
<p>Spark 1.1：基于Sort的Shuffle机制</p>
<ul>
<li>每一个Mapper阶段的Task生成两个文件：索引和数据文件，Reduce阶段通过索引读取</li>
</ul>
<p>Spark 1.4：钨丝计划——优化内存管理模型</p>
<ul>
<li>直接使用二进制数据，而不是Java对象；避免序列化和反序列化开销</li>
</ul>
<h2 id="3-分布式存储系统"><a href="#3-分布式存储系统" class="headerlink" title="3 分布式存储系统"></a>3 分布式存储系统</h2><h3 id="3-1-类型"><a href="#3-1-类型" class="headerlink" title="3.1 类型"></a>3.1 类型</h3><p>云计算中分布式计算主要作为“PaaS”，分布式存储则作为IaaS、PaaS、SaaS都有</p>
<p>根据存储的数据类型（结构化、非结构化、半结构化等），将存储系统分为以下几类</p>
<ul>
<li><p>分布式文件系统——泛指以分布式的方式存储文件的系统，文件可以多种形式存在</p>
<ul>
<li>三种数据类型：Binary large object(Blob)二进制大对象，定长块，大文件</li>
<li>提供不同类型的存储服务：对象存储、文件存储、块存储</li>
<li>可以作为分布式健值存储、分布式表、分布式数据的底层存储。GFS，弹性块存储EBS，Ceph</li>
</ul>
</li>
<li><p>分布式键值系统</p>
<ul>
<li>用来存储关系简单的半结构化数据，提供基于主键的CRUD功能</li>
<li>可以看作是对分布式表的简化，一般用来作缓存，例如Memcached。一致性Hash是常用技术</li>
</ul>
</li>
<li><p>分布式表</p>
<ul>
<li>用于存储半结构化数据；以表格为单位组织数据，一个表格有多行，通过主键标识一行</li>
<li>不仅仅支持简单的CRUD，还支持扫描某个主键的范围和范围查找功能。Google Bigtable</li>
</ul>
</li>
<li><p>分布式数据库</p>
<ul>
<li>基于传统关系型数据库发展而来，例如分布式MySQL</li>
</ul>
</li>
</ul>
<h3 id="3-2-文件系统的发展"><a href="#3-2-文件系统的发展" class="headerlink" title="3.2 文件系统的发展"></a>3.2 文件系统的发展</h3><p>狭义上的“文件系统”——不同于分布式文件存储中的块存储、对象存储</p>
<p>单机文件系统</p>
<ul>
<li>核心是使用树型数据结构组织文件、目录以及访问控制；随着单机能够管理的存储空间在变大，提升管理能力和性能的文件系统也在演化。</li>
</ul>
<p>网络文件系统</p>
<ul>
<li>目标是让用户能够以访问本地文件系统的方式访问远程机器上的文件，提供跨平台的文件共享系统</li>
</ul>
<p>并行文件系统</p>
<ul>
<li>用在大规模并行处理体系结构中，保证一个业务的多个并行任务可以同时对同一个文件的不同位置并行处理</li>
</ul>
<p>分布式文件系统</p>
<ul>
<li>采用集中式管理、分布式存储的架构，将文件实际存储在多个不同的节点上，且每一个部分都有多个副本</li>
</ul>
<p>高通量文件系统</p>
<ul>
<li>专指为大型数据中心设计的分布式文件系统，将数据中心所有的低成本存储资源有效地组织起来服务于上层多种应用的数据存储需求和数据访问需求</li>
</ul>
<h3 id="3-3-从单机到分布式"><a href="#3-3-从单机到分布式" class="headerlink" title="3.3 从单机到分布式"></a>3.3 从单机到分布式</h3><p>单机存储系统</p>
<ul>
<li>硬件基础</li>
<li>存储引擎：实现数据的基本操作，包括增删改查，读取分随机读和顺序扫描，重点是数据结构</li>
<li>数据模型：存储系统的外壳，三类数据模型：文件、关系、健值；对应文件系统、数据库、健值存储</li>
</ul>
<p>分布式存储系统</p>
<ul>
<li><p>对单机的扩展，面临的重要问题是：</p>
<ul>
<li>如何将数据均匀的分布到多个存储节点</li>
<li>如何保证提供高可用性的数据多副本始终保持一致</li>
<li>如何检测节点故障并高效应对</li>
</ul>
</li>
<li><p>评价指标</p>
<ul>
<li><p>性能：吞吐率-在某一段时间可以处理的请求总数；系统响应时间-从某个请求发出到收到结果的时间</p>
<p>==&gt;  性能分析-性能优化、负载均衡、数据复制、故障检测</p>
</li>
<li><p>可用性：指在系统面对各种异常时可以提供的正常服务能力；用停止服务的时间和正常时间比重度量</p>
</li>
<li><p>一致性：越强的一致性模型用户使用起来越简单——可能牺牲可用性或分区容错性</p>
</li>
<li><p>可扩展性：能否通过增加服务器数量提高系统能力或者增加服务器的难度；理想的“线性可扩展”</p>
</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/云计算/">云计算</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/云计算/">云计算</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/29/云计算-5-OpenStack/"><span>云计算(5) OpenStack</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/29/云计算-5-OpenStack/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-29T06:34:10.000Z">
          2022-10-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="五、OpenStack"><a href="#五、OpenStack" class="headerlink" title="五、OpenStack"></a>五、OpenStack</h1><h2 id="1-OpenStack简介"><a href="#1-OpenStack简介" class="headerlink" title="1. OpenStack简介"></a>1. OpenStack简介</h2><h3 id="1-1-OpenStack是什么"><a href="#1-1-OpenStack是什么" class="headerlink" title="1.1 OpenStack是什么"></a>1.1 OpenStack是什么</h3><ul>
<li><p>OpenStack引领新一代数据中心：为下一代数据中心操作系统赋能</p>
<ul>
<li><p>专注于快速、灵活和自动化地提供服务</p>
</li>
<li><p>可编程、可扩展、多租户感知的基础架构</p>
</li>
<li><p>单一、大型、灵活、可扩展和自动化的单元</p>
</li>
</ul>
</li>
<li><p>是开源云计算平台，可控制整个数据中心的大型计算、存储和网络资源池</p>
</li>
<li><p>管理员能够通过Web界面、命令行或API接口控制、配置资源；用户可以通过Web界面使用资源。</p>
</li>
<li><p>既是一个<code>开源</code>软件，也是一个开源社区，里面包含很多开源子项目</p>
</li>
<li>提供了一个部署云的操作平台和工具集<ul>
<li>用OpenStack易于构建虚拟计算或存储服务云，可为公有、私有云(无论大小)提供<code>可扩展、灵活</code>的云计算</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029003014897.png" alt="image-20221029003014897"></p>
<h4 id="1-1-1-设计理念"><a href="#1-1-1-设计理念" class="headerlink" title="1.1.1 设计理念"></a>1.1.1 设计理念</h4><p><strong>开放(Open)</strong></p>
<ul>
<li>理念：不重复造轮子，站在巨人的肩膀上</li>
<li>措施：开源，尽最大可能重用开源项目</li>
</ul>
<p><strong>灵活(Flexible)</strong></p>
<ul>
<li>大量使用插件化方式进行架构设计与实现</li>
<li>不使用任何不可替代的私有/商业组件</li>
</ul>
<p><strong>可扩展(Scalable)</strong></p>
<ul>
<li>由多个相互独立的项目组成</li>
<li>每个项目包含多个独立组件</li>
<li>无中心架构，无状态架构</li>
</ul>
<h4 id="1-1-2-类比OS"><a href="#1-1-2-类比OS" class="headerlink" title="1.1.2 类比OS"></a>1.1.2 类比OS</h4><ul>
<li>操作系统是一组<strong>主管并控制</strong>计算机操作、运用和运行硬件、软件资源和<strong>提供公共服务</strong>来组织用户交互的相互关联的系统软件程序。</li>
<li>云平台综合管理系统指构架于服务器、存储、网络等<strong>基础硬件资源</strong>和单机操作系统、中间件、数据库等<strong>基础软件</strong>之上，<strong>管理</strong>海量的基础硬件、软件资源并提供底层公共云服务的软件程序。</li>
<li>“云操作系统”的三种不同指代<ul>
<li>类虚拟化中为适配云计算需求而被修改的传统操作系统</li>
<li>在每一台物理设备上或集群里管理虚拟机的监控器VMM</li>
<li>云平台或数据中心操作系统</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029003754755.png" alt="image-20221029003754755"></p>
<p><strong>全面网络化、更多的安全考虑、计算可扩充性考虑</strong></p>
<h4 id="1-1-3-地位"><a href="#1-1-3-地位" class="headerlink" title="1.1.3 地位"></a>1.1.3 地位</h4><ul>
<li>重要地位：赋能安全、灵活、易扩展的全面自动化数据中心</li>
<li>但除了云操作系统，构建云计算还需要很多其他东西：底层驱动 + 上层应用程序   同等重要</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029003920753.png" alt="image-20221029003920753"></p>
<h3 id="1-2-从概念模型到物理部署"><a href="#1-2-从概念模型到物理部署" class="headerlink" title="1.2 从概念模型到物理部署"></a>1.2 从概念模型到物理部署</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029004414598.png" alt="image-20221029004414598"></p>
<blockquote>
<p>块存储：对外提供的是扇区的访问方式，将硬盘包装成卷对外服务，可以划分不同大小的卷。</p>
<p>文件存储：基于文件系统对外提供服务，用户可以像使用本地文件系统一样使用云文件存储服务。</p>
<p>对象存储：一种特殊的文件存储，只有一个层次，用hash方式存储二进制文件。</p>
</blockquote>
<h4 id="1-2-1-Map-of-OpenStack-Projects"><a href="#1-2-1-Map-of-OpenStack-Projects" class="headerlink" title="1.2.1 Map of OpenStack Projects"></a>1.2.1 Map of OpenStack Projects</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029234715257.png" alt="image-20221029234715257"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029004532607.png" alt="image-20221029004532607"></p>
<ul>
<li><p>除了以上各功能性服务组件，还有两个非常核心的基础组件</p>
<ul>
<li><p>消息队列：中心化的消息交换器，用于在服务组件不同模块传递消息；队列的优势在于可以<strong>缓冲请求</strong></p>
</li>
<li><p>数据库：构建时和运行时状态信息，例如可以使用的实例类型、正在使用的实例、可用网络等，也是各个组件间<strong>共享信息</strong>的重要组件</p>
</li>
</ul>
</li>
<li><p>服务目录：所有服务向其注册，了解OpenStack的所有服务——Keystone承担注册中心角色</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029004704248.png" alt="image-20221029004704248"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029004720874.png" alt="image-20221029004720874"></p>
<h4 id="1-2-2-网络设计"><a href="#1-2-2-网络设计" class="headerlink" title="1.2.2 网络设计"></a>1.2.2 网络设计</h4><p>单台计算机设备：CPU、内存、硬盘、总线？ &lt;==&gt; 云数据中心</p>
<p><strong>所有组件分布在四种节点上</strong>：<code>云控制器</code>、<code>网络节点</code>、<code>计算节点</code>、<code>存储节点</code>；<strong>网络连接</strong></p>
<ul>
<li>控制节点中封装了很多Openstack的服务</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029004954383.png" alt="image-20221029004954383"></p>
<ul>
<li>四种节点如何通过物理网络连接在一起？<ul>
<li>管理网络：Openstack服务之间的通信，包括消息队列、数据库和API</li>
<li>存储网络：虚拟机和存储节点之间的物理连接</li>
<li>租户数据网络：为租户创建的<strong>虚拟网络</strong>提供物理路径</li>
<li>对外的网络：互联网连接+对外的API网络</li>
</ul>
</li>
<li>使用隔离的<strong>物理网络</strong>处理不同类型的网络流量：同一个节点在不同网络中使用不同接口</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029005158947.png" alt="image-20221029005158947"></p>
<h4 id="1-2-3-物理模型设计"><a href="#1-2-3-物理模型设计" class="headerlink" title="1.2.3 物理模型设计"></a>1.2.3 物理模型设计</h4><p>物理模型设计——估算硬件容量</p>
<ul>
<li>例如：在Openstack环境中运行200个虚拟机<ul>
<li>CPU评估<ul>
<li>逻辑CPU数：物理CPU * 核数 * 超线程数；一个逻辑CPU对应一个虚拟CPU；一个虚拟CPU支持多个虚拟机【影响性能；可以使用频数计算】；一个虚拟机可以使用多个虚拟CPU，但不能多于逻辑CPU数；</li>
<li>可以超额分配，但是不能超额执行；超分：单台物理机中虚拟机个数＊频数 &gt; 物理频数</li>
</ul>
</li>
<li>内存评估<ul>
<li>单台物理机虚拟机个数 * 虚拟机最大动态分配内存 + 主机内存用量</li>
</ul>
</li>
<li>网络评估<ul>
<li>网卡带宽 &gt; 单个虚拟机带宽 * 虚拟机个数；公共IP地址个数；浮动IP地址个数</li>
</ul>
</li>
<li>存储评估<ul>
<li>虚拟机的临时存储 + 永久存储；存储节点的对象存储、块存储和文件共享存储</li>
</ul>
</li>
</ul>
</li>
<li>最佳实践<ul>
<li>分析需求、考虑需求增长情况、持续跟踪每一个服务单元、丢弃和替换服务单元等</li>
</ul>
</li>
</ul>
<h3 id="1-3-案例：虚拟机创建过程"><a href="#1-3-案例：虚拟机创建过程" class="headerlink" title="1.3 案例：虚拟机创建过程"></a>1.3 案例：虚拟机创建过程</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029005608265.png" alt="image-20221029005608265"></p>
<h2 id="2-云控制器：Keystone、Nova及其他服务"><a href="#2-云控制器：Keystone、Nova及其他服务" class="headerlink" title="2 云控制器：Keystone、Nova及其他服务"></a>2 云控制器：Keystone、Nova及其他服务</h2><h3 id="2-1-总览"><a href="#2-1-总览" class="headerlink" title="2.1 总览"></a>2.1 总览</h3><p>基础架构服务</p>
<ul>
<li>不属于OpenStack对外提供的公共服务，但被多个OpenStack组件使用</li>
<li>消息队列：必须是集群式的；RabbitMQ，ZeroMQ，Qpid</li>
<li>数据库：OpenStack的环境数据，使用数据等；MySQL和MongoDB</li>
</ul>
<p>OpenStack服务</p>
<ul>
<li>身份认证</li>
<li>编排引擎</li>
<li>计量服务</li>
<li>仪表盘</li>
<li>……</li>
</ul>
<p>所有服务不一定要部署在同一台物理设备</p>
<p>运行每一类服务的都可以是一个独立的集群</p>
<p>各服务的Restful API</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029135425428.png" alt="image-20221029135425428" style="zoom: 67%;" /></p>
<h3 id="2-2-物理部署"><a href="#2-2-物理部署" class="headerlink" title="2.2 物理部署"></a>2.2 物理部署</h3><ul>
<li>Openstack采用 无中心结构、节点无本地状态</li>
<li>控制器(除基础架构服务)使用对称高性能集群<ul>
<li>请求聚合+负载均衡</li>
<li>每一台物理设备运行相同的服务</li>
</ul>
</li>
<li>控制器节点很容易水平扩展</li>
<li>数据库、消息队列可采用非对称高可用集群</li>
</ul>
<blockquote>
<p><strong>集群</strong>：两台或多台服务器的能力聚合就是服务器集群</p>
<p><strong>非对称集群</strong>：通常用于高可用目的，比如扩展数据库、消息系统或者文件系统的读写能力。备用服务器只有在主服务器发生故障的时候才会接管系统。备用服务器可以看作悄悄执行的观察者，集群需要配置故障切换机制。</p>
<p><strong>对称集群</strong>：所有节点都是活的，都参与请求的处理，当节点出现故障后，被集群丢弃，其他节点接管其工作负载并继续处理事务。典型的就是负载均衡集群，所有节点共享工作负载，增强性能和服务的扩展性</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029135846449.png" alt="image-20221029135846449"></p>
<h3 id="2-3-Keystone服务"><a href="#2-3-Keystone服务" class="headerlink" title="2.3 Keystone服务"></a>2.3 Keystone服务</h3><p>身份认证和服务目录（所有其他服务需向Keystone注册API端点），由多个Provider组成</p>
<ul>
<li>身份提供者Identity Provider：服务用户、管理员用户、终端用户</li>
<li>资源提供者resource Provider：project、domain</li>
<li>认证提供者Authorization Provider：用户和用户组和他们角色之间的关系</li>
<li>令牌提供者Token Provider：访问openstack服务需要一个有效的令牌，通过身份提供者的认证后获得令牌</li>
<li>目录提供者Catalog Provider：维护服务和API端点的目录</li>
<li>策略提供者Policy Provider：策略由多条规则组成，每条规则定义了哪些用户和角色被允许访问哪些资源</li>
</ul>
<p>高级特性</p>
<ol>
<li>联邦keystone：使用外部身份提供者提供的身份服务访问服务提供商可用资源的机制</li>
<li>Fernet令牌：解决原生令牌提供者带来的性能问题</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029140245358.png" alt="image-20221029140245358"></p>
<h3 id="2-4-Nova管理组件及API"><a href="#2-4-Nova管理组件及API" class="headerlink" title="2.4 Nova管理组件及API"></a>2.4 Nova管理组件及API</h3><p>Nova是Openstack中提供计算资源服务的项目，是OpenStack最核心的项目</p>
<ul>
<li>负责：虚拟机和其他计算资源的生命周期管理</li>
<li>不负责：承载虚拟机的物理机自身的管理和全面的系统状态监控</li>
</ul>
<p>运行在云控制器上的组件</p>
<ul>
<li>Nova-api<ul>
<li>云控制器中的编排引擎；通过API将消息写入数据库和消息队列向其他守护进程传递消息</li>
</ul>
</li>
<li>Nova-conductor<ul>
<li>代表计算节点上nova-compute执行数据库操作，提供数据库访问隔离；将来自计算节点请求并行化</li>
</ul>
</li>
<li>Nova-scheduler<ul>
<li>专门的调度算法；确定虚拟机创建的最佳放置位置；支持过滤器检查计算节点上资源可用性，通过加权机制过滤出计算节点列表，再确定启动虚拟机的最佳位置；支持自定义度量标准和策略考量配置</li>
<li>在生产环境下，配置单独的存储主机，其调度器运行在存储主机上</li>
</ul>
</li>
</ul>
<p>Nova-compute则运行在计算节点上</p>
<h3 id="2-5-其他服务"><a href="#2-5-其他服务" class="headerlink" title="2.5 其他服务"></a>2.5 其他服务</h3><p>云控制器托管用于镜像管理的Glance服务</p>
<ul>
<li>Glance API提供外部REST接口，用于查询虚拟机镜像及相关元数据</li>
<li>Glance registry将镜像元数据存储在数据库中，并利用存储后端实际存储镜像<ul>
<li>例如使用Swift对象存储作为镜像存储后端</li>
</ul>
</li>
</ul>
<p>网络服务采用类似Nova的部署概念</p>
<ul>
<li>网络API驻留在云控制器中，独立配置网络服务器节点</li>
</ul>
<p>仪表盘服务</p>
<ul>
<li>运行在Apache Web服务器后端，可以将其运行在可以访问API端点的单独节点上，降低云控制器负载</li>
</ul>
<p>计量服务</p>
<ul>
<li>跟踪资源使用情况，计算资源利用率</li>
<li>多种使用目的：计费、容量规划、按需求和吞吐量的虚拟基础架构自动扩展等</li>
</ul>
<h2 id="3-计算节点：Nova、Magnum"><a href="#3-计算节点：Nova、Magnum" class="headerlink" title="3 计算节点：Nova、Magnum"></a>3 计算节点：Nova、Magnum</h2><h3 id="3-1-Nova-compute总览"><a href="#3-1-Nova-compute总览" class="headerlink" title="3.1 Nova-compute总览"></a>3.1 Nova-compute总览</h3><p>计算节点运行nova-compute服务，负责启动和终止虚拟机，通过消息总线监听虚拟机相关请求</p>
<p>Scheduler 通过 MQ 通知 Compute 创建虚拟机，Compute 通过 MQ 请求 Conductor 从 DB 处获取虚拟机相关信息</p>
<p><strong>Compute</strong>: Manages communication with hypervisor and virtual machines</p>
<p>Hypervisor是Nova计算节点的核心，又称VMM</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029141309092.png" alt="image-20221029141309092"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029141320164.png" alt="image-20221029141320164"></p>
<h3 id="3-2-核心：Hypervisor"><a href="#3-2-核心：Hypervisor" class="headerlink" title="3.2 核心：Hypervisor"></a>3.2 核心：Hypervisor</h3><p>Nova-compute通过API server控制节点上的Hypervisor</p>
<p>支持多种Hypervisor，通过配置文件设置选择哪一个Hypervisor</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029141458969.png" alt="image-20221029141458969"></p>
<h3 id="3-3-Nova相关概念"><a href="#3-3-Nova相关概念" class="headerlink" title="3.3 Nova相关概念"></a>3.3 Nova相关概念</h3><p>Nova中对主机有一个层次划分——高于一台物理主机</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029141826800.png" alt="image-20221029141826800"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029141917707.png" alt="image-20221029141917707"></p>
<h3 id="3-4-Nova操作"><a href="#3-4-Nova操作" class="headerlink" title="3.4 Nova操作"></a>3.4 Nova操作</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029141938319.png" alt="image-20221029141938319"></p>
<h3 id="3-5-Nova单元"><a href="#3-5-Nova单元" class="headerlink" title="3.5 Nova单元"></a>3.5 Nova单元</h3><p>所有计算节点都要与消息总线和数据库服务器通信，随着计算节点增多，使得消息队列和数据库过载</p>
<p>同时考虑到安全、易扩展和效率问题，按照Nova单元管理计算节点，增强计算节点的隔离性和分散性</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029142048816.png" alt="image-20221029142048816"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029142117676.png" alt="image-20221029142117676"></p>
<h3 id="3-6-Magnum"><a href="#3-6-Magnum" class="headerlink" title="3.6 Magnum"></a>3.6 Magnum</h3><p>现实需求：在计算节点编排容器</p>
<ul>
<li>解决方案1：在Nova中添加可以管理容器生命周期的Hypervisor</li>
<li>问题：和虚拟机不同，在容器中托管应用程序往往要部署多个容器，每个容器只运行一个进程，这些容器化的进程相互协作提供完整的应用程序功能。容器需要被成组地创建，需要配置网络连接用于协作进程之间的通信，还需要存储——独立为专门提供容器集群服务的项目：<strong>Magnum</strong></li>
<li>项目目的：提供容器编排引擎(COE)以方便部署和管理容器集群</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029142247333.png" alt="image-20221029142247333"></p>
<h2 id="4-存储节点：Swift、Cinder"><a href="#4-存储节点：Swift、Cinder" class="headerlink" title="4 存储节点：Swift、Cinder"></a>4 存储节点：Swift、Cinder</h2><h3 id="4-1-对象存储Swift"><a href="#4-1-对象存储Swift" class="headerlink" title="4.1 对象存储Swift"></a>4.1 对象存储Swift</h3><p>数据与其副本作为二进制大对象存储在对象存储服务器上</p>
<p>对象存储没有文件存储的层次结构，对象存储在扁平的命名空间——<code>一种特殊的文件系统</code></p>
<p>使用REST或SOAP等API访问对象存储，而不是文件协议</p>
<p>不适用于高性能要求以及经常更改的结构话化数据，例如数据库</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029143040123.png" alt="image-20221029143040123"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029143305120.png" alt="image-20221029143305120"></p>
<h3 id="4-2-块存储Cinder"><a href="#4-2-块存储Cinder" class="headerlink" title="4.2 块存储Cinder"></a>4.2 块存储Cinder</h3><p>为云平台提供统一接口，按需分配的，持久化的块存储服务</p>
<p>核心功能是对卷的管理，允许对卷、卷的类型、卷的快照、卷备份进行操作</p>
<p>为后端不同的存储设备提供了统一的接口，不同的块设备服务厂商在 Cinder 中实现其驱动支持以与OpenStack进行整合</p>
<p><strong><code>块存储作为虚拟机硬盘使用时，必须先分区、创建文件系统，再挂载到虚拟机文件系统层次结构中</code></strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029143430300.png" alt="image-20221029143430300"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029143442914.png" alt="image-20221029143442914"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029143500878.png" alt="image-20221029143500878"></p>
<h2 id="5-网络节点：Neutron"><a href="#5-网络节点：Neutron" class="headerlink" title="5 网络节点：Neutron"></a>5 网络节点：Neutron</h2><h3 id="5-1-网络连接"><a href="#5-1-网络连接" class="headerlink" title="5.1 网络连接"></a>5.1 网络连接</h3><p>路由器：连接多个独立的网络</p>
<p>虚拟路由器：连接多个虚拟的网络；负责转发所有人请求</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029152425537.png" alt="image-20221029152425537"></p>
<p>解决方案：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029152522515.png" alt="image-20221029152522515"></p>
<p>浮动IP：每一台虚拟机都动态分配一个对外的IP地址；外部通过IP访问到虚拟机，虚拟机通过该IP访问外部网络。</p>
<p>SNAT：虚拟机共享对外的IP地址，实现访问外部网络，但是外部无法通过IP地址定位到具体虚拟机。</p>
<p>DNAT：在共享的IP地址基础上添加映射到虚拟机的端口号。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029152659036.png" alt="image-20221029152659036"></p>
<h3 id="5-2-Neutron组件"><a href="#5-2-Neutron组件" class="headerlink" title="5.2 Neutron组件"></a>5.2 Neutron组件</h3><p>API服务器：运行在云控制器上</p>
<ul>
<li>基于插件的架构</li>
<li>API服务将请求转发到特定插件，插件通过代理和设备交互或者控制资源</li>
<li>提供了基于开源技术的插件和代理参考实现</li>
<li>网络节点提供资源实现网络服务：路由、防火墙、负载均衡器和VPN</li>
</ul>
<p>核心插件：创建和管理网络、端口和子网</p>
<p>服务插件：实现高阶网络服务、路由、防火墙等</p>
<p>代理：计算和网络节点上，通过消息总线上的RPC和服务器交互</p>
<ul>
<li>L2代理：在计算和网络节点上，将虚拟机和网络设备连接到二层网络上</li>
<li>DHCP代理、L3代理和VPN代理</li>
</ul>
<p>网络节点L3代理：配置虚拟路由器</p>
<ul>
<li>虚拟网络之间转发</li>
<li>外部网络和虚拟网络之间转发</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029160422687.png" alt="image-20221029160422687"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029160445194.png" alt="image-20221029160445194"></p>
<h3 id="5-3-细节"><a href="#5-3-细节" class="headerlink" title="5.3 细节"></a>5.3 细节</h3><p>网络节点细节</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029160514440.png" alt=""></p>
<p>计算节点上的网络配置细节</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029160548839.png" alt="image-20221029160548839"></p>
<h3 id="5-4-Distributed-Virtual-Routing-DVR"><a href="#5-4-Distributed-Virtual-Routing-DVR" class="headerlink" title="5.4 Distributed Virtual Routing (DVR)"></a>5.4 Distributed Virtual Routing (DVR)</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029160641521.png" alt="image-20221029160641521"></p>
<p>为了降低网络节点的负载，同时提高可扩展性，OpenStack在Juno版本引入了DVR特性，DVR部署在计算节点上</p>
<p>计算节点上的VM使用floatingIP访问Internet，不必经过网络节点，直接从计算节点的DVR就可以访问</p>
<h2 id="6-部署"><a href="#6-部署" class="headerlink" title="6 部署"></a>6 部署</h2><h3 id="6-1-DevOps"><a href="#6-1-DevOps" class="headerlink" title="6.1 DevOps"></a>6.1 DevOps</h3><p>矛盾：</p>
<ul>
<li>对于运维来说，稳定压倒一切，新 Feature 越少越好。而对于研发来说，却希望能开发更多的功能。</li>
</ul>
<p>DevOps 的理念：</p>
<ul>
<li>让研发（Development）和运维（Operations）一体化，让团队从业务需求出发，向着同一个目标前进。</li>
</ul>
<p>DevOps 是一种软件研发管理的思想，方法论，追求的是一种没有隔阂的理想的研发协作的状态，可能涉及到的角色有开发、测试、产品、项目管理、运维等等。</p>
<p>DevOps（Development和Operations的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029161012546.png" alt="image-20221029161012546"></p>
<h3 id="6-2-DevOps和Openstack"><a href="#6-2-DevOps和Openstack" class="headerlink" title="6.2 DevOps和Openstack"></a>6.2 DevOps和Openstack</h3><p>要求开发人员、网络工程师和运维人员必须相互协作，来部署、运维和维护OpenStack云基础架构</p>
<p>OpenStack和DevOps结合</p>
<ul>
<li><p>要求</p>
<ul>
<li>OpenStack软件和部署云基础架构的持续增长的复杂性必须被简化</li>
</ul>
</li>
<li><p>方式</p>
<ul>
<li><p>基础架构中的所有内容都必须自动化</p>
</li>
<li><p>将OpenStack分解为多个部分</p>
</li>
</ul>
</li>
<li><p>要点</p>
<ul>
<li><p>简化和模块化OpenStack服务；像开发构建模块一样开发OpenStack服务</p>
</li>
<li><p>在不影响整个系统的情况下，促进服务的定制和改进</p>
</li>
<li><p>使用正确的工具来构建服务，确保服务在相同输入情况下输出相同结果</p>
</li>
<li><p>将服务愿景从如何做切换到要做什么</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029161152125.png" alt="image-20221029161152125"></p>
<h3 id="6-3-Ansible"><a href="#6-3-Ansible" class="headerlink" title="6.3 Ansible"></a>6.3 Ansible</h3><p>基础架构自动化引擎：安装Ansible自身部署系统和管理的目标系统</p>
<p>模块</p>
<ul>
<li>封装系统资源或操作的组件，对资源及其属性进行建模；通过执行模块改变目标系统状态；执行后清除</li>
</ul>
<p>变量</p>
<ul>
<li>代表更新中的动态部分，可用于修改模块行为；可以用户自定义，作为模块一部分</li>
</ul>
<p>清单</p>
<ul>
<li>由Ansible管理的主机列表；支持将主机分类到多个组中；同一个主机可以出现在多个分段中</li>
</ul>
<p>角色</p>
<ul>
<li>表示在一组主机上配置服务时必须执行的任务集合；封装了在主机上部署服务所需的任务、变量、处理程序和其他相关功能；在Web服务器集群中为主机分配角色：Web服务器，数据库服务器，负载平衡器等</li>
</ul>
<p>Playbook</p>
<ul>
<li><p>Ansible的主要配置文件；描述了完整的系统部署计划，由一系列任务组成；用YAML编写</p>
</li>
<li><p>Yet Another Markup Language</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029161408318.png" alt="image-20221029161408318"></p>
<h3 id="6-4-OpenStack-Ansible"><a href="#6-4-OpenStack-Ansible" class="headerlink" title="6.4 OpenStack Ansible"></a>6.4 OpenStack Ansible</h3><p>自动化部署OpenStack</p>
<p>聚焦于提供多个角色和playbook，用于部署可扩展的、可理解投入生产的OpenStack环境</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029161427527.png" alt="image-20221029161427527"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/云计算/">云计算</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/云计算/">云计算</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/29/云计算-4-虚拟化技术/"><span>云计算(4) 虚拟化技术</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/29/云计算-4-虚拟化技术/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-29T06:34:09.000Z">
          2022-10-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="四、虚拟化技术"><a href="#四、虚拟化技术" class="headerlink" title="四、虚拟化技术"></a>四、虚拟化技术</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><ul>
<li>虚拟化是云计算的核心技术，但不是其专用技术</li>
<li>虚拟化的本质就是通过添加一个<strong>虚拟化层</strong>将原先的物理设备进行逻辑化，转化成一个文件夹或文件，实现软硬件的解耦。</li>
<li>“虚拟化技术”的两种理解方式：抽象 vs. 拆分<ul>
<li>分布式集群管理 -&gt; 抽象成一个独立的虚拟设备</li>
<li>一个功能强大的设备拆分成多个虚拟设备<ul>
<li>核心思想是利用软件或固件管理程序构成虚拟化层，<code>把物理资源映射为虚拟资源</code>。在虚拟资源上可以<code>安装和部署多个虚拟机</code>，实现<code>多用户共享物理资源</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-1-计算机系统的虚拟化"><a href="#1-1-计算机系统的虚拟化" class="headerlink" title="1.1 计算机系统的虚拟化"></a>1.1 计算机系统的虚拟化</h3><ul>
<li>由位于下层的软件模块，通过向上一层软件模块提供一个<code>与它原先所期待的运行环境完全一致的接口</code>的方法，抽象出一个虚拟的软件或硬件接口，使得上层软件可以直接运行在虚拟的环境上。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928141658132.png" alt="image-20220928141658132"></p>
<h2 id="2-服务器虚拟化层级"><a href="#2-服务器虚拟化层级" class="headerlink" title="2 服务器虚拟化层级"></a>2 服务器虚拟化层级</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928142113805.png" alt="image-20220928142113805"></p>
<h3 id="2-1-服务器虚拟化技术的发展及代表产品"><a href="#2-1-服务器虚拟化技术的发展及代表产品" class="headerlink" title="2.1 服务器虚拟化技术的发展及代表产品"></a>2.1 服务器虚拟化技术的发展及代表产品</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028174335742.png" alt="image-20221028174335742"></p>
<h3 id="2-2-硬件级虚拟化"><a href="#2-2-硬件级虚拟化" class="headerlink" title="2.2 硬件级虚拟化"></a>2.2 硬件级虚拟化</h3><h4 id="2-2-1-系统虚拟化"><a href="#2-2-1-系统虚拟化" class="headerlink" title="2.2.1 系统虚拟化"></a>2.2.1 系统虚拟化</h4><ul>
<li><p><strong>添加一个称为虚拟化层的软件，管理客户操作系统，使其能够独立于主机操作系统同时运行在同一个 硬件上</strong></p>
<ul>
<li>Hypervisor</li>
<li>Virtual Machine Monitor（VMM，虚拟机监视器）</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005140516166.png" alt="image-20221005140516166"></p>
</li>
<li><p>1974年，Popek和Goldberg定义虚拟机可以看作物理机的一种==高效====隔离==的==复制==。</p>
<ul>
<li>三个要求<ul>
<li>运行在该虚拟硬件环境中的程序性能损失应该较低(高效)</li>
<li>系统资源应该处于VMM的完全控制之中(隔离—资源受控)</li>
<li>为程序提供与原始硬件机器基本一致的环境(复制—同质)</li>
</ul>
</li>
<li><p>硬件仿真(裸机虚拟化)</p>
<ul>
<li>例：高性能服务器上使用vSphere管理虚拟机</li>
</ul>
</li>
<li><p>寄居虚拟化</p>
<ul>
<li>例：个人笔记本使用VirtualBox管理虚拟机</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-优势"><a href="#2-2-2-优势" class="headerlink" title="2.2.2 优势"></a>2.2.2 优势</h4><ul>
<li><code>封装性</code><ul>
<li>以虚拟机为粒度的封装使得虚拟机运行环境的保存非常便捷<ul>
<li>虚拟机快照（某个时间点的状态抓取下来并保存）</li>
<li>虚拟机克隆（从一个虚拟机的执行环境复制出一个或多个相同的虚拟机）</li>
<li>虚拟机挂起和恢复（暂停一个运行中的虚拟机，将其运行环境保存在磁盘上；将保存在磁盘上的虚拟机运行环境恢复到内存中）</li>
</ul>
</li>
<li>使得保存、部署更加方便，从而使得软件开发、测试和调试更加便捷；降低IT管理和维护成本</li>
</ul>
</li>
<li><code>多实例</code><ul>
<li>提高计算机性能利用率，降低计算机资源消耗<ul>
<li>不同的服务器有不同的繁忙和空闲时段，将多个物理服务器合并到少数服务器上以虚拟机运行，使用更少的服务器获得同样的整体性能，通过虚拟机的忙闲交错大大提高资源利用率；节约物理资源、人力资源、软件资源成本。</li>
</ul>
</li>
</ul>
</li>
<li><code>隔离</code><ul>
<li>虚拟机中的应用程序可以在自己的操作系统中独立地运行，不影响其他工作负载<ul>
<li>提高安全性：适用于测试场景；适合作为安全软件公司的蜜罐</li>
</ul>
</li>
</ul>
</li>
<li><code>硬件无关性</code><ul>
<li>屏蔽硬件差异，无缝跨硬件迁移；云计算环境中虚拟机迁移是非常重要的；【复现老旧硬件接口】</li>
</ul>
</li>
<li><code>特权功能</code><ul>
<li>在虚拟化层添加特权功能的优点：不能被客户机绕过、更容易实现</li>
<li>事件记录和回放——入侵检测、病毒检测等</li>
</ul>
</li>
</ul>
<h4 id="2-2-3-可与不可"><a href="#2-2-3-可与不可" class="headerlink" title="2.2.3 可与不可"></a>2.2.3 可与不可</h4><p>可虚拟化架构 VS 不可虚拟化架构：是否能够虚拟化出满足 “同质、高效、资源受控” 的虚拟机</p>
<ul>
<li>两个或两个以上的特权级：分隔应用软件与系统软件</li>
<li>特权指令：管理和操作关键系统资源的指令，只有在最高特权级才能执行</li>
<li>敏感指令：操作特权资源的指令<ul>
<li>修改虚拟机运行模式或者物理机状态</li>
<li>读写敏感的寄存器或内存，如时钟或中断寄存器</li>
<li>访问存储保护系统、内存系统或地址重定位系统</li>
</ul>
</li>
<li>客户机操作系统的敏感指令都是特权指令才能够实现高效的虚拟化——陷入VMM</li>
</ul>
<p><strong>虚拟化的硬件对象：CPU，内存，I/O 设备（硬盘、网卡、鼠标、键盘等）</strong></p>
<h4 id="2-2-4-CPU虚拟化"><a href="#2-2-4-CPU虚拟化" class="headerlink" title="2.2.4 CPU虚拟化"></a>2.2.4 CPU虚拟化</h4><ul>
<li>任意时刻一个物理CPU只能运行一个虚拟CPU</li>
<li>每个客户操作系统可以使用一个或多个虚拟CPU</li>
<li>各个操作系统之间虚拟CPU运行相互隔离，互不影响</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028160515257.png" alt="image-20221028160515257" style="zoom:67%;" /></p>
<p><strong>调度</strong>：调度问题指 VMM 决定当前哪个虚拟 CPU 在物理 CPU 上运行，保证隔离、公平和性能。</p>
<p><strong>执行</strong>：虚拟 CPU 正确运行是保证虚拟机指令正确运行，实现技术包括模拟执行和监控执行。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028160608688.png" alt="image-20221028160608688"></p>
<p><strong>三种类型:</strong></p>
<ol>
<li><p><code>基于软件的完全虚拟化</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028161301898.png" alt="image-20221028161301898"></p>
</li>
<li><p><code>基于硬件辅助的虚拟化</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028161326302.png" alt="image-20221028161326302"></p>
</li>
<li><p><code>改操作系统的类虚拟化</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028174908847.png" alt="image-20221028174908847"></p>
<ul>
<li>类虚拟化的三大优势：<ul>
<li>通过消减冗余代码、减少地址空间切换和跨特全级切换、减少内存复制等，优化虚拟化的性能开销</li>
<li>一定程度上消除了虚拟层和上层操作系统间的语义鸿沟：操作系统内部运行状态能够被VMM获得</li>
<li>使得硬件抽象层的抽象高度更加灵活，为实现各种不同功能的硬件抽象探索出了可行的路径。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-5-内存虚拟化"><a href="#2-2-5-内存虚拟化" class="headerlink" title="2.2.5 内存虚拟化"></a>2.2.5 内存虚拟化</h4><ul>
<li><p>内存虚拟化：内存虚拟化技术把物理内存统一管理，包装成多个虚拟的物理内存提供给若干虚拟机使用，每个虚拟机拥有各自独立的内存空间。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028175141720.png" alt="image-20221028175141720"></p>
</li>
<li><p>在没有虚拟化的操作系统中看到的内存：直接是机器地址的物理空间</p>
</li>
<li><p>虚拟化后，VMM要让客户操作系统看到“假的”物理空间，两件事：</p>
<ol>
<li>维护客户机物理地址和宿主机器的机器地址之间的映射</li>
<li>截获虚拟机对客户机物理地址的访问，并根据所记录的映射关系，转换成机器地址</li>
</ol>
</li>
</ul>
<p><strong>三种类型</strong></p>
<ol>
<li><p><code>基于软件的完全虚拟化</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028175332059.png" alt="image-20221028175332059"></p>
</li>
<li><p><code>基于硬件辅助的虚拟化</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028175354411.png" alt="image-20221028175354411"></p>
</li>
<li><p><code>改操作系统的类虚拟化</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028175408820.png" alt="image-20221028175408820"></p>
</li>
</ol>
<h4 id="2-2-6-I-O虚拟化"><a href="#2-2-6-I-O虚拟化" class="headerlink" title="2.2.6 I/O虚拟化"></a>2.2.6 I/O虚拟化</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005143610078.png" alt="image-20221005143610078"></p>
<h3 id="2-3-操作系统级虚拟化"><a href="#2-3-操作系统级虚拟化" class="headerlink" title="2.3 操作系统级虚拟化"></a>2.3 操作系统级虚拟化</h3><ul>
<li><strong>可以看作是“寄居虚拟化”的一种</strong><ul>
<li>虽然没有Hypervisor/VMM</li>
<li>但是需要主机操作系统，在主机操作系统中插入一个虚拟化层<ul>
<li>在同一个操作系统内核内，运行多个虚拟机；虚拟机可以访问</li>
</ul>
</li>
</ul>
</li>
<li>虚拟执行环境(Virtual Execution Environment)/虚拟专用系统(Virtual Private System)/容器(Container)</li>
<li>优点<ul>
<li>最小的启动/停止开销/资源需求低/可扩展性强</li>
<li>可同步虚拟机与宿主操作系统环境状态的变化</li>
<li>允许虚拟机中进程访问尽可能多的主机资源</li>
</ul>
</li>
<li>缺点<ul>
<li>同一个容器中的操作系统级虚拟机必须使用相同的客户操作系统</li>
<li>资源隔离性较差</li>
</ul>
</li>
<li><strong>虚拟机 VS. 容器</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005150707841.png" alt="image-20221005150707841"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028180121858.png" alt="image-20221028180121858"></p>
<h3 id="2-4-Docker"><a href="#2-4-Docker" class="headerlink" title="2.4 Docker"></a>2.4 Docker</h3><ul>
<li><p>架构</p>
<ul>
<li>服务端(引擎)，包括守护进程，接收和处理客户端请求、联系后端仓库、创建镜像、容器；</li>
<li>客户端，提交相关请求，如获取镜像、创建容器、运行容器等；</li>
<li>后端仓库，用来存储和管理相关资源，一些基本的镜像和库，有官方公共的仓库，也可以自行建立私有仓库。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005150952959.png" alt="image-20221005150952959"></p>
</li>
</ul>
<h3 id="2-5-不同层级虚拟化技术对比"><a href="#2-5-不同层级虚拟化技术对比" class="headerlink" title="2.5 不同层级虚拟化技术对比"></a>2.5 不同层级虚拟化技术对比</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005151139973.png" alt="image-20221005151139973"></p>
<h2 id="3-云数据中心的虚拟化"><a href="#3-云数据中心的虚拟化" class="headerlink" title="3 云数据中心的虚拟化"></a>3 云数据中心的虚拟化</h2><p>为什么要虚拟化？</p>
<ul>
<li>一台物理设备一个用户 vs. 一台物理设备多个用户：提升资源共享与复用的效率，降低成本</li>
<li>固定大小与位置的存储空间 vs. 灵活扩展和空间分布的空间：提升可扩展性，提升存储资源使用效率</li>
<li>为了实现服务器、存储虚拟化，要求网络也要能够方便、灵活地调整：随着虚拟机的迁移一起迁移</li>
</ul>
<h3 id="3-1-服务器虚拟化"><a href="#3-1-服务器虚拟化" class="headerlink" title="3.1 服务器虚拟化"></a>3.1 服务器虚拟化</h3><ul>
<li><strong>虚拟机和容器共存，容器的地位不断提升，目前与虚拟机相当</strong></li>
<li><strong>高效率的unikernel技术</strong><ul>
<li>unikernel是使用库操作系统（LibOS）构建的专用的、单一地址空间机器镜像。</li>
<li>LibOS库操作系统：在应用程序层中实施访问控制和隔离，用户应用无需在用户模式和内核模式间切换，直接访问硬件；然而多个应用程序同时运行时隔离性不好。</li>
<li>可使用操作系统虚拟化（虚拟机监控器VMM）克服硬件资源隔离缺陷：LibOS通过VMM驱动物理硬件，像虚拟机一样运行。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005153822512.png" alt="image-20221005153822512"></p>
<h3 id="3-2-存储虚拟化"><a href="#3-2-存储虚拟化" class="headerlink" title="3.2 存储虚拟化"></a>3.2 存储虚拟化</h3><ul>
<li><p><strong>概念</strong>：存储虚拟化将系统中分散且异构的存储资源整合起来，形成一个统一的连续编址的逻辑存储空间</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005153933717.png" alt="image-20221005153933717"></p>
</li>
<li><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005154007370.png" alt="image-20221005154007370"></p>
</li>
<li><p><strong>具体实现</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005154043004.png" alt="image-20221005154043004"></p>
</li>
<li><p><strong>示例</strong>：VMware的vSphere提出了虚拟文件系统VMFS，允许来自多个不同主机服务器的并发访问，即允许多个物理主机同时读写同一个存储器。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005154143381.png" alt="image-20221005154143381"></p>
</li>
</ul>
<h3 id="3-3-网络虚拟化"><a href="#3-3-网络虚拟化" class="headerlink" title="3.3 网络虚拟化"></a>3.3 网络虚拟化</h3><ul>
<li><p>由于云计算技术的使用，云数据中心的业务集中度、服务的客户数量远远超过传统数据中心，对网络的高带宽、低拥塞的要求更高</p>
<ul>
<li>传统数据中心问题1：L2层网络拥塞、丢包严重，需要L3层协议保证重传，效率低</li>
<li>传统数据中心问题2：二层以太网络采用生成树协议保证数据包在互连交换机回路传递，产生大量冗余。</li>
</ul>
</li>
<li><p>云数据中心对网络的需求</p>
<ul>
<li>提高数据传输效率：应对数据同步、备份、虚拟机迁移等的大流量</li>
<li>提高管理效率：采用统一的交换网络减少布线、维护和扩容的成本</li>
</ul>
</li>
<li><p><strong>在不改变传统数据中心网络设计的物理拓扑和布线方式前提下，引入网络虚拟化技术加以解决</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005154358772.png" alt="image-20221005154358772"></p>
</li>
<li><p>示例：VMware网络虚拟化技术</p>
<ul>
<li>虚拟网卡：每个虚拟机可以配置一个或多个虚拟网卡</li>
<li>虚拟交换机：工作原理与物理交换机一样，满足虚拟机网卡互连</li>
<li>分布式虚拟交换机：跨主机的虚拟交换机，保证跨主机迁移时网络配置保持一致</li>
<li>端口组：使用同一种策略设置的一组端口，虚拟环境特有的概念</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005154521468.png" alt="image-20221005154521468"></p>
</li>
</ul>
<h2 id="4-云环境中的虚拟机迁移"><a href="#4-云环境中的虚拟机迁移" class="headerlink" title="4 云环境中的虚拟机迁移"></a>4 云环境中的虚拟机迁移</h2><ul>
<li><p>云计算环境中虚拟机迁移的需求</p>
<ul>
<li>云计算中心物理服务器负载处于动态变化中，当无法提供额外物理资源而为了负载平衡，可将占 用热门物理资源的虚拟机迁移到其他物理服务器</li>
<li>物理服务器定期升级的需要，升级前将虚拟机迁移到其他物理服务器，等升级完成再迁移回来</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>物理机到虚拟机 P2V</li>
<li>虚拟机到虚拟机 V2V</li>
<li>虚拟机到物理机 V2P</li>
</ul>
</li>
<li><p><strong><code>云计算中关注的重点：实时迁移(Live Migration)</code></strong></p>
<ul>
<li>保持虚拟机运行的同时，将其从一个计算机迁移到另一个计算机，并在目的计算机恢复运行</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028212907878.png" alt="image-20221028212907878"></p>
<p>虚拟机迁移的具体内容</p>
<ul>
<li><p>内存迁移——最困难的地方</p>
<ul>
<li>第一阶段：Push；第二阶段：Stop-and-Copy；第三阶段：Pull</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027003411378.png" alt="image-20221027003411378"></p>
</li>
<li><p>网络迁移</p>
<ul>
<li>虚拟机所有网络设备，包括协议状态（如TCP连接状态）以及IP地址都要随之一起迁移；通过发送并修改相关配置实现</li>
</ul>
</li>
<li><p>存储设备迁移</p>
<ul>
<li>迁移数据存储需要占用大量时间和网络带宽，通常的解决办法是以共享的方式共享数据和文件系统，而非真正迁移</li>
<li>目前大多数集群使用NAS（Network Attached Storage，网络连接存储）作为存储设备共享数据</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/云计算/">云计算</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/云计算/">云计算</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/29/云计算-3-云数据中心/"><span>云计算(3) 云数据中心</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/29/云计算-3-云数据中心/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-29T06:34:08.000Z">
          2022-10-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="三、云数据中心"><a href="#三、云数据中心" class="headerlink" title="三、云数据中心"></a>三、云数据中心</h1><h2 id="1-云数据中心特征"><a href="#1-云数据中心特征" class="headerlink" title="1 云数据中心特征"></a>1 云数据中心特征</h2><ul>
<li><p>高设备利用率</p>
<ul>
<li>通过虚拟化技术(<code>服务器虚拟化、存储虚拟化、网络虚拟化、应用虚拟化</code>)将云平台系统与数据中心硬件资源整合，达到减少物理服务器数量的目标</li>
<li>优化资源利用率、简化管理，降低成本、快速响应业务需求的变化等</li>
<li><code>较大的数据中心有更低的单位运营成本：网络、存储、管理</code></li>
</ul>
</li>
<li><p>绿色节能</p>
<ul>
<li>服务器本身：节能服务器、节能存储设备、刀片服务器</li>
<li>环境：供电技术、散热技术，降低能耗</li>
<li>软件：虚拟机等资源调度算法、计算任务管理算法等</li>
</ul>
</li>
<li>高可用性<ul>
<li>各个部分的冗余、容错、容灾设计</li>
<li>扩展和升级时，保持正常运行</li>
</ul>
</li>
<li>自动化管理<ul>
<li>无人值守，远程管理(系统漏洞与补丁管理、性能管理和瓶颈分析、服务器与操作系统部署、系统功率测量和调整)</li>
<li>门禁、通风、温度、湿度、电力均可远程调度与控制</li>
</ul>
</li>
</ul>
<h2 id="2-云数据中心的设计"><a href="#2-云数据中心的设计" class="headerlink" title="2 云数据中心的设计"></a>2 云数据中心的设计</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220926162908969.png" alt="image-20220926162908969"></p>
<h2 id="3-云数据中心网络部署"><a href="#3-云数据中心网络部署" class="headerlink" title="3 云数据中心网络部署"></a>3 云数据中心网络部署</h2><ul>
<li><p>云数据中心对网络架构的需求</p>
<ul>
<li>低成本、高可扩展性、低配置开销、健壮性、节能</li>
</ul>
</li>
<li><p>现有数据中心网络结构对比如下</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220926163353818.png" alt="image-20220926163353818"></p>
</li>
</ul>
<h3 id="3-1-传统树结构"><a href="#3-1-传统树结构" class="headerlink" title="3.1 传统树结构"></a>3.1 传统树结构</h3><ul>
<li>建造方便简单</li>
<li>但不便于拓展与升级</li>
<li>任意一个核心交换机故障导致上千台服务器失效</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220926163609579.png" alt="image-20220926163609579"></p>
<h3 id="3-2-改进型树结构"><a href="#3-2-改进型树结构" class="headerlink" title="3.2 改进型树结构"></a>3.2 改进型树结构</h3><h4 id="FatTree"><a href="#FatTree" class="headerlink" title="FatTree"></a><code>FatTree</code></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220926164605776.png" alt="image-20220926164605776"></p>
<ul>
<li><p>两级路由表，允许两级前缀查询：Pod间流量尽可能均匀分布于核心交换机</p>
</li>
<li><p>任意两个不同Pod主机之间存在K条路径</p>
<ul>
<li>将流量在这些路径间分散</li>
<li>任意给定Pod的低层和高层交换机对位于本Pod的任意子网都有<code>终结性表项</code></li>
<li>在<code>全负载最坏</code>的情况下实现约87%的<code>聚合带宽</code></li>
</ul>
</li>
<li><p>与传统层次结构相比，FatTree有如下特点：</p>
<ul>
<li>消除了树形结构上层链路对吞吐量的限制</li>
<li>为内部节点间通信提供多条并行链路</li>
<li>与现有数据中心网络使用的以太网结构和IP配置的服务器兼容</li>
<li>但是布线复杂了；扩展时需要重构；受到端口数限制等</li>
</ul>
<blockquote>
<p>但是，FatTree的扩展性受限于核心交换机端口数量，目前比较常用的是48端口10G核心交换机，在3层树结构中能够支持27648台主机。</p>
<p>48个端口 -&gt; 48个Pod -&gt; 每个Pod有24个汇聚，24个接入 -&gt; 每个接入有24个接口接主机</p>
<p>48 * 24 * 24 = 27648</p>
</blockquote>
</li>
</ul>
<h4 id="VL2：一套可扩展且很灵活的网络架构，微软数据中心采用。"><a href="#VL2：一套可扩展且很灵活的网络架构，微软数据中心采用。" class="headerlink" title="VL2：一套可扩展且很灵活的网络架构，微软数据中心采用。"></a><code>VL2</code>：一套可扩展且很灵活的网络架构，微软数据中心采用。</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220926171214434.png" alt="image-20220926171214353"></p>
<blockquote>
<p>核心交换机Di个端口，汇聚交换机Da个端口</p>
<p>每台汇聚与所有核心连接，所以有Di台汇聚</p>
</blockquote>
<ul>
<li><p>VL2特点</p>
<ul>
<li>扁平寻址，允许服务实例被放置到网络覆盖的任何地方</li>
<li>负载均衡将流量统一分配到网络路径</li>
<li>终端系统的地址解析拓展到巨大的服务器池</li>
</ul>
</li>
<li><p>核心思想：使用<code>FatTree</code>同样的拓扑结构建立扁平的第二层网络</p>
</li>
<li><p>具体机制</p>
<ul>
<li>IP地址仅仅作为名字使用，没有拓扑含义；将服务器的名字与其位置分开。</li>
<li>使用可扩展、可靠的目录系统来维持名字和位置间的映射。</li>
<li>当服务器发送分组时，服务器上的VL2代理开启目录系统以得到实际的目的位置，然后将分组发送到目的地。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005115320401.png" alt="image-20221005115320401"></p>
</li>
<li><p>优势：</p>
<ul>
<li>VL2是目前最易用于对现有数据中心网络改造的结构；应用程序使用服务地址通信而底层网络使用位置信息地址进行转发，使得虚拟机能够在网络中任意迁移而不影响服务质量。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>VL2依赖于中心化的基础设施来实现2层语义和资源整合，面临单点失效和扩展性问题。</li>
</ul>
</li>
</ul>
<h3 id="3-3-递归层次结构"><a href="#3-3-递归层次结构" class="headerlink" title="3.3 递归层次结构"></a>3.3 递归层次结构</h3><ul>
<li>解决可扩展性的较好选择<ul>
<li>最小递归单元的结构</li>
<li>递归规律</li>
</ul>
</li>
<li>每一个高层的网络拓扑，由多个低层的递归单元按照递归规律相互连接构成，同时也是更高层级网络的一个递归单元。</li>
<li>增加服务器数量==&gt;提高总的递归层次<ul>
<li>添加服务器更加灵活，可增加的数量增大</li>
<li>对交换机性能要求低</li>
</ul>
</li>
<li>递归层次结构<ul>
<li>DCell、FiConn、BCube、MDCube</li>
</ul>
</li>
</ul>
<h4 id="DCell"><a href="#DCell" class="headerlink" title="DCell"></a>DCell</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005115549608.png" alt="image-20221005115549608"></p>
<ul>
<li>可扩展性好，拓扑层数受限于服务器端口数</li>
</ul>
<h4 id="FiConn"><a href="#FiConn" class="headerlink" title="FiConn"></a>FiConn</h4><ul>
<li>服务器使用两个网卡端口：主用端口连接低层网络，备用端口连接高层网络</li>
<li>递归定义的结构<ul>
<li>第0层为基本构建单元，n个服务器连接一个具有n个端口的交换机</li>
<li>每个低层FiConn中备用端口空闲的一半服务器与其他相同层次的FiConn网络中备用端口空闲的服务器连接</li>
<li>k层服务器、k层端口、k层链路</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028001548924.png" alt="image-20221028001548924"></p>
<h4 id="BCube"><a href="#BCube" class="headerlink" title="BCube"></a>BCube</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005115643875.png" alt="image-20221005115643875"></p>
<ul>
<li>主要使用交换机构建层次化网络<ul>
<li>第0层：n服务器连接1交换机</li>
<li>第1层：n个0层连接n个交换机</li>
<li>……</li>
<li>第k层：n个k-1层连接$n^k$交换机</li>
<li>交换机n个端口，服务器k+1个端口</li>
</ul>
</li>
<li>没有明显的瓶颈链路，出现故障时性能优雅下降，服务可用性高</li>
<li>服务器间路径多，探测的通信和计算开销大</li>
<li>硬件要求特殊：端口数目</li>
</ul>
<h3 id="3-4-光交换网络"><a href="#3-4-光交换网络" class="headerlink" title="3.4 光交换网络"></a>3.4 光交换网络</h3><ul>
<li><p>业务越来越庞大和复杂，数据中心内部和服务器间的数据流量快速增加，传统网络设备无法处理如此流量的数据——考虑可光速传播数据的设备，需要调整网络拓扑</p>
</li>
<li><p>Helios：混合电/光结构网络</p>
<ul>
<li>两层多根树</li>
<li>服务器连接接入交换机</li>
<li>接入交换机连接电交换和光交换网络</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028001635979.png" alt="image-20221028001635979"></p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027003648457.png" alt="image-20221027003648457"></p>
<h3 id="3-5-无线数据中心网络"><a href="#3-5-无线数据中心网络" class="headerlink" title="3.5 无线数据中心网络"></a>3.5 无线数据中心网络</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027003658560.png" alt="image-20221027003658560"></p>
<h3 id="3-6-软件定义网络"><a href="#3-6-软件定义网络" class="headerlink" title="3.6 软件定义网络"></a>3.6 软件定义网络</h3><ul>
<li><p>Software Defined Networking, SDN</p>
</li>
<li><p>将网络的控制平面和数据转发平面分离</p>
<ul>
<li>基础设施层：底层转发设备，根据控制器设定的规则进行数据分组的转发</li>
<li>控制器层：即SDN控制软件，维护网络状态，向底层提供控制和数据平面接口用于获取底层基础设施信息，向应用层提供可扩展的接口。</li>
<li>应用程序层</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027003753812.png" alt="image-20221027003753812"></p>
</li>
<li><p>Openflow，第一个针对SDN实现的标准接口</p>
</li>
<li><p>以良好的灵活性、规范性被看成SDN通信协议的标准，类似TCP/IP作为互联网的标准</p>
</li>
<li><p>起源于斯坦福大学的Clean Slate计划（致力于研究重新设计互联网的项目）</p>
</li>
<li><p>Openflow交换机、控制器</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027003832359.png" alt="image-20221027003832359"></p>
</li>
<li><p>Google基于Openflow的数据中心网络方案</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027003844590.png" alt="image-20221027003844590"></p>
</li>
</ul>
<h2 id="4-绿色节能技术"><a href="#4-绿色节能技术" class="headerlink" title="4 绿色节能技术"></a>4 绿色节能技术</h2><p>云计算数据中心的耗能越来越大</p>
<ul>
<li>解决云计算数据中心的高能耗问题已经成为一个环境问题，构建绿色节能的云计算数据中心也成为一个重要的研究热点。</li>
</ul>
<p>绿色节能技术</p>
<ul>
<li>配电系统节能</li>
<li>空调系统节能</li>
<li>集装箱数据中心节能技术</li>
<li>管理系统节能策略和算法</li>
<li>新能源应用</li>
</ul>
<h3 id="4-1-配电系统节能"><a href="#4-1-配电系统节能" class="headerlink" title="4.1 配电系统节能"></a>4.1 配电系统节能</h3><ul>
<li><p>传统数据中心使用UPS系统稳定供电：外部供电系统异常时使用电池系统过度到油机发电</p>
</li>
<li><p>问题</p>
<ul>
<li>整流逆变两个环节获得标准交流电压给服务器，再变压给主板——转换多、复杂</li>
<li>为避免UPS单点故障，采用多台UPS并机——供电架构复杂、难维护</li>
<li>UPS自身消耗大量电能、热量增加空调系统负载——电力损耗10%以上</li>
</ul>
</li>
<li><p>传统配电系统效率一般低于77%——如何改善配电系统得效率成为重要问题</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028001858816.png" alt="image-20221028001858816"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028001913365.png" alt="image-20221028001913365"></p>
</li>
</ul>
<h3 id="4-2-空调系统节能"><a href="#4-2-空调系统节能" class="headerlink" title="4.2 空调系统节能"></a>4.2 空调系统节能</h3><ul>
<li>数据中心中服务器节点、网络设备、办公环境等时刻产生热量，如果不及时散热，数据中心将无法运行</li>
<li>空调系统作为数据中心必备得基础设施，用于保证适合的温湿度</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028002005177.png" alt="image-20221028002005177"></p>
<ul>
<li>高温回风空调系统<ul>
<li>提高空调出供水和回水温度，有助于降低空调能耗（10 供水 15 回水，23~27服务器送风）</li>
<li>精确制冷空调<ul>
<li>机架冷热通道密封：盲板密封空余处，避免冷热混合，提高热风收集密度</li>
<li>机架背面安装冷水板，或机架式精密空调：辅助功耗大的机架散热</li>
<li>芯片级散热：热管换热器或相变制冷系统冷却核心发热元器件</li>
</ul>
</li>
</ul>
</li>
<li>低能耗加湿系统：湿膜加湿系统或水喷雾系统</li>
<li>自然冷空调系统<ul>
<li>新风自然冷系统，能效比 EER（制冷量/制冷电能耗）由 2-3.5 提高到 10-15：低温或降温风系统、新风过滤系统、气流组织、智能控制</li>
<li>水自然冷系统，能效比 EER 6~8</li>
</ul>
</li>
</ul>
<h3 id="4-3-集装箱数据中心节能技术"><a href="#4-3-集装箱数据中心节能技术" class="headerlink" title="4.3 集装箱数据中心节能技术"></a>4.3 集装箱数据中心节能技术</h3><ul>
<li>将数据中心的服务器设备、网络设备、空调设备、供电设备等高密度地装入固定尺寸的集装箱中，成为数据中心的标准构建模块</li>
<li>集装箱网络和电力互通，构建完整数据中心</li>
<li>特点：高密度、模块化、按需快速部署、移动便捷</li>
<li>诸多良好的绿色节能设计：<ul>
<li>缩短送风距离</li>
<li>提高冷通道温度</li>
<li>冷热通道完全隔离</li>
<li>Free Cooling 功能</li>
</ul>
</li>
</ul>
<h3 id="4-4-节能策略和算法研究"><a href="#4-4-节能策略和算法研究" class="headerlink" title="4.4 节能策略和算法研究"></a>4.4 节能策略和算法研究</h3><ul>
<li>功率管理和降低能耗两个角度<ul>
<li>动态功率管理（Dynamic Power Management，DPM）：Dynamic Voltage &amp; Frequency Scaling，DVFS，动态电压/频率调整</li>
<li>静态功率管理（Static Power Management，SPM）：通过设备结构的改变降低能耗</li>
</ul>
</li>
<li>关闭开启技术、虚拟机技术等</li>
<li>DVFS：当CPU未被完全利用时，降低CPU供电电压和时钟频率主动降低CPU性能</li>
<li>虚拟机节能<ul>
<li>虚拟机迁移实现负载合并，转换闲置节点为节能模式；虚拟机能耗管理；最大化空闲物理机数量；基于蚁群算法的虚拟资源分配策略等。</li>
</ul>
</li>
<li>主机关闭/开启节能：随机策略、超时策略和预测式策略</li>
<li>其他：如冷却系统节能等</li>
</ul>
<h3 id="4-5-新能源应用"><a href="#4-5-新能源应用" class="headerlink" title="4.5 新能源应用"></a>4.5 新能源应用</h3><ul>
<li>实现绿色IT的方式：高能效+新能源<ul>
<li>开发利用可再生能源，太阳能、生物质能、风能等</li>
</ul>
</li>
<li>现在，越来越多的IT企业和机构正在逐步实现完全或者部分新能源驱动的数据中心</li>
</ul>
<h3 id="4-6-典型的绿色节能数据中心"><a href="#4-6-典型的绿色节能数据中心" class="headerlink" title="4.6 典型的绿色节能数据中心"></a>4.6 典型的绿色节能数据中心</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028002755354.png" alt="image-20221028002755354"></p>
<h2 id="5-自动化管理"><a href="#5-自动化管理" class="headerlink" title="5 自动化管理"></a>5 自动化管理</h2><h3 id="5-1-内容和特征"><a href="#5-1-内容和特征" class="headerlink" title="5.1 内容和特征"></a>5.1 内容和特征</h3><ul>
<li>使得在规模较大的情况下，实现较少人员对数据中心的高度智能管理。</li>
<li>工作范围：按需分配和收回服务器、存储、网络、应用程序</li>
<li>具体内容：资源的自动化调度和对业务的灵活响应，即需要单个业务能自治管理，也需要一个负责全局控制和协调的中心，对业务和资源进行统一监控、管理和调度。</li>
<li>五个特征：<ul>
<li>全面的可视性——基础设施、中间件、数据库、应用层、业务服务层的运行时视图，全面掌握数据中心资产、配置和各层次依赖关系的现状</li>
<li>自动的控制执行——全面自动化数据中心的流程管理</li>
<li>多层次的无缝集成——流畅地自动执行在不同层次和组成部分之间地各种处理流程，快速的协调数据中心内外的所有变更，实现端到端的流程管理</li>
<li>综合与实时的报告——提供全面综合和透视依赖关系的报告提高管理水平</li>
<li>全生命周期支持——自动化整个“计划—实施—检查—更正”的 IT 流程生命周期</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028003436027.png" alt="image-20221028003436027"></p>
<h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h3><ul>
<li>由于资金、效率等问题，不可能一蹴而就，经历三个阶段：<ul>
<li>IT服务操作：监控和管理IT基础设施的广义集合，如网络、服务器、应用和现关存储设备<ul>
<li>目标：生成有效的全局IT支撑架构，提高IT服务质量，对活动和过程进行协调和执行</li>
<li>活动和过程：事故管理、事件监控和管理、问题管理</li>
</ul>
</li>
<li>IT服务管理：制定设施间的交互和协作处理，确保IT服务符合标准规范<ul>
<li>定义：根据客户需求的层次确保IT服务质量的一系列过程</li>
<li>主题：服务管理、服务层管理、IT资产管理、财务管理</li>
</ul>
</li>
<li>数据中心自动化：维护IT环境，定制、检查和执行服务层协议</li>
</ul>
</li>
<li>采用数据中心自动化工具必须具备如下条件<ul>
<li>管理系统：支持各类IT管理软件，能管理、监控、探测、识别和解决 IT 设施的异常行为。</li>
<li>定义过程：一套基本明确定义的流程并能运作良好，应包括事件管理、变更管理、配置管理和版本管理。</li>
<li>认知非自动化过程的成本：必须知道非自动化过程的成本，避免为了自动化而自动化。</li>
<li>内部流程资源：在初始配置时可使用外部资源，但是在后续的维护中，使用内部资源是更节约并有效的。</li>
</ul>
</li>
</ul>
<h2 id="6-容灾备份"><a href="#6-容灾备份" class="headerlink" title="6 容灾备份"></a>6 容灾备份</h2><ul>
<li>容灾备份是通过在异地建立和维护一个备份存储系统，利用地理上的分离来保证系统和数据对灾难性事件的抵御能力。</li>
<li>容灾系统对灾难的抵抗程度分为<ul>
<li>数据级容灾：数据级容灾只保证数据的完整性、可靠性和安全性，但提供实时服务的请求在灾难中会中断。</li>
<li>应用级容灾：应用级容灾系统能够提供不间断的应用服务，让服务请求能够透明地继续运行，保证数据中心提供的服务完整、可靠、安全。</li>
</ul>
</li>
<li>两个技术指标<ul>
<li>数据恢复点目标 Recovery Point Objective，RPO：主要指业务系统所能容忍的数据丢失量</li>
<li>恢复时间目标 Recovery Time Objective，RTO：主要指所能容忍的业务停止服务的最长时间</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028004103407.png" alt="image-20221028004103407"></p>
<h3 id="6-1-标准等级"><a href="#6-1-标准等级" class="headerlink" title="6.1 标准等级"></a>6.1 标准等级</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028004121168.png" alt="image-20221028004121168"></p>
<h3 id="6-2-关键技术"><a href="#6-2-关键技术" class="headerlink" title="6.2 关键技术"></a>6.2 关键技术</h3><ul>
<li>核心：复制数据</li>
<li>远程镜像技术<ul>
<li>主从镜像系统；远程复制；数据传输失败，数据不一致；延迟复制技术</li>
</ul>
</li>
<li>快照技术<ul>
<li>将远程存储系统中的信息备份到磁带库、光盘库；通过软件对要备份的磁盘子系统的数据快速扫描；备份数据复制到缓冲区，存在缓冲区调度的问题</li>
</ul>
</li>
<li>基于IP的SAN的远程数据容灾备份技术<ul>
<li>将主数据中心SAN(Storage Area Networks)中的信息通过现有TCP/IP网络远程复制到备份中心SAN中；可跨越LAN、MAN、WAN，成本低可扩展性好</li>
</ul>
</li>
<li>数据库复制技术<ul>
<li>数据必须实时、准确、可在线查询；数据复制具有独立性、配置简单、便于监控</li>
</ul>
</li>
<li>Spanner:谷歌的可扩展、多版本、全球分布式、同步复制数据库</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/云计算/">云计算</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/云计算/">云计算</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/29/云计算-2-云计算架构/"><span>云计算(2) 云计算架构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/29/云计算-2-云计算架构/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-29T06:34:07.000Z">
          2022-10-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="二、云计算架构"><a href="#二、云计算架构" class="headerlink" title="二、云计算架构"></a>二、云计算架构</h1><h2 id="1-计算架构及演化"><a href="#1-计算架构及演化" class="headerlink" title="1 计算架构及演化"></a>1 计算架构及演化</h2><ul>
<li><p>计算机软硬件经历了长时间的演变，计算范式也经过了多次变化：集中式、CS、BS、并行、分布式等</p>
</li>
<li><p>不同的计算范式对应不同的计算架构</p>
<ul>
<li><strong>中央集权架构</strong><ul>
<li>计算机刚出现时候的首选：所有计算及计算资源、业务逻辑都集中于一台主机</li>
</ul>
</li>
<li><strong>客户机/服务器架构</strong><ul>
<li>客户端：承载少量计算任务和所有IO任务</li>
<li>服务器：承载主要计算任务</li>
<li>优点：关注点分离，简化软件复杂度、编程模式</li>
<li>缺点：持久链接，系统伸缩能力受限</li>
</ul>
</li>
<li><strong>中间层架构</strong>——简化和提升伸缩能力<ul>
<li>将业务逻辑和数据服务分别放在两个服务器上</li>
<li>客户机到中间件为无状态的非持久链接——提升架构弹性</li>
</ul>
</li>
<li><strong>浏览器/服务器架构</strong><ul>
<li>对客户机、中间层架构的扩展——客户端和中间层均改动</li>
<li>客户端：负载进一步缩减，仅显示和运行基于浏览器的脚本程序</li>
<li>服务器：Web服务器层屏蔽各中间件的差异，提供通用的用户访问界面</li>
<li>扩展性高：对客户机性能无要求</li>
<li>对网络性能要求高</li>
</ul>
</li>
<li><strong>C/S和B/S混合架构</strong><ul>
<li>没有一种架构能够适用于所有场景</li>
<li>有些服务需要持久的链接（内部用户）</li>
<li>有些仅通过非持久链接即可（外部用户）</li>
</ul>
</li>
<li><strong>面向服务的架构（SOA）</strong></li>
</ul>
</li>
<li><p><strong>SOA</strong></p>
<ul>
<li><p>中间层计算架构、B/S架构、混合计算架构都可为云计算提供一定的伸缩能力</p>
<ul>
<li>共性：基于无状态连接【http请求】和基于服务的访问【而非过程调用】</li>
</ul>
</li>
<li><p>Service-oriented Architecture 面向服务的体系结构</p>
<ul>
<li><p>每个程序只做本职工作，将服务暴露出来供其他程序使用</p>
</li>
<li><p>多个程序通过一个统一的界面协调工作——控制复杂性，更容易管理</p>
</li>
<li><p>区别于“分布式对象”</p>
<blockquote>
<p>Java：Java对象、RMI(Remote Method Invocation，远程方法调用)</p>
<p>CORBA：CORBA分布式对象、IDL(Interface Definition Language，接口定义语言)</p>
<p>通过RPC(Remote Procedure Call，远程过程调用)连接</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005103200089.png" alt="image-20221005103200089"></p>
<ul>
<li>将Service(服务)作为分布式对象<ul>
<li>SOA是关于如何设计一套使用服务的软件系统</li>
<li>使得服务间的互操作性变得可扩展和有效</li>
<li>特点：松耦合，定义并发布接口，基于标准的通信模型</li>
<li>实例：<code>REST</code>(Representational State Transfer)<code>Web Service</code></li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005103638669.png" alt="image-20221005103638669"></p>
<h2 id="2-一般云计算架构的二维视角"><a href="#2-一般云计算架构的二维视角" class="headerlink" title="2 一般云计算架构的二维视角"></a>2 一般云计算架构的二维视角</h2><ul>
<li><p>从不同的角度看，云计算架构的复杂性有一定的差异</p>
</li>
<li><p>最易于理解的二维视角：基础设施 + 应用程序；两者分别视为：前端(呈现给用户的界面) + 后端(云组件)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005104717547.png" alt="image-20221005104717547"></p>
</li>
<li><p>多实例同时执行；不同实例之间能够协调对数据的处理及任务的执行；方便数据在各个模块之间共享。</p>
</li>
<li><p>基础架构——云内部，后端</p>
<ul>
<li>硬件：服务器、存储器、网络交换机等</li>
<li>管理软件：服务的高可用性、可恢复性、数据一致性、应用伸缩性、可预测性、云安全等</li>
</ul>
</li>
<li><p>应用程序——云对外，前端</p>
<ul>
<li>并发性、协调性、容错性、开放的API格式、开放的数据格式、承载数据密集型计算</li>
</ul>
</li>
</ul>
<p>基础架构的进一步分层结构</p>
<ul>
<li>虚拟化层<ul>
<li>将硬件转换为统一的IT资源【可灵活拆分、统一计量、统一管理、软件定义的】</li>
<li>可以在不同的抽象层实现：应用层、操作系统层、体系结构层、硬件层等</li>
</ul>
</li>
<li>Web服务层<ul>
<li>将云资源提供给客户的一种最方便的方式，解决大部分客户无法直接使用虚拟机的问题</li>
<li>支持面广、对客户端要求低，只需要浏览器就可以访问；所有提供的服务均可以通过API访问，该类API为”表征状态转移” Representational State Transfer, REST</li>
</ul>
</li>
<li>服务总线层<ul>
<li>即中间件层，封装计算服务、数据存储、消息传递</li>
<li>分离用户与虚拟化层、连接用户与Web服务层</li>
</ul>
</li>
<li>客户机用户界面<ul>
<li>Web门户，将各种服务混搭集成在一个页面</li>
<li>基于Ajax,JavaScript，趋势是使用功能完善的组件<ul>
<li>如JavaBeans/Applets, Silvedight/.NET等</li>
<li>可下载和安装在客户机上</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005105203774.png" alt="image-20221005105203774"></p>
<p>云应用程序的结构——云应用程序与传统操作系统上的应用程序结构有所不同</p>
<ul>
<li>传统操作系统上的应用程序：进程、线程、服务、shell（应用程序的控制接口）<ul>
<li>进程就是最终产品，每一个进程可运行多个指令序列（线程），一个线程对应一种服务</li>
</ul>
</li>
<li>云环境中的应用程序：应用程序本身、应用实例、服务、云命令行界面（控制端）<ul>
<li>应用程序是云应用最终的样子，由多个同时运行的实例支撑</li>
<li>不同的应用实例运行在不同的服务器上，每一个应用实例提供一种或多种服务</li>
<li>服务之间是相互独立的（微服务架构）</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005110228629.png" alt="image-20221005110228629"></p>
<h2 id="3-云计算逻辑架构"><a href="#3-云计算逻辑架构" class="headerlink" title="3 云计算逻辑架构"></a>3 云计算逻辑架构</h2><ul>
<li>云体、云平台、云栈、云计算、云环境、云系统…</li>
<li>云体<ul>
<li>是云计算的物质基础，是云计算使用的资源集合，是构成云计算的软硬件环境，例如网络、服务器、存储器、交换机等。广义的云体包括数据中心机器辅助设施如电力、空调、机架、冷却等系统。</li>
<li>目前可以认为：云体 就是 数据中心</li>
</ul>
</li>
<li>云栈<ul>
<li>又称云平台，是在云上建造的运行环境。它能够支持应用程序的发布、运行、监控、调度、伸缩，并为应用程序提供辅助服务机制，如访问控制、权限管理等。</li>
</ul>
</li>
<li>云计算<ul>
<li>是利用云体和云平台所进行的计算或处理——云计算可以在云体上直接进行，也可以在云平台上进行。无论在哪个层面开展，只要符合“按量计费、资源可伸缩”就是云计算。</li>
<li>云存储、云服务、在云上运行自己的软件或算法，都是云计算。</li>
<li>云计算是人们利用云体和云平台所从事的活动。</li>
</ul>
</li>
</ul>
<h3 id="3-1-逻辑云栈"><a href="#3-1-逻辑云栈" class="headerlink" title="3.1 逻辑云栈"></a>3.1 逻辑云栈</h3><ul>
<li><p>云栈——提供的服务多种多样，规模巨大，需要简历规则才能便于管理，即层次架构</p>
</li>
<li><p>云计算也遵循分层规则，组织为多个层次，相互叠加</p>
<ul>
<li>每一层都提供一种抽象，最下为物理硬件层</li>
<li>每往上一层，易用性就增加一分</li>
<li>到底应该分几层没有明确的规定或准则</li>
<li>不同的厂商有不同分法：三层、四层、五层</li>
</ul>
</li>
<li><p><code>以纵向的方式来构建云计算的整体架构</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005111806870.png" alt="image-20221005111806870"></p>
</li>
<li><p>云栈的三层模式</p>
<ul>
<li><p>基础设施即服务层</p>
<ul>
<li>不仅包括硬件设施，还包括虚拟化，因为各种硬件规格、性能、质量不统一，无法在其上直接建造云平台。虚拟化可以将各种硬件变为统一的标准件。</li>
</ul>
</li>
<li><p>平台即服务层</p>
<ul>
<li>在虚拟化的IT资源上构建起应用程序的运行环境，对外提供的产品包括计算环境、云存储库、通信机制、控制调度机制，统称为云计算平台或云解决方案栈。消费的是云基础设施服务，支持的是上层的云应用程序。</li>
</ul>
</li>
<li><p>应用程序层-软件即服务层</p>
<ul>
<li>基于网络进行远程访问的商用软件</li>
<li>集中式管理，而非分散在每个用户站点</li>
<li>单个实例多个租户架构——一对多模型</li>
<li>按照用量计费（实际应用中按月或其他时间周期计费）</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005112550160.png" alt="image-20221005112550160"></p>
</li>
</ul>
</li>
<li><p>从管理角度看，与云栈分层架构对应的是云计算技术体系结构——如何实现三层服务</p>
</li>
<li><p>不同供应商提供了不同的解决方案，没有统一的技术体系结构</p>
</li>
<li><p>综合不同厂商，构造如下参考体系结构：<code>关键是如何实现和管理</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005112653197.png" alt="image-20221005112653197"></p>
</li>
</ul>
<h3 id="3-2-技术体系结构—各层内涵"><a href="#3-2-技术体系结构—各层内涵" class="headerlink" title="3.2 技术体系结构—各层内涵"></a>3.2 技术体系结构—各层内涵</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005113005932.png" alt="image-20221005113005932"></p>
<h3 id="3-3-IaaS实现机制"><a href="#3-3-IaaS实现机制" class="headerlink" title="3.3 IaaS实现机制"></a>3.3 IaaS实现机制</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005113246238.png" alt="image-20221005113246238"></p>
<h3 id="3-4-物理云栈OpenStack"><a href="#3-4-物理云栈OpenStack" class="headerlink" title="3.4 物理云栈OpenStack"></a>3.4 物理云栈OpenStack</h3><ul>
<li>OpenStack是一个管理云计算中计算、存储和网络，甚至是应用的通用平台，其提供Web界面、命令行工具和应用程序接口（API）等使用接口。</li>
<li>官方描述<ul>
<li>The Most Widely Deployed <code>Open Source Cloud Software</code> in the World</li>
<li>OpenStack is a <code>cloud operating system</code> that controls large pools of compute, storage, and networking resources throughout a datacenter, all managed and provisioned through APIs with common authentication mechanisms.</li>
</ul>
</li>
<li>平台管理员<ul>
<li>位于各厂商特定资源之上的云计算资源管理层</li>
</ul>
</li>
<li>开发者<ul>
<li>通过其为应用提供基础设施和相应软件依赖</li>
<li>云编排平台：基于应用模板部署可扩展应用</li>
</ul>
</li>
<li>最终用户<ul>
<li>每一个最终用户被定义为一个租户</li>
<li>为租户提供自助服务的基础设施和应用管理系统</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005113731447.png" alt="image-20221005113731447"></p>
<ul>
<li><p>本质上OpenStack通过抽象和一个通用的API接口控制不同厂商提供的硬件和软件资源，是对计算系统的更高层次的抽象。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005113815800.png" alt="image-20221005113815800"></p>
</li>
</ul>
<h3 id="3-5-逻辑云体"><a href="#3-5-逻辑云体" class="headerlink" title="3.5 逻辑云体"></a>3.5 逻辑云体</h3><ul>
<li>云栈是从纵向角度看云计算的整体架构，那么云体则主要是从横向角度看其架构模式</li>
<li>类比传统操作系统横向切面：运行时环境 + 应用本身（程序+数据）<ul>
<li>环境：进程/线程/内存管理 + 文件系统 + 进程间通信/网络</li>
<li>云应用程序<ul>
<li>类似传统应用</li>
</ul>
</li>
<li>云运行时环境<ul>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005114052410.png" alt="image-20221005114052410"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005114130957.png" alt="image-20221005114130957"></p>
<h3 id="3-6-物理云体云数据中心"><a href="#3-6-物理云体云数据中心" class="headerlink" title="3.6 物理云体云数据中心"></a>3.6 物理云体云数据中心</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005114253518.png" alt="image-20221005114253518"></p>
<ul>
<li><p>传统数据中心暴露的问题</p>
<ul>
<li>过多的机器</li>
<li>机器利用率过低</li>
<li>应用迁移太困难</li>
<li>存储需求增长太快</li>
</ul>
</li>
<li><p>软件定义的数据中心</p>
</li>
<li><p>重新重视虚拟化，以提高资源利用率</p>
<ul>
<li>不仅应用到计算节点</li>
<li>复制到存储、网络、安全等方方面面</li>
<li>软件定义计算：计算节点的虚拟化：虚拟机成为计算调度和管理的单位，不中断服务的前提下动态迁移。</li>
<li>软件定义存储：分离管理接口与数据读写；统一的管理接口与上层管理软件交互；数据读写可以兼容各种不同的链接方式。</li>
<li>软件定义网络：数据平面（数据转发）和控制平面（转发表的设置等）分离；集中控制，分布式转发。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221005114453737.png" alt="image-20221005114453737"></p>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/云计算/">云计算</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/云计算/">云计算</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/29/云计算-1-云计算概念/"><span>云计算(1) 云计算概念</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/29/云计算-1-云计算概念/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-29T06:34:06.000Z">
          2022-10-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="一、云计算概念"><a href="#一、云计算概念" class="headerlink" title="一、云计算概念"></a>一、云计算概念</h1><h2 id="1-云计算定义"><a href="#1-云计算定义" class="headerlink" title="1 云计算定义"></a>1 云计算定义</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928102058638.png" alt="image-20220928102058638"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928102121291.png" alt="image-20220928102121291"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928102135445.png" alt="image-20220928102135445"></p>
<h2 id="2-计算模式的演进"><a href="#2-计算模式的演进" class="headerlink" title="2 计算模式的演进"></a>2 计算模式的演进</h2><p><strong>人类对计算的追求</strong>: <code>自动化、高性能、易使用</code></p>
<p><strong>演进过程</strong>:</p>
<p>   主机系统与集中计算: 仅规定了计费使用的模式，没有IT资源管理方面的考虑。</p>
<p>-&gt; <code>效用计算</code>: 考虑购买主机成本高，将IT资源包装成可以度量的服务提供给用户。</p>
<p>-&gt; 客户机/服务器模式: (IBM: 设备放在IBM内部，通过网络远程使用)</p>
<p>-&gt; 集群计算</p>
<p>-&gt; <code>服务计算</code>(软件即服务SaaS): 将所有应用程序都作为服务提供，而不是购买软件。</p>
<ul>
<li>不同服务相对独立，松散耦合，随意组合。重点是服务发现。</li>
</ul>
<p>-&gt; 个人计算机与桌面计算</p>
<p>-&gt; 分布式计算</p>
<p>-&gt; 网格计算</p>
<p>-&gt; <code>云计算</code>: “效用计算 + 服务计算”</p>
<ul>
<li><code>增强版的效用计算(不仅考虑计费，还考虑 IT 管理) + 更广泛的服务计算(不仅是软件，还包括基础设施和平台)</code></li>
</ul>
<p><strong>传统分布式计算系统</strong></p>
<ul>
<li>计算机集群: 将多个可信、静态的独立节点连接起来协作完成计算</li>
<li>P2P网络: 每一个节点既是客户端也是服务器，提供部分系统资源</li>
<li>计算网格: 将多个异构计算机动态、紧耦合地整合在一起完成计算任务</li>
</ul>
<p><strong>传统分布式系统的特点及问题</strong></p>
<ul>
<li>计算集群(计算抽象)<ul>
<li>基本组件为计算节点、通信软件、网络接口卡</li>
<li>集群应该合并多个系统镜像到一个单系统镜像，然而并没有</li>
<li>依靠中间件实现单系统镜像的支持</li>
<li>以单独计算机身份接入互联网</li>
</ul>
</li>
<li>P2P系统(存储抽象)<ul>
<li>节点是简单接入互联网的客户机，自治、自由加入和退出</li>
<li>无中心协作或中心数据库；没有专用的物理互联网络</li>
</ul>
</li>
<li>计算网格(接近”云”)<ul>
<li>计算资源整合，一个集成的资源池，提供基础设施；类比电力网格</li>
<li>节点包括：工作站、服务器、集群、超级计算机</li>
<li>计算和数据网格、P2P网格</li>
<li>太异构、用户管理、耗资源的协议、安全性、应用受限</li>
</ul>
</li>
</ul>
<p><strong>云计算基本想法</strong></p>
<ul>
<li>一种完美的分布式计算解决方案——对网格的优化<ul>
<li>大量计算节点，同构可控</li>
<li>专用内部网络</li>
<li>通过互联网对外服务（公有云）</li>
<li>全面虚拟化：计算、存储、网络、桌面</li>
<li>集中管理：安全、高效</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928102556298.png" alt="image-20220928102556298"></p>
<p><strong>云计算 vs. 网格计算</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928102623483.png" alt="image-20220928102623483"></p>
<h2 id="3-云计算的发展与推动力"><a href="#3-云计算的发展与推动力" class="headerlink" title="3 云计算的发展与推动力"></a>3 云计算的发展与推动力</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221028151806915.png" alt="image-20221028151806915"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221029212704108.png" alt="image-20221029212704108"></p>
<p><code>持续优化的动力：节能降耗、降低维护成本、提升资产安全、提升信息系统的容灾备份能力</code></p>
<h2 id="4-云计算的特征与分类"><a href="#4-云计算的特征与分类" class="headerlink" title="4 云计算的特征与分类"></a>4 云计算的特征与分类</h2><h3 id="4-1-概念模型"><a href="#4-1-概念模型" class="headerlink" title="4.1 概念模型"></a>4.1 概念模型</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928103628210.png" alt="image-20220928103628210"></p>
<h3 id="4-2-特征"><a href="#4-2-特征" class="headerlink" title="4.2 特征"></a>4.2 特征</h3><ul>
<li>现实中云的特点：大、规模动态伸缩、边界是模糊的、飘忽不定，无法也无需确定具体位置</li>
<li>Elastic Computing Cloud<ul>
<li>亚马逊弹性计算云的成功</li>
</ul>
</li>
<li>云计算的特点<ul>
<li>超大规模——需求</li>
<li>虚拟化——技术</li>
<li>按需服务——商业模式</li>
<li>通用</li>
<li>高可伸缩</li>
<li>极其廉价</li>
<li>高可靠——要求</li>
</ul>
</li>
</ul>
<h3 id="4-3-云部署模型"><a href="#4-3-云部署模型" class="headerlink" title="4.3 云部署模型"></a>4.3 云部署模型</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928103759022.png" alt="image-20220928103759022"></p>
<h3 id="4-4-云的服务模型"><a href="#4-4-云的服务模型" class="headerlink" title="4.4 云的服务模型"></a>4.4 云的服务模型</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928103844673.png" alt="image-20220928103844673"></p>
<p><strong>IaaS</strong></p>
<ul>
<li>通过虚拟机方式对外提供计算和存储能力</li>
<li>机器享有公网IP，多个虚拟机之间通过网络进行通信；也会有内部子网</li>
<li>类似租用独立的计算机</li>
<li>用户自行解决多台机器之间的协同问题</li>
<li>优势<ul>
<li>允许用户动态申请和释放资源</li>
<li>按使用量计费</li>
<li>更高的资源使用效率（节能环保）</li>
</ul>
</li>
</ul>
<p><strong>PaaS</strong></p>
<ul>
<li>提供用户应用程序的开发和运行环境，包括应用编程接口和运行平台等，支持应用从创建到运行整个生命周期需要的各种软硬件资源和工具。<ul>
<li>经过封装的IT能力，或逻辑资源：数据库、文件系统和应用运行环境</li>
<li>主要面向软件开发者（包括应用服务上）</li>
</ul>
</li>
<li>PaaS自身负责资源的动态扩展和容错管理</li>
<li>用户无需考虑节点间的配合问题</li>
<li>用户自主权降低，需按照给定的编程环境和编程模型构建应用</li>
<li>类似MPI (Message Passing Interface)编程<ul>
<li>只适用于解决模型特定的计算问题</li>
</ul>
</li>
</ul>
<p><strong>SaaS</strong></p>
<ul>
<li>通过标准的Web浏览器获软件客户端访问云上的应用</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928104113819.png" alt="image-20220928104113819"></p>
<h2 id="5-云计算相关的技术"><a href="#5-云计算相关的技术" class="headerlink" title="5 云计算相关的技术"></a>5 云计算相关的技术</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928104157857.png" alt="image-20220928104157857"></p>
<h2 id="6-云计算三元认知论"><a href="#6-云计算三元认知论" class="headerlink" title="6 云计算三元认知论"></a>6 云计算三元认知论</h2><ul>
<li>一种商业模式<ul>
<li>一种全新的商业模式，从产品提供的服务类型看，而非技术角度</li>
<li>区别于传统的”互联网服务”模式：在软件服务基础上提供平台和基础设施服务</li>
<li>除了服务理念，还要有具体的实现机制；云平台就是具体体现，包括计算范式和实现方式</li>
</ul>
</li>
<li>一种计算范式<ul>
<li>理论层面的实现方式，偏向针对商业模式的体系结构设计</li>
<li>云体逻辑结构：具体落地的云平台逻辑结构——物理结构就是云数据中心<ul>
<li>计算+存储+通信</li>
</ul>
</li>
<li>云栈逻辑结构：面向服务的云平台逻辑结构——物理结构就是管理系统的结构</li>
<li>基础设施即服务，平台即服务，软件即服务</li>
</ul>
</li>
<li>一种实现方式<ul>
<li>数据中心+云平台管理系统</li>
<li>软件定义数据中心：软件定义计算，软件定义存储，软件定义网络，软件定义安全</li>
</ul>
</li>
</ul>
<h2 id="7-云计算的开源方法论"><a href="#7-云计算的开源方法论" class="headerlink" title="7 云计算的开源方法论"></a>7 云计算的开源方法论</h2><ul>
<li>云计算时代，开源不仅是一种开放源代码的具体产品，更是一种方法论、一种构造大规模复杂软件的协作方式。</li>
<li>开源的可以是各行各业的技术或产品</li>
<li><p>开源软件 —— 一种版权持有人为任何人和任何目的提供学习、修改和分发权力，并公布源代码的计算机软件</p>
<ol>
<li>许可证不应限制任何个人或团体奖包含该开源软件的广义作品进行销售或赠予</li>
<li>开源软件的程序必须包含源代码，必须允许发布源代码及以后的程序</li>
<li>开源软件许可证必须允许修改和派生作品，并允许使用原有软件的许可条款发布他们</li>
</ol>
</li>
<li><p>开源软件 vs. 自由软件 vs. 免费软件</p>
<ul>
<li>开源不一定自由，开源不一定免费，自由不一定免费；免费不一定开源，不一定自由</li>
</ul>
</li>
</ul>
<p><strong>价值和意义</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928104559253.png" alt="image-20220928104559253"></p>
<h2 id="8-三个问题"><a href="#8-三个问题" class="headerlink" title="8 三个问题"></a>8 三个问题</h2><h3 id="8-1-发展阶段"><a href="#8-1-发展阶段" class="headerlink" title="8.1 发展阶段"></a>8.1 发展阶段</h3><p>Google Trends、国家重视程度、产业发展现状</p>
<h3 id="8-2-云计算的优势"><a href="#8-2-云计算的优势" class="headerlink" title="8.2 云计算的优势"></a>8.2 云计算的优势</h3><ul>
<li>经济性<ul>
<li>能耗接近硬件成本；管理成本线性增长</li>
</ul>
</li>
<li>可扩展性和可伸缩性<ul>
<li>类似个人笔记本电脑的单个虚拟机</li>
<li>组建超出想象的计算能力的集群<ul>
<li>内存达到40万GB</li>
<li>近似无上限的硬盘空间</li>
<li>快速完成</li>
</ul>
</li>
</ul>
</li>
<li>虚拟化：模拟出符合用户需求的任何计算环境</li>
<li>高可靠：多副本容错、计算节点同构可互换等措施</li>
<li>管理简单：无需专职IT维护人员</li>
<li>安全：专业的团队 + 严格的权限管理</li>
</ul>
<h3 id="8-3-大数据关系"><a href="#8-3-大数据关系" class="headerlink" title="8.3 大数据关系"></a>8.3 大数据关系</h3><ul>
<li>海量数据或巨量数据，其规模巨大到无法通过目前主流的计算机系统在合理时间内获取、存储、管理、处理并提炼以帮助使用者决策。</li>
<li>为什么会产生大数据？<ul>
<li>数据产生方式的改变</li>
<li>人类活动越来越依赖数据</li>
<li>互联网+物联网：互联网用户，传感器，摄像头…</li>
</ul>
</li>
<li>特征<ul>
<li>3V：Volume(量大), Variety(多样), Velocity(快速)</li>
<li>4V+1C：Value(低价值密度), Complexity(复杂：处理和分析难度大)</li>
<li>5V：Volume, Variety, Velocity, Value, Veracity(真实)</li>
</ul>
</li>
<li>大数据促进了云计算的产生，激发了云计算的潜力；云计算为大数据的收集、存储、加工和应用提供了更好的支持。<ul>
<li>关系密切而多样</li>
</ul>
</li>
</ul>
<h2 id="9-难点、风险与挑战"><a href="#9-难点、风险与挑战" class="headerlink" title="9 难点、风险与挑战"></a>9 难点、风险与挑战</h2><h3 id="9-1-云计算技术难点"><a href="#9-1-云计算技术难点" class="headerlink" title="9.1 云计算技术难点"></a>9.1 云计算技术难点</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220928105239558.png" alt="image-20220928105239558"></p>
<h3 id="9-2-风险与挑战"><a href="#9-2-风险与挑战" class="headerlink" title="9.2 风险与挑战"></a>9.2 风险与挑战</h3><ul>
<li>增加了安全漏洞<ul>
<li>运程使用IT资源需要云用户将信任边界扩展到外部的云，建立这样的安全架构同时又不引入安全漏洞是非常困难的</li>
<li>重叠的信任边界和不断增加的数据曝光为恶意的云用户提供了更多的攻击IT资源、窃取或破坏企业数据的机会</li>
</ul>
</li>
<li>降低了运营管理控制<ul>
<li>云用户对云资源的管理控制低于对企业内部IT资源的管理控制<ul>
<li>云提供者可能不遵守它发布的云服务保证</li>
<li>云用户和云提供者之间较长的地理距离可能需要更多的网络跳数，会带来延迟波动和带宽受限</li>
</ul>
</li>
</ul>
</li>
<li>云提供者之间有限的可移植性<ul>
<li>由于缺乏行业标准，不同的云提供者提供的服务存在较大差异</li>
</ul>
</li>
<li>多地区法规和法律问题<ul>
<li>第三方云提供者通常选择造价较低、方便的地理位置建立数据中心，而云用户通常不会意识到所使用IT资源和自身数据所存放的位置</li>
<li>某些云用户可能会遇到严重的法律问题<ul>
<li>例如：英国法律规定，英国公民的个人数据只能留在英国境内</li>
</ul>
</li>
<li>潜在的数据获得和公开<ul>
<li>例如：某些国家的法律规定，某些类型的数据必须向某些政府机构或数据主体公开</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="9-3-缺陷与未来"><a href="#9-3-缺陷与未来" class="headerlink" title="9.3 缺陷与未来"></a>9.3 缺陷与未来</h3><ul>
<li>虽然是最成功的商业计算模型，但不是完美的，仍有缺陷<ul>
<li>从平台角度看——没有统一的标准</li>
<li>从计算角度看——针对松耦合的数据处理</li>
<li>从数据角度看——管理和分析商业数据</li>
<li>从资源集成角度看——必须集中到云中</li>
<li>从信息安全角度看——暴露、丢失的风险</li>
</ul>
</li>
<li>然而这些恰是网格的优势所在</li>
<li>未来：云格计算——结合的基准是SOA</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/云计算/">云计算</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/云计算/">云计算</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/6/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/8/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Whale
    
  </p>
</footer>
    
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>