<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="码农预备役">
<meta property="og:type" content="website">
<meta property="og:title" content="Whale&#39;s Blog">
<meta property="og:url" content="https://whale-lyi.github.io/page/4/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="码农预备役">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Whale">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://whale-lyi.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/05/02/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84-2-%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/02/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84-2-%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">软件系统设计-架构(2) 质量属性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-02 14:22:57" itemprop="dateCreated datePublished" datetime="2023-05-02T14:22:57+08:00">2023-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-19 00:14:12" itemprop="dateModified" datetime="2023-08-19T00:14:12+08:00">2023-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">软件系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-软件架构-Software-Architecture"><a href="#1-软件架构-Software-Architecture" class="headerlink" title="1. 软件架构 Software Architecture"></a>1. 软件架构 Software Architecture</h2><ul>
<li><strong>软件架构</strong>是系统的一个或多个结构，包含了软件<strong>元素</strong>、这些<strong>组件</strong>的外部可见<strong>属性</strong>以及他们之间的<strong>关系</strong>。<br>Software Architecture is the structure or structures of the system, which comprise software elements, the externally visible properties of these components, and the relationship among them.(In pratice书中的定义)</li>
<li>单独的盒式模型不是架构，而是一个起点<br>Box-and-line drawings alone are not architecture, but a starting point.</li>
<li>架构包含了组件的行为 Architecture includes behaviour of components.</li>
</ul>
<h3 id="1-1-架构扮演的角色-Role-of-Architecture"><a href="#1-1-架构扮演的角色-Role-of-Architecture" class="headerlink" title="1.1 架构扮演的角色 Role of Architecture"></a>1.1 架构扮演的角色 Role of Architecture</h3><ul>
<li>架构是代表<strong>如何实现需求</strong>的决策的<strong>首批人工制品之一</strong>。作为早期设计决策的体现，架构代表了那些<strong>最难</strong>更改的设计决策，因此值得<strong>最仔细的考虑</strong><br>An architecture is one of the first artefacts that represents decision on how requirements are to be achieved. As the manifestation of early design decisions, the architecture represents those design decisions that are hardest to change and hence deserve the most careful consideration.</li>
<li>“架构”是实现成功的产品线工程的关键制品，它是对一系列类似系统的规范开发方法，与独立开发每个系统相比，其工作量、费用和风险更少。<br>An architecture is the key artefact in achieving successful product line engineering, the disciplined development of a family of similar system with less effort, expense, and risk than developing each system independently.</li>
<li>当有人开始在系统上工作时，架构通常是首先要检查的设计工件<br>An architecture is usually the first design artefact to be examined when someone starts working on a system.</li>
<li>软件架构为<strong>维护和修改</strong>决策提供了参考<strong>框架</strong><br>Software architecture provides a framework of reference for maintenance and modification decisions.</li>
</ul>
<h3 id="1-2-为什么软件架构是重要的-Why-is-software-architecture-important"><a href="#1-2-为什么软件架构是重要的-Why-is-software-architecture-important" class="headerlink" title="1.2 为什么软件架构是重要的 Why is software architecture important?"></a>1.2 为什么软件架构是重要的 Why is software architecture important?</h3><ol>
<li>软件架构提供了<strong>沟通的工具</strong><br>Software architecture provides a vehicle for communication<ul>
<li>软件架构是一个可以确定和谈判利益冲突的参考框架<br>It is a frame of reference in which competing interests may be identified and negotiated<ul>
<li>和用户<strong>讨论需求</strong> Negotiating requirements with users</li>
<li><strong>保证</strong>客户获取到过程和成本的<strong>信息</strong> Keeping customer informed of progress, cost etc.</li>
<li><strong>实现管理决策</strong>和分配 Implementing management decisions and allocations.</li>
</ul>
</li>
</ul>
</li>
<li>软件架构表现了<strong>最早期的决策集合</strong><br>Software architecture manifests the earliest set of design decisions<ul>
<li>约束着实现和开发者 It constraints the implementation and developers<ul>
<li>实现必须要<strong>符合架构</strong> Implementation must conform to architecture</li>
<li><strong>资源分配的决策</strong>约束着单独模块的实现 Resource allocation decisions constrain implementations of individual components</li>
</ul>
</li>
</ul>
</li>
<li>表现了早期的设计决策 Manifestation of early design decisions<ul>
<li>软件架构决定了开发和维护工作的<strong>组织结构</strong><br>Software architecture dictates organisational structure for development &amp; maintenance efforts, e.g.<ul>
<li>划分为<strong>团队</strong> Division into teams</li>
<li><strong>预算</strong>，计划单位 Units for budgeting, planning</li>
<li><strong>工作分解结构</strong>的基础 Basis of <strong>W</strong>ork <strong>B</strong>reakdown <strong>S</strong>tructure</li>
<li><strong>文档</strong>的组织 Organisation for documentation</li>
<li><strong>CM</strong>库的组织 Organisation for CM libraries</li>
<li><strong>集成</strong>的基础 Basis of integration</li>
<li><strong>测试</strong>计划、测试的基础 Basis of test plans, testing</li>
<li>运维的<strong>基础</strong> Basis of maintenance</li>
</ul>
</li>
</ul>
</li>
<li>架构促进/阻碍<strong>质量属性的实现</strong>，比如灵活性、安全性、易用性<br>Architecture facilitates/hinders achievement of quality attributes, e.g., modifiability, security, usability etc.</li>
<li>架构会影响质量，但由于涉及许多其他因素，可能<strong>无法保证</strong>质量<br>Architecture influences qualities, but may not guarantee them as there are a number of other factors involved.</li>
<li>架构引发有关<strong>潜在变更</strong>的讨论(系统的80％的工作是<strong>部署后</strong>的工作)<br>An architecture invokes discussion about potential change ( 80% of effort for a system is post-deployment effort)</li>
<li>架构将<strong>更改</strong>分为三种类型 Architecture categorise changes into three types:<ul>
<li><strong>本地</strong>: 信号组件修改 Local: signal component modification</li>
<li><strong>非本地</strong>: 几个组件修改 Non-local: several component modification.</li>
<li><strong>架构</strong>: 修改系统的基本结构，通信和协调机制 Architectural: modification of the system’s basic structure, communication, and coordination mechanism</li>
</ul>
</li>
<li>架构是一种<strong>可迁移</strong>和<strong>可重用</strong>的抽象: <strong>一对多映射</strong>(一种架构，许多系统)<br>Architecture is a transferable and reusable abstraction one-to-many mapping (one architecture, many systems)</li>
<li>架构是<strong>产品通用性</strong>的基础。整个产品线共享一个架构<br>Architecture is the basis for product commonality. A whole product line shares a single architecture</li>
<li>可以通过架构集成独立开发的组件来开发系统(基于Component的软件工程-CBSE)<br>Systems can be developed by integrating independently developed components via architecture ((Component-Based Software Engineering - CBSE)</li>
</ol>
<h3 id="1-3-软件架构过程-Software-Architecture-Process"><a href="#1-3-软件架构过程-Software-Architecture-Process" class="headerlink" title="1.3 软件架构过程 Software Architecture Process"></a>1.3 软件架构过程 Software Architecture Process</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501151308634.png" alt="image-20230501151308634" style="zoom:80%;" /></p>
<ol>
<li>通过StackHolder获取到ASRs(架构攸关的需求)</li>
<li>通过分析得到Prioritized Quality Attribute Scenarios(高优先级质量属性解决方案)和Requirements，Constraints(需求和约束)</li>
<li>将上述部分，结合模式和策略，综合可以得到架构的设计</li>
<li>根据架构的设计得到由模式决定的候选视图的示意图，之后完成文档化</li>
<li>选择、组合视图，将文档进行进一步的评估，这一部分需要StackHolders的参与、也需要Prioritized Quality Attribute Scenarios和文档等作为参考。</li>
</ol>
<h4 id="1-3-1-移动手机系统架构-Mobile-Phone-System-Architecture"><a href="#1-3-1-移动手机系统架构-Mobile-Phone-System-Architecture" class="headerlink" title="1.3.1 移动手机系统架构 Mobile Phone System Architecture"></a>1.3.1 移动手机系统架构 Mobile Phone System Architecture</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502201139387.png" alt="image-20230502201139387" style="zoom:80%;" /></p>
<h4 id="1-3-2-洗衣机架构-Washing-Machine-Architecture"><a href="#1-3-2-洗衣机架构-Washing-Machine-Architecture" class="headerlink" title="1.3.2 洗衣机架构 Washing Machine Architecture"></a>1.3.2 洗衣机架构 Washing Machine Architecture</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502201152983.png" alt="image-20230502201152983" style="zoom:80%;" /></p>
<h3 id="1-4-讨论-Discussion"><a href="#1-4-讨论-Discussion" class="headerlink" title="1.4 讨论 Discussion"></a>1.4 讨论 Discussion</h3><ol>
<li>科学和工程有什么不同？What is Difference between Science and Engineering? <ul>
<li>科学的研究是研究这个世界既有的部分</li>
<li>工程是研究的是人类创造新的世界(是不是因为人才产生的)</li>
</ul>
</li>
<li>软件和硬件有什么不同？What is Difference between ‘Software’ and ‘Hardware’?<ul>
<li>软件是不可见的: 软件是虚拟的，而硬件是实体的。</li>
<li>软件制作出来就是为了被修改和改变的(软件的演化是他的本质属性)</li>
</ul>
</li>
<li>架构和设计有什么不同？What is Difference between Architecture and Design?<ul>
<li>所有的架构都是软件设计，但是不是所有的软件设计都是架构</li>
<li>架构是设计过程的一个过程。</li>
<li>其他观点<ul>
<li>架构是更高层的设计，是为了修改的</li>
<li>架构是设计决策的组合</li>
</ul>
</li>
</ul>
</li>
<li>架构和结构有什么不同？What is Difference between Architecture and Structure?<ul>
<li>架构定义了组件(Component)的接口，Component之间如何交流以及如何相互依赖，Component的职责。</li>
<li>架构提供了设计的更高层抽象视角，隐藏设计的复杂性和实现，更强调非功能性需求。</li>
<li>【标准】架构是包括结构信息的，因为结构是一种静态的、逻辑的、是关于系统如何构成。但是架构除了包含结构，还会增加组件的相互之间的关系接口，还会定义一些动态的行为(一个组件可能和谁进行交互)</li>
</ul>
</li>
<li>为什么要在架构中使用抽象？Why Abstraction in Architecture?<ul>
<li>更高层的视角，更关注本身的结构而不是本身的实现。</li>
<li><strong>降低</strong>架构设计时的系统复杂度，可以屏蔽和<strong>隐藏</strong>一些细节。</li>
</ul>
</li>
</ol>
<h2 id="2-需求-Requirements"><a href="#2-需求-Requirements" class="headerlink" title="2. 需求 Requirements"></a>2. 需求 Requirements</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502201209993.png" alt="image-20230502201209993" style="zoom:80%;" /></p>
<p>需求中往往存在有开发人员和用户的矛盾，我们需要将这一个部分进行转化</p>
<h3 id="2-1-功能性需求-Functional-Requirements"><a href="#2-1-功能性需求-Functional-Requirements" class="headerlink" title="2.1 功能性需求 Functional Requirements"></a>2.1 功能性需求 Functional Requirements</h3><ol>
<li>功能性需求定义了<strong>系统必须做什么</strong>并且强调了<strong>系统如何提供价值</strong>给涉众<br>Functional requirements state what the system must do and address how the system provides value to the stakeholders.</li>
<li>功能性需求意味着<strong>系统的行为</strong><br>Functional requirements means the behaviour of the system.</li>
<li>功能是系统<strong>完成其预期工作</strong>的能力，例如，使学生能够在线注册<br>Functionality is the ability of the system to do the work for which it was intended, e.g., enable students to enrol online.</li>
<li>通过使用<strong>任意数量的可能结构</strong>来实现功能<br>Functionality may be achieved through the use of any<br>number of possible structures.</li>
<li>功能在很大程度上与结构无关，因为它可以作为单个整体系统存在而没有任何内部结构<br>Functionality is <strong>largely independent of structure</strong>, because it could exist as a single monolithic system without any internal structure.</li>
</ol>
<h3 id="2-2-质量需求-Quality-Requirements"><a href="#2-2-质量需求-Quality-Requirements" class="headerlink" title="2.2 质量需求 Quality Requirements"></a>2.2 质量需求 Quality Requirements</h3><ol>
<li>质量需求是系统应<strong>在其功能需求之上</strong>提供的整个系统的<strong>理想特性</strong>(又称质量属性)<br>Quality requirements are desirable characteristics of the overall system (aka. quality attributes) that system should provide on the top of its functional requirements.</li>
<li>质量需求是功能要求或整个产品的<strong>资格</strong><br>Quality requirements are qualifications of the functional requirements or of the overall product.</li>
<li>如果质量属性很重要，则软件架构将<strong>功能分配</strong>(映射)限制在各种<strong>结构</strong>上。<br>Software architecture constrains the allocation (mapping) of the functionality onto various structures if quality attributes are important.</li>
</ol>
<h4 id="2-2-1-非功能性需求-Non-functional-Requirements"><a href="#2-2-1-非功能性需求-Non-functional-Requirements" class="headerlink" title="2.2.1 非功能性需求 Non-functional Requirements"></a>2.2.1 非功能性需求 Non-functional Requirements</h4><ol>
<li><p><strong>非功能</strong>需求或<strong>架构</strong>需求是用于<strong>质量属性</strong>的替代术语<br>Non-functional requirements or architectural requirements are alternative terms used for quality attributes.</p>
</li>
<li><p>无法在实现功能后再去满足非功能性需求(不能事后追加质量)</p>
<p>It is not possible to get the functionality right and then try to accommodate non-functional requirements (NO retro-fitting quality).</p>
<blockquote>
<p>在任何设计决策中都必须考虑非功能性需求，而不是在完成功能后再去改造系统或设备，以满足非功能性要求</p>
</blockquote>
</li>
<li><p>在任何设计决策中都必须考虑非功能性要求<br>Non-functional requirements must be taken into account during any design decision.</p>
</li>
<li><p>非功能性需求分为两大类: There are two broad categories ot non-functional requirements:</p>
<ol>
<li>在执行过程中<strong>可观察</strong>(<strong>外部</strong>): 系统满足其行为要求的程度如何？ 例如性能，安全性，可用性，可用性等。<br>Observable (External) during execution: How well a system satisties its behavioural requirements? e.g., performance, security, availability, usability etc.</li>
<li>执行期间<strong>不可观察</strong>(<strong>内部</strong>): 系统的维护，集成或测试有多容易？ 例如，可修改性，可移植性，可重用性，可测试性等。<br>Not observable (Internal) during execution: How easily a system can be maintained, integrated, or tested? e.g., modifiability, portability, reusability, testability etc.</li>
</ol>
</li>
</ol>
<blockquote>
<p>约束是限定的边界，之后的架构是在这个边界内找到最优的解。</p>
</blockquote>
<h4 id="2-2-2-质量属性-Quality-Attributes"><a href="#2-2-2-质量属性-Quality-Attributes" class="headerlink" title="2.2.2 质量属性 Quality Attributes"></a>2.2.2 质量属性 Quality Attributes</h4><ol>
<li><strong>开发完成后</strong>，质量<strong>不能</strong>添加到软件密集型系统中<br>Quality isn’t something that can be added to a software intensive system after development finishes.</li>
<li>在<strong>软件开发的所有阶段</strong>都需要解决质量问题<br>Quality concerns need to be addressed during ALL phases of the software development.</li>
<li>业务目标确定系统必须具备的质量<br>Business goals determine qualities that a system must posses.</li>
<li>质量属性<strong>高于系统功能</strong>，而系统功能是系统能力，服务和行为的基本表述<br>Quality attributes are over and above of system’s functionality, which is the basic statement of the system’s capabilities, services, and behaviours.</li>
<li>功能通常在开发计划中占据<strong>首要位置</strong><br>Functionality usually takes the front seat in the development plan.</li>
<li>但是，系统通常会被<strong>重新设计</strong>，因为它们<strong>缺乏所需的质量水平</strong>，即难以维护，移植或扩展<br>However, systems are usually redesigned because they lack desired level of quality, i.e. difficult to maintain, port, or scale.</li>
<li>软件架构限制了各种质量属性的实现，例如性能，安全性，可用性等<br>Software architecture constrains the achievement of various quality attributes, e.g., performance, security, usability etc.</li>
<li>这就是为什么软件架构被认为是解决质量问题的最合适的层次<br>That is why software architecture is considered the most appropriate level of addressing the quality Issues.</li>
<li>没有质量属性完全依赖于<strong>设计</strong>，也不依赖于<strong>实施或部署</strong><br>No quality attribute is entirely dependent on design, nor is it dependent on implementation or deployment.</li>
</ol>
<h4 id="2-2-3-确定质量属性-Specifying-Quality-Attributes"><a href="#2-2-3-确定质量属性-Specifying-Quality-Attributes" class="headerlink" title="2.2.3 确定质量属性 Specifying Quality Attributes"></a>2.2.3 确定质量属性 Specifying Quality Attributes</h4><ol>
<li>要在架构级别对其进行<strong>评估</strong>，必须对质量属性进行<strong>精确定义</strong><br>Precise definition of a quality attribute is necessary to evaluate it at the architecture level.</li>
<li>质量属性<strong>场景</strong>用于定义所需的质量属性<br>Quality attribute scenarios are used to define the desired quality attribute.</li>
<li>场景是具有一定结构的简单描述。<br>Scenarios are simple descriptions with certain structure. Two main classes of scenarlos are:<ol>
<li><strong>通用场景</strong>是与<strong>系统无关</strong>的场景，用于指导质量属性要求的规范<br>General scenarios are system independent scenarios to guide the specification of quality attribute requirements.</li>
<li><strong>具体场景</strong>是系统<strong>特定</strong>的场景，用于指导特定系统的质量属性要求的规范。它们是通用场景的<strong>实例</strong><br>Concrete scenarios are system specific scenarios to guide the specification of quality attribute requirements for a particular system. They are instances ot general scenarios.</li>
</ol>
</li>
</ol>
<blockquote>
<p>这个场景(scenarios)就是4+1视图中的1(Use Case)</p>
</blockquote>
<h4 id="2-2-4-通用场景-General-Scenarios"><a href="#2-2-4-通用场景-General-Scenarios" class="headerlink" title="2.2.4 通用场景 General Scenarios"></a>2.2.4 通用场景 General Scenarios</h4><ol>
<li>通用场景提供了一个<strong>框架</strong>，用于生成<strong>大量</strong>通用的，独立于系统的，质量属性特定的场景<br>General scenarios provide a framework for generating a large number of generic, system-independent, quality attribute specific scenarios.</li>
<li>每种场景都可能但不一定与我们所关注的系统相关<br>Each scenario is potentially but not necessarily relevant to the system We are concerned with.</li>
<li>为了使通用场景对特定系统有用，我们必须使它们<strong>特定于系统</strong><br>To make the general scenario useful for a particular system, We must make them system specific.</li>
<li>将通用场景系统具体化意味着将其<strong>转换</strong>为特定系统的具体术语<br>Making a general scenario system specific means translating it into concrete terms for the particular system.</li>
</ol>
<h4 id="2-2-5-质量属性场景建模-Modeling-Quality-Attribute-Scenarios-重要"><a href="#2-2-5-质量属性场景建模-Modeling-Quality-Attribute-Scenarios-重要" class="headerlink" title="2.2.5 质量属性场景建模 Modeling Quality Attribute Scenarios 重要"></a>2.2.5 质量属性场景建模 Modeling Quality Attribute Scenarios 重要</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501162310334.png" alt="image-20230501162310334" style="zoom:80%;" /></p>
<ol>
<li><p><strong>刺激(Stimulus)</strong>: 到达系统时需要考虑的<strong>条件</strong><br>Stimulus: A condition that needs to be considered when it arrives at a system.</p>
</li>
<li><p><strong>刺激源(Source of Stimulus)</strong>: 产生刺激的<strong>实体</strong>(人，系统或任何执行器)<br>Source of Stimulus: An entity (human, system, or any actuator) that generates the stimulus.</p>
<blockquote>
<p>可能是输入、消息等等，对当前的状态有一个变化。</p>
</blockquote>
</li>
<li><p><strong>响应(Response)</strong>: 刺激措施到来之后开展的<strong>活动</strong><br>Response: The activity undertaken after the arrival of the stimulus.</p>
</li>
<li><p><strong>响应度量(Response Measure)</strong>: 对刺激的响应应以某种方式进行<strong>测量</strong>，以便可以<strong>测试</strong>需求<br>Response Measure: The response to the stimulus should be measurable in some fashion so that the requirement can be testable.</p>
<blockquote>
<p>多长时间系统有反馈</p>
</blockquote>
</li>
<li><p><strong>环境(Environment)</strong>: 发生刺激时系统的状况，例如过载，运行等<br>Environment: A system’s condition when a stimulus occurs, e.g. overloaded, running etc.</p>
</li>
<li><p><strong>工件(Artifact)</strong>: 需求适用的<strong>整个</strong>系统或系统的一部分<br>Artifact: The whole system or the portion of the system to which the requirement applies.</p>
<blockquote>
<p>可能是一个软件制品</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>只有定义好这6个元素，就能锁定架构的一个场景，之后可以用来进行架构的设计</p>
<p>刺激和响应发生在一个环境中: 系统正常运行、系统过载、系统受到攻击、系统网络等出现了故障。</p>
</blockquote>
<h4 id="2-2-6-策略-Tactics-原子级别的最小的决定"><a href="#2-2-6-策略-Tactics-原子级别的最小的决定" class="headerlink" title="2.2.6 策略 Tactics (原子级别的最小的决定)"></a>2.2.6 策略 Tactics (原子级别的最小的决定)</h4><ol>
<li>风格或模式应用策略来提供承诺的收益<br>Style or pattern applies tactics to provide the promised benefit.</li>
<li>策略是影响质量属性响应<strong>控制</strong>的<strong>设计决策</strong>，例如冗余<br>A tactic is a design decision, .e.g. redundancy, that influences the control of a quality attribute response.</li>
<li>策略的<strong>集合</strong>称为体系结构策略<br>A collection of tactics is called an architectural strategy.</li>
<li>系统设计包括一组设计决策，其中一些决策可帮助控制<strong>质量</strong>属性响应；其他确保系统<strong>功能</strong>的实现<br>A system design consists of a collection of design decisions: some of these decisions help control the quality attribute response; others ensure achievement of system functionality.</li>
<li>像模式一样，策略也可以由其他策略组成，例如，冗余可以由数据冗余，计算冗余组成。设计人员根据需求选择一个或另一个<br>Like patterns, tactics may also be composed of other tactics, e.g., redundancy may be composed of redundancy of data, redundancy of computation-Designer chooses one or other depending upon requirements.</li>
<li><p>策略可以用作<strong>策略层次结构</strong> Tactics can be used as hierarchy of tactics.</p>
<blockquote>
<p>这句话的意思是，策略可以按照层次结构来使用。也就是说，可以将不同的策略分层，按照优先级或者重要性来组织。这样可以更好地管理和使用策略。— New Bing</p>
</blockquote>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501164956678.png" alt="image-20230501164956678" style="zoom:80%;" /></p>
<h4 id="2-2-7-质量设计决策-Quality-Design-Decisions"><a href="#2-2-7-质量设计决策-Quality-Design-Decisions" class="headerlink" title="2.2.7 质量设计决策 Quality Design Decisions"></a>2.2.7 质量设计决策 Quality Design Decisions</h4><ul>
<li>架构是设计决策的集合。Architecture is a collection of design decisions. </li>
<li>七类设计决策(可能重叠) Seven categories of design decisions (may overlap):<ol>
<li><strong>职责分配</strong> Allocation of responsibilities: 将大的职责进行分配</li>
<li><strong>协调模型</strong> Coordination model: 各部分之间的沟通、交互</li>
<li><strong>数据模型</strong> Data model: 数据格式、存储方式(缓存等)</li>
<li><strong>资源管理</strong> Management of resources: CPU、网络、内存、<strong>时间(部分时间敏感的场景)等资源</strong></li>
<li><strong>架构元素之间的映射</strong> Mapping among architecture elements: 架构元素如何映射到软件的实现上</li>
<li><strong>绑定时间决策</strong> Binding time decisions: <ul>
<li>系统的变化在什么时间点前需要固定下来，也就是这个时间前，系统还是可以变化的，但是这个时间之后就不可以变化了</li>
<li>比如选择安装环境是需要在一个时间点前完成的，技术是否添加、编译时间、初始化时间，运行时绑定，但运行时是弹性最大的</li>
<li>实际上我们希望绑定时间越往后越好，但是也就要付出相应的代价。</li>
</ul>
</li>
<li><strong>技术选择</strong> Choice of technology: 前面的部分都确定后，我们可以选择技术栈相对比较局限，解空间已经被压缩了</li>
</ol>
</li>
</ul>
<h4 id="2-2-8-质量属性"><a href="#2-2-8-质量属性" class="headerlink" title="2.2.8 质量属性"></a>2.2.8 质量属性</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501165533669.png" alt="image-20230501165533669" style="zoom:80%;" /></p>
<h3 id="2-3-约束-Constraints"><a href="#2-3-约束-Constraints" class="headerlink" title="2.3 约束 Constraints"></a>2.3 约束 Constraints</h3><ul>
<li>约束是具有<strong>零自由度</strong>的设计决策<br>A constraint is a design decision with <strong>ZERO</strong> degrees of freedom.</li>
<li>约束是已经做出的<strong>预先</strong>指定的设计决策<br>Constraints are pre-specified design decisions that have been already made.</li>
<li>通过<strong>接受</strong>设计决策并将其与其他受影响的设计决策进行<strong>协调</strong>来满足约束条件<br>Constraints are satisfied by accepting the design decision and reconciling it with other affected design decisions.</li>
</ul>
<h2 id="3-质量属性和策略-Quality-Attributes-amp-Tactics"><a href="#3-质量属性和策略-Quality-Attributes-amp-Tactics" class="headerlink" title="3. 质量属性和策略 Quality Attributes &amp; Tactics"></a>3. 质量属性和策略 Quality Attributes &amp; Tactics</h2><h3 id="3-1-可用性-Availability"><a href="#3-1-可用性-Availability" class="headerlink" title="3.1 可用性 Availability"></a>3.1 可用性 Availability</h3><ul>
<li><p>可用性是应用程序的<strong>关键</strong>需求 Key requirement for most IT applications</p>
</li>
<li><p>度量方式: 以<strong>所需</strong>的可用<strong>时间</strong>比例来衡量<br>Measured by the proportion of the required time it is useable, e.g.</p>
<ul>
<li>营业时间内100％可用<br>100% available during business hours</li>
<li>每周计划的停机时间不超过2个小时-24x7x52(100％可用性)<br>No more than 2 hours scheduled downtime per week - 24x7x52 (100% availability)</li>
</ul>
</li>
<li><p>相关性: 与应用程序的<strong>可靠性</strong>有关 Related to an application’s reliability</p>
<ul>
<li>不可靠的应用程序的可用性较差<br>Unreliable applications suffer poor availability</li>
<li>可用性、可靠性不同: <ul>
<li>可用性是指可以使用，但是不保证正确</li>
<li>可靠性是指可以稳定正确的使用</li>
</ul>
</li>
</ul>
</li>
<li><p>可用性损失的时间由以下因素决定: Period of loss of availability determined by:</p>
<ul>
<li><strong>发现</strong>故障的时间 Time to detect failure</li>
<li><strong>纠正</strong>故障的时间 Time to correct failure</li>
<li><strong>重启</strong>应用的时间 Time to restart application</li>
</ul>
<blockquote>
<p>例子(时间序): 发生故障-检测到故障-纠正故障-重启应用，这三个代表的是not available的时间(N/A)</p>
<p>提高可用性的方案:</p>
<ol>
<li>尽可能降低N/A的时间<ul>
<li>机器尽可能缩短failure到detect时间</li>
<li>机器尽可能缩短correct到restart的时间</li>
</ul>
</li>
<li>尽可能提高Available的时间</li>
</ol>
</blockquote>
</li>
<li><p>高可用性策略 Strategies for high availability</p>
<ul>
<li>消除<strong>单点故障</strong> Eliminate single points of failure</li>
<li><strong>复制</strong>和<strong>故障转移</strong> Replication and failover</li>
<li>自动<strong>检测</strong>并<strong>重启</strong> Automatic detection and restart</li>
</ul>
</li>
<li><p>可恢复性 Recoverability (e.g., a database)</p>
<ul>
<li>在应用程序或系统出现故障后，可以重新建立<strong>性能级别</strong>并<strong>恢复</strong>受影响的数据的能力<br>The capability to re-establish performance levels and recover affected data after an application or system failure.</li>
</ul>
</li>
<li><p>可将<strong>可用性</strong>计算为在<strong>指定的时间间隔</strong>内它将在所需范围内<strong>提供指定服务</strong>的概率<br>Availability can be calculated as the probability that it will provide the specified services within required bounds over a specified time interval.</p>
<ul>
<li><strong>MTBF</strong>(平均无故障时间, mean time between failures)</li>
<li><strong>MTTR</strong>(平均维修时间, mean time to repair)</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230613165243754.png" alt="image-20230613165243754"></p>
</li>
<li><p>计算可用性时，可能不考虑<strong>计划内的停机时间</strong><br>Scheduled downtimes may not be considered when calculating availability.</p>
</li>
</ul>
<h4 id="3-1-1-Outage-Failure-Fault-Error"><a href="#3-1-1-Outage-Failure-Fault-Error" class="headerlink" title="3.1.1 Outage, Failure, Fault, Error"></a>3.1.1 Outage, Failure, Fault, Error</h4><ul>
<li>可用性是指通过<strong>减少</strong>故障来最大程度地减少服务<strong>中断</strong>时间<br>Availability is about minimizing the service <strong>outage</strong> time by mitigating faults.</li>
<li><strong>引起 Failure 的原因</strong>称为 <strong>Fault</strong><br>A failure’s cause is called a fault.</li>
<li>当系统无法交付该系统期望的服务时，将发生Failure<br>A failure occurs when a system cannot deliver a service that is expected of that system.</li>
<li>Failure是系统状态的<strong>可观察</strong>特征<br>A failure is an observable characteristics of a system’s state.</li>
<li>系统任何部分中的 Fault 都有可能导致 Failure。系统可以从 Failure 中修复或恢复<br>A fault in any part of a system has a potential to cause a failure; a system can be repaired or recovered from a failure.</li>
<li>发生 Fault 与 Failure 之间的<strong>中间状态</strong>称为 Error<br>Intermediate states between the occurrence of a fault and a ftailure are called errors.</li>
<li>名词辨别<ul>
<li>Outage: 系统不可用的情况，scheduled downTime就是一种Outage。</li>
<li>Failure: 系统不可用失效</li>
<li>Fault: 是系统导致Failure的原因，Fault不会立即导致Failure</li>
<li>Error: 在Fault发生与Failure的中间状态</li>
</ul>
</li>
</ul>
<h4 id="3-1-2-服务水平协议-Service-Level-Agreement"><a href="#3-1-2-服务水平协议-Service-Level-Agreement" class="headerlink" title="3.1.2 服务水平协议 Service-Level Agreement"></a>3.1.2 服务水平协议 Service-Level Agreement</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502201241584.png" alt="image-20230502201241584"></p>
<p>Amazon EC2’s SLA:</p>
<ul>
<li><p>AWS将通过商业上合理的努力来使 Amazon EC2 在服务年度内的年度正常运行率至少达到99.95％。如果 Amazon EC2 不符合年度正常运行时间百分比承诺，您将有资格获得服务信用<br>AWS will use commercially reasonable efforts to make Amazon EC2 available with an Annual Uptime Percentage of at least 99.95% during the Service Year. In the event Amazon EC2 does not meet the Annual Uptime Percentage commitment, you will be eligible to receive a Service Credit.</p>
</li>
<li><p>99.95%的是99.9%的一半</p>
</li>
</ul>
<h4 id="3-1-3-对于Failure的计划-Planning-for-Failure"><a href="#3-1-3-对于Failure的计划-Planning-for-Failure" class="headerlink" title="3.1.3 对于Failure的计划 Planning for Failure"></a>3.1.3 对于Failure的计划 Planning for Failure</h4><ul>
<li>危害分析 Hazard analysis: 对Failure进行分类<ul>
<li>灾难性的/危险 Catastrophic/Hazardous</li>
<li>主要的/次要的 Major/Minor</li>
<li>没有影响 No effect</li>
</ul>
</li>
<li>故障树分析: Fault tree analysis:<ul>
<li>分级处理 Failure</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501171827036.png" alt="image-20230501171827036" style="zoom:80%;" /></p>
<ul>
<li>故障模式，影响和严重性分析<br>Failure Mode, Effects, and Criticality Analysis(FMECA)<ul>
<li>FMECA依靠过去类似系统的故障历史<br>FMECA relies on the history of failure of similar systems in the past.</li>
<li>$5 <em> 10^{-5} = 1 </em> 10^{-3} * 5\%$</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501172010947.png" alt="image-20230501172010947" style="zoom:80%;" /></p>
<h4 id="3-1-4-可用性通用场景-Availability-General-Scenario"><a href="#3-1-4-可用性通用场景-Availability-General-Scenario" class="headerlink" title="3.1.4 可用性通用场景 Availability General Scenario"></a>3.1.4 可用性通用场景 Availability General Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501172132423.png" alt="image-20230501172132423" style="zoom:80%;" /></p>
<ol>
<li>source: 可能是内部的，也可能是外部的，可能是人、设施、硬件等等，无论是哪一类都会引起可用性的问题，都能发出一个刺激</li>
<li>Stiumulus: Failure，不正确的时间、不正确响应(超过边界)</li>
<li>工件: 在进程中、交流通道中等等</li>
<li>环境: 各种不同的系统环境，正常的错误的等等</li>
<li>反应: 错误发生后一些的可能反应，recover是correct的时间</li>
<li>反应度量: 时间上、可用性的描述(多长时间，可以用多少)</li>
</ol>
<h4 id="3-1-5-可用性示例场景-Availability-Sample-Scenario"><a href="#3-1-5-可用性示例场景-Availability-Sample-Scenario" class="headerlink" title="3.1.5 可用性示例场景 Availability Sample Scenario"></a>3.1.5 可用性示例场景 Availability Sample Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501173053221.png" alt="image-20230501173053221" style="zoom: 67%;" /></p>
<ol>
<li>Source没有收到Heartbeat认为出现了一个Failure</li>
<li>将Stimulus发送给正在处理的进程</li>
<li>进程会通知Operation(人和服务器，来检查是否可以运行)</li>
<li>最后会发送一个回复</li>
<li>整体发生在一个正常运转的环境中</li>
</ol>
<h4 id="3-1-6-可用性策略-Availability-Tactics"><a href="#3-1-6-可用性策略-Availability-Tactics" class="headerlink" title="3.1.6 可用性策略 Availability Tactics"></a>3.1.6 可用性策略 Availability Tactics</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501173240504.png" alt="image-20230501173240504" style="zoom:80%;" /></p>
<blockquote>
<ul>
<li>这个树说明了对于可用性可以采用哪些手段来解决: 很重要</li>
<li>每一个树的分支代表了我们考虑的时间点: 尽可能的延长可用时间</li>
<li>不同的检测服务可用的手段<ul>
<li>主动发送心跳: Heart Beat<ul>
<li>资源的损耗有一次通讯</li>
<li>可以同时承担更多的业务(定期更新状态)</li>
<li>自动化检测，更为定时的服务</li>
<li>单向更为安全</li>
</ul>
</li>
<li>被动接受检测: Ping/Echo 或 Minotor<ul>
<li>资源损耗有两次通讯</li>
<li>更加灵活自助，根据自己的情况进行检测</li>
<li>双向确认</li>
</ul>
</li>
<li>TimeStamp<ul>
<li>收到一系列的消息应该在时间上有先后顺序</li>
<li>进行常识的信息的检查，如果和常识不符合那么可能是出现了问题</li>
</ul>
</li>
<li>自检: 检查一下自己是否有问题</li>
</ul>
</li>
<li>Preparation and Repair<ul>
<li>Active Redundancy 冗余部分是都在工作的，如果没有发现问题时，我们只接受Primary的输入，而Secondary的输入会被抛弃，有明显的downTime</li>
<li>Passive Redundancy: Primary同步到Secondary上，而如果Primary挂掉了，则启用Secondary，并快速操作(从上一个状态)，不一定有明显的DownTime，一般选择使用Passive的方式</li>
<li>Spare: 组合在一起使用</li>
<li>Rollback: 回滚解决不一致的问题</li>
<li>Retry</li>
<li>Ignore Faulty Behavior</li>
<li>Degradation: 服务降级，比如Windows的安全模式，让目前已经发生的问题不再影响系统的修复</li>
<li>Reconfiguration</li>
</ul>
</li>
<li>Reintroduction: <ul>
<li>shadow</li>
<li>State Retry Resynchronized</li>
<li>Escalating Restart</li>
<li>Non-Stop Forwarding</li>
</ul>
</li>
<li>Denial of Service: Dos攻击: 大量无效的请求将资源耗尽以阻止提供正常的服务</li>
<li>上述的操作可能不仅仅涉及到一个质量属性</li>
</ul>
</blockquote>
<h5 id="3-1-6-1-Fault-探测-Fault-Detection"><a href="#3-1-6-1-Fault-探测-Fault-Detection" class="headerlink" title="3.1.6.1 Fault 探测 Fault Detection"></a>3.1.6.1 Fault 探测 Fault Detection</h5><ul>
<li><strong>Ping/Echo</strong><ul>
<li>一个组件发出ping命令，并期望在预定时间内在另一个组件上产生回波<br>One component issues a ping and expects, an echo from another component within a pre-detined time.</li>
<li>Ping/Echo可以在负责一项任务的一组组件中使用<br>Ping/Echo can be used within a group of components responsible for one task.</li>
</ul>
</li>
<li><strong>心跳 Heartbeat(dead man time)</strong><ul>
<li>一个组件定期发出心跳消息(也可以携带数据)，而另一个组件侦听该消息<br>One component emits a heartbeat message (can also carry data) periodically and another component listens for it.</li>
<li>如果心跳失败，则假定发起组件已失败，并通知故障纠正组件<br>If the heartbeat fails, the originating component is assumed to have failed and a fault correction component is notified.</li>
</ul>
</li>
<li><strong>异常 Exception</strong><ul>
<li>识别故障的一种方法是遇到异常<br>One method for recognising faults is to encounter an exception.</li>
<li>异常处理程序通常在引入异常的同一过程中执行<br>The exception handler typically executes in the same process that introduces the exception.</li>
</ul>
</li>
<li>ping和心跳策略在不同的进程中运行，异常策略在单个进程中运行<br>The ping and heartbeat tactics operate among distinct processes, and the exception tactic operates within a single process.</li>
</ul>
<h5 id="3-1-6-2-Fault-恢复-Fault-Recovery"><a href="#3-1-6-2-Fault-恢复-Fault-Recovery" class="headerlink" title="3.1.6.2 Fault 恢复 Fault Recovery"></a>3.1.6.2 Fault 恢复 Fault Recovery</h5><ul>
<li><strong>表决 Voting</strong><ul>
<li>在冗余处理器上运行的进程每个都接受等效输入并计算一个简单值，该值将发送给投票者<br>Processes running on redundant processors each take equivalent input and compute a simple value that is sent to a voter.</li>
<li>如果投票器检测到单个进程的异常行为，它将使其失败。<br>If the voter detects deviant behaviour from a single process, it fails it.</li>
</ul>
</li>
<li><strong>主动冗余 Active redundancy</strong><ul>
<li>所有冗余组件均以并行方式响应事件-所有组件均处于相同状态<br>All redundant components respond to events in parallel - there are all in the same state.</li>
<li>仅使用了一个组件的响应，其余组件则被丢弃<br>The response from only one component is used, and the rest are discarded.</li>
<li>发生故障时，通常不存在停机时间，因为备份是最新的，唯一的切换时间是恢复时间<br>When a failure occurs, the downtime is usually non-existent as backup is current and the only switching time is the recovery time.</li>
</ul>
</li>
<li><strong>被动冗余 Passive redundancy</strong><ul>
<li>一个组件(主要)响应事件，并通知其他组件(次要)它们必须进行的状态更新<br>One component (primary) responds to events and informs the other components (secondary) of state updates they must make.</li>
<li>发生故障时，系统必须首先确保备份状态足够新，然后才能恢复服务<br>When a failure occurs, the system must first ensure that the backup state is sufficiently recent before resuming services.</li>
</ul>
</li>
<li><strong>备件 Spare</strong><ul>
<li>备用备用计算平台配置为替换许多不同的故障组件<br>A standby spare computing platform is configured to replace many different failed components.</li>
</ul>
</li>
<li><strong>影子操作 Shadow operation</strong><ul>
<li>先前发生故障的组件可能会在“影子模式”下运行一小段时间，以确保它可以模仿工作组件的行为，然后再将其恢复正常工作<br>A previously failed component may be run in “shadow mode” for a short time to make sure that it mimics the behaviour of the working components before restoring it to service.</li>
</ul>
</li>
<li><strong>状态重新同步 State re-synchronisation</strong><ul>
<li>被动和主动冗余策略要求要恢复的组件在恢复服务之前对其状态进行升级<br>The passive and active redundancy tactics require the component being restored to have its state upgraded before its return to service.</li>
</ul>
</li>
<li><strong>检查点/回滚 Checkpoint/Rollback</strong><ul>
<li>检查点记录的是定期或响应特定事件而创建的一致状态<br>A checkpoint is recording of a consistent state created either periodically or in response to specific events.</li>
</ul>
</li>
<li><strong>从服务中删除 Removal from service</strong><ul>
<li>该策略将系统的某个组件从运行中移除，以进行一些活动以防止预期的故障<br>This tactic removes a component of the system from operation to undergo some activities to prevent anticipated failure.</li>
</ul>
</li>
<li><strong>事务 Transaction</strong><ul>
<li>事务是几个连续步骤的捆绑，这样就可以一次撤消整个捆绑<br>A transaction is the bundling of several sequential steps such that the entire bundle can be undone at once.</li>
</ul>
</li>
<li><strong>过程监控器 Process monitor</strong><ul>
<li>一旦检测到进程中的故障，监视进程就可以检测到不良进程并为其创建新实例，并按照备用策略将其初始化为适当的状态<br>Once a fault in a process has been detected, a monitoring process can detect the non-performing process and create a new instance of it, initialised to some appropriate state as in the spare tactic.</li>
</ul>
</li>
</ul>
<h4 id="3-1-7-可用性设计和分析的检查列表-Checklist-for-Availability-Design-amp-Analysis"><a href="#3-1-7-可用性设计和分析的检查列表-Checklist-for-Availability-Design-amp-Analysis" class="headerlink" title="3.1.7 可用性设计和分析的检查列表 Checklist for Availability Design &amp; Analysis"></a>3.1.7 可用性设计和分析的检查列表 Checklist for Availability Design &amp; Analysis</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502010221233.png" alt="image-20230502010221233" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502010246494.png" alt="image-20230502010246494" style="zoom:80%;" /></p>
<blockquote>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec13/60.png" style="zoom: 67%;" /></p>
</blockquote>
<h3 id="3-2-互操作性-Interoperability"><a href="#3-2-互操作性-Interoperability" class="headerlink" title="3.2 互操作性 Interoperability"></a>3.2 互操作性 Interoperability</h3><ul>
<li><strong>互操作性</strong>是指两个或多个系统可以在特定上下文中<strong>通过接口</strong>有用地<strong>交换</strong>有意义的信息的程度<br>Interoperability is about the degree to which two or more systems can usefully exchange meaningful information via interfaces in a particular context.<ul>
<li><strong>交换</strong>数据的能力(<strong>语法</strong>互操作性)<br>Ability to exchange data (syntactic interoperability)</li>
<li>能够正确<strong>解释</strong>数据(<strong>语义</strong>互操作性)<br>Ability to correctly interpret the data (semantic interoperability)</li>
</ul>
</li>
<li>互操作性需要确定与<strong>谁，什么以及在什么情况</strong>下(上下文)<br>Interoperability needs to identify with whom, with what, and under what circumstances (the context). </li>
<li>互动 Interface<ul>
<li>夏琳说金告诉她特雷弗听说希瑟想参加你的聚会<br>Charlene said that Kim told her that Trevor heard that Heather wants to come to your party.</li>
</ul>
</li>
<li>互操作性的两个重要方面 Two important aspects of interoperability:<ul>
<li><strong>发现</strong>: 服务的使用者必须发现服务的<strong>位置，身份和接口</strong><br>Discovery: the consumer of a service must discover the location, identity, and the interface of the service.</li>
<li><strong>处理回应</strong>: Handling of the response:<ul>
<li>向请求者<strong>报告</strong>并做出<strong>响应</strong> reports back to the requester with response.</li>
<li>将其响应<strong>发送</strong>到另一个系统 sends its response on to another system.</li>
<li>向任何感兴趣的各方<strong>广播</strong>其响应 broadcasts its response to any interested parties.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-1-互操作性的通用场景-Interoperability-General-Scenario"><a href="#3-2-1-互操作性的通用场景-Interoperability-General-Scenario" class="headerlink" title="3.2.1 互操作性的通用场景 Interoperability General Scenario"></a>3.2.1 互操作性的通用场景 Interoperability General Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502014009007.png" alt="image-20230502014009007" style="zoom:80%;" /></p>
<h4 id="3-2-2-互操作性示例场景-Interoperability-Sample-Scenario"><a href="#3-2-2-互操作性示例场景-Interoperability-Sample-Scenario" class="headerlink" title="3.2.2 互操作性示例场景 Interoperability Sample Scenario"></a>3.2.2 互操作性示例场景 Interoperability Sample Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502014204116.png" alt="image-20230502014204116" style="zoom:80%;" /></p>
<h4 id="3-2-3-互操作性的策略-Interoperability-Tactics"><a href="#3-2-3-互操作性的策略-Interoperability-Tactics" class="headerlink" title="3.2.3 互操作性的策略 Interoperability Tactics"></a>3.2.3 互操作性的策略 Interoperability Tactics</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502014217912.png" alt="image-20230502014217912" style="zoom:80%;" /></p>
<ul>
<li>定位 Locate<ul>
<li><strong>发现</strong>服务: 通过搜索已知目录服务来找到服务<br>Discovery service: locate a service through searching a known directory service.<ul>
<li>多级间接 multiple levels of indirection</li>
</ul>
</li>
</ul>
</li>
<li>管理接口 Manage interfaces<ul>
<li><strong>编排</strong>: 使用控制机制来协调，管理和排序特定服务的调用<br>Orchestrate: uses a control mechanism to coordinate and manage and sequence the invocation of particular services.</li>
<li><strong>定制接口</strong>: 向接口添加或删除功能<br>Tailor interface: adds or removes capabilities to an interface.</li>
</ul>
</li>
<li>Orchestrate: 请求，一个请求会涉及到多个Service，我们需要按照一定顺序进行处理请求</li>
</ul>
<h4 id="3-2-4-互操作性的检查列表-Checklist-for-Interoperability-Design-amp-Analysis"><a href="#3-2-4-互操作性的检查列表-Checklist-for-Interoperability-Design-amp-Analysis" class="headerlink" title="3.2.4 互操作性的检查列表 Checklist for Interoperability Design &amp; Analysis"></a>3.2.4 互操作性的检查列表 Checklist for Interoperability Design &amp; Analysis</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502014645621.png" alt="image-20230502014645621" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502014703290.png" alt="image-20230502014703290" style="zoom:80%;" /></p>
<h3 id="3-3-可修改性-Modifiability"><a href="#3-3-可修改性-Modifiability" class="headerlink" title="3.3 可修改性 Modifiability"></a>3.3 可修改性 Modifiability</h3><ul>
<li>可修改性涉及<strong>更改</strong>以及进行更改<strong>的时间或金钱成本</strong>，包括这种可更改性影响其他功能或质量属性的程度<br>Modifiability deal with change and the cost in time or money of making a change, including the extent to which this modifiability affects other functions or quality attributes.</li>
<li>为变更做<strong>准备</strong>是有代价的，而<strong>进行</strong>变更则要付出代价<br>There is a cost of prepraring for change as well as a cost of making a change.</li>
<li>计划可修改性的四个问题 Four questions to plan for modifiability<ol>
<li>有什么可以改变的？What can change?</li>
<li>变化的<strong>可能性</strong>是多少？What is the likelihood of the change?</li>
<li><strong>何时</strong>进行更改，谁进行更改？When is the change made and who makes it?</li>
<li>变更的<strong>成本</strong>是多少？What is the cost of the change?</li>
</ol>
</li>
<li>如果更改少于预期，则可能不需要昂贵的修改机制<br>If fewer changes than expected come in, then an expensive modification mechanism may not be warranted.</li>
<li>计算公式: N $\ast$ 没有机制的情况下进行更改的成本 &lt;= 安装机制的成本 + (N $\ast$ 使用机制进行更改的成本)</li>
<li>降低的成本可以用于提高可修改性</li>
</ul>
<h4 id="3-3-1-可修改性的通用场景-Modifiability-General-Scenario"><a href="#3-3-1-可修改性的通用场景-Modifiability-General-Scenario" class="headerlink" title="3.3.1 可修改性的通用场景 Modifiability General Scenario"></a>3.3.1 可修改性的通用场景 Modifiability General Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502142540597.png" alt="image-20230502142540597" style="zoom:80%;" /></p>
<h4 id="3-3-2-可修改性的样本场景-Modifiability-Sample-Scenario"><a href="#3-3-2-可修改性的样本场景-Modifiability-Sample-Scenario" class="headerlink" title="3.3.2 可修改性的样本场景 Modifiability Sample Scenario"></a>3.3.2 可修改性的样本场景 Modifiability Sample Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502142635756.png" alt="image-20230502142635756" style="zoom:80%;" /></p>
<h4 id="3-3-3-可修改性的策略-Modifiability-Tactics"><a href="#3-3-3-可修改性的策略-Modifiability-Tactics" class="headerlink" title="3.3.3 可修改性的策略 Modifiability Tactics"></a>3.3.3 可修改性的策略 Modifiability Tactics</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502180141602.png" alt="image-20230502180141602" style="zoom:80%;" /></p>
<ul>
<li>减小模块大小 Reduce Size of a Module:<ul>
<li><strong>拆分模块</strong>: 如果要修改的模块包含<strong>大量功能</strong>，则修改成本可能会很高(尽可能的控制包的大小)<br>Split module: If the module being modified includes a great deal of capabilities, the modification costs will likely be high.</li>
</ul>
</li>
<li>增加一致性 Increase Cohesion:<ul>
<li><strong>增加语义一致性</strong>: 如果模块中的职责 A 和 B <strong>目的不同</strong>，则应通过创建新模块或将职责移至现有模块将它们放置在不同的模块中<br>Increase semantic coherence: If the responsibilities A and B in a module do not serve the same purpose, they should be placed in different modules by creating a new module or moving a responsibility to an existing module.</li>
</ul>
</li>
<li>减少耦合 Reduce Coupling: <ul>
<li><strong>封装</strong>为模块引入了显式<strong>接口</strong>，并减少了对一个模块的更改<strong>传播</strong>到其他模块的可能性<br>Encapsulation introduces an explicit interface to a module, and reduces the probability that a change to one module propagates to other modules.</li>
<li>使用<strong>中介</strong>打破<strong>依赖</strong>: 所有的组件都要通过中间的组件进行通信，使用反模式等方法解决<br>Use an intermediary breaks a dependency.</li>
<li>当两个模块受到相同更改的影响时，请进行<strong>重构</strong>: 不同于代码重构<br>Refactor when two modules are affected by the same change.</li>
</ul>
</li>
<li><strong>延迟绑定</strong>: 在生命周期的<strong>不同阶段</strong>绑定某些参数的值，而不是最初定义它们的阶段。<br>Defer binding: Binds the value of some parameters at a different phase in the life cycle than the one in which they are initially defined.</li>
</ul>
<h4 id="3-3-4-Checklist-for-Modifiability-Design-and-Analsis"><a href="#3-3-4-Checklist-for-Modifiability-Design-and-Analsis" class="headerlink" title="3.3.4 Checklist for Modifiability Design and Analsis"></a>3.3.4 Checklist for Modifiability Design and Analsis</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502181331259.png" alt="image-20230502181331259" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502181359531.png" alt="image-20230502181359531" style="zoom:80%;" /></p>
<h3 id="3-4-性能-Performance"><a href="#3-4-性能-Performance" class="headerlink" title="3.4 性能 Performance"></a>3.4 性能 Performance</h3><ul>
<li>性能是关于<strong>时间</strong>和软件系统满足时序要求的能力 (单位时间内能做多少事情)<br>Performance is about time and the software system’s ability to meet timing requirements. </li>
<li>所有系统都有性能要求，即使未明确表示也是如此<br>All systems have pertormance requirements, even it they are not explicitl y expressed.</li>
<li>响应时间的两个基本因素 Two basic contributors to the response time<ol>
<li>处理时间(系统<strong>正在</strong>响应时)<br>processing time (when the system is working to response)</li>
<li>阻塞时间(系统<strong>无法</strong>响应时)<br>blocked time (when the system is unable to response)</li>
</ol>
</li>
</ul>
<h4 id="3-4-1-性能的通用场景-Performance-General-Scenario"><a href="#3-4-1-性能的通用场景-Performance-General-Scenario" class="headerlink" title="3.4.1 性能的通用场景 Performance General Scenario"></a>3.4.1 性能的通用场景 Performance General Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502201358249.png" alt="image-20230502201358249" style="zoom:80%;" /></p>
<h4 id="3-4-2-性能的样本场景-Performance-Sample-Scenario"><a href="#3-4-2-性能的样本场景-Performance-Sample-Scenario" class="headerlink" title="3.4.2 性能的样本场景 Performance Sample Scenario"></a>3.4.2 性能的样本场景 Performance Sample Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502202540659.png" alt="image-20230502202540659" style="zoom:80%;" /></p>
<h4 id="3-4-3-性能的策略-Tactics-for-Performance"><a href="#3-4-3-性能的策略-Tactics-for-Performance" class="headerlink" title="3.4.3 性能的策略 Tactics for Performance"></a>3.4.3 性能的策略 Tactics for Performance</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502202644408.png" alt="image-20230502202644408" style="zoom:80%;" /></p>
<ul>
<li>在<strong>需求</strong>方面 On the demand side<ul>
<li>管理<strong>采样率</strong>(降低采样频率)<br>Manage sampling rate (reducing sampling frequency)</li>
<li>限制事件响应: 当离散事件到达系统的速度太快而无法处理时，必须将事件<strong>排队</strong>，直到可以处理它们为止<br>Limit event response: When discrete events arrive at the system too rapidly to be processed, the events must be queued until they can be processed.</li>
<li>如果不是所有事件都同样重要，则对事件进行<strong>优先级</strong>排序<br>Prioritize events if not all events are equally important.</li>
<li>通过使用<strong>中介</strong>来增加处理事件流的资源，从而减少开销<br>Reduce overhead by using intermediaries to increase the resources in processing an event stream</li>
</ul>
</li>
<li>在<strong>资源</strong>方面 On the resource side<ul>
<li>增加<strong>资源</strong>(更快的处理器，更多的内存，更快的网络…)<br>Increase resources(faster processor, additional memory, faster network…)</li>
<li>如果可以<strong>并行</strong>处理请求，请引入并发<br>Introduce concurrency if requests can be processed in parallel.</li>
<li>维护多个计算副本: 使用负载均衡器将新工作分配给可用的<strong>副本</strong>服务器之一<br>Maintain multiple copies of computations: Use load balancer to assign new work to one of the available duplicate servers.</li>
<li>维护数据的多个副本: Maintain multiple copies of data:<ul>
<li>缓存 caching</li>
<li>数据复制 data replication</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-4-Checklist-for-Performance-Design-and-Analysis"><a href="#3-4-4-Checklist-for-Performance-Design-and-Analysis" class="headerlink" title="3.4.4 Checklist for Performance Design and Analysis"></a>3.4.4 Checklist for Performance Design and Analysis</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502203334412.png" alt="image-20230502203334412" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502203358242.png" alt="image-20230502203358242" style="zoom:80%;" /></p>
<h3 id="3-5-安全性-Security"><a href="#3-5-安全性-Security" class="headerlink" title="3.5 安全性 Security"></a>3.5 安全性 Security</h3><ul>
<li><strong>安全性</strong>是衡量系统<strong>保护</strong>数据和信息免遭<strong>未授权访问</strong>的能力，同时仍提供对授权人员和系统的访问权限。<br>Security measures system’s ability to protect data and information from unauthorized access while still providing access to people and systems that are authorized.</li>
<li>安全性的三个特征 Three characteristics of security: (CIA)<ol>
<li>机密性：保护数据和服务免受<strong>未经授权的访问</strong>。<br>Confidentiality: Data and services are protected from unauthorized access.</li>
<li>完整性: 数据和服务不会受到<strong>未经授权</strong>的操纵<br>Integrity: Data and services are not subject to unauthorized manipulation.</li>
<li>可用性: 系统将可供<strong>合法使用</strong><br>Availability: The system will be available for legitimate use.</li>
</ol>
</li>
</ul>
<h4 id="3-5-1-安全性的通用场景-Security-General-Scenario"><a href="#3-5-1-安全性的通用场景-Security-General-Scenario" class="headerlink" title="3.5.1 安全性的通用场景 Security General Scenario"></a>3.5.1 安全性的通用场景 Security General Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502203735211.png" alt="image-20230502203735211" style="zoom:80%;" /></p>
<h4 id="3-5-2-安全性的样本场景-Security-Sample-Scenario"><a href="#3-5-2-安全性的样本场景-Security-Sample-Scenario" class="headerlink" title="3.5.2 安全性的样本场景 Security Sample Scenario"></a>3.5.2 安全性的样本场景 Security Sample Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502203808913.png" alt="image-20230502203808913"></p>
<h4 id="3-5-3-安全性的策略-Security-Tactics"><a href="#3-5-3-安全性的策略-Security-Tactics" class="headerlink" title="3.5.3 安全性的策略 Security Tactics"></a>3.5.3 安全性的策略 Security Tactics</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230502203843719.png" alt="image-20230502203843719" style="zoom:80%;" /></p>
<ul>
<li>通过将系统内的网络流量或服务请求模式与一组签名或已知模式进行比较来检测<strong>入侵</strong><br>Detect intrusion by comparing network traffic or service request patterns within a system to a set of signatures or known patterns.</li>
<li>检测服务<strong>拒绝</strong> Detect service denial</li>
<li>使用校验和或哈希值验证<strong>消息的完整性</strong><br>Verify message integrity using checksums or hash values.</li>
<li>识别参与者-系统的任何<strong>外部</strong>输入的<strong>来源</strong><br>Identify actors - source of any external input to the system.</li>
<li><strong>验证</strong>参与者或他们所声称的角色<br>Authenticate actors who or what they purport to be.</li>
<li><strong>授权</strong>有权访问和修改数据或服务的行为者<br>Authorize actors who have the rights to access and modify either data or services.</li>
<li><strong>限制</strong>对计算资源的<strong>访问</strong><br>Limit access to computing resouces.</li>
<li>通过最小化系统的攻击面来<strong>限制暴露</strong><br>Limit exposure by minimizing the attack surface of a system.</li>
<li><strong>加密</strong>数据。Encrypt data.</li>
<li>正在进行攻击时，撤消对<strong>敏感资源</strong>的访问<br>Revoke access to sensitive resources when an attack is underway.</li>
<li>Authenticate: 认证，Authorize: 授权。</li>
</ul>
<h4 id="3-5-4-安全性的检查列表-Checklist-for-Security-Design-and-Analysis"><a href="#3-5-4-安全性的检查列表-Checklist-for-Security-Design-and-Analysis" class="headerlink" title="3.5.4 安全性的检查列表 Checklist for Security Design and Analysis"></a>3.5.4 安全性的检查列表 Checklist for Security Design and Analysis</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503174500263.png" alt="image-20230503174500263" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503174533139.png" alt="image-20230503174533139" style="zoom:80%;" /></p>
<h3 id="3-6-可测试性-Testability"><a href="#3-6-可测试性-Testability" class="headerlink" title="3.6 可测试性 Testability"></a>3.6 可测试性 Testability</h3><ul>
<li>可测试性是指可以使软件通过(通常基于执行)测试来证明其错误的难易程度。<br>Testability refers to ease with which software can be made to demonstrate its faults through (stypically execution-based) testing.</li>
<li>为了使系统能够正确测试，必须有可能控制每个组件的输入，然后观察其输出。<br>For a system to be properly testable, it must be possible to control each component’s inputs and then to observe its outputs.</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503180645224.png" alt="image-20230503180645224"></p>
<h4 id="3-6-1-可测试性的通用场景-Testability-General-Scenario"><a href="#3-6-1-可测试性的通用场景-Testability-General-Scenario" class="headerlink" title="3.6.1 可测试性的通用场景 Testability General Scenario"></a>3.6.1 可测试性的通用场景 Testability General Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503180658761.png" alt="image-20230503180658761" style="zoom:80%;" /></p>
<h4 id="3-6-2-可测试性的样本场景-Testability-Sample-Scenario"><a href="#3-6-2-可测试性的样本场景-Testability-Sample-Scenario" class="headerlink" title="3.6.2 可测试性的样本场景 Testability Sample Scenario"></a>3.6.2 可测试性的样本场景 Testability Sample Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503180914829.png" alt="image-20230503180914829"></p>
<h4 id="3-6-3-可测试性的策略-Testability-Tactcs"><a href="#3-6-3-可测试性的策略-Testability-Tactcs" class="headerlink" title="3.6.3 可测试性的策略 Testability Tactcs"></a>3.6.3 可测试性的策略 Testability Tactcs</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503180953929.png" alt="image-20230503180953929" style="zoom:80%;" /></p>
<ul>
<li><strong>控制和观察系统状态</strong>: 维护某种状态信息，允许测试人员为该状态信息分配一个值，和/或使测试人员可以按需访问该信息。<br>Control and observe system state: Maintain some sort of state information, allow testers to assign a value to that state information, and/or make that information accessible to testers on demand.<ul>
<li><strong>专用接口</strong>使您可以控制或捕获组件的值<br>Specialized interfaces allow you to control or capture values for a component.</li>
<li><strong>记录/回放</strong>导致故障的状态，然后复现故障<br>Record/playback the state that caused a fault and re-create the fault.</li>
<li><strong>沙盒</strong>将系统的实例与现实世界隔离开来，可以进行实验以消除其后果<br>Sandboxing isolates an instance of the system from the real world to enable experimentation to undo its consequences.</li>
</ul>
</li>
<li><strong>限制复杂度</strong>: 复杂的软件更难测试，因为它的操作状态空间很大，并且在大状态空间中重新创建精确状态更加困难。<br>Limit complexity: Complex software is harder to test, because its operating state space is very large and more difficult to re-create an exact state in a large state space.<ul>
<li>限制结构的<strong>复杂性</strong>，避免、减少或解决组件之间的<strong>依赖</strong>关系；隔离和封装对外部环境的依赖关系。<br>Limit structural complexity avoiding, reducing or resolving dependencies between components; isolating and encapsulating dependencies on external environment.<ul>
<li>限制一个类派生自的类的数量<br>Limit the number of classes from which a class is derived.</li>
<li>限制继承<strong>树的深度</strong>和类的孩子数量<br>Limit the depth of the inheritance tree and the number of children of a class.</li>
<li>限制<strong>多态</strong>和<strong>动态调用</strong> Limit polymorphism and dynamic calls.</li>
</ul>
</li>
<li>限制<strong>不确定性</strong>-限制<strong>行为复杂性</strong> Limit nondeterminism - limiting behavioral complexity.<ul>
<li>非确定性系统更难测试。Nondeterminism systems are harder to test.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-6-4-可测试性的检查列表-Checklist-for-Testability-Design-and-Analysis"><a href="#3-6-4-可测试性的检查列表-Checklist-for-Testability-Design-and-Analysis" class="headerlink" title="3.6.4 可测试性的检查列表 Checklist for Testability Design and Analysis"></a>3.6.4 可测试性的检查列表 Checklist for Testability Design and Analysis</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503182000928.png" alt="image-20230503182000928" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503182027715.png" alt="image-20230503182027715" style="zoom:80%;" /></p>
<h3 id="3-7-易用性-Usability"><a href="#3-7-易用性-Usability" class="headerlink" title="3.7 易用性 Usability"></a>3.7 易用性 Usability</h3><ul>
<li>易用性与用户完成所需任务的<strong>难易程度</strong>以及系统提供的用户<strong>支持</strong>的类型有关。<br>Usability is concerned with h how easy it is for the user to accomplish a desired task and the kind of user support the system provides.</li>
<li>易用性包括以下几个方面: Usability comprises the following aspects:<ul>
<li><strong>学习</strong>系统功能 Learning system features</li>
<li><strong>高效</strong>使用系统 Using a system efficiently</li>
<li>最小化<strong>错误的影响</strong> Minimizing the impact of errors</li>
<li>使系统<strong>适应</strong>用户需求 Adapting the system to user’s needs</li>
<li>增强信心和<strong>满意度</strong> Increasing confidence and satistaction</li>
</ul>
</li>
</ul>
<h4 id="3-7-1-易用性的通用场景-Usability-General-Scenario"><a href="#3-7-1-易用性的通用场景-Usability-General-Scenario" class="headerlink" title="3.7.1 易用性的通用场景 Usability General Scenario"></a>3.7.1 易用性的通用场景 Usability General Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503193042483.png" alt="image-20230503193042483" style="zoom:80%;" /></p>
<h4 id="3-7-2-易用性的样本场景-Usbility-Sample-Scenario"><a href="#3-7-2-易用性的样本场景-Usbility-Sample-Scenario" class="headerlink" title="3.7.2 易用性的样本场景 Usbility Sample Scenario"></a>3.7.2 易用性的样本场景 Usbility Sample Scenario</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503193105081.png" alt="image-20230503193105081" style="zoom:80%;" /></p>
<h4 id="3-7-3-易用性的策略-Usability-Tactics"><a href="#3-7-3-易用性的策略-Usability-Tactics" class="headerlink" title="3.7.3 易用性的策略 Usability Tactics"></a>3.7.3 易用性的策略 Usability Tactics</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503193129199.png" alt="image-20230503193129199" style="zoom:80%;" /></p>
<ul>
<li>支持<strong>用户主动性</strong>: 支持用户纠正错误或提高效率。<br>Support user initiative: support the user in either correcting errors or being more efficient.<ul>
<li><strong>取消</strong> Cancel</li>
<li><strong>撤消</strong>: 系统必须维持足够数量的系统状态，以便可以恢复更早的状态<br>Undo: System must maintain a sufficient amount of system state so that an earlier state may be restored.</li>
<li>用户启动长时间运行的操作时<strong>暂停/恢复</strong><br>Pause/resume when a user has initiated a long-running operation</li>
<li>将较低级别的对象<strong>聚合</strong>到一个<strong>组</strong>中，以便可以将操作应用于该组<br>Aggregate the lower-level objects into a single group, so that the operation may be applied to the group.</li>
</ul>
</li>
<li>支持<strong>系统主动性</strong>: 确定系统用来预测其自身行为或用户意图的模型。<br>Support system initiative: Identify the models the system uses to predict either its own behavior or the user’s intention.<ul>
<li>维护<strong>任务模型</strong>: 确定<strong>上下文</strong>，以便系统可以了解用户正在尝试的内容并提供帮助<br>Maintain task model: Determine context so the system can have some idea of what the user is attempting and provide assistance.</li>
<li>维护<strong>用户模型</strong>: 代表用户的关于<strong>系统的知识</strong>，根据用户行为训练出用户的模型<br>Maintain user model: Represent the user’s knowledge of system.</li>
<li>维护<strong>系统模型</strong>: 确定预期的<strong>系统行为</strong>，以便可以向用户提供适当的反馈<br>Maintain system model: Determine expected system behavior so that appropriate feedback can be given to the user.</li>
</ul>
</li>
</ul>
<h4 id="3-7-4-Checklist-for-Usbility-Design-and-Analysis"><a href="#3-7-4-Checklist-for-Usbility-Design-and-Analysis" class="headerlink" title="3.7.4 Checklist for Usbility Design and Analysis"></a>3.7.4 Checklist for Usbility Design and Analysis</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503193849811.png" alt="image-20230503193849811" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503193906777.png" alt="image-20230503193906777" style="zoom:80%;" /></p>
<h3 id="3-8-更多的能力-X-ability"><a href="#3-8-更多的能力-X-ability" class="headerlink" title="3.8 更多的能力 X-ability"></a>3.8 更多的能力 X-ability</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230503194537890.png" alt="image-20230503194537890" style="zoom:80%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-5-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E3%80%81POP%E3%80%81MVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-5-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E3%80%81POP%E3%80%81MVC/" class="post-title-link" itemprop="url">软件系统设计-设计(5) 表驱动、POP、MVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-30 17:50:37" itemprop="dateCreated datePublished" datetime="2023-04-30T17:50:37+08:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-19 00:15:38" itemprop="dateModified" datetime="2023-08-19T00:15:38+08:00">2023-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">软件系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-表驱动"><a href="#1-表驱动" class="headerlink" title="1. 表驱动"></a>1. 表驱动</h2><ol>
<li>表驱动法是一种编程模式(scheme)：从表里面查找信息而不使用逻辑语句(if和case)</li>
<li>表驱动法适用于复杂的逻辑</li>
<li>表驱动法的另一个好处是可以将复杂逻辑从代码中独立出来，以便于单独维护</li>
</ol>
<h3 id="1-1-表驱动示例"><a href="#1-1-表驱动示例" class="headerlink" title="1.1 表驱动示例"></a>1.1 表驱动示例</h3><ol>
<li>Java示例：使用复杂的逻辑对字符分类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (((<span class="hljs-string">&#x27;a&#x27;</span> &lt;= inputChar) &amp;&amp; (inputChar &lt;= <span class="hljs-string">&#x27;z&#x27;</span>))||<br>  ((<span class="hljs-string">&#x27;A&#x27;</span> &lt;= inputChar) &amp;&amp; (inputChar &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>))) &#123;<br>    charType = CharacterType.Letter;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((inputChar==<span class="hljs-string">&#x27; &#x27;</span>)||(inputChar==<span class="hljs-string">&#x27;,&#x27;</span>)||<br>  (inputChar == <span class="hljs-string">&#x27;.&#x27;</span>)||(inputChar == <span class="hljs-string">&#x27;!&#x27;</span>)||<br>  (inputChar == <span class="hljs-string">&#x27;(&#x27;</span>)||(inputChar == <span class="hljs-string">&#x27;)&#x27;</span>)||<br>  (inputChar == <span class="hljs-string">&#x27;:&#x27;</span>)||(inputChar == <span class="hljs-string">&#x27;;&#x27;</span>)||<br>  (inputChar == <span class="hljs-string">&#x27;?&#x27;</span>)||(inputChar == <span class="hljs-string">&#x27;-&#x27;</span>))&#123;<br>    charType = CharacterType.Punctuation;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-string">&#x27;0&#x27;</span> &lt;= inputChar)&amp;&amp;(inputChar &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)) &#123;<br>    charType = CharacterType.Digit;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>构造一个查询表：把每一个字符的类型保存在一个字符编码访问的数组</li>
<li>Java示例：使用查询表对字符分类<code>chartype = charTypeTable[inputChar];</code></li>
</ol>
<h3 id="1-2-使用表驱动法的两个问题"><a href="#1-2-使用表驱动法的两个问题" class="headerlink" title="1.2 使用表驱动法的两个问题"></a>1.2 使用表驱动法的两个问题</h3><ol>
<li>在表里存放什么信息：主要存放的是数据，但在一些特殊情况下也存放动作</li>
<li>如何快速从表中查询条目<ol>
<li>直接访问(Direct access)</li>
<li>索引访问(Indexed access)</li>
<li>阶梯访问(Stair-step access)：连续性条件方法</li>
</ol>
</li>
</ol>
<h3 id="1-3-直接访问表"><a href="#1-3-直接访问表" class="headerlink" title="1.3 直接访问表"></a>1.3 直接访问表</h3><p>所谓”直接访问”是指通过索引值(如下标)可以直接从表中找到对应的条目</p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-comment">&#x27;VB示例：确定各月天数的笨拙做法</span><br><span class="hljs-keyword">If</span> (month = <span class="hljs-number">1</span>) <span class="hljs-keyword">Then</span><br>  days = <span class="hljs-number">31</span><br><span class="hljs-keyword">ElseIf</span> (month = <span class="hljs-number">2</span>) <span class="hljs-keyword">Then</span><br>  days = <span class="hljs-number">28</span><br><span class="hljs-keyword">ElseIf</span> (month = <span class="hljs-number">3</span>) <span class="hljs-keyword">Then</span><br>  days = <span class="hljs-number">31</span><br>...<br><span class="hljs-keyword">ElseIf</span> (month = <span class="hljs-number">11</span>) <span class="hljs-keyword">Then</span><br>  days = <span class="hljs-number">30</span><br><span class="hljs-keyword">ElseIf</span> (month = <span class="hljs-number">12</span>) <span class="hljs-keyword">Then</span><br>  days = <span class="hljs-number">31</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br><br><span class="hljs-comment">&#x27; 你需要首先创建出这张表用来存放各个月份的天数</span><br><span class="hljs-comment">&#x27; VB示例：确定各月天数的优雅做法</span><br><span class="hljs-keyword">Dim</span> daysPerMonth() <span class="hljs-keyword">As</span> <span class="hljs-type">Integer</span> = _<br>&#123;<span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;<br>days = daysPerMonth(month-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<h3 id="1-4-索引访问表"><a href="#1-4-索引访问表" class="headerlink" title="1.4 索引访问表"></a>1.4 索引访问表</h3><ol>
<li>当无法直接从表中查询需要的条目时，就需要借助其他办法先获取<strong>表键值</strong></li>
<li>索引访问的方法<ol>
<li>就是先用一个<strong>基本类型</strong>的数据从一张<strong>索引表</strong>中查出一个<strong>键值</strong>，然后再用这一键值查出你感兴趣的<strong>主数据</strong></li>
</ol>
</li>
<li>索引表是一种间接访问的技术</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li>假设你经营着一家商店，有大约 100 种商品。再假设每种商品都有一个 4 位数字的物品编号， 其范围是 0000 到 9999<ol>
<li>如果你想用这个编号作为键值直接查询一张描述商品信息的表，那么就要生成一个具有 10000 条记录的访问表</li>
</ol>
</li>
<li>利用索引表<ol>
<li>如果用这个编号作为键值直接查询一张描述商品信息的表，那么就生成一个具有 10000 条记录的索引数组(从0到9999)</li>
<li>该数组中除了与你商店中的货物的标志相对应的100条记录以外，其余记录都是空的索引</li>
</ol>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612121102830.png" alt="image-20230612121102830" style="zoom:80%;" /></p>
<h4 id="索引访问技术的主要优点："><a href="#索引访问技术的主要优点：" class="headerlink" title="索引访问技术的主要优点："></a>索引访问技术的主要优点：</h4><ol>
<li>如果主查询表中的每一条记录都很大，那么索引数组就可以节省很多空间<ol>
<li>一般而言索引表中的每条记录需要占用2 ~ 4字节</li>
</ol>
</li>
<li>即使你用了索引以后没有节省内存空间， 操作位于索引中的记录有时也要比操作位于主表中的记录更方便更廉价</li>
<li>编写到表里面的数据比嵌入代码中的数据更容易维护</li>
</ol>
<h3 id="1-5-阶梯访问表"><a href="#1-5-阶梯访问表" class="headerlink" title="1.5 阶梯访问表"></a>1.5 阶梯访问表</h3><ol>
<li><p>阶梯访问方法不像索引结构那样直接，但是它要比索引访问方法节省空间</p>
</li>
<li><p>阶梯结构的基本想法</p>
<ol>
<li>通过确定每项命中的阶梯层次确定其归类</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612121404381.png" alt="image-20230612121404381" style="zoom:80%;" /></p>
</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>如果你正在开发一个等级评定的应用程序，按照如下等级区间对分数定级</p>
<ol>
<li>你不能用简单的数据转换函数来把表键值转换为 A 至 F 字母所代表的等级</li>
<li>用索引也不合适，因为这里用的是浮点数</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec11/6.png" alt=""></p>
<p>使用阶梯方法</p>
<ol>
<li>把每一区间的上限写入一张表里， 然后写一个循环，按照各区间的上限来检查分数<ol>
<li>当分数第一次超过某个区间的上限时， 你就知道相应的等级了</li>
<li>区间表：{ 50.0, 65.0, 75.0, 90.0, 100.0 }</li>
</ol>
</li>
<li>Visual Basic示例：阶梯表查询</li>
</ol>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-comment">&#x27; set up data for grading table</span><br><span class="hljs-keyword">Dim</span> rangeLimit() <span class="hljs-keyword">As</span> <span class="hljs-type">Double</span> = &#123; <span class="hljs-number">50.0</span>, <span class="hljs-number">65.0</span>, <span class="hljs-number">75.0</span>, <span class="hljs-number">90.0</span>, <span class="hljs-number">100.0</span> &#125;<br><span class="hljs-keyword">Dim</span> grade() <span class="hljs-keyword">As</span> <span class="hljs-type">String</span> = &#123; <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span> &#125;<br>maxGradeLevel = grade.Length - <span class="hljs-number">1</span><br>...<br><span class="hljs-comment">&#x27; assign a grade to a student based on the student&#x27;s score</span><br>gradeLevel = <span class="hljs-number">0</span><br>studentGrade = <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-keyword">While</span> ( gradeLevel &lt; maxGradeLevel )<br>  <span class="hljs-keyword">If</span> ( studentScore &lt; rangeLimit( gradeLevel ) ) <span class="hljs-keyword">Then</span><br>    studentGrade = grade( gradeLevel )<br>  <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br>  gradeLevel = gradeLevel + <span class="hljs-number">1</span><br>Wend<br></code></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>注意端点</li>
<li>二分查找取代顺序查找</li>
</ol>
<h2 id="2-Patterns-of-Patterns"><a href="#2-Patterns-of-Patterns" class="headerlink" title="2. Patterns of Patterns"></a>2. Patterns of Patterns</h2><h3 id="2-1-Working-together"><a href="#2-1-Working-together" class="headerlink" title="2.1 Working together"></a>2.1 Working together</h3><p>使用模式的最佳方式之一是让他们走出家门，这样他们就可以与其他模式互动。 你使用模式越多，你就会越多地看到它们一起出现在你的设计中。对于在设计中协同工作的一组模式，可以应用于许多问题，我们有一个特殊的名称：复合模式（Compound Pattern）。没错，我们现在说的是模式的模式！</p>
<ul>
<li>模式经常一起使用，并结合在同一个设计解决方案中。</li>
<li>复合模式将两个或多个模式组合成解决重复出现或一般问题的解决方案。</li>
</ul>
<h3 id="2-2-Duck-reunion"><a href="#2-2-Duck-reunion" class="headerlink" title="2.2 Duck reunion"></a>2.2 Duck reunion</h3><ol>
<li>实现 Quackable 接口</li>
<li>a Goose class：需要被 simulation 使用，使用适配器模式</li>
<li>统计鸭叫的次数（要求不能修改原有的代码）：装饰器模式(不改变原本代码，而增加功能，装饰者接口与被装饰者接口一致)<ol>
<li>装饰者两个缺点：设计上的缺点(注意)</li>
<li>用户仍然可以创建非计数鸭：抽象工厂(所有的行为要么都被观测，要么不被观察)<ol>
<li>抽象工厂、抽象产品</li>
<li>具体工厂：计数工厂与不计数工厂</li>
</ol>
</li>
<li>Counting Duck Factory<ol>
<li>产品都是装饰者鸭</li>
</ol>
</li>
</ol>
</li>
<li>不同的鸭群要分开管理：<ol>
<li>想要在一群鸭子上执行操作：组合模式</li>
<li>只是监听(中介者模式)</li>
<li>实现对组合的整体操作，遍历时可以结合迭代器模式</li>
</ol>
</li>
<li>实时跟踪每一个鸭子的叫的行为：观察者模式<ol>
<li>创建 Observable 类实现 QuackObservable 接口，以组合的方式使得鸭子 Observable</li>
</ol>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612124127944.png" alt="image-20230612124127944"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612124102324.png" alt="image-20230612124102324"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-MVC"><a href="#3-MVC" class="headerlink" title="3. MVC"></a>3. MVC</h2><p>使用模式：策略、组合、观察者</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612153531402.png" alt="image-20230612153531402"></p>
<p><strong>策略模式</strong></p>
<p>视图和控制器实现了经典的策略模式：视图是一个配置了策略的对象。控制器提供策略。视图只关心应用程序的视觉方面，并将有关界面行为的任何决定委托给控制器。使用策略模式还可以使视图与模型分离，因为它是负责与模型交互以执行用户请求的控制器。视图对这是如何完成的一无所知。</p>
<p><strong>观察者模式</strong></p>
<p>模型实现了观察者模式，以便在状态发生变化时保持感兴趣的对象更新。使用观察者模式可以使模型完全独立于视图和控制器。它允许我们对同一个模型使用不同的视图，甚至一次使用多个视图。</p>
<p><strong>组合模式</strong></p>
<p>显示由一组嵌套的窗口、面板、按钮、文本标签等组成。每个显示组件都是一个组合（如窗口）或叶子（如按钮）。当控制器告诉视图更新时，它只需要告诉顶视图组件，Composite 会处理剩下的事情。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-4-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-4-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">软件系统设计-设计(4) 行为型模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-30 16:32:20" itemprop="dateCreated datePublished" datetime="2023-04-30T16:32:20+08:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-19 00:15:38" itemprop="dateModified" datetime="2023-08-19T00:15:38+08:00">2023-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">软件系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-模板方法模式-类"><a href="#1-模板方法模式-类" class="headerlink" title="1. 模板方法模式(类)"></a>1. 模板方法模式(类)</h2><h3 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1 模式动机"></a>1.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612093800218.png" alt="image-20230612093800218" style="zoom:80%;" /></p>
<ol>
<li>模板方法模式是<strong>基于继承</strong>的代码复用基本技术，模板方法模式的结构和用法也是面向对象设计的核心之一。在模板方法模式中，可以<strong>将相同的代码放在父类中，而将不同的方法实现放在不同的子类中</strong>。</li>
<li>在模板方法模式中，我们需要准备一个抽象类，<strong>将部分逻辑以具体方法以及具体构造函数的形式实现</strong>，<strong>然后声明一些抽象方法来让子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现</strong>，这就是模板方法模式的用意。模板方法模式体现了面向对象的诸多重要思想，是一种使用频率较高的模式。</li>
</ol>
<h3 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2 模式定义"></a>1.2 模式定义</h3><ol>
<li>模板方法模式(Template Method Pattern)：定义一个操作中<strong>算法的骨架</strong>，而将一些步骤<strong>延迟到子类</strong>中，模板方法使得子类<strong>可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。模板方法是一种<strong>类行为型</strong>模式。</li>
<li>Template Method Pattern: Define <strong>the skeleton of an algorithm</strong> in an operation, <strong>deferring some steps to subclasses</strong>. Template Method <strong>lets subclasses redefine certain steps</strong> of an algorithm <strong>without changing the algorithm’s structure</strong>.</li>
</ol>
<h3 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3 模式结构"></a>1.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612094432867.png" alt="image-20230612094432867" style="zoom:80%;" /></p>
<p>模板方法模式包含如下角色：</p>
<ol>
<li>AbstractClass: 抽象类</li>
<li>ConcreteClass: 具体子类</li>
</ol>
<h3 id="1-4-模式分析"><a href="#1-4-模式分析" class="headerlink" title="1.4 模式分析"></a>1.4 模式分析</h3><ol>
<li>模板方法模式是一种类的行为型模式，在它的结构图中<strong>只有类之间的继承关系，没有对象关联关系</strong>。</li>
<li>在模板方法模式的使用过程中，要求开发抽象类和开发具体子类的设计师之间进行协作。一个设计师负责给出<strong>一个算法的轮廓和骨架</strong>，另一些设计师则<strong>负责给出这个算法的各个逻辑步骤</strong>。实现这些具体逻辑步骤的方法称为<strong>基本方法(Primitive Method)</strong>，而将这些基本法方法汇总起来的方法称为<strong>模板方法(Template Method)</strong>，模板方法模式的名字从此而来。</li>
<li>模板方法：一个模板方法是<strong>定义在抽象类中的、把基本操作方法组合在一起</strong>形成一个总算法或一个总行为的方法。</li>
<li>基本方法：基本方法是<strong>实现算法各个步骤的方法</strong>，是模板方法的组成部分。<ol>
<li>抽象方法(Abstract Method)</li>
<li>具体方法(Concrete Method)</li>
<li>钩子方法(Hook Method)：“挂钩”方法和空方法</li>
</ol>
</li>
<li>钩子方法(Hook Method)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">template</span><span class="hljs-params">()</span>&#123;<br>   open();<br>   display();<br>   <span class="hljs-keyword">if</span>(isPrint())&#123;<br>      print();<br>   &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrint</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>典型的抽象类代码如下所示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span>&#123;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//模板方法</span><br>      	primitiveOperation1();<br>      	primitiveOperation2();<br>      	primitiveOperation3();<br>   	&#125;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation1</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//基本方法—具体方法</span><br>   		<span class="hljs-comment">//实现代码</span><br>   	&#125;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//基本方法—抽象方法</span><br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation3</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-comment">//基本方法—钩子方法</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>典型的具体子类代码如下所示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//实现代码</span><br>    &#125;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation3</span><span class="hljs-params">()</span> &#123;<br>   		<span class="hljs-comment">//实现代码, 覆盖空方法</span><br>   	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，<strong>具体子类的基本方法将覆盖父类中定义的基本方法，子类的钩子方法也将覆盖父类的钩子方法</strong>，从而可以<strong>通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制</strong>。</li>
</ol>
<h3 id="1-5-模板方法模式实例与解析"><a href="#1-5-模板方法模式实例与解析" class="headerlink" title="1.5 模板方法模式实例与解析"></a>1.5 模板方法模式实例与解析</h3><p>实例一：银行业务办理流程</p>
<p>在银行办理业务时，一般都包含几个基本步骤，首先需要取号排队，然后办理具体业务，最后需要对银行工作人员进行评分。无论具体业务是取款、存款还是转账，其基本流程都一样。现使用模板方法模式模拟银行业务办理流程。模板方法模式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612094805890.png" alt="image-20230612094805890" style="zoom:80%;" /></p>
<p>实例二：数据库操作模板</p>
<p>对数据库的操作一般包括连接、打开、使用、关闭等步骤，在数据库操作模板类中我们定义了<code>connDB()</code>、<code>openDB()</code>、<code>useDB()</code>、<code>closeDB()</code> 四个方法分别对应这四个步骤。对于不同类型的数据库（如SQL Server和Oracle），其操作步骤都一致，只是连接数据库 <code>connDB()</code> 方法有所区别，现使用模板方法模式对其进行设计。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612094835824.png" alt="image-20230612094835824" style="zoom:80%;" /></p>
<h3 id="1-6-模式优缺点"><a href="#1-6-模式优缺点" class="headerlink" title="1.6 模式优缺点"></a>1.6 模式优缺点</h3><p>模板方法模式的<strong>优点</strong></p>
<ol>
<li>模板方法模式<strong>在一个类中抽象地定义算法</strong>，而<strong>由它的子类实现细节的处理</strong>。</li>
<li>模板方法模式是一种<strong>代码复用的基本技术</strong>。</li>
<li>模板方法模式导致一种<strong>反向的控制结构</strong>，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，<strong>符合“开闭原则”</strong>。</li>
</ol>
<p>模板方法模式的<strong>缺点</strong></p>
<ol>
<li>每个不同的实现都需要定义一个子类，这会<strong>导致类的个数增加</strong>，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。</li>
</ol>
<h3 id="1-7-模式适用环境"><a href="#1-7-模式适用环境" class="headerlink" title="1.7 模式适用环境"></a>1.7 模式适用环境</h3><p>在以下情况下可以使用模板方法模式：</p>
<ol>
<li>一次性实现一个算法的不变的部分，并<strong>将可变的行为留给子类来实现</strong>。</li>
<li><strong>各子类中公共的行为应被提取出来并集中到一个公共父类</strong>中以避免代码重复。</li>
<li><strong>对一些复杂的算法进行分割</strong>，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。</li>
<li>控制<strong>子类的扩展</strong>。</li>
</ol>
<h3 id="1-8-模式应用"><a href="#1-8-模式应用" class="headerlink" title="1.8 模式应用"></a>1.8 模式应用</h3><ol>
<li>模板方法模式广泛应用于框架设计（如Spring，Struts等）中，<strong>以确保父类控制处理流程的逻辑顺序</strong>（如框架的初始化）。</li>
<li>Java单元测试工具JUnit中的TestCase类的设计：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runBare</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>   setUp();<br>   <span class="hljs-keyword">try</span> &#123;<br>      runTest();<br>   &#125;<br>   <span class="hljs-keyword">finally</span> &#123;<br>      tearDown();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-9-模式扩展"><a href="#1-9-模式扩展" class="headerlink" title="1.9 模式扩展"></a>1.9 模式扩展</h3><h4 id="关于继承的讨论"><a href="#关于继承的讨论" class="headerlink" title="关于继承的讨论"></a>关于继承的讨论</h4><ol>
<li>模板方法模式鼓励我们<strong>恰当使用继承</strong>，此模式可以用来改写一些拥有相同功能的相关类，<strong>将可复用的一般性的行为代码移到父类里面</strong>，而将特殊化的行为代码移到子类里面。这也进一步说明，虽然继承复用存在一些问题，但是在某些情况下还是可以给开发人员带来方便，<strong>模板方法模式就是体现继承优势的模式之一</strong>。</li>
</ol>
<h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><ol>
<li>在模板方法模式中，子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，<strong>父类控制对子类的调用</strong>，这种机制被称为<strong>好莱坞原则</strong>(Hollywood Principle)，好莱坞原则的定义为：“<strong>不要给我们打电话，我们会给你打电话(Don‘t call us, we’ll call you)</strong>”。</li>
<li>在模板方法模式中，好莱坞原则体现在：<strong>子类不需要调用父类，而通过父类来调用子类，将某些步骤的实现写在子类中，由父类来控制整个过程</strong>。</li>
</ol>
<h4 id="钩子方法的使用"><a href="#钩子方法的使用" class="headerlink" title="钩子方法的使用"></a>钩子方法的使用</h4><ol>
<li>钩子方法的引入使得子类可以控制父类的行为。</li>
<li>最简单的钩子方法就是<strong>空方法</strong>，也<strong>可以在钩子方法中定义一个默认的实现</strong>，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</li>
<li>比较复杂一点的钩子方法<strong>可以对其他方法进行约束</strong>，这种钩子方法通常返回一个boolean类型，即返回true或false，用来判断是否执行某一个基本方法。</li>
</ol>
<h3 id="1-10-小结"><a href="#1-10-小结" class="headerlink" title="1.10 小结"></a>1.10 小结</h3><ol>
<li>在模板方法模式中，定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。</li>
<li>模板方法模式包含两个角色<ol>
<li>在抽象类中定义一系列基本操作，这些基本操作可以是具体的，也可以是抽象的，同时，在抽象类中实现了一个模板方法，用于定义一个算法的骨架</li>
<li>具体子类是抽象类的子类，用于实现在父类中定义的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中实现的具体基本操作。</li>
</ol>
</li>
<li>在模板方法模式中，方法可以分为模板方法和基本方法，其中基本方法又可以分为抽象方法、具体方法和钩子方法，钩子方法根据其特点又分为空方法和与实现算法步骤的基本方法“挂钩”的方法。</li>
<li>模板方法模式<ol>
<li>优点在于在子类定义详细的处理算法时不会改变算法的结构，实现了代码的复用，通过对子类的扩展可以增加新的行为，符合“开闭原则”</li>
<li>其缺点在于需要为每个不同的实现都定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</li>
</ol>
</li>
<li>模板方法模式适用情况包括<ol>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复</li>
<li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法，而一些可以改变的细节由其子类来实现</li>
<li>通过模板方法模式还可以控制子类的扩展。</li>
</ol>
</li>
</ol>
<h2 id="2-命令模式-对象"><a href="#2-命令模式-对象" class="headerlink" title="2. 命令模式(对象)"></a>2. 命令模式(对象)</h2><h3 id="2-1-模式动机"><a href="#2-1-模式动机" class="headerlink" title="2.1 模式动机"></a>2.1 模式动机</h3><p>命令模式可以<strong>对发送者和接收者完全解耦</strong>，发送者与接收者之间<strong>没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</strong>。这就是命令模式的模式动机。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314112052652.png" alt="image-20230314112052652" style="zoom:80%;" /></p>
<h3 id="2-2-模式定义"><a href="#2-2-模式定义" class="headerlink" title="2.2 模式定义"></a>2.2 模式定义</h3><p>命令模式(Command Pattern)：<strong>将一个请求封装为一个对象</strong>，从而使我们可用<strong>不同的请求对客户进行参数化</strong>；<strong>对请求排队或者记录请求日志，以及支持可撤销的操作</strong>。命令模式是一种<strong>对象行为型模式</strong>，其别名为动作(Action)模式或事务(Transaction)模式。</p>
<p>Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p>
<h3 id="2-3-模式结构"><a href="#2-3-模式结构" class="headerlink" title="2.3 模式结构"></a>2.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314112241809.png" alt="image-20230314112241809" style="zoom:80%;" /></p>
<p>命令模式包含如下角色：</p>
<ol>
<li>Command: 抽象命令类</li>
<li>ConcreteCommand: 具体命令类</li>
<li>Invoker: 调用者</li>
<li>Receiver: 接收者</li>
<li>Client:客户类</li>
</ol>
<h3 id="2-4-模式分析"><a href="#2-4-模式分析" class="headerlink" title="2.4 模式分析"></a>2.4 模式分析</h3><ol>
<li>命令模式的本质是<strong>对命令进行封装</strong>，<strong>将发出命令的责任和执行命令的责任分割开</strong>。</li>
<li>每一个命令都是一个操作：<strong>请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作</strong>。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，<strong>使得请求的一方不必知道接收请求的一方的接口</strong>，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
<li>命令模式<strong>使请求本身成为一个对象</strong>，这个对象和其他对象一样可以被存储和传递。</li>
<li>命令模式的关键在于<strong>引入了抽象命令接口</strong>，且<strong>发送者针对抽象命令接口编程</strong>，只有实现了抽象命令接口的<strong>具体命令才能与接收者相关联</strong>。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314114539376.png" alt="image-20230314114539376" style="zoom:80%;" /></p>
<p>典型的抽象命令类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的调用者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span>&#123;<br>  <span class="hljs-keyword">private</span> Command command;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Invoker</span><span class="hljs-params">(Command command)</span>&#123;<br>    <span class="hljs-built_in">this</span>.command=command;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span>&#123;<br>    <span class="hljs-built_in">this</span>.command=command;<br>  &#125;<br>  <span class="hljs-comment">//业务方法，用于调用命令类的方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>    command.execute();<br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>典型的具体命令类代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>  <span class="hljs-keyword">private</span> Receiver receiver;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>    receiver.action();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的请求接收者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//具体操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-5-命令模式实例与解析"><a href="#2-5-命令模式实例与解析" class="headerlink" title="2.5 命令模式实例与解析"></a>2.5 命令模式实例与解析</h3><p><strong>电视机遥控器</strong></p>
<p>电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。显然，电视机遥控器就是一个典型的命令模式应用实例。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314114828230.png" alt="image-20230314114828230" style="zoom:80%;" /></p>
<p><strong>功能键设置</strong></p>
<p>为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，如功能键 FunctionButton 可以用于退出系统(SystemExitClass)，也可以用于打开帮助界面 (DisplayHelpClass)。用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，相同的功能键可以对应不同的功能。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314115051773.png" alt="image-20230314115051773" style="zoom:80%;" /></p>
<h3 id="2-6-模式优缺点"><a href="#2-6-模式优缺点" class="headerlink" title="2.6 模式优缺点"></a>2.6 模式优缺点</h3><p>命令模式的优点</p>
<ol>
<li>降低系统的耦合度。</li>
<li>新的命令可以很容易地加入到系统中。</li>
<li>可以比较容易地设计一个命令队列和宏命令(组合命令)。</li>
<li><strong>可以方便地实现对请求的Undo和Redo</strong>。</li>
</ol>
<p>命令模式的缺点</p>
<ol>
<li>使用命令模式可能会<strong>导致某些系统有过多的具体命令类</strong>。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用</li>
</ol>
<h3 id="2-7-模式适用环境"><a href="#2-7-模式适用环境" class="headerlink" title="2.7 模式适用环境"></a>2.7 模式适用环境</h3><ol>
<li>系统<strong>需要将请求调用者和请求接收者解耦</strong>，使得调用者和接收者不直接交互。</li>
<li>系统<strong>需要在不同的时间指定请求、将请求排队和执行请求</strong>。</li>
<li>系统<strong>需要支持命令的撤销(Undo)操作和恢复(Redo)操作</strong>。</li>
<li>系统<strong>需要将一组操作组合在一起</strong>，即支持宏命令。</li>
</ol>
<h3 id="2-8-模式应用"><a href="#2-8-模式应用" class="headerlink" title="2.8 模式应用"></a>2.8 模式应用</h3><p>Java语言使用命令模式实现AWT/Swing GUI的<strong>委派事件模型 (Delegation Event Model, DEM)</strong>。</p>
<ul>
<li>在AWT/Swing中，Frame、Button等<strong>界面组件</strong>是<strong>请求发送者</strong>，而AWT提供的<strong>事件监听器接口和事件适配器类</strong>是<strong>抽象命令接口</strong>，<strong>用户可以自己</strong>写抽象命令接口的子类来实现事件处理，即实现<strong>具体命令类</strong>，而在具体命令类中可以调用业务处理方法来实现该事件的处理。对于界面组件而言，只需要了解命令接口即可，无须关心接口的实现，组件类并不关心实际操作，而操作由用户来实现。</li>
</ul>
<p>很多系统都提供了宏命令功能，如<strong>UNIX平台下的Shell编程</strong>，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列，这也是命令模式的应用实例之一。</p>
<h3 id="2-9-模式扩展"><a href="#2-9-模式扩展" class="headerlink" title="2.9 模式扩展"></a>2.9 模式扩展</h3><h4 id="撤销操作的实现"><a href="#撤销操作的实现" class="headerlink" title="撤销操作的实现"></a>撤销操作的实现</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314151619323.png" alt="image-20230314151619323" style="zoom:80%;" /></p>
<h4 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h4><ol>
<li>宏命令又称为<strong>组合命令</strong>，它是<strong>命令模式和组合模式</strong>联用的产物。</li>
<li>宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，<strong>在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法</strong>，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314151824589.png" alt="image-20230314151824589" style="zoom:80%;" /></p>
<h2 id="3-迭代器模式-对象"><a href="#3-迭代器模式-对象" class="headerlink" title="3. 迭代器模式(对象)"></a>3. 迭代器模式(对象)</h2><h3 id="3-1-模式动机"><a href="#3-1-模式动机" class="headerlink" title="3.1 模式动机"></a>3.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627221420555.png" alt="image-20230627221420555"></p>
<ul>
<li>电视机 &lt;-&gt; 存储电视频道的集合 &lt;-&gt; 聚合类(Aggregate Classes)</li>
<li>电视机遥控器 &lt;-&gt; 操作电视频道 &lt;-&gt; 迭代器(Iterator)</li>
<li>访问一个聚合对象中的元素但又不需要暴露它的内部结构</li>
<li>聚合对象的两个职责：<ul>
<li><strong>存储数据</strong>，聚合对象的基本职责</li>
<li><strong>遍历数据</strong>，既是可变化的，又是可分离的</li>
</ul>
</li>
<li>将遍历数据的行为从聚合对象中分离出来，封装在迭代器对象中</li>
<li>由迭代器来提供遍历聚合对象内部数据的行为，简化聚合对象的设计，更符合单一职责原则</li>
</ul>
<h3 id="3-2-模式定义"><a href="#3-2-模式定义" class="headerlink" title="3.2 模式定义"></a>3.2 模式定义</h3><ul>
<li>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，且不用暴露该对象的内部表示。</li>
<li>Iterator Pattern: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</li>
<li>又名游标(Cursor)模式</li>
<li>通过引入迭代器，客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要很方便地增加新的遍历方式</li>
</ul>
<h3 id="3-3-模式结构"><a href="#3-3-模式结构" class="headerlink" title="3.3 模式结构"></a>3.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627221720676.png" alt="image-20230627221720676">迭代器模式包含以下4个角色：</p>
<ul>
<li>Iterator (抽象迭代器)</li>
<li>ConcreteIterator (具体迭代器)</li>
<li>Aggregate (抽象聚合类)</li>
<li>ConcreteAggregate (具体聚合类)</li>
</ul>
<p>典型的抽象迭代器代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span>; <span class="hljs-comment">//将游标指向第一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>; <span class="hljs-comment">//将游标指向下一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>; <span class="hljs-comment">//判断是否存在下一个元素</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>; <span class="hljs-comment">//获取游标指向的当前元素</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的具体迭代器代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">private</span> ConcreteAggregate objects; <span class="hljs-comment">//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor; <span class="hljs-comment">//定义一个游标，用于记录当前访问位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteIterator</span><span class="hljs-params">(ConcreteAggregate objects)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.objects=objects;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的抽象聚合类代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>	Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的具体聚合类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    ......<br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-4-模式分析"><a href="#3-4-模式分析" class="headerlink" title="3.4 模式分析"></a>3.4 模式分析</h3><ul>
<li>如果需要<strong>增加一个新的具体聚合类</strong>，只需增加一个新的聚合子类和一个新的具体迭代器类即可，原有类库代码无须修改，<strong>符合开闭原则</strong></li>
<li>如果需要<strong>更换一个迭代器</strong>，只需要增加一个新的具体迭代器类作为抽象迭代器类的子类，重新实现遍历方法即可，原有迭代器代码无须修改，也<strong>符合开闭原则</strong></li>
<li>如果要在<strong>迭代器中增加新的方法</strong>，则需要修改抽象迭代器的源代码，这将<strong>违背开闭原则</strong></li>
</ul>
<h4 id="不同的实现-宽接口-vs-窄接口"><a href="#不同的实现-宽接口-vs-窄接口" class="headerlink" title="不同的实现(宽接口 vs. 窄接口)"></a>不同的实现(宽接口 vs. 窄接口)</h4><ul>
<li>宽接口：一个聚集的接口提供了可以用来修改聚集元素的方法</li>
<li>窄接口：一个聚集的接口没有提供修改聚集元素的方法</li>
</ul>
<h4 id="白箱聚集-vs-黑箱聚集"><a href="#白箱聚集-vs-黑箱聚集" class="headerlink" title="白箱聚集 vs. 黑箱聚集"></a>白箱聚集 vs. 黑箱聚集</h4><ul>
<li>白箱聚集：聚集对象为所有对象提供同一个接口(宽接口)<ul>
<li>迭代子可以从外部控制聚集元素的迭代，控制的仅仅是一个游标—游标(Cursor)/外禀(Extrinsic)迭代子</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627222858106.png" alt="image-20230627222858106"></p>
<ul>
<li>黑箱聚集：聚集对象为迭代子对象提供一个宽接口，而为其它对象提供一个窄接口。同时保证聚集对象的封装和迭代子功能的实现。<ul>
<li>迭代子是聚集的内部类，可以自由访问聚集的元素。迭代子可以自行实现迭代功能并控制聚集元素的迭代逻辑—内禀迭代子(Intrinsic Iterator)</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627222954258.png" alt="image-20230627222954258"></p>
<h3 id="3-5-模式优缺点"><a href="#3-5-模式优缺点" class="headerlink" title="3.5 模式优缺点"></a>3.5 模式优缺点</h3><p>迭代器模式优点</p>
<ul>
<li>支持<strong>以不同的方式遍历一个聚合对象</strong>，在同一个聚合对象上<strong>可以定义多种遍历方式</strong></li>
<li><strong>简化了聚合类</strong></li>
<li>由于引入了抽象层，<strong>增加新的聚合类和迭代器类都很方便</strong>，无须修改原有代码，符合开闭原则</li>
</ul>
<p>迭代器模式缺点</p>
<ul>
<li>在增加新的聚合类时需要对应地增加新的迭代器类，<strong>类的个数成对增加</strong>，这在一定程度上增加了系统的复杂性</li>
<li><strong>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。</strong>在自定义迭代器时，<strong>创建一个考虑全面的抽象迭代器并不是一件很容易的事情</strong></li>
</ul>
<h3 id="3-6-模式适用环境"><a href="#3-6-模式适用环境" class="headerlink" title="3.6 模式适用环境"></a>3.6 模式适用环境</h3><ul>
<li>访问一个聚合对象的内容而<strong>无须暴露它的内部表示</strong></li>
<li>需要<strong>为一个聚合对象提供多种遍历方式</strong></li>
<li><strong>为遍历不同的聚合结构提供一个统一的接口</strong>，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而<strong>客户端可以一致性地操作该接口</strong></li>
</ul>
<h3 id="3-7-模式应用"><a href="#3-7-模式应用" class="headerlink" title="3.7 模式应用"></a>3.7 模式应用</h3><p><strong>使用内部类实现迭代器</strong></p>
<ul>
<li>JDK中的AbstractList</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br>......<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>	......<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        ......<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用内部类实现的商品数据类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractObjectList</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProductList</span><span class="hljs-params">(List products)</span> &#123;<br>    	<span class="hljs-built_in">super</span>(products);<br>    &#125;<br>    <span class="hljs-keyword">public</span> AbstractIterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductIterator</span>();<br>    &#125;<br>    <span class="hljs-comment">//商品迭代器：具体迭代器，内部类实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractIterator</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor1;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor2;<br>        <span class="hljs-comment">//省略其他代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结构</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627223238811.png" alt="image-20230627223238811"></p>
<p>实现</p>
<ul>
<li><p>java.util.Collection</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br>    ......<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object c)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection c)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection c)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remainAll</span><span class="hljs-params">(Collection c)</span>;<br>    Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>java.util.Iterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> Java java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Collection c)</span> &#123;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> c.iterator(); <span class="hljs-comment">//创建迭代器对象</span><br>        <span class="hljs-comment">//通过迭代器遍历聚合对象</span><br>        <span class="hljs-keyword">while</span>(i.hasNext()) &#123;<br>        	System.out.println(i.next().toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        Collection persons;<br>        persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">//创建一个ArrayList类型的聚合对象</span><br>        persons.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;小龙女&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;令狐冲&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;韦小宝&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;袁紫衣&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;小龙女&quot;</span>);<br>        process(persons);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-观察者模式-对象"><a href="#4-观察者模式-对象" class="headerlink" title="4. 观察者模式(对象)"></a>4. 观察者模式(对象)</h2><h3 id="4-1-模式动机"><a href="#4-1-模式动机" class="headerlink" title="4.1 模式动机"></a>4.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612085531412.png" alt="image-20230612085531412" style="zoom:80%;" /></p>
<ul>
<li>建立一种<strong>对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应</strong>。<ul>
<li>发生改变的对象称为<strong>观察目标</strong></li>
<li>被通知的对象称为<strong>观察者</strong></li>
</ul>
</li>
<li><strong>一个观察目标可以对应多个观察者</strong>，而且这些观察者之间没有相互联系，<strong>可以根据需要增加和删除观察者，使得系统更易于扩展</strong>，这就是观察者模式的模式动机。</li>
</ul>
<h3 id="4-2-模式定义"><a href="#4-2-模式定义" class="headerlink" title="4.2 模式定义"></a>4.2 模式定义</h3><ol>
<li>观察者模式(Observer Pattern)：定义对象间的一种<strong>一对多依赖关系</strong>，使得<strong>每当一个对象状态发生改变</strong>时，其<strong>相关依赖对象皆得到通知并被自动更新</strong>。</li>
<li>观察者模式又叫做<strong>发布-订阅</strong>（Publish/Subscribe）模式、<strong>模型-视图</strong>（Model/View）模式、<strong>源-监听器</strong>（Source/Listener）模式或<strong>从属者</strong>（Dependents）模式。观察者模式是一种<strong>对象行为型</strong>模式。</li>
<li>Observer Pattern: Define a <strong>one-to-many dependency</strong> between objects so that when <strong>one  object changes state, all its dependents are notified  and updated automatically</strong>.</li>
</ol>
<h3 id="4-3-模式结构"><a href="#4-3-模式结构" class="headerlink" title="4.3 模式结构"></a>4.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612085646353.png" alt="image-20230612085646353" style="zoom:80%;" /></p>
<ul>
<li>观察者模式包含如下角色：<ul>
<li>Subject: 目标</li>
<li>ConcreteSubject: 具体目标</li>
<li>Observer: 观察者</li>
<li>ConcreteObserver: 具体观察者</li>
</ul>
</li>
</ul>
<h3 id="4-4-模式分析"><a href="#4-4-模式分析" class="headerlink" title="4.4 模式分析"></a>4.4 模式分析</h3><ul>
<li>观察者模式描述了<strong>如何建立对象与对象之间的依赖关系</strong>，如何构造满足这种需求的系统。</li>
<li>这一模式中的关键对象是观察目标和观察者，<strong>一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知</strong>。</li>
<li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅 (publish-subscribe)</strong>。</li>
</ul>
<p><strong>松耦合</strong></p>
<ul>
<li>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</li>
<li>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</li>
<li>改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，就可以自由地改变他们。</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ul>
<h3 id="4-5-观察者模式实例与解析"><a href="#4-5-观察者模式实例与解析" class="headerlink" title="4.5 观察者模式实例与解析"></a>4.5 观察者模式实例与解析</h3><p>WeatherData</p>
<ul>
<li>WeatherData类具有getter方法，可以取得三个测量值：温度、湿度与气压。</li>
<li>当新的测量数据备妥时，measurementsChanged() 方法就会被调用。</li>
<li>需要实现三个使用天气数据的布告板: “目前状况” 布告、“气象统计”布告、“天气预报”布告。一旦 WeatherData 有新测量，这些布告必须马上更新。</li>
<li>此系统必须可扩展，让其他开发人员建立定制的布告板，用户可以随心所欲地添加或删除任何布告板</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612090525324.png" alt="image-20230612090525324"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditions</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span>, DisplayElement &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CurrentConditions</span><span class="hljs-params">(Subject weatherSubject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.weatherData = weatherSubject;<br>        weatherData.registerObserver(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Current Conditions: &quot;</span> + temperature + <span class="hljs-string">&quot;F degrees and &quot;</span> + humidity + <span class="hljs-string">&quot;% humidity&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> t, <span class="hljs-type">float</span> h)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = t;<br>        <span class="hljs-built_in">this</span>.humidity = h;<br>        display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-6-模式优缺点"><a href="#4-6-模式优缺点" class="headerlink" title="4.6 模式优缺点"></a>4.6 模式优缺点</h3><p>观察者模式的优点</p>
<ol>
<li>观察者模式可以<strong>实现表示层和数据逻辑层的分离</strong>，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li>
<li>观察者模式在观察目标和观察者之间<strong>建立一个抽象的耦合</strong>。</li>
<li>观察者模式<strong>支持广播通信</strong>。</li>
<li>观察者模式<strong>符合开闭原则</strong>的要求。</li>
</ol>
<p>观察者模式的缺点</p>
<ol>
<li>如果一个观察目标对象有很多直接和间接的观察者的话，<strong>将所有的观察者都通知到会花费很多时间</strong>。</li>
<li>如果在观察者和观察目标之间有<strong>循环依赖的话</strong>，观察目标会触发它们之间进行循环调用，<strong>可能导致系统崩溃</strong>。</li>
<li>观察者模式<strong>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</strong>，而仅仅只是知道观察目标发生了变化。</li>
</ol>
<h3 id="4-7-模式适用环境"><a href="#4-7-模式适用环境" class="headerlink" title="4.7 模式适用环境"></a>4.7 模式适用环境</h3><p>在以下情况下可以使用观察者模式：</p>
<ol>
<li>一个抽象模型有两个方面，其中<strong>一个方面依赖于另一个方面</strong>。将这些方面<strong>封装在独立的对象中使它们可以各自独立地改变和复用</strong>。</li>
<li><strong>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变</strong>，可以降低对象之间的耦合度。</li>
<li><strong>一个对象必须通知其他对象，而并不知道这些对象是谁</strong>。</li>
<li><strong>需要在系统中创建一个触发链</strong>，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种<strong>链式触发机制</strong>。</li>
</ol>
<h3 id="4-8-模式应用"><a href="#4-8-模式应用" class="headerlink" title="4.8 模式应用"></a>4.8 模式应用</h3><ol>
<li>JDK1.1版本及以后的各个版本中，事件处理模型采用基于观察者模式的<strong>委派事件模型(Delegation Event Model, DEM)</strong>。<ol>
<li>在DEM中，事件的发布者称为<strong>事件源(Event Source)</strong>，而订阅者叫做<strong>事件监听器(Event Listener)</strong>，在这个过程中还可以通过<strong>事件对象(Event Object)</strong>来传递与事件相关的信息，可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。</li>
<li><strong>事件源对象、事件监听对象(事件处理对象)和事件对象</strong>构成了Java事件处理模型的三要素。</li>
</ol>
</li>
<li>除了AWT中的事件处理之外，Java语言解析XML的技术<strong>SAX2</strong>以及<strong>Servlet技术的事件处理机制</strong>都基于DEM，它们都是观察者模式的应用。</li>
<li>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到<strong>一对一或者一对多的对象交互场景都可以使用观察者模式</strong>。</li>
</ol>
<h3 id="4-9-模式扩展"><a href="#4-9-模式扩展" class="headerlink" title="4.9 模式扩展"></a>4.9 模式扩展</h3><h4 id="Java语言提供的对观察者模式的支持"><a href="#Java语言提供的对观察者模式的支持" class="headerlink" title="Java语言提供的对观察者模式的支持"></a>Java语言提供的对观察者模式的支持</h4><ul>
<li>在JDK的java.util包中，提供了<strong>Observable类</strong>以及<strong>Observer接口</strong>，它们构成了Java语言对观察者模式的支持。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612091826405.png" alt="image-20230612091826405" style="zoom:80%;" /></p>
<ul>
<li>Observer接口:<code>void update(Observable o, Object arg);</code></li>
<li><p>Observable类</p>
<ul>
<li><code>Observable()</code></li>
<li><code>addObserver(Observer o)</code></li>
<li><code>deleteObserver (Observer o)</code></li>
<li><code>notifyObservers()</code>、<code>notifyObservers(Object arg)</code></li>
<li><code>deleteObservers</code></li>
<li><code>setChanged()</code></li>
<li><code>clearChanged()</code></li>
<li><code>hasChanged()</code></li>
<li><code>countObservers()</code></li>
</ul>
</li>
<li><p>谁触发更新：目标和它的观察者依赖于通知机制来保持一致。但到底哪一个对象调用 Notify 来触发更新? 此时有两个选择:</p>
<ul>
<li>由目标对象的状态设定操作在改变目标对象的状态后自动调用 Notify。这种方法的优点是客户不需要记住要在目标对象上调用 Notify，缺点是多个连续的操作会产生多次连续的更新, 可能效率较低。</li>
<li>让客户负责在适当的时候调用 Notify。这样做的优点是客户可以在一系列的状态改变完成后再一次性地触发更新, 避免了不必要的中间更新。缺点是给客户增加了触发更新的责任。由于客户可能会忘记调用 Notify，这种方式较易出错。</li>
</ul>
</li>
</ul>
<h4 id="封装复杂的更新语义"><a href="#封装复杂的更新语义" class="headerlink" title="封装复杂的更新语义"></a>封装复杂的更新语义</h4><ul>
<li>当目标和观察者间的依赖关系特别复杂时, 可能需要一个维护这些关系的对象。我们称这样的对象为更改管理器（Change Manager）。</li>
<li>它的目的是尽量减少观察者反映其目标的状态变化所需的工作量。例如, 如果一个操作涉及到对几个相互依赖的目标进行改动, 就必须保证仅在所有目标都已更改完毕后，才一次性地通知它们的观察者, 而不是每个目标都通知观察者。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092416439.png" alt="image-20230612092416439" style="zoom:80%;" /></p>
<h4 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h4><ul>
<li>MVC模式是一种架构模式，它包含三个角色：<strong>模型(Model)，视图(View)和控制器(Controller)</strong>。观察者模式可以用来实现MVC模式，观察者模式中的<strong>观察目标</strong>就是MVC模式中的<strong>模型(Model)</strong>，而<strong>观察者</strong>就是MVC中的<strong>视图</strong>(View)，控制器(Controller)充当两者之间的中介者(Mediator)。<strong>当模型层的数据发生改变时，视图层将自动改变其显示内容</strong>。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092529510.png" alt="image-20230612092529510" style="zoom:80%;" /></p>
<h3 id="4-10-小结"><a href="#4-10-小结" class="headerlink" title="4.10 小结"></a>4.10 小结</h3><ol>
<li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li>
<li>观察者模式包含四个角色：<ol>
<li>目标又称为主题，它是指被观察的对象</li>
<li>具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知</li>
<li>观察者将对观察目标的改变做出反应</li>
<li>在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li>
</ol>
</li>
<li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li>
<li>观察者模式<ol>
<li>主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信</li>
<li>主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
</ol>
</li>
<li>观察者模式适用情况包括：<ol>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li>
</ol>
</li>
<li>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。</li>
</ol>
<h2 id="5-中介者模式-对象"><a href="#5-中介者模式-对象" class="headerlink" title="5. 中介者模式(对象)"></a>5. 中介者模式(对象)</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092658438.png" alt="image-20230612092658438" style="zoom:80%;" /></p>
<h3 id="5-1-模式动机"><a href="#5-1-模式动机" class="headerlink" title="5.1 模式动机"></a>5.1 模式动机</h3><ol>
<li>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：<ol>
<li><strong>系统结构复杂</strong>：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li>
<li><strong>对象可重用性差</strong>：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li>
<li><strong>系统扩展性低</strong>：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li>
</ol>
</li>
<li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们<strong>应该尽量将对象细化，使其只负责或呈现单一的职责</strong>。</li>
<li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，<strong>为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式</strong>，这就是中介者模式的模式动机。</li>
</ol>
<h3 id="5-2-模式定义"><a href="#5-2-模式定义" class="headerlink" title="5.2 模式定义"></a>5.2 模式定义</h3><ol>
<li>中介者模式(Mediator Pattern)定义：用一个中介对象来<strong>封装一系列的对象交互</strong>，中介者使各对象不需要显式地相互引用，从而<strong>使其耦合松散</strong>，而且<strong>可以独立地改变它们之间的交互</strong>。中介者模式又称为<strong>调停者模式</strong>，它是一种<strong>对象行为型模式</strong>。</li>
<li>Mediator Pattern: Define an object that encapsulates how a set of objects interact. Mediator promotes <strong>loose coupling</strong> by keeping objects from referring to each other explicitly, and <strong>it lets you vary their interaction independently</strong>.</li>
</ol>
<h3 id="5-3-模式结构"><a href="#5-3-模式结构" class="headerlink" title="5.3 模式结构"></a>5.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092759415.png" alt="image-20230612092759415"></p>
<p>中介者模式包含如下角色：</p>
<ol>
<li>Mediator: 抽象中介者</li>
<li>ConcreteMediator: 具体中介者</li>
<li>Colleague: 抽象同事类</li>
<li>ConcreteColleague: 具体同事类</li>
</ol>
<h3 id="5-4-模式分析"><a href="#5-4-模式分析" class="headerlink" title="5.4 模式分析"></a>5.4 模式分析</h3><ul>
<li>中介者模式可以使对象之间的关系数量急剧减少：</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092851729.png" alt="image-20230612092851729"></p>
<ul>
<li><p>中介者承担两方面的职责：</p>
<ol>
<li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者<strong>在结构上的支持</strong>。</li>
<li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者<strong>在行为上的支持</strong>。</li>
</ol>
</li>
<li><p>典型的抽象中介者类代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>   <span class="hljs-keyword">protected</span> ArrayList colleagues;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Colleague colleague)</span> &#123;<br>      colleagues.add(colleague);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>典型的具体中介者类代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>      ......<br>      ((Colleague)(colleagues.get(<span class="hljs-number">0</span>))).method1();<br>      ......<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>典型的抽象同事类代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span>&#123;<br>   <span class="hljs-keyword">protected</span> Mediator mediator;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Colleague</span><span class="hljs-params">(Mediator mediator)</span>&#123;<br>      <span class="hljs-built_in">this</span>.mediator=mediator;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>典型的具体同事类代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague</span><span class="hljs-params">(Mediator mediator)</span>&#123;<br>      <span class="hljs-built_in">super</span>(mediator);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>      ......<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>      mediator.operation1();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-5-中介者模式实例与解析"><a href="#5-5-中介者模式实例与解析" class="headerlink" title="5.5 中介者模式实例与解析"></a>5.5 中介者模式实例与解析</h3><p><strong>实例：虚拟聊天室</strong></p>
<p>某论坛系统欲增加一个虚拟聊天室，允许论坛会员通过该聊天室进行信息交流，普通会员(CommonMember)可以给其他会员发送文本信息，钻石会员(DiamondMember)既可以给其他会员发送文本信息，还可以发送图片信息。该聊天室可以对不雅字符进行过滤，如“日”等字符；还可以对发送的图片大小进行控制。用中介者模式设计该虚拟聊天室。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612093348250.png" alt="image-20230612093348250"></p>
<h3 id="5-6-模式优缺点"><a href="#5-6-模式优缺点" class="headerlink" title="5.6 模式优缺点"></a>5.6 模式优缺点</h3><p>中介者模式的优点</p>
<ol>
<li>简化了对象之间的交互。</li>
<li>将各同事解耦。</li>
<li>减少子类生成。</li>
<li>可以简化各同事类的设计和实现。</li>
</ol>
<p>中介者模式的缺点</p>
<ol>
<li>在具体中介者类中包含了同事之间的交互细节，可能会导致<strong>具体中介者类非常复杂</strong>，使得<strong>系统难以维护</strong>。</li>
</ol>
<h3 id="5-7-模式适用环境"><a href="#5-7-模式适用环境" class="headerlink" title="5.7 模式适用环境"></a>5.7 模式适用环境</h3><p>在以下情况下可以使用中介者模式：</p>
<ol>
<li>系统中<strong>对象之间存在复杂的引用关系</strong>，产生的相互依赖关系结构混乱且难以理解。</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致<strong>难以复用该对象</strong>。</li>
<li><strong>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类</strong>。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li>
</ol>
<h3 id="5-8-模式应用"><a href="#5-8-模式应用" class="headerlink" title="5.8 模式应用"></a>5.8 模式应用</h3><ol>
<li>中介者模式在<strong>事件驱动类软件</strong>中应用比较多，在设计GUI应用程序时，组件之间可能存在较为复杂的交互关系，一个组件的改变将影响与之相关的其他组件，此时可以使用中介者模式来对组件进行协调。</li>
<li>MVC 是Java EE 的一个基本模式，此时<strong>控制器Controller作为一种中介者</strong>，它负责控制视图对象View和模型对象Model之间的交互。如在Struts中，Action就可以作为JSP页面与业务对象之间的中介者。</li>
</ol>
<h3 id="5-9-模式扩展"><a href="#5-9-模式扩展" class="headerlink" title="5.9 模式扩展"></a>5.9 模式扩展</h3><ol>
<li>中介者模式与迪米特法则<ol>
<li>在中介者模式中，通过创造出一个中介者对象，<strong>将系统中有关的对象所引用的其他对象数目减少到最少</strong>，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，<strong>中介者模式就是迪米特法则的一个典型应用</strong>。</li>
</ol>
</li>
<li>中介者模式与GUI开发<ol>
<li>中介者模式可以方便地应用于<strong>图形界面(GUI)开发</strong>中，在比较复杂的界面中可能存在<strong>多个界面组件之间的交互关系</strong>。</li>
<li>对于这些复杂的交互关系，有时候我们可以引入一个中介者类，<strong>将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责</strong>，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。</li>
</ol>
</li>
</ol>
<h3 id="5-10-小结"><a href="#5-10-小结" class="headerlink" title="5.10 小结"></a>5.10 小结</h3><ol>
<li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li>
<li>中介者模式包含四个角色：<ol>
<li>抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信</li>
<li>具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用</li>
<li>抽象同事类定义各同事的公有方法</li>
<li>具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li>
</ol>
</li>
<li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li>
<li>中介者模式<ol>
<li>主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现</li>
<li>主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li>
</ol>
</li>
<li>中介者模式适用情况包括<ol>
<li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
</ol>
</li>
</ol>
<h2 id="6-状态模式-对象"><a href="#6-状态模式-对象" class="headerlink" title="6. 状态模式(对象)"></a>6. 状态模式(对象)</h2><h3 id="6-1-模式动机"><a href="#6-1-模式动机" class="headerlink" title="6.1 模式动机"></a>6.1 模式动机</h3><p>在很多情况下，<strong>一个对象的行为取决于一个或多个动态变化的属性</strong>，这样的属性叫做<strong>状态</strong>，这样的对象叫做<strong>有状态的(stateful)对象</strong>，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p>
<p>在UML中可以使用<strong>状态图</strong>来描述对象状态的变化。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307114008550.png" style="zoom: 67%;" /></p>
<h3 id="6-2-模式定义"><a href="#6-2-模式定义" class="headerlink" title="6.2 模式定义"></a>6.2 模式定义</h3><p>状态模式(State Pattern)：<strong>允许一个对象在其内部状态改变时改变它的行为</strong>，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</p>
<p>State Pattern: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</p>
<h3 id="6-3-模式结构"><a href="#6-3-模式结构" class="headerlink" title="6.3 模式结构"></a>6.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307115128774.png" alt="image-20230307115128774" style="zoom:80%;" /></p>
<p>状态模式包含如下角色：</p>
<ol>
<li>Context: 环境类</li>
<li>State: 抽象状态类</li>
<li>ConcreteState: 具体状态类</li>
</ol>
<p>在结构上策略模式和状态模式是一致的，但是在使用上是很不同的</p>
<ul>
<li>状态模式由状态自己进行转换</li>
<li>策略模式由客户端决定</li>
</ul>
<h3 id="6-4-模式分析"><a href="#6-4-模式分析" class="headerlink" title="6.4 模式分析"></a>6.4 模式分析</h3><ol>
<li>状态模式描述了<strong>对象状态的变化</strong>以及<strong>对象如何在每一种状态下表现出不同的行为</strong>。</li>
<li>状态模式的关键是<strong>引入了一个抽象类来专门表示对象的状态</strong>，这个类我们叫做<strong>抽象状态类</strong>，而对象的每一种具体状态类都继承了该类，并在<strong>不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换</strong>。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307115352857.png" alt="image-20230307115352857" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(state==<span class="hljs-string">&quot;空闲&quot;</span>)&#123;<br>    <span class="hljs-keyword">if</span>(预订房间)&#123;<br>        <span class="hljs-comment">// 预订操作;</span><br>        state=<span class="hljs-string">&quot;已预订&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(住进房间)&#123;<br>        <span class="hljs-comment">// 入住操作;</span><br>        state=<span class="hljs-string">&quot;已入住&quot;</span>;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state==<span class="hljs-string">&quot;已预订&quot;</span>)&#123;<br>    <span class="hljs-keyword">if</span>(住进房间)&#123;<br>        <span class="hljs-comment">// 入住操作;</span><br>        state=<span class="hljs-string">&quot;已入住&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(取消预订)&#123;<br>        <span class="hljs-comment">// 取消操作;</span><br>        state=<span class="hljs-string">&quot;空闲&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用状态模式重构</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307151033908.png" alt="image-20230307151033908" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重构之后的“空闲状态类”示例代码</span><br><span class="hljs-keyword">if</span>(预订房间)&#123;<br>  <span class="hljs-comment">// 预订操作;</span><br>  context.setState(<span class="hljs-keyword">new</span> 已预订状态类());<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(住进房间)&#123;<br>  <span class="hljs-comment">// 入住操作;</span><br>  context.setState(<span class="hljs-keyword">new</span> 已入住状态类());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在状态模式结构中需要理解<strong>环境类与抽象状态类</strong>的作用：</p>
<ol>
<li>环境类实际上就是<strong>拥有状态的对象</strong>，环境类有时候可以充当<strong>状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作</strong>。</li>
<li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，<strong>状态类的产生是由于环境类存在多个状态</strong>，同时还满足两个条件：<strong>这些状态经常需要切换，在不同的状态下对象的行为不同</strong>。因此可以<strong>将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类</strong>，而实际上是<strong>由于切换到不同的具体状态类实现的</strong>。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li>
</ol>
<h3 id="6-5-状态模式实例与解析"><a href="#6-5-状态模式实例与解析" class="headerlink" title="6.5 状态模式实例与解析"></a>6.5 状态模式实例与解析</h3><p>实例：论坛用户等级</p>
<p>在某论坛系统中，用户可以发表留言，发表留言将增加积分；用户也可以回复留言，回复留言也将增加积分；用户还可以下载文件，下载文件将扣除积分。该系统用户分为三个等级，分别是新手、高手和专家，这三个等级对应三种不同的状态，这三种状态分别定义如下：</p>
<ol>
<li>如果积分小于100分，则为新手状态，用户可以发表留言、回复留言，但是不能下载文件。如果积分大于等于1000分，则转换为专家状态；如果积分大于等于100分，则转换为高手状态。</li>
<li>如果积分大于等于100分但小于1000分，则为高手状态，用户可以发表留言、回复留言，还可以下载文件，而且用户在发表留言时可以获取双倍积分。如果积分小于100分，则转换为新手状态；如果积分大于等于1000分，则转换为专家状态；如果下载文件后积分小于0，则不能下载该文件。</li>
<li>如果积分大于等于1000分，则为专家状态，用户可以发表留言、回复留言和下载文件，用户除了在发表留言时可以获取双倍积分外，下载文件只扣除所需积分的一半。如果积分小于100分，则转换为新手状态；如果积分小于1000分，但大于等于100，则转换为高手状态；如果下载文件后积分小于0，则不能下载该文件。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307151649799.png" alt="image-20230307151649799" style="zoom:80%;" /></p>
<h3 id="6-6-模式优缺点"><a href="#6-6-模式优缺点" class="headerlink" title="6.6 模式优缺点"></a>6.6 模式优缺点</h3><p>状态模式的优点</p>
<ol>
<li><strong>封装了转换规则</strong>。</li>
<li><strong>枚举可能的状态</strong>，在枚举状态之前需要确定状态种类。</li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以<strong>方便地增加新的状态</strong>，只需要改变对象状态即可改变对象的行为。</li>
<li>允许<strong>状态转换逻辑与状态对象合成一体</strong>，而不是某一个巨大的条件语句块。</li>
<li>可以<strong>让多个环境对象共享一个状态对象</strong>，从而减少系统中对象的个数。</li>
</ol>
<p>状态模式的缺点</p>
<ol>
<li>状态模式的使用必然会<strong>增加系统类和对象的个数</strong>。</li>
<li>状态模式的结构与实现都较为复杂，<strong>如果使用不当将导致程序结构和代码的混乱</strong>。</li>
<li>状态模式<strong>对“开闭原则”的支持并不太好</strong>，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ol>
<h3 id="6-7-模式适用环境"><a href="#6-7-模式适用环境" class="headerlink" title="6.7 模式适用环境"></a>6.7 模式适用环境</h3><ol>
<li>对象的<strong>行为依赖于它的状态(属性)</strong>并且<strong>可以根据它的状态改变而改变它的相关行为</strong>。</li>
<li>代码中包含大量与<strong>对象状态有关的条件语句</strong>，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>
</ol>
<h3 id="6-8-模式应用"><a href="#6-8-模式应用" class="headerlink" title="6.8 模式应用"></a>6.8 模式应用</h3><ol>
<li>状态模式在<strong>工作流或游戏</strong>等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。<strong>使用状态模式可以描述工作流对象(如批文)的状态转换以及不同状态下它所具有的行为。</strong></li>
<li>在目前主流的RPG(Role Play Game，角色扮演游戏)中，<strong>使用状态模式可以对游戏角色进行控制</strong>，游戏角色的升级伴随着其状态的变化和行为的变化。对于游戏程序本身也可以通过状态模式进行总控，一个游戏活动包括开始、运行、结束等状态，通过对状态的控制可以控制系统的行为，决定游戏的各个方面，因此<strong>可以使用状态模式对整个游戏的架构进行设计与实现</strong>。</li>
</ol>
<h3 id="6-9-模式扩展"><a href="#6-9-模式扩展" class="headerlink" title="6.9 模式扩展"></a>6.9 模式扩展</h3><h4 id="共享状态"><a href="#共享状态" class="headerlink" title="共享状态"></a>共享状态</h4><p>在有些情况下<strong>多个环境对象需要共享同一个状态</strong>，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么<strong>需要将这些状态对象定义为环境的静态成员对象</strong>。</p>
<h4 id="简单状态模式与可切换状态的状态模式"><a href="#简单状态模式与可切换状态的状态模式" class="headerlink" title="简单状态模式与可切换状态的状态模式"></a>简单状态模式与可切换状态的状态模式</h4><ol>
<li><strong>简单状态模式</strong>：简单状态模式是指<strong>状态都相互独立，状态之间无须进行转换的状态模式</strong>，这是最简单的一种状态模式。对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到环境类中。<strong>如果是这种简单的状态模式，它遵循“开闭原则”，在客户端可以针对抽象状态类进行编程</strong>，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。</li>
<li><strong>可切换状态的状态模式</strong>：大多数的状态模式都是<strong>可以切换状态的状态模式</strong>，在实现状态切换时，在具体状态类内部需要调用环境类<strong>Context的setState()</strong>方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换。在这种可以切换状态的状态模式中，<strong>增加新的状态类可能需要修改其他某些状态类甚至环境类的源代码</strong>，否则系统无法切换到新增状态。</li>
</ol>
<h2 id="7-策略模式-对象"><a href="#7-策略模式-对象" class="headerlink" title="7. 策略模式(对象)"></a>7. 策略模式(对象)</h2><h3 id="7-1-模式描述"><a href="#7-1-模式描述" class="headerlink" title="7.1 模式描述"></a>7.1 模式描述</h3><p>策略模式定义了一系列算法，将每个算法封装在一起，并使它们可替换。策略使算法可以独立于使用该算法的客户端而变化</p>
<ol>
<li>变化在客户使用时才会出现，也就是要实现这个模式就必须要将细节暴露给用户。</li>
<li>实际开发的时候，可能是由多个设计模式组合成的</li>
<li>我们可能需要一个算法族，希望彼此是可以替换的</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302010414510.png" alt="image-20230302010414510" style="zoom:80%;" /></p>
<h3 id="7-2-模式动机"><a href="#7-2-模式动机" class="headerlink" title="7.2 模式动机"></a>7.2 模式动机</h3><ul>
<li>例如：存在许多用于将文本流分成行的算法。将所有这样的算法硬连接到类中是不可取的。<ul>
<li>不满足开闭原则，每次修改都要反复检查每一个条件语句</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302010708842.png" alt="image-20230302010708842" style="zoom:80%;" /></p>
<h3 id="7-3-应用场景"><a href="#7-3-应用场景" class="headerlink" title="7.3 应用场景"></a>7.3 应用场景</h3><p>在以下情况下使用策略模式</p>
<ol>
<li>许多相关的类仅在<strong>行为</strong>上有所不同，策略提供了一种使用其中一种行为配置类的方法</li>
<li>您需要<strong>算法的不同变体</strong>。例如，您可能定义了反映不同空间/时间权衡的算法。将这些变体实现为算法的类层次结构时，可以使用策略。</li>
<li>一种算法使用客户端不应该知道的数据。使用策略模式<strong>可避免暴露复杂的、特定于算法的数据结构</strong></li>
<li>一个类定义了许多行为，这些行为在其操作中显示为多个条件语句。代替许多条件，将相关的条件分支移到他们自己的<strong>策略类</strong>中。</li>
</ol>
<h3 id="7-4-产生的结果"><a href="#7-4-产生的结果" class="headerlink" title="7.4 产生的结果"></a>7.4 产生的结果</h3><ul>
<li>相关算法族(<em>Families of related algorithms</em>)<ul>
<li>策略类的层次结构定义了一个算法族或行为，以供上下文重用。继承可以帮助分解出算法的通用功能</li>
</ul>
</li>
<li>子类化的替代方法(<em>An alternative to subclassing</em>)</li>
<li>策略消除了条件语句(<em>Strategies eliminate conditional statements</em>)</li>
<li>多种实现方式(<em>A choice of implementations</em>)<ul>
<li>策略可以提供相同行为的不同实现。客户可以选择具有不同时间和空间权衡的策略</li>
</ul>
</li>
<li>客户必须意识到不同的策略(<em>Clients must be aware of different Strategies</em>)<ul>
<li>这种模式有一个潜在的缺点，即<strong>客户在选择合适的策略之前必须先了解策略的不同</strong>，不然客户可能会遇到实现问题</li>
</ul>
</li>
<li>策略和上下文之间的通信开销(<em>Communication overhead between Strategy and Context</em>)</li>
<li>对象数量增加(<em>Increased number of objects</em>)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-3-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-3-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">软件系统设计-设计(3) 结构型模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-30 15:05:42" itemprop="dateCreated datePublished" datetime="2023-04-30T15:05:42+08:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-19 00:13:37" itemprop="dateModified" datetime="2023-08-19T00:13:37+08:00">2023-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">软件系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-类-适配器模式与-对象-适配器模式"><a href="#1-类-适配器模式与-对象-适配器模式" class="headerlink" title="1. (类)适配器模式与(对象)适配器模式"></a>1. (类)适配器模式与(对象)适配器模式</h2><h3 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1 模式动机"></a>1.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612095510933.png" alt="image-20230612095510933" style="zoom:80%;" /></p>
<ol>
<li>在软件开发中采用类似于电源适配器的设计和编码技巧被称为<strong>适配器模式</strong>。</li>
<li>通常情况下，<strong>客户端可以通过目标类的接口访问它所提供的服务</strong>。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li>
<li>在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</li>
<li>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是<strong>适配器(Adapter)</strong>，它所包装的对象就是<strong>适配者(Adaptee)</strong>，即被适配的类。</li>
<li>适配器提供客户类需要的接口，<strong>适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用</strong>。也就是说：<strong>当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类</strong>。因此，<strong>适配器可以使由于接口不兼容而不能交互的类可以一起工作</strong>。这就是适配器模式的模式动机。</li>
</ol>
<h3 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2 模式定义"></a>1.2 模式定义</h3><ol>
<li>适配器模式(Adapter Pattern) ：<strong>将一个接口转换成客户希望的另一个接口</strong>，适配器模式使<strong>接口不兼容的那些类可以一起工作</strong>，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li>
<li>Adapter Pattern: <strong>Convert the interface of a  class into another interface clients expect</strong>.  Adapter lets classes work together that  couldn’t otherwise because of incompatible  interfaces.</li>
</ol>
<h3 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3 模式结构"></a>1.3 模式结构</h3><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612095709256.png" alt="image-20230612095709256" style="zoom:80%;" /></p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612095817460.png" alt="image-20230612095817460" style="zoom:80%;" /></p>
<p>适配器模式包含如下角色：</p>
<ol>
<li>Target：目标抽象类</li>
<li>Adapter：适配器类</li>
<li>Adaptee：适配者类</li>
<li>Client：客户类</li>
</ol>
<h3 id="1-4-模式分析"><a href="#1-4-模式分析" class="headerlink" title="1.4 模式分析"></a>1.4 模式分析</h3><ol>
<li>典型的类适配器代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>    specificRequest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>典型的对象适配器代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span>&#123;<br>  <span class="hljs-keyword">private</span> Adaptee adaptee;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span>&#123;<br>    <span class="hljs-built_in">this</span>.adaptee=adaptee;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>    adaptee.specificRequest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-5-适配器模式实例与解析"><a href="#1-5-适配器模式实例与解析" class="headerlink" title="1.5 适配器模式实例与解析"></a>1.5 适配器模式实例与解析</h3><p>实例一：仿生机器人</p>
<p>现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法cry()、机器人移动方法move()等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑，使用适配器模式进行系统设计。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612100106413.png" alt="image-20230612100106413" style="zoom:80%;" /></p>
<p>实例二：加密适配器</p>
<p>某系统需要提供一个加密模块，将用户信息（如密码等机密信息）加密之后再存储在数据库中，系统已经定义好了数据库操作类。为了提高开发效率，现需要重用已有的加密算法，这些算法封装在一些由第三方提供的类中，有些甚至没有源代码。使用适配器模式设计该加密模块，实现在不修改现有类的基础上重用第三方加密方法。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612100259747.png" alt="image-20230612100259747" style="zoom:80%;" /></p>
<h3 id="1-6-模式优缺点"><a href="#1-6-模式优缺点" class="headerlink" title="1.6 模式优缺点"></a>1.6 模式优缺点</h3><p><strong>适配器模式的优点</strong></p>
<ol>
<li><strong>将目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
<li><strong>增加了类的透明性和复用性</strong>，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li><strong>灵活性和扩展性都非常好</strong>，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合”开闭原则”。</li>
</ol>
<p><strong>类适配器模式的优点</strong></p>
<ol>
<li>由于适配器类是适配者类的子类，因此<strong>可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</strong>。</li>
</ol>
<p><strong>类适配器模式的缺点</strong></p>
<ol>
<li>对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，<strong>其使用有一定的局限性</strong>，不能将一个适配者类和它的子类都适配到目标接口。</li>
</ol>
<p><strong>对象适配器模式的优点</strong></p>
<ol>
<li>一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，<strong>同一个适配器可以把适配者类和它的子类都适配到目标接口</strong>。</li>
</ol>
<p><strong>对象适配器模式的缺点</strong></p>
<ol>
<li>与类适配器模式相比，要想<strong>置换适配者类的方法就不容易</strong>。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>
</ol>
<h3 id="1-7-模式适用环境"><a href="#1-7-模式适用环境" class="headerlink" title="1.7 模式适用环境"></a>1.7 模式适用环境</h3><p>在以下情况下可以使用适配器模式：</p>
<ol>
<li>系统<strong>需要使用现有的类</strong>，而这些类的接口不符合系统的需要。</li>
<li><strong>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类</strong>，包括一些可能在将来引进的类<strong>一起工作</strong>。</li>
</ol>
<h3 id="1-8-模式应用"><a href="#1-8-模式应用" class="headerlink" title="1.8 模式应用"></a>1.8 模式应用</h3><ol>
<li>Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。<strong>JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎</strong>（如SQL Server、Oracle、MySQL等）<strong>的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件</strong>。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的<strong>驱动程序</strong>。</li>
</ol>
<h3 id="1-9-模式应用"><a href="#1-9-模式应用" class="headerlink" title="1.9 模式应用"></a>1.9 模式应用</h3><p><strong>JDK类库中的适配器类</strong></p>
<p>如在com.sun.imageio.plugins.common包中定义的<strong>InputStreamAdapter</strong>类，用于包装ImageInputStream接口及其子类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span>&#123;<br>  ImageInputStream stream;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamAdapter</span><span class="hljs-params">(ImageInputStream stream)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.stream = stream;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> stream.read();<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> stream.read(b, off, len);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>默认适配器模式(Default Adapter Pattern)或缺省适配器模式</strong></p>
<p>当不需要全部实现接口提供的方法时，可先设计一个<strong>抽象类实现接口</strong>，并<strong>为该接口中每个方法提供一个默认实现</strong>（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它<strong>适用于一个接口不想使用其所有的方法的情况</strong>。因此也称为<strong>单接口适配器模式</strong>。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612100912991.png" alt="image-20230612100912991" style="zoom:80%;" /><br><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612100934239.png" alt="image-20230612100934239" style="zoom:80%;" /></p>
<p><strong>双向适配器</strong></p>
<p>在对象适配器的使用过程中，如果<strong>在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法</strong>，那么该适配器就是一个<strong>双向适配器</strong>。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612101107369.png" alt="image-20230612101107369" style="zoom:80%;" /></p>
<h3 id="1-10-适配器小结"><a href="#1-10-适配器小结" class="headerlink" title="1.10 适配器小结"></a>1.10 适配器小结</h3><ol>
<li>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</li>
<li>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li>
<li>适配器模式包含四个角色<ol>
<li>目标抽象类定义客户要用的特定领域的接口</li>
<li>适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心</li>
<li>适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配</li>
<li>在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li>
</ol>
</li>
<li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li>
<li>适配器模式<ol>
<li>主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合”开闭原则”</li>
<li>类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类</li>
<li>对象适配器模式的缺点是很难置换适配者类的方法。</li>
</ol>
</li>
<li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li>
</ol>
<h2 id="2-组合模式-对象"><a href="#2-组合模式-对象" class="headerlink" title="2. 组合模式(对象)"></a>2. 组合模式(对象)</h2><h3 id="2-1-模式动机"><a href="#2-1-模式动机" class="headerlink" title="2.1 模式动机"></a>2.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612102923937.png" alt="image-20230612102923937" style="zoom:80%;" /></p>
<ol>
<li>对于<strong>树形结构</strong>，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行。<strong>（递归调用）</strong></li>
<li>由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须<strong>有区别地对待容器对象和叶子对象</strong>，而实际上<strong>大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂</strong>。</li>
<li>组合模式描述了<strong>如何将容器对象和叶子对象进行递归组合</strong>，使得<strong>用户在使用时无须对它们进行区分</strong>，可以<strong>一致地对待容器对象和叶子对象</strong>，这就是组合模式的模式动机。</li>
</ol>
<h3 id="2-2-模式定义"><a href="#2-2-模式定义" class="headerlink" title="2.2 模式定义"></a>2.2 模式定义</h3><ol>
<li>组合模式(Composite Pattern)：组合多个对象形成<strong>树形结构</strong>以<strong>表示”整体-部分”的结构层次</strong>。组合模式对<strong>单个对象（即叶子对象）</strong>和<strong>组合对象（即容器对象）</strong>的<strong>使用具有一致性</strong>。</li>
<li>组合模式又可以称为<strong>整体-部分(Part-Whole)模式</strong>，属于对象的结构模式，它<strong>将对象组织到树结构中，可以用来描述整体与部分的关系</strong>。</li>
<li>Composite Pattern: Compose objects into tree  structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</li>
</ol>
<h3 id="2-3-模式结构"><a href="#2-3-模式结构" class="headerlink" title="2.3 模式结构"></a>2.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612103906865.png" alt="image-20230612103906865" style="zoom:80%;" /></p>
<p>组合模式包含如下角色：</p>
<ol>
<li>Component: 抽象构件</li>
<li>Leaf: 叶子构件</li>
<li>Composite: 容器构件</li>
<li>Client: 客户类</li>
</ol>
<h3 id="2-4-模式分析"><a href="#2-4-模式分析" class="headerlink" title="2.4 模式分析"></a>2.4 模式分析</h3><ol>
<li>组合模式的关键是<strong>定义了一个抽象构件类</strong>，它既可以代表叶子，又可以代表容器，而<strong>客户端针对该抽象构件类进行编程</strong>，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</li>
<li>同时<strong>容器对象与抽象构件类之间还建立一个聚合关联关系</strong>，在容器对象中既可以包含叶子，也可以包含容器，以此<strong>实现递归组合，形成一个树形结构</strong>。</li>
<li>文件系统组合模式结构图：</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104101339.png" alt="image-20230612104101339" style="zoom:80%;" /></p>
<ol>
<li>典型的抽象构件角色代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>典型的叶子构件角色代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span><br>  &#123; <span class="hljs-comment">//实现代码</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>典型的容器构件角色代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span><br>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span> &#123;<br>    list.add(c);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span> &#123;<br>    list.remove(c);<br>  &#125;<br>  <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> (Component)list.get(i);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(Object obj:list) &#123;<br>      ((Component)obj).operation();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-5-组合模式实例与解析"><a href="#2-5-组合模式实例与解析" class="headerlink" title="2.5 组合模式实例与解析"></a>2.5 组合模式实例与解析</h3><p>实例一：水果盘</p>
<p>在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行”吃”方法，实际上就是吃其中的水果。使用组合模式模拟该场景。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104406439.png" alt="image-20230612104406439" style="zoom:80%;" /></p>
<p>实例二：文件浏览</p>
<p>文件有不同类型，不同类型的文件其浏览方式有所区别，如文本文件和图片文件的浏览方式就不相同。对文件夹的浏览实际上就是对其中所包含文件的浏览，而客户端可以一致地对文件和文件夹进行操作，无须关心它们的区别。使用组合模式来模拟文件的浏览操作。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104525305.png" alt="image-20230612104525305"></p>
<h3 id="2-6-模式优缺点"><a href="#2-6-模式优缺点" class="headerlink" title="2.6 模式优缺点"></a>2.6 模式优缺点</h3><p>组合模式的优点</p>
<ol>
<li>可以清楚地定义<strong>分层次的复杂对象</strong>，表示对象的全部或部分层次，使得增加新构件也更容易。</li>
<li>客户端调用简单，<strong>客户端可以一致的使用组合结构或其中单个对象</strong>。</li>
<li>定义了包含叶子对象和容器对象的<strong>类层次结构</strong>，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，<strong>可以形成复杂的树形结构</strong>。</li>
<li><strong>更容易在组合体内加入对象构件</strong>，客户端不必因为加入了新的对象构件而更改原有代码。组合模式</li>
</ol>
<p>组合模式的缺点</p>
<ol>
<li><strong>使设计变得更加抽象</strong>，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。</li>
<li>增加新构件时可能会产生一些问题，<strong>很难对容器中的构件类型进行限制</strong>。</li>
</ol>
<h3 id="2-7-模式适用环境"><a href="#2-7-模式适用环境" class="headerlink" title="2.7 模式适用环境"></a>2.7 模式适用环境</h3><p>在以下情况下可以使用组合模式：</p>
<ol>
<li>需要表示一个<strong>对象整体或部分层次</strong>，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。</li>
<li>让客户能够忽略不同对象层次的变化，<strong>客户端可以针对抽象构件编程，无须关心对象层次结构的细节</strong>。</li>
<li><strong>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们</strong>。</li>
</ol>
<h3 id="2-8-模式应用"><a href="#2-8-模式应用" class="headerlink" title="2.8 模式应用"></a>2.8 模式应用</h3><ol>
<li>XML文档解析</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">books</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Carson<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">price</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dollar&quot;</span>&gt;</span>31.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pubdate</span>&gt;</span>05/01/2001<span class="hljs-tag">&lt;/<span class="hljs-name">pubdate</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pubinfo</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">publisher</span>&gt;</span>MSPress<span class="hljs-tag">&lt;/<span class="hljs-name">publisher</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">state</span>&gt;</span>WA<span class="hljs-tag">&lt;/<span class="hljs-name">state</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pubinfo</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">books</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104708064.png" alt="image-20230612104708064" style="zoom:80%;" /></p>
<ol>
<li><strong>操作系统中的目录结构</strong>是一个树形结构，因此在对文件和文件夹进行操作时可以应用组合模式，例如杀毒软件在查毒或杀毒时，既可以针对一个具体文件，也可以针对一个目录。如果是对目录查毒或杀毒，将递归处理目录中的每一个子目录和文件。</li>
<li>JDK的<strong>AWT/Swing</strong>是组合模式在Java类库中的一个典型实际应用。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104736113.png" alt="image-20230612104736113" style="zoom:80%;" /></p>
<h3 id="2-9-模式扩展"><a href="#2-9-模式扩展" class="headerlink" title="2.9 模式扩展"></a>2.9 模式扩展</h3><h4 id="更复杂的组合模式"><a href="#更复杂的组合模式" class="headerlink" title="更复杂的组合模式"></a>更复杂的组合模式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104808582.png" alt="image-20230612104808582" style="zoom:80%;" /></p>
<h4 id="透明组合模式"><a href="#透明组合模式" class="headerlink" title="透明组合模式"></a>透明组合模式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104847480.png" alt="image-20230612104847480"></p>
<h4 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h4><ul>
<li>违反了里氏代换原则</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104908637.png" alt="image-20230612104908637"></p>
<h3 id="2-10-组合小结"><a href="#2-10-组合小结" class="headerlink" title="2.10 组合小结"></a>2.10 组合小结</h3><ol>
<li>组合模式用于组合多个对象形成树形结构以表示”整体-部分”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。组合模式又可以称为”整体-部分”模式，属于对象的结构模式，它将对象组织到树结构中，可以用来描述整体与部分的关系。</li>
<li>组合模式包含三个角色<ol>
<li>抽象构件为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现</li>
<li>叶子构件在组合结构中表示叶子节点对象，叶子节点没有子节点</li>
<li>容器构件在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为。</li>
</ol>
</li>
<li>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</li>
<li>组合模式<ol>
<li>主要优点在于可以方便地对层次结构进行控制，客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关心自己处理的是单个对象还是整个组合结构，简化了客户端代码</li>
<li>缺点在于使设计变得更加抽象，且增加新构件时可能会产生一些问题，而且很难对容器中的构件类型进行限制。</li>
</ol>
</li>
<li>组合模式适用情况包括<ol>
<li>需要表示一个对象整体或部分层次</li>
<li>让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节</li>
<li>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。</li>
</ol>
</li>
<li>组合模式根据抽象构件类的定义形式，又可以分为透明组合模式和安全组合模式。</li>
</ol>
<h2 id="3-装饰模式-对象"><a href="#3-装饰模式-对象" class="headerlink" title="3. 装饰模式(对象)"></a>3. 装饰模式(对象)</h2><h3 id="3-1-模式动机"><a href="#3-1-模式动机" class="headerlink" title="3.1 模式动机"></a>3.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612105355434.png" alt="image-20230612105355434"></p>
<ol>
<li>一般有两种方式可以实现给一个类或对象增加行为：<ol>
<li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li>
<li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为。</li>
</ol>
</li>
<li>装饰模式以<strong>对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在<strong>不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</li>
</ol>
<h3 id="3-2-模式定义"><a href="#3-2-模式定义" class="headerlink" title="3.2 模式定义"></a>3.2 模式定义</h3><ol>
<li>装饰模式(Decorator Pattern) ：<strong>动态地给一个对象增加一些额外的职责</strong>(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为<strong>包装器</strong>(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为”油漆工模式”，它是一种<strong>对象结构型模式</strong>。</li>
<li>Decorator Pattern: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to  subclassing for extending functionality.</li>
</ol>
<h3 id="3-3-模式结构"><a href="#3-3-模式结构" class="headerlink" title="3.3 模式结构"></a>3.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612105517641.png" alt="image-20230612105517641" style="zoom:80%;" /></p>
<p>装饰模式包含如下角色：</p>
<ol>
<li>Component: 抽象构件</li>
<li>ConcreteComponent: 具体构件</li>
<li>Decorator: 抽象装饰类</li>
<li>ConcreteDecorator: 具体装饰类</li>
</ol>
<h3 id="3-4-模式分析"><a href="#3-4-模式分析" class="headerlink" title="3.4 模式分析"></a>3.4 模式分析</h3><ol>
<li>与继承关系相比，关联关系的主要优势在于<strong>不会破坏类的封装性</strong>，而且<strong>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得<strong>系统更加容易维护</strong>。当然，关联关系的缺点是<strong>比继承关系要创建更多的对象</strong>。</li>
<li>使用装饰模式来实现扩展比继承更加灵活，<strong>它以对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li>
<li>典型的抽象装饰类代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>  	<span class="hljs-keyword">private</span> Component component;<br>  	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Component component)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.component=component;<br>  	&#125;<br>  	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>   		component.operation();<br>   	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>典型的具体装饰类代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator</span><span class="hljs-params">(Component component)</span> &#123;<br>    	<span class="hljs-built_in">super</span>(component);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.operation();<br>        addedBehavior();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addedBehavior</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//新增方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-5-装饰模式实例与解析"><a href="#3-5-装饰模式实例与解析" class="headerlink" title="3.5 装饰模式实例与解析"></a>3.5 装饰模式实例与解析</h3><p>实例一：变形金刚</p>
<p>变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612110030272.png" alt="image-20230612110030272" style="zoom:80%;" /></p>
<p>实例二：多重加密系统</p>
<p>某系统提供了一个数据加密功能，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。现使用装饰模式设计该多重加密系统。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612110111263.png" alt="image-20230612110111263"></p>
<h3 id="3-6-模式优缺点"><a href="#3-6-模式优缺点" class="headerlink" title="3.6 模式优缺点"></a>3.6 模式优缺点</h3><p>装饰模式的优点</p>
<ol>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是<strong>装饰模式可以提供比继承更多的灵活性</strong>。</li>
<li>可以<strong>通过一种动态的方式来扩展一个对象的功能</strong>，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li>
<li><strong>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合</strong>。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li>
<li><strong>具体构件类与具体装饰类可以独立变化</strong>，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合”开闭原则”。</li>
</ol>
<p>装饰模式的缺点</p>
<ol>
<li>使用装饰模式进行系统设计时将<strong>产生很多小对象</strong>，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li>
<li>这种比继承更加灵活机动的特性，也同时意味着<strong>装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐</strong>。</li>
</ol>
<h3 id="3-7-模式适用环境"><a href="#3-7-模式适用环境" class="headerlink" title="3.7 模式适用环境"></a>3.7 模式适用环境</h3><p>在以下情况下可以使用装饰模式：</p>
<ol>
<li>在不影响其他对象的情况下，<strong>以动态、透明的方式给单个对象添加职责</strong>。</li>
<li>需要<strong>动态地给一个对象增加功能</strong>，这些功能也可以<strong>动态地被撤销</strong>。</li>
<li><strong>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时</strong>。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li>
</ol>
<h3 id="3-8-模式应用"><a href="#3-8-模式应用" class="headerlink" title="3.8 模式应用"></a>3.8 模式应用</h3><p>在javax.swing包中，可以通过装饰模式动态给一些构件增加新的行为或改善其外观显示。</p>
<ul>
<li>如JList构件本身并不支持直接滚动，即没有滚动条，要创建可以滚动的列表，可以使用如下代码实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JList</span>();<br><span class="hljs-type">JScrollPane</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JScrollPane</span>(list);<br></code></pre></td></tr></table></figure>
<p>装饰模式在JDK中最经典的实例是Java IO。</p>
<ul>
<li>以 <code>InputStream</code> 为例：</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612110315912.png" alt="image-20230612110315912" style="zoom:80%;" /></p>
<ul>
<li>抽象装饰类：<code>FilterInputStream</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">FilterInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>	<span class="hljs-built_in">this</span>.in = in;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>角色分配：</p>
<ul>
<li>抽象构件类：InputStream</li>
<li>具体构件类：FileInputStream、ByteArrayInputStream等</li>
<li>抽象装饰类：FilterInputStream</li>
<li>具体装饰类：BufferedInputStream、DataInputStream等</li>
</ul>
</li>
<li><p>客户端使用：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inFS</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;temp/fileSrc.txt&quot;</span>);<br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">inBS</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(inFS);<br><span class="hljs-comment">//定义一个字节数组，用于存放缓冲数据</span><br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>inBS.read(data);<br></code></pre></td></tr></table></figure>
<h3 id="3-9-模式扩展"><a href="#3-9-模式扩展" class="headerlink" title="3.9 模式扩展"></a>3.9 模式扩展</h3><h4 id="装饰模式的简化"><a href="#装饰模式的简化" class="headerlink" title="装饰模式的简化"></a>装饰模式的简化</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612110713084.png" alt="image-20230612110713084" style="zoom:80%;" /></p>
<p>需要注意的问题</p>
<ul>
<li><strong>一个装饰类的接口必须与被装饰类的接口保持相同</strong>，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li>
<li>尽量保持具体构件类Component作为一个”轻”类，也就是说<strong>不要把太多的逻辑和状态放在具体构件类中</strong>，可以通过装饰类对其进行扩展。</li>
<li><strong>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类</strong>。</li>
</ul>
<h4 id="透明装饰模式（多重加密系统）"><a href="#透明装饰模式（多重加密系统）" class="headerlink" title="透明装饰模式（多重加密系统）"></a>透明装饰模式（多重加密系统）</h4><ol>
<li>在透明装饰模式中，要求<strong>客户端完全针对抽象编程</strong>，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Cipher sc,cc,ac;<br>sc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleCipher</span>();<br>cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComplexCipher</span>(sc);<br>ac = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvancedCipher</span>(cc);<br></code></pre></td></tr></table></figure>
<h4 id="半透明装饰模式（变形金刚）"><a href="#半透明装饰模式（变形金刚）" class="headerlink" title="半透明装饰模式（变形金刚）"></a>半透明装饰模式（变形金刚）</h4><ol>
<li><strong>半透明(semi-transparent)</strong>的装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Transform camaro;<br>camaro=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>camaro.move();<br><span class="hljs-type">Robot</span> <span class="hljs-variable">bumblebee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Robot</span>(camaro);<br>bumblebee.move();<br>bumblebee.say();<br></code></pre></td></tr></table></figure>
<h3 id="3-10-小结"><a href="#3-10-小结" class="headerlink" title="3.10 小结"></a>3.10 小结</h3><ol>
<li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li>
<li>装饰模式包含四个角色<ol>
<li>抽象构件定义了对象的接口，可以给这些对象动态增加职责（方法）</li>
<li>具体构件定义了具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）</li>
<li>抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现</li>
<li>具体装饰类是抽象装饰类的子类，负责向构件添加新的职责。</li>
</ol>
</li>
<li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li>
<li>装饰模式<ol>
<li>主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类</li>
<li>主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li>
</ol>
</li>
<li>装饰模式适用情况包括<ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li>
<li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销</li>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</li>
</ol>
</li>
<li>装饰模式可分为透明装饰模式和半透明装饰模式<ol>
<li>在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型</li>
<li>半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li>
</ol>
</li>
</ol>
<h2 id="4-外观模式-对象"><a href="#4-外观模式-对象" class="headerlink" title="4. 外观模式(对象)"></a>4. 外观模式(对象)</h2><h3 id="4-1-模式动机"><a href="#4-1-模式动机" class="headerlink" title="4.1 模式动机"></a>4.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612111836731.png" alt="image-20230612111836731" style="zoom:80%;" /></p>
<p>引入外观角色之后，<strong>用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现</strong>，从而降低了系统的耦合度。</p>
<h3 id="4-2-模式定义"><a href="#4-2-模式定义" class="headerlink" title="4.2 模式定义"></a>4.2 模式定义</h3><ol>
<li>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个<strong>统一的外观对象</strong>进行，为子系统中的一组接口<strong>提供一个一致的界面</strong>，外观模式定义了一个高层接口，这个接口<strong>使得这一子系统更加容易使用</strong>。外观模式又称为<strong>门面模式</strong>，它是一种<strong>对象结构型模式</strong>。<ol>
<li>简化了接口</li>
<li>接口相关模式：适配器模式、外观模式，变化决定了要使用哪个模式</li>
</ol>
</li>
<li>Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</li>
</ol>
<h3 id="4-3-模式结构"><a href="#4-3-模式结构" class="headerlink" title="4.3 模式结构"></a>4.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612112036071.png" alt="image-20230612112036071"></p>
<ul>
<li>外观模式包含如下角色：<ol>
<li>Facade: 外观角色</li>
<li>SubSystem:子系统角色</li>
</ol>
</li>
<li>使用的设计思想：迪米特法则</li>
</ul>
<h3 id="4-4-模式分析"><a href="#4-4-模式分析" class="headerlink" title="4.4 模式分析"></a>4.4 模式分析</h3><ol>
<li>根据“单一职责原则”，<strong>在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性</strong>，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是<strong>引入一个外观对象</strong>，它<strong>为子系统的访问提供了一个简单而单一的入口</strong>。</li>
<li>外观模式也是“迪米特法则”的体现，<strong>通过引入一个新的外观类可以降低原有系统的复杂度</strong>，同时<strong>降低客户类与子系统类的耦合度</strong>。</li>
<li>外观模式要求一个子系统的外部与其内部的通信<strong>通过一个统一的外观对象进行</strong>，外观类将客户端与子系统的内部复杂性分隔开，使得<strong>客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道</strong>。</li>
<li>外观模式的目的在于<strong>降低系统的复杂程度</strong>。</li>
<li>外观模式从很大程度上<strong>提高了客户端使用的便捷性</strong>，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li>
<li>典型的外观角色代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemA</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemA</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemB</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemB</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemC</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemC</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    obj1.method();<br>    obj2.method();<br>    obj3.method();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-5-外观模式实例与解析"><a href="#4-5-外观模式实例与解析" class="headerlink" title="4.5 外观模式实例与解析"></a>4.5 外观模式实例与解析</h3><p>实例一：电源总开关</p>
<p>现在考察一个电源总开关的例子，以便进一步说明外观模式。为了使用方便，一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。通过该电源总开关可以同时控制上述所有电器设备，使用外观模式设计该系统。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612112647563.png" alt="image-20230612112647563"></p>
<p>实例二：文件加密</p>
<p>某系统需要提供一个文件加密模块，加密流程包括三个操作，分别是读取源文件、加密、保存加密之后的文件。读取文件和保存文件使用流来实现，这三个操作相对独立，其业务代码封装在三个不同的类中。现在需要提供一个统一的加密外观类，用户可以直接使用该加密外观类完成文件的读取、加密和保存三个操作，而不需要与每一个类进行交互，使用外观模式设计该加密模块。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612112820640.png" alt="image-20230612112820640"></p>
<p>可以使用模板方法模式实现嘛？子类提供不同的实现，复用父类方法的步骤</p>
<p>什么时候外观？如果每一个部分都不变，只是提供接口</p>
<h3 id="4-6-模式优缺点"><a href="#4-6-模式优缺点" class="headerlink" title="4.6 模式优缺点"></a>4.6 模式优缺点</h3><p>外观模式的优点</p>
<ol>
<li><strong>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易</strong>。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li>
<li><strong>实现了子系统与客户之间的松耦合关系</strong>，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li>
<li><strong>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</strong>，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li>
<li><strong>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</strong>。</li>
</ol>
<p>外观模式的缺点</p>
<ol>
<li><strong>不能很好地限制客户使用子系统类</strong>，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>在不引入<strong>抽象外观类</strong>的情况下，<strong>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</strong>。</li>
</ol>
<h3 id="4-7-模式适用环境"><a href="#4-7-模式适用环境" class="headerlink" title="4.7 模式适用环境"></a>4.7 模式适用环境</h3><p>在以下情况下可以使用外观模式：</p>
<ol>
<li><strong>当要为一个复杂子系统提供一个简单接口时可以使用外观模式</strong>。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li>
<li><strong>客户程序与多个子系统之间存在很大的依赖性</strong>。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以<strong>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度</strong>。</li>
</ol>
<h3 id="4-8-模式应用"><a href="#4-8-模式应用" class="headerlink" title="4.8 模式应用"></a>4.8 模式应用</h3><p>外观模式应用于JDBC数据库操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCFacade</span> &#123;<br>  <span class="hljs-keyword">private</span> Connection conn=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">private</span> Statement statement=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(String driver,String jdbcUrl,String userName,String userPwd)</span> &#123;<br>  	......<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">executeUpdate</span><span class="hljs-params">(String sql)</span> &#123;<br>  	......<br>  &#125;<br>  <span class="hljs-keyword">public</span> ResultSet <span class="hljs-title function_">executeQuery</span><span class="hljs-params">(String sql)</span> &#123;<br>  	......<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>  	......<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Session外观模式是外观模式在Java EE框架中的应用。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612113443164.png" alt="image-20230612113443164" style="zoom:80%;" /></p>
<h3 id="4-9-模式扩展"><a href="#4-9-模式扩展" class="headerlink" title="4.9 模式扩展"></a>4.9 模式扩展</h3><h4 id="一个系统有多个外观类"><a href="#一个系统有多个外观类" class="headerlink" title="一个系统有多个外观类"></a>一个系统有多个外观类</h4><p>在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个<strong>单例类</strong>。<strong>在很多情况下为了节约系统资源，一般将外观类设计为单例类</strong>。当然这并不意味着在整个系统里只能有一个外观类，<strong>在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互</strong>，向用户提供相应的业务功能。</p>
<h4 id="不要试图通过外观类为子系统增加新行为"><a href="#不要试图通过外观类为子系统增加新行为" class="headerlink" title="不要试图通过外观类为子系统增加新行为"></a>不要试图通过外观类为子系统增加新行为</h4><p><strong>不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。</strong>外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。</p>
<h4 id="外观模式与迪米特法则"><a href="#外观模式与迪米特法则" class="headerlink" title="外观模式与迪米特法则"></a>外观模式与迪米特法则</h4><p><strong>外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代</strong>。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。</p>
<h4 id="抽象外观类的引入"><a href="#抽象外观类的引入" class="headerlink" title="抽象外观类的引入"></a>抽象外观类的引入</h4><p>外观模式最大的缺点在于违背了“开闭原则”，<strong>当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程</strong>。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612113636474.png" alt="image-20230612113636474" style="zoom:80%;" /></p>
<h3 id="4-10-小结"><a href="#4-10-小结" class="headerlink" title="4.10 小结"></a>4.10 小结</h3><ol>
<li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li>
<li>外观模式包含两个角色<ol>
<li>外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</li>
<li>在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li>
</ol>
</li>
<li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li>
<li>外观模式<ol>
<li>主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程</li>
<li>其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
</li>
<li>外观模式适用情况包括<ol>
<li>要为一个复杂子系统提供一个简单接口</li>
<li>客户程序与多个子系统之间存在很大的依赖性</li>
<li>在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li>
</ol>
</li>
</ol>
<h2 id="5-代理模式-对象"><a href="#5-代理模式-对象" class="headerlink" title="5. 代理模式(对象)"></a>5. 代理模式(对象)</h2><h3 id="5-1-模式动机"><a href="#5-1-模式动机" class="headerlink" title="5.1 模式动机"></a>5.1 模式动机</h3><p>在某些情况下，<strong>一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用</strong>。代理对象可以在<strong>客户端和目标对象之间起到中介的作用</strong>，并且可以<strong>通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114233046.png" alt="image-20230612114233046"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114245067.png" alt="image-20230612114245067"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>通过<strong>引入一个新的对象</strong>（如小图片和远程代理对象）<strong>来实现对真实对象的操作或者将新的对象作为真实对象的一个替身</strong>，这种实现机制即为代理模式，<strong>通过引入代理对象来间接访问一个对象</strong>，这就是代理模式的模式动机。</p>
<h3 id="5-2-模式定义"><a href="#5-2-模式定义" class="headerlink" title="5.2 模式定义"></a>5.2 模式定义</h3><ol>
<li>代理模式(Proxy Pattern) ：给某一个对象<strong>提供一个代理</strong>，并<strong>由代理对象控制对原对象的引用</strong>。代理模式的英文叫做<strong>Proxy或Surrogate</strong>，它是一种<strong>对象结构型模式</strong>。</li>
<li>Proxy Pattern: Provide a surrogate or placeholder for another object to control access to it.</li>
<li>思想简单，但是变体很多</li>
</ol>
<h3 id="5-3-模式结构"><a href="#5-3-模式结构" class="headerlink" title="5.3 模式结构"></a>5.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114401259.png" alt="image-20230612114401259" style="zoom:80%;" /></p>
<ol>
<li>代理模式包含如下角色：<ol>
<li>Subject: 抽象主题角色</li>
<li>Proxy: 代理主题角色</li>
<li>RealSubject: 真实主题角色</li>
</ol>
</li>
<li>Proxy是符合迪米特法则的。</li>
</ol>
<h3 id="5-4-模式分析"><a href="#5-4-模式分析" class="headerlink" title="5.4 模式分析"></a>5.4 模式分析</h3><ol>
<li>代理模式示意结构图比较简单，一般可以简化为如下图所示，但是在现实中要复杂很多。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114500888.png" alt="image-20230612114500888" style="zoom:80%;" /></p>
<ol>
<li>典型的代理类实现代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">RealSubject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preRequest</span><span class="hljs-params">()</span> &#123;......&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>    preRequest();<br>    realSubject.request();<br>    postRequest();<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postRequest</span><span class="hljs-params">()</span> &#123;......&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-5-代理模式实例与解析"><a href="#5-5-代理模式实例与解析" class="headerlink" title="5.5 代理模式实例与解析"></a>5.5 代理模式实例与解析</h3><p>实例一：论坛权限控制代理</p>
<ol>
<li>在一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖、修改自己的注册信息、修改自己的帖子等功能；而游客只能看到别人发的帖子，没有其他权限。使用代理模式来设计该权限管理模块。</li>
<li>在本实例中我们使用代理模式中的保护代理，该代理用于控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114629895.png" alt="image-20230612114629895"></p>
<p>实例二：数学运算代理</p>
<p>模拟应用远程代理来访问另外一个应用程序域中的对象，如果在远程实现了加减乘除等运算，在本地需要调用，那么可以考虑在本地设置一个代理。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114715673.png" alt="image-20230612114715673"></p>
<h3 id="5-6-模式优缺点"><a href="#5-6-模式优缺点" class="headerlink" title="5.6 模式优缺点"></a>5.6 模式优缺点</h3><p>代理模式的优点</p>
<ol>
<li>代理模式能够<strong>协调调用者和被调用者</strong>，在一定程度上降低了系统的耦合度。</li>
<li><strong>远程代理使得客户端可以访问在远程机器上的对象</strong>，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li><strong>虚拟代理</strong>通过使用一个小对象来代表一个大对象，<strong>可以减少系统资源的消耗，对系统进行优化并提高运行速度。</strong></li>
<li><strong>保护代理可以控制对真实对象的使用权限。</strong></li>
<li>C++：智能指针代理</li>
</ol>
<p>代理模式的缺点</p>
<ol>
<li>由于在客户端和真实主题之间增加了代理对象，因此<strong>有些类型的代理模式可能会造成请求的处理速度变慢</strong>。</li>
<li><strong>实现代理模式需要额外的工作，有些代理模式的实现非常复杂</strong>。</li>
</ol>
<h3 id="5-7-模式适用环境"><a href="#5-7-模式适用环境" class="headerlink" title="5.7 模式适用环境"></a>5.7 模式适用环境</h3><ol>
<li>根据代理模式的使用目的，常见的代理模式有以下几种类型：<ol>
<li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li>
<li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li><strong>Copy-on-Write代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
</ol>
</li>
<li>根据代理模式的使用目的，代理模式有以下几种类型（续）：<ol>
<li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li>
<li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li>
</ol>
</li>
</ol>
<h3 id="5-8-模式应用"><a href="#5-8-模式应用" class="headerlink" title="5.8 模式应用"></a>5.8 模式应用</h3><ol>
<li>Java RMI (Remote Method Invocation，远程方法调用)。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114851066.png" alt="image-20230612114851066"></p>
<ol>
<li><strong>EJB、Web Service等分布式技术都是代理模式的应用</strong>。在EJB中使用了RMI机制，远程服务器中的企业级Bean在本地有一个桩代理，客户端通过桩来调用远程对象中定义的方法，而无须直接与远程对象交互。在EJB的使用中需要提供一个公共的接口，客户端针对该接口进行编程，无须知道桩以及远程EJB的实现细节。</li>
</ol>
<h3 id="5-9-模式扩展"><a href="#5-9-模式扩展" class="headerlink" title="5.9 模式扩展"></a>5.9 模式扩展</h3><p>几种常用的代理模式</p>
<h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><p>远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612115001201.png" alt="image-20230612115001201"></p>
<h4 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h4><ol>
<li><p>当一个对象的加载十分耗费资源的时候，虚拟代理的优势就非常明显地体现出来了。<strong>虚拟代理模式是一种内存节省技术</strong>，那些占用大量内存或处理复杂的对象将推迟到使用它的时候才创建。</p>
</li>
<li><p>在应用程序启动的时候，可以用代理对象代替真实对象初始化，节省了内存的占用，并大大加速了系统的启动时间。</p>
</li>
<li>一个很常见的代理模式的应用实例就是<strong>对大图浏览的控制</strong>。</li>
<li>用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，<strong>先使用一个线程向客户端浏览器加载一个小图片</strong>，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。<strong>通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览</strong>。</li>
</ol>
<h3 id="5-10-小结"><a href="#5-10-小结" class="headerlink" title="5.10 小结"></a>5.10 小结</h3><ol>
<li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</li>
<li>代理模式包含三个角色<ol>
<li>抽象主题角色声明了真实主题和代理主题的共同接口</li>
<li>代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象</li>
<li>真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li>
</ol>
</li>
<li>代理模式<ol>
<li>优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li>
<li>缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ol>
</li>
<li>远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
</ol>
<h2 id="6-桥接模式-对象"><a href="#6-桥接模式-对象" class="headerlink" title="6. 桥接模式(对象)"></a>6. 桥接模式(对象)</h2><h3 id="6-1-模式动机"><a href="#6-1-模式动机" class="headerlink" title="6.1 模式动机"></a>6.1 模式动机</h3><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p>
<ol>
<li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li>
<li>第二种设计方案是根据实际需要对形状和颜色进行组合。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627215938461.png" alt="image-20230627215938461">对于有<strong>两个变化维度（即两个变化的原因)</strong>的系统，采用<strong>方案二</strong>来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式<strong>将继承关系转换为关联关系</strong>，从而<strong>降低了类与类之间的耦合，减少了代码编写量</strong>。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627220126858.png" alt="image-20230627220126858"></p>
<h3 id="6-2-模式定义"><a href="#6-2-模式定义" class="headerlink" title="6.2 模式定义"></a>6.2 模式定义</h3><ol>
<li>桥接模式(Bridge Pattern)：<strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化</strong>。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</li>
<li>Bridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.</li>
</ol>
<h3 id="6-3-模式结构"><a href="#6-3-模式结构" class="headerlink" title="6.3 模式结构"></a>6.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627220159169.png" alt="image-20230627220159169"></p>
<p>桥接模式包含如下角色：</p>
<ol>
<li>Abstraction：抽象类</li>
<li>RefinedAbstraction：扩充抽象类</li>
<li>Implementor：实现类接口</li>
<li>ConcreteImplementor：具体实现类</li>
</ol>
<h3 id="6-4-模式分析"><a href="#6-4-模式分析" class="headerlink" title="6.4 模式分析"></a>6.4 模式分析</h3><p>理解桥接模式，重点需要理解如何将<strong>抽象化(Abstraction)与实现化(Implementation)脱耦</strong>，使得二者可以独立地变化。</p>
<ol>
<li><strong>抽象化</strong>：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，<strong>将对象的共同性质抽取出来形成类的过程即为抽象化的过程</strong>。</li>
<li><strong>实现化</strong>：<strong>针对抽象化给出的具体实现，就是实现化</strong>，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li>
<li><strong>脱耦</strong>：脱耦就是<strong>将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系</strong>。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</li>
</ol>
<p>典型的实现类接口代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Implementor</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationImpl</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的抽象类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span>&#123;<br>    <span class="hljs-keyword">protected</span> Implementor impl;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImpl</span><span class="hljs-params">(Implementor impl)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.impl=impl;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的扩充抽象类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//代码</span><br>        impl.operationImpl();<br>        <span class="hljs-comment">//代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-5-桥接模式实例与解析"><a href="#6-5-桥接模式实例与解析" class="headerlink" title="6.5 桥接模式实例与解析"></a>6.5 桥接模式实例与解析</h3><p>实例一：模拟毛笔</p>
<p>现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627220431701.png" alt="image-20230627220431701"></p>
<p>实例二：跨平台视频播放器</p>
<p>如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627220841600.png" alt="image-20230627220841600"></p>
<h3 id="6-6-模式优缺点"><a href="#6-6-模式优缺点" class="headerlink" title="6.6 模式优缺点"></a>6.6 模式优缺点</h3><p>桥接模式的优点</p>
<ol>
<li><strong>分离抽象接口及其实现部分。</strong></li>
<li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，<strong>桥接模式是比多继承方案更好的解决方法</strong>。</li>
<li>桥接模式<strong>提高了系统的可扩充性</strong>，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li>
<li><strong>实现细节对客户透明，可以对用户隐藏实现细节。</strong></li>
</ol>
<p>桥接模式的缺点</p>
<ol>
<li>桥接模式的引入会<strong>增加系统的理解与设计难度</strong>，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此<strong>其使用范围具有一定的局限性</strong>。</li>
</ol>
<h3 id="6-7-模式适用环境"><a href="#6-7-模式适用环境" class="headerlink" title="6.7 模式适用环境"></a>6.7 模式适用环境</h3><p>在以下情况下可以使用桥接模式：</p>
<ol>
<li>如果一个系统<strong>需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系</strong>，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
<li><strong>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响</strong>，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li>
<li>一个类<strong>存在两个独立变化的维度</strong>，且这两个维度都需要进行扩展。</li>
<li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li>
<li>对于那些<strong>不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统</strong>，桥接模式尤为适用。</li>
</ol>
<h3 id="6-8-模式应用"><a href="#6-8-模式应用" class="headerlink" title="6.8 模式应用"></a>6.8 模式应用</h3><ol>
<li>Java语言通过Java虚拟机实现了平台的无关性。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627221049267.png" alt="image-20230627221049267"></p>
<ol>
<li><p>一个 Java桌面软件总是带有所在操作系统的视感(<strong>LookAndFeel</strong>)，如果一个Java软件是在Unix系统上开发的，那么开发人员看到的是Motif用户界面的视感；在Windows上面使用这个系统的用户看到的是Windows用户界面的视感；而一个在Macintosh上面使用的用户看到的则是Macintosh用户界面的视感，Java语言是通过所谓的Peer架构做到这一点的。Java为AWT中的每一个GUI构件都提供了一个Peer构件，<strong>在AWT中的Peer架构就使用了桥接模式</strong>。</p>
</li>
<li><p>JDBC驱动程序也是桥接模式的应用之一。使用JDBC驱动程序的应用系统就是抽象角色，而所使用的数据库是实现角色。<strong>一个JDBC驱动程序可以动态地将一个特定类型的数据库与一个Java应用程序绑定在一起，从而实现抽象角色与实现角色的动态耦合</strong>。</p>
</li>
</ol>
<h3 id="6-9-模式扩展"><a href="#6-9-模式扩展" class="headerlink" title="6.9 模式扩展"></a>6.9 模式扩展</h3><h4 id="适配器模式与桥接模式的联用"><a href="#适配器模式与桥接模式的联用" class="headerlink" title="适配器模式与桥接模式的联用"></a>适配器模式与桥接模式的联用</h4><ol>
<li>桥接模式和适配器模式用于设计的不同阶段，<strong>桥接模式用于系统的初步设计</strong>，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式</strong>。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627221147628.png" alt="image-20230627221147628"></p>
<h3 id="6-10-小结"><a href="#6-10-小结" class="headerlink" title="6.10 小结"></a>6.10 小结</h3><ol>
<li>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</li>
<li>桥接模式包含如下四个角色：<ol>
<li>抽象类中定义了一个实现类接口类型的对象并可以维护该对象</li>
<li>扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法</li>
<li>实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作</li>
<li>具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</li>
</ol>
</li>
<li>在桥接模式中，抽象化(Abstraction)与实现化(Implementation)脱耦，它们可以沿着各自的维度独立变化。</li>
<li>桥接模式<ol>
<li>主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节</li>
<li>主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情</li>
</ol>
</li>
<li>桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。</li>
</ol>
<h2 id="7-享元模式-对象"><a href="#7-享元模式-对象" class="headerlink" title="7. 享元模式(对象)"></a>7. 享元模式(对象)</h2><h3 id="7-1-模式动机"><a href="#7-1-模式动机" class="headerlink" title="7.1 模式动机"></a>7.1 模式动机</h3><ul>
<li><p>面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。<strong>当对象数量太多时，将导致运行代价过高，带来性能下降等问题</strong>。</p>
</li>
<li><p><strong>享元模式</strong>正是为解决这一类问题而诞生的。<strong>享元模式通过共享技术实现相同或相似对象的重用</strong>。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627202717629.png" alt="image-20230627202717629"></p>
<ul>
<li>在享元模式中<strong>可以共享的相同内容称为内部状态</strong>(Intrinsic State)，而那些<strong>需要外部环境来设置的不能共享的内容称为外部状态</strong>(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。</li>
<li>在享元模式中通常会出现工厂模式，需要<strong>创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象</strong>。</li>
<li>在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此<strong>享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用</strong>。</li>
</ul>
<h3 id="7-2-模式定义"><a href="#7-2-模式定义" class="headerlink" title="7.2 模式定义"></a>7.2 模式定义</h3><ol>
<li>享元模式(Flyweight Pattern)：运用<strong>共享技术</strong>有效地支持大量<strong>细粒度对象</strong>的复用。系统只使用少量的对象，<strong>而这些对象都很相似，状态变化很小</strong>，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为<strong>轻量级模式</strong>，它是一种<strong>对象结构型模式</strong>。</li>
<li>Flyweight Pattern: Use sharing to support large numbers of fine-grained objects efficiently.</li>
</ol>
<h3 id="7-3-模式结构"><a href="#7-3-模式结构" class="headerlink" title="7.3 模式结构"></a>7.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210428493.png" alt="image-20230627210428493"></p>
<ul>
<li><p>享元工厂和原型管理器非常相似</p>
</li>
<li><p>享元模式包含如下角色：</p>
<ul>
<li>Flyweight: 抽象享元类</li>
<li>ConcreteFlyweight: 具体享元类</li>
<li>UnsharedConcreteFlyweight: 非共享具体享元类</li>
<li>FlyweightFactory: 享元工厂类</li>
</ul>
</li>
<li><p>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210554872.png" alt="image-20230627210554872" style="zoom:80%;" /></p>
<h3 id="7-4-模式分析"><a href="#7-4-模式分析" class="headerlink" title="7.4 模式分析"></a>7.4 模式分析</h3><ul>
<li><p>享元模式的核心在于<strong>享元工厂类</strong>，<strong>享元工厂类的作用在于提供一个用于存储享元对象的享元池</strong>，用户需要对象时，首先从享元池中获取，<strong>如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象</strong>。</p>
</li>
<li><p>比较原型管理模式和享元工厂模型</p>
</li>
<li><p>典型的享元工厂类代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HashMap</span> <span class="hljs-variable">flyweights</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <span class="hljs-keyword">public</span> Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(flyweights.containsKey(key)) &#123;<br>        	<span class="hljs-keyword">return</span> (Flyweight)flyweights.get(key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Flyweight</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>();<br>            flyweights.put(key,fw);<br>            <span class="hljs-keyword">return</span> fw;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。</p>
<ul>
<li><p><strong>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态</strong>，因此内部状态可以共享。</p>
</li>
<li><p><strong>外部状态是随环境改变而改变的</strong>、<strong>不可以共享的状态</strong>。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。</p>
</li>
</ul>
</li>
<li><p>典型的享元类代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>    <span class="hljs-comment">//内部状态作为成员属性</span><br>    <span class="hljs-keyword">private</span> String intrinsicState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Flyweight</span><span class="hljs-params">(String intrinsicState)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.intrinsicState = intrinsicState;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(String extrinsicState)</span> &#123;<br>    	......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-5-享元模式实例与解析"><a href="#7-5-享元模式实例与解析" class="headerlink" title="7.5 享元模式实例与解析"></a>7.5 享元模式实例与解析</h3><p>实例一：共享网络设备（无外部状态）</p>
<p>很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发，如图所示，现用享元模式模拟共享网络设备的设计原理。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210852187.png" alt="image-20230627210852187"><br><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210918202.png" alt="image-20230627210918202"></p>
<p>实例二：共享网络设备（有外部状态）</p>
<p>虽然网络设备可以共享，但是分配给每一个终端计算机的端口(Port)是不同的，因此多台计算机虽然可以共享同一个网络设备，但必须使用不同的端口。我们可以将端口从网络设备中抽取出来作为外部状态，需要时再进行设置。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210952014.png" alt="image-20230627210952014"></p>
<h3 id="7-6-模式优缺点"><a href="#7-6-模式优缺点" class="headerlink" title="7.6 模式优缺点"></a>7.6 模式优缺点</h3><p>享元模式的优点</p>
<ol>
<li>享元模式的优点在于它可以<strong>极大减少内存中对象的数量</strong>，使得相同对象或相似对象在内存中只保存一份。</li>
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得<strong>享元对象可以在不同的环境中被共享</strong>。</li>
</ol>
<p>享元模式的缺点</p>
<ol>
<li>享元模式使得系统更加复杂，需要<strong>分离出内部状态和外部状态，这使得程序的逻辑复杂化</strong>。</li>
<li>为了使对象可以共享，享元模式<strong>需要将享元对象的状态外部化，而读取外部状态使得运行时间变长</strong>。</li>
</ol>
<h3 id="7-7-模式适用环境"><a href="#7-7-模式适用环境" class="headerlink" title="7.7 模式适用环境"></a>7.7 模式适用环境</h3><p>在以下情况下可以使用享元模式：</p>
<ol>
<li>一个系统有<strong>大量相同或者相似的对象</strong>，由于这类对象的大量使用，造成内存的大量耗费。</li>
<li>对象的<strong>大部分状态都可以外部化</strong>，可以将这些外部状态传入对象中。</li>
<li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，<strong>应当在多次重复使用享元对象时才值得使用享元模式</strong>。</li>
</ol>
<h3 id="7-8-模式应用"><a href="#7-8-模式应用" class="headerlink" title="7.8 模式应用"></a>7.8 模式应用</h3><ol>
<li>享元模式在<strong>编辑器软件</strong>中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</li>
<li>在JDK类库中定义的String类使用了享元模式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-string">&quot;cd&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        str4 += <span class="hljs-string">&quot;cd&quot;</span>;<br>        System.out.println(str1 == str2);<span class="hljs-comment">// T</span><br>        System.out.println(str1 == str3);<span class="hljs-comment">// T</span><br>        System.out.println(str1 == str4);<span class="hljs-comment">// F</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-9-模式扩展"><a href="#7-9-模式扩展" class="headerlink" title="7.9 模式扩展"></a>7.9 模式扩展</h3><h4 id="单纯享元模式和复合享元模式"><a href="#单纯享元模式和复合享元模式" class="headerlink" title="单纯享元模式和复合享元模式"></a>单纯享元模式和复合享元模式</h4><p><strong>单纯享元模式</strong>：在单纯享元模式中，<strong>所有的享元对象都是可以共享的</strong>，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627211404485.png" alt="image-20230627211404485"></p>
<p><strong>复合享元模式</strong>：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627211422141.png" alt="image-20230627211422141"></p>
<h4 id="享元模式与其他模式的联用"><a href="#享元模式与其他模式的联用" class="headerlink" title="享元模式与其他模式的联用"></a>享元模式与其他模式的联用</h4><ol>
<li>在享元模式的享元工厂类中通常<strong>提供一个静态的工厂方法用于返回享元对象</strong>，使用简单工厂模式来生成享元对象。</li>
<li>在一个系统中，通常只有唯一一个享元工厂，因此<strong>享元工厂类可以使用单例模式进行设计</strong>。</li>
<li>享元模式可以结合组合模式形成<strong>复合享元模式</strong>，统一对享元对象设置外部状态。</li>
</ol>
<h3 id="7-10-小结"><a href="#7-10-小结" class="headerlink" title="7.10 小结"></a>7.10 小结</h3><ol>
<li>享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用，它是一种对象结构型模式。</li>
<li>享元模式包含四个角色<ol>
<li>抽象享元类声明一个接口，通过它可以接受并作用于外部状态</li>
<li>具体享元类实现了抽象享元接口，其实例称为享元对象；非共享具体享元是不能被共享的抽象享元类的子类</li>
<li>享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。</li>
</ol>
</li>
<li>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态和外部状态。其中内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享；外部状态是随环境改变而改变的、不可以共享的状态。</li>
<li>享元模式<ol>
<li>主要优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份</li>
<li>其缺点是使得系统更加复杂，并且需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li>
</ol>
</li>
<li>享元模式适用情况包括<ol>
<li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；多次重复使用享元对象。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-2-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-2-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">软件系统设计-设计(2) 创建型模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-30 12:56:58" itemprop="dateCreated datePublished" datetime="2023-04-30T12:56:58+08:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-19 00:13:37" itemprop="dateModified" datetime="2023-08-19T00:13:37+08:00">2023-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">软件系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-简单工厂模式-对象"><a href="#1-简单工厂模式-对象" class="headerlink" title="1. 简单工厂模式(对象)"></a>1. 简单工厂模式(对象)</h2><h3 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1 模式动机"></a>1.1 模式动机</h3><p>考虑一个简单的软件应用场景，<strong>一个软件系统可以提供多个外观不同</strong>的按钮(如圆形按钮、矩形按钮、菱形按钮等)，这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式</p>
<h3 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2 模式定义"></a>1.2 模式定义</h3><p>简单工厂模式(Simple Factory Pattern)：又称为<strong>静态工厂</strong>方法(Static Factory Method)模式，它属于<strong>类创建型模式</strong>。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类</p>
<p>工厂角色提供<strong>静态工厂方法</strong>来创建其他类的实例，这样子满足了原则：</p>
<ol>
<li>单一职责原则(封装变化)<strong>将对象的创建和使用分离</strong>(创建本质上和使用上强耦合)，将复杂度降低，并将变化的部分和不变的部分分离开。</li>
<li>但是对开闭原则的支持不太好</li>
</ol>
<p>Java一般会提供一个static的方法，这样就不必实例化工厂对象。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/1.png" alt="img" style="zoom: 50%;" /></p>
<h3 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3 模式结构"></a>1.3 模式结构</h3><p>简单工厂模式包含如下角色：</p>
<ol>
<li>Factory：工厂角色</li>
<li>Product：抽象产品角色</li>
<li>ConcreteProduct：具体产品角色</li>
</ol>
<h3 id="1-4-模式分析"><a href="#1-4-模式分析" class="headerlink" title="1.4 模式分析"></a>1.4 模式分析</h3><ul>
<li><strong>将对象的创建和对象本身业务处理分离</strong>可以<strong>降低系统的耦合度</strong>，使得两者修改起来都相对容易。</li>
<li>在调用工厂类的工厂方法时，由于工厂方法是<strong>静态方法</strong>，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的<strong>配置文件</strong>中，修改参数时无须修改任何Java源代码。</li>
<li>简单工厂模式最大的问题在于<strong>工厂类的职责相对过重</strong>，增加新的产品需要修改工厂类的判断逻辑，这一点<strong>与开闭原则</strong>是相违背的。</li>
<li>简单工厂模式的要点在于：<strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节</strong></li>
</ul>
<h3 id="1-5-模式实例与解析"><a href="#1-5-模式实例与解析" class="headerlink" title="1.5 模式实例与解析"></a>1.5 模式实例与解析</h3><p>在某OA系统中，系统根据对比用户在登录时输入的账号和密码以及在数据库中存储的账号和密码是否一致来进行身份验证，如果验证通过，则取出存储在数据库中的用户权限等级(以整数形式存储)，根据不同的权限等级创建不同等级的用户对象，不同等级的用户对象拥有不同的操作权限。现使用简单工厂模式来设计该权限管理模块</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/2.png" alt="img" style="zoom:50%;" /></p>
<h3 id="1-6-模式优缺点"><a href="#1-6-模式优缺点" class="headerlink" title="1.6 模式优缺点"></a>1.6 模式优缺点</h3><p>简单工厂模式的优点</p>
<ol>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅”消费”产品；简单工厂模式通过这种做法<strong>实现了对责任的分割，它提供了专门的工厂类用于创建对象</strong>。</li>
<li><strong>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可</strong>，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li><strong>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</strong>，在一定程度上提高了系统的灵活性。</li>
</ol>
<p>简单工厂模式的缺点</p>
<ol>
<li>由于<strong>工厂类集中了所有产品创建逻辑</strong>，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会<strong>增加系统中类的个数</strong>，在一定程序上增加了系统的复杂度和理解难度。</li>
<li><strong>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时</strong>，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。只是把分散在系统各个地方的变化汇总到了一起。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成<strong>工厂角色无法形成基于继承的等级结构</strong>。</li>
</ol>
<h3 id="1-7-模式使用环境"><a href="#1-7-模式使用环境" class="headerlink" title="1.7 模式使用环境"></a>1.7 模式使用环境</h3><ul>
<li><strong>工厂类负责创建的对象比较少</strong>：由于创建的对象较少，不会造成工厂方法中的业务逻辑<strong>太过复杂</strong>(如果扩展使比较少的)</li>
<li><strong>客户端只知道传入工厂类的参数，对于如何创建对象不关心</strong>：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数(比如只知道名称参数)</li>
</ul>
<h3 id="1-8-模式应用"><a href="#1-8-模式应用" class="headerlink" title="1.8 模式应用"></a>1.8 模式应用</h3><p>在JDK类库中广泛使用了<strong>简单工厂模式</strong>，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">(<span class="hljs-type">int</span> style)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">(<span class="hljs-type">int</span> style, Locale locale)</span>;<br></code></pre></td></tr></table></figure>
<p>Java加密技术：对称加密和非对称加密，但是变化比较少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取不同加密算法的密钥生成器</span><br><span class="hljs-type">KeyGenerator</span> <span class="hljs-variable">keyGen</span> <span class="hljs-operator">=</span> KeyGenerator.getInstance(<span class="hljs-string">&quot;DESede&quot;</span>);<br><span class="hljs-comment">//创建密码器</span><br><span class="hljs-type">Cipher</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;DESede&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="1-9-模式扩展"><a href="#1-9-模式扩展" class="headerlink" title="1.9 模式扩展"></a>1.9 模式扩展</h3><h4 id="简单工厂模式的简化"><a href="#简单工厂模式的简化" class="headerlink" title="简单工厂模式的简化"></a>简单工厂模式的简化</h4><ul>
<li>在有些情况下工厂类可以由抽象产品角色扮演，一个抽象产品类同时也是子类的工厂，也就是说把静态工厂方法写到抽象产品类中。</li>
<li>有些情况下，产品本身只提供一两个方法，此时抽象产品可以和简单工厂进行角色合并。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302144630958.png" alt="image-20230302144630958" style="zoom:80%;" /></p>
<h2 id="2-工厂方法模式-类"><a href="#2-工厂方法模式-类" class="headerlink" title="2. 工厂方法模式(类)"></a>2. 工厂方法模式(类)</h2><h3 id="2-1-简单工厂模式的不足"><a href="#2-1-简单工厂模式的不足" class="headerlink" title="2.1 简单工厂模式的不足"></a>2.1 简单工厂模式的不足</h3><p>在简单工厂模式中，只提供了一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。<strong>简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了”开闭原则”</strong>。</p>
<p>在简单工厂模式中，所有的产品都是由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。</p>
<h3 id="2-2-模式动机"><a href="#2-2-模式动机" class="headerlink" title="2.2 模式动机"></a>2.2 模式动机</h3><p>考虑这样一个系统，按钮工厂类可以返回一个具体的按钮实例，如圆形按钮、矩形按钮、菱形按钮等。在这个系统中，如果需要增加一种新类型的按钮，如椭圆形按钮，那么<strong>除了增加一个新的具体产品类之外，还需要修改工厂类的代码，这就使得整个设计在一定程度上违反了”开闭原则”</strong>。</p>
<p>现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是<strong>将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等</strong>，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构<strong>可以在不修改具体工厂类的情况下引进新的产品</strong>，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，<strong>更加符合“开闭原则”</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>简单工厂</th>
<th>工厂方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302150010701.png" alt="image-20230302150010701" style="zoom:80%;" /></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302145941669.png" alt="image-20230302145941669" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-模式定义"><a href="#2-3-模式定义" class="headerlink" title="2.3 模式定义"></a>2.3 模式定义</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫<strong>虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式</strong>，它属于<strong>类创建型模式</strong>。</p>
<p>在工厂方法模式中，<strong>工厂父类</strong>负责定义创建产品对象的公共接口，而<strong>工厂子类</strong>则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
<p>工厂方法是以<strong>继承方法</strong>为主，工厂子类是<strong>继承工厂父类</strong>的。</p>
<p>按钮只有被创建时才需要确定类型(任意对象使用要尽可能在设计时延迟，延迟到必须要进行实例化的时候)，在抽象工厂，我们使用的是抽象产品，而不是具体的某个对象</p>
<p>工厂方法</p>
<ol>
<li>变化的部分：变化的是产品的服务</li>
<li>不变的部分：对象的使用是不变的</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302150733212.png" alt="image-20230302150733212" style="zoom:80%;" /></p>
<h3 id="2-4-模式分析"><a href="#2-4-模式分析" class="headerlink" title="2.4 模式分析"></a>2.4 模式分析</h3><ol>
<li><p>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。<strong>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做</strong>。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得<strong>工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品</strong>。</p>
</li>
<li><p>当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体产品对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，<strong>很好地符合了”开闭原则”</strong>。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。<strong>工厂方法模式退化(抽象工厂和具体工厂合并)后可以演变成简单工厂模式</strong>。</p>
</li>
<li><p>为了提高系统的可扩展性和灵活性，在<strong>定义工厂和产品时都必须使用抽象层</strong>，如果需要更换产品类，只需要更换对应的工厂即可，其他代码不需要进行任何修改。</p>
</li>
<li><p>配置文件代码：</p>
<ul>
<li>在实际的应用开发中，一般将具体工厂类的实例化过程进行改进，不直接使用new关键字来创建对象，而是将具体类的类名写入<strong>配置文件</strong>中，再通过Java的<strong>反射机制</strong>，读取XML格式的配置文件，根据存储在XML文件中的类名字符串生成对象。</li>
</ul>
</li>
<li><p>Java反射(Java Reflection)：</p>
<ul>
<li>是指<strong>在程序运行时获取已知名称的类或已有对象的相关信息的一种机制</strong>，包括类的方法、属性、超类等信息，还包括实例的创建和实例类型的判断等。可通<strong>过Class类的forName()方法</strong>返回与带有给定字符串名的类或接口相关联的Class对象，再通过newInstance()方法创建此对象所表示的类的一个新实例，即<strong>通过一个类名字符串得到类的实例</strong>。</li>
</ul>
</li>
<li><p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工具类XMLUtil代码片段：</span><br><span class="hljs-comment">// 创建DOM文档对象</span><br><span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dFactory</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br><span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> dFactory.newDocumentBuilder();<br>Document doc;<br>doc = builder.parse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;config.xml&quot;</span>));<br><span class="hljs-comment">// 获取包含类名的文本节点</span><br><span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> doc.getElementsByTagName(<span class="hljs-string">&quot;className&quot;</span>);<br>Node classNode=nl.item(<span class="hljs-number">0</span>).getFirstChild();<br>String cName=classNode.getNodeValue();<br><span class="hljs-comment">// 通过类名生成实例对象并将其返回</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(cName);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> c.newInstance();<br><span class="hljs-keyword">return</span> obj;<br><br><span class="hljs-comment">// 修改后的客户类代码片段：</span><br>PayMethodFactory factory;<br>AbstractPay payMethod;<br>factory = (PayMethodFactory)XMLUtil.getBean(); <span class="hljs-comment">//getBean()的返回类型为Object，此处需要进行强制类型转换</span><br>payMethod = factory.getPayMethod();<br>payMethod.pay();<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-5-模式实例与解析"><a href="#2-5-模式实例与解析" class="headerlink" title="2.5 模式实例与解析"></a>2.5 模式实例与解析</h3><p>某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，且用户可以根据要求动态选择日志记录方式，现使用工厂方法模式设计该系统。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302152423613.png" alt="image-20230302152423613" style="zoom: 50%;" /></p>
<h3 id="2-6-模式优缺点"><a href="#2-6-模式优缺点" class="headerlink" title="2.6 模式优缺点"></a>2.6 模式优缺点</h3><p>工厂方法模式的优点</p>
<ol>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，<strong>用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名</strong>。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使<strong>工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部</strong>。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在<strong>系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品</strong>，而<strong>只要添加一个具体工厂和具体产品就可以了</strong>。这样，系统的可扩展性也就变得非常好，完全符合”开闭原则”。</li>
</ol>
<p>工厂方法模式的缺点</p>
<ol>
<li>在添加新产品时，<strong>需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度</strong>，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，<strong>增加了系统的抽象性和理解难度</strong>，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ol>
<h3 id="2-7-模式适用环境"><a href="#2-7-模式适用环境" class="headerlink" title="2.7 模式适用环境"></a>2.7 模式适用环境</h3><ol>
<li><strong>一个类不知道它所需要的对象的类</strong>：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li><strong>一个类通过其子类来指定创建哪个对象</strong>：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li><strong>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定</strong>，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ol>
<h2 id="3-抽象工厂模式-对象"><a href="#3-抽象工厂模式-对象" class="headerlink" title="3. 抽象工厂模式(对象)"></a>3. 抽象工厂模式(对象)</h2><h3 id="3-1-概念引入"><a href="#3-1-概念引入" class="headerlink" title="3.1 概念引入"></a>3.1 概念引入</h3><p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候<strong>我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</strong></p>
<p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p>
<ol>
<li><strong>产品等级结构：产品等级结构即产品的继承结构</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>
<li><strong>产品族</strong>：在抽象工厂模式中，<strong>产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品</strong>，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li>
</ol>
<p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是<strong>多个位于不同产品等级结构中属于不同类型的具体产品时</strong>需要使用抽象工厂模式。</p>
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p>
<p>抽象工厂模式与工厂方法模式最大的区别在于，<strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong>，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>
<h3 id="3-2-模式定义"><a href="#3-2-模式定义" class="headerlink" title="3.2 模式定义"></a>3.2 模式定义</h3><ol>
<li>抽象工厂模式(Abstract Factory Pattern)：提供一个<strong>创建一系列相关或相互依赖对象的接口</strong>，而<strong>无须指定它们具体的类</strong>。抽象工厂模式又称为<strong>Kit模式</strong>，属于<strong>对象创建型模式</strong>。<ul>
<li>调用kit很可能是抽象工厂模式。</li>
<li>判断是类模式还是对象模式：重点是类和对象哪个更为重要</li>
</ul>
</li>
<li><strong>Abstract Factory Pattern</strong>: Provide an interface for creating <strong>families of related or dependent objects</strong> without specifying their concrete classes.</li>
<li>Frequency of use: high</li>
</ol>
<h3 id="3-3-模式结构"><a href="#3-3-模式结构" class="headerlink" title="3.3 模式结构"></a>3.3 模式结构</h3><p>抽象工厂模式包含如下角色：</p>
<ol>
<li>AbstractFactory：抽象工厂</li>
<li>ConcreteFactory：具体工厂</li>
<li>AbstractProduct：抽象产品</li>
<li>Product：具体产品</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302153303001.png" alt="image-20230302153303001" style="zoom:80%;" /></p>
<h3 id="3-4-模式优缺点"><a href="#3-4-模式优缺点" class="headerlink" title="3.4 模式优缺点"></a>3.4 模式优缺点</h3><p>抽象工厂模式的优点</p>
<ol>
<li>抽象工厂模式<strong>隔离了具体类的生成</strong>，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此<strong>只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</strong>。另外，应用抽象工厂模式<strong>可以实现高内聚低耦合的设计目的</strong>，因此抽象工厂模式得到了广泛的应用。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它<strong>能够保证客户端始终只使用同一个产品族中的对象</strong>。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li>
<li><strong>增加新的具体工厂和产品族很方便，无须修改已有系统，符合”开闭原则”</strong></li>
</ol>
<p>抽象工厂模式的缺点</p>
<ol>
<li>在添加新的产品对象时，<strong>难以扩展抽象工厂来生产新种类的产品</strong>，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li>
<li>开闭原则的倾斜性(<strong>增加新的工厂和产品族容易，增加新的产品等级结构麻烦</strong>)</li>
</ol>
<h3 id="3-5-模式适用场景"><a href="#3-5-模式适用场景" class="headerlink" title="3.5 模式适用场景"></a>3.5 模式适用场景</h3><ol>
<li>一个系统<strong>不应当依赖于产品类实例如何被创建、组合和表达的细节</strong>，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有<strong>多于一个的产品族</strong>，而每次只使用其中某一产品族。</li>
<li><strong>属于同一个产品族的产品将在一起使用</strong>，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，<strong>所有的产品以同样的接口出现</strong>，从而<strong>使客户端不依赖于具体实现</strong>。</li>
</ol>
<h3 id="3-6-模式扩展"><a href="#3-6-模式扩展" class="headerlink" title="3.6 模式扩展"></a>3.6 模式扩展</h3><h4 id="“开闭原则”的倾斜性"><a href="#“开闭原则”的倾斜性" class="headerlink" title="“开闭原则”的倾斜性"></a>“开闭原则”的倾斜性</h4><p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<ol>
<li>增加产品族：<strong>对于增加新的产品族，工厂方法模式很好的支持了”开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改</strong>。</li>
<li>增加新的产品等级结构：<strong>对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持”开闭原则”</strong>。</li>
</ol>
<p>抽象工厂模式的这种性质称为”开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</p>
<h4 id="工厂模式的退化"><a href="#工厂模式的退化" class="headerlink" title="工厂模式的退化"></a>工厂模式的退化</h4><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是<strong>只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式</strong>；<strong>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式</strong>。</p>
<h2 id="4-建造者模式-对象"><a href="#4-建造者模式-对象" class="headerlink" title="4. 建造者模式(对象)"></a>4. 建造者模式(对象)</h2><h3 id="4-1-模式动机"><a href="#4-1-模式动机" class="headerlink" title="4.1 模式动机"></a>4.1 模式动机</h3><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，<strong>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象</strong>。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p>
<p>在软件开发中，也存在大量类似汽车一样的复杂对象，<strong>它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象</strong>。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p>
<p><strong>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件</strong>，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被”外部化”到一个称作建造者的对象里，<strong>建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式</strong>，这就是建造者模式的模式动机。</p>
<h3 id="4-2-模式定义"><a href="#4-2-模式定义" class="headerlink" title="4.2 模式定义"></a>4.2 模式定义</h3><ul>
<li>建造者模式(Builder Pattern)：将<strong>一个复杂对象的构建与它的表示分离</strong>，使得<strong>同样的构建过程可以创建不同的表示</strong>。</li>
<li>Builder Pattern: Separate the construction of a complex object from its representation so that the same construction process can create different representations.</li>
<li>建造者模式是<strong>一步一步创建一个复杂的对象</strong>，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</li>
</ul>
<h3 id="4-3-模式结构"><a href="#4-3-模式结构" class="headerlink" title="4.3 模式结构"></a>4.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307103223798.png" alt="image-20230307103223798" style="zoom:80%;" /></p>
<p>建造者模式包含如下角色：</p>
<ol>
<li>Builder：抽象建造者</li>
<li>ConcreteBuilder：具体建造者</li>
<li>Director：指挥者</li>
<li>Product：产品角色</li>
</ol>
<h3 id="4-4-模式分析"><a href="#4-4-模式分析" class="headerlink" title="4.4 模式分析"></a>4.4 模式分析</h3><p>一个典型的复杂对象其类代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>&#123;<br>  <span class="hljs-keyword">private</span> String partA; <span class="hljs-comment">//可以是任意类型</span><br>  <span class="hljs-keyword">private</span> String partB;<br>  <span class="hljs-keyword">private</span> String partC;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span>&#123;<br>  <span class="hljs-keyword">protected</span> Product product=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartC</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> product;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它<strong>隔离了客户与生产过程</strong>；另一方面它<strong>负责控制产品的生成过程</strong>。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p>
<p>指挥者类的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span>&#123;<br>  <span class="hljs-keyword">private</span> Builder builder;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Director</span><span class="hljs-params">(Builder builder)</span>&#123;<br>    <span class="hljs-built_in">this</span>.builder=builder;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBuilder</span><span class="hljs-params">(Builder builder)</span>&#123;<br>    <span class="hljs-built_in">this</span>.builder=builer;<br>  &#125;<br>  <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">construct</span><span class="hljs-params">()</span>&#123;<br>    builder.buildPartA();<br>    builder.buildPartB();<br>    builder.buildPartC();<br>    <span class="hljs-keyword">return</span> builder.getResult();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>客户端类代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteBuilder</span>();<br><span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>(builder);<br><span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> director.construct();<br></code></pre></td></tr></table></figure>
<p>在客户端代码中，无须关心产品对象的具体组装过程，<strong>只需确定具体建造者的类型即可</strong>，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现</p>
<h3 id="4-5-建造者模式实例与解析"><a href="#4-5-建造者模式实例与解析" class="headerlink" title="4.5 建造者模式实例与解析"></a>4.5 建造者模式实例与解析</h3><p>建造者模式可以用于描述KFC如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307105004867.png" alt="image-20230307105004867"  /></p>
<h3 id="4-6-模式优缺点"><a href="#4-6-模式优缺点" class="headerlink" title="4.6 模式优缺点"></a>4.6 模式优缺点</h3><p>建造者模式的优点</p>
<ol>
<li>在建造者模式中，<strong>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</strong>。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，<strong>用户使用不同的具体建造者即可得到不同的产品对象</strong>。</li>
<li><strong>可以更加精细地控制产品的创建过程</strong>。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li><strong>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合”开闭原则”</strong>。</li>
</ol>
<p>建造者模式的缺点</p>
<ol>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得<strong>很庞大</strong>。</li>
</ol>
<h3 id="4-7-模式适用环境"><a href="#4-7-模式适用环境" class="headerlink" title="4.7 模式适用环境"></a>4.7 模式适用环境</h3><ol>
<li>需要生成的产品对象有<strong>复杂的内部结构</strong>，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的<strong>属性相互依赖，需要指定其生成顺序</strong>。</li>
<li><strong>对象的创建过程独立于创建该对象的类。</strong>在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li><strong>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品</strong>。</li>
</ol>
<h3 id="4-8-模式应用"><a href="#4-8-模式应用" class="headerlink" title="4.8 模式应用"></a>4.8 模式应用</h3><p><strong>JavaMail</strong></p>
<p>一步一步构造一个完整的邮件对象，然后发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由邮件会话对象新建一个邮件消息对象</span><br>MimeMessage message=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMessage</span>(session);<br><span class="hljs-comment">//设置邮件地址</span><br>InternetAddress from=<span class="hljs-keyword">new</span> <span class="hljs-title class_">InternetAddress</span>(<span class="hljs-string">&quot;sunny@test.com&quot;</span>);<br>message.setFrom(from);<span class="hljs-comment">//设置发件人</span><br>InternetAddress to=<span class="hljs-keyword">new</span> <span class="hljs-title class_">InternetAddress</span>(to_mail);<br>message.setRecipient(Message.RecipientType.TO,to);<span class="hljs-comment">//设置</span><br>收件人，并设置其接收类型为TO<br>message.setSubject(to_title);<span class="hljs-comment">//设置主题</span><br>message.setText(to_content);<span class="hljs-comment">//设置信件内容</span><br>message.setSentDate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<span class="hljs-comment">//设置发信时间</span><br>message.saveChanges();<span class="hljs-comment">//存储邮件信息</span><br>Transport transport=session.getTransport(<span class="hljs-string">&quot;smtp&quot;</span>);<br>transport.connect(<span class="hljs-string">&quot;smtp.test.com&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<br>transport.sendMessage(message,message.getAllRecipients());<br></code></pre></td></tr></table></figure>
<p><strong>地图或人物</strong></p>
<p>在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。</p>
<h3 id="4-9-模式比较"><a href="#4-9-模式比较" class="headerlink" title="4.9 模式比较"></a>4.9 模式比较</h3><p>建造者模式的简化</p>
<ol>
<li><strong>省略抽象建造者角色</strong>：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。</li>
<li><strong>省略指挥者角色</strong>：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色</li>
</ol>
<p>建造者模式与抽象工厂模式的比较</p>
<ol>
<li>与抽象工厂模式相比，建造者模式返回<strong>一个组装好的完整产品</strong>，而抽象工厂模式返回<strong>一系列相关的产品</strong>，这些产品位于不同的产品等级结构，构成了一个产品族。</li>
<li>在抽象工厂模式中，<strong>客户端实例化工厂类，然后调用工厂方法获取所需产品对象</strong>，而在建造者模式中，<strong>客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象</strong>。</li>
<li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li>
</ol>
<h2 id="5-原型模式-对象"><a href="#5-原型模式-对象" class="headerlink" title="5. 原型模式(对象)"></a>5. 原型模式(对象)</h2><h3 id="5-1-模式动机"><a href="#5-1-模式动机" class="headerlink" title="5.1 模式动机"></a>5.1 模式动机</h3><p>在面向对象系统中，使用原型模式来复制一个对象自身，从而<strong>克隆出多个与原型对象一模一样的对象</strong>。</p>
<p>在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，<strong>原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象</strong>，这就是原型模式的意图所在。</p>
<h3 id="5-2-模式定义"><a href="#5-2-模式定义" class="headerlink" title="5.2 模式定义"></a>5.2 模式定义</h3><p>原型模式(Prototype Pattern)：原型模式是一种对象创建型模式，<strong>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</strong>原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。</p>
<p>Prototype Pattern: Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype.</p>
<p>原型模式的基本工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝原型自己来实现创建过程</p>
<h3 id="5-3-模式结构"><a href="#5-3-模式结构" class="headerlink" title="5.3 模式结构"></a>5.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307135426191.png" alt="image-20230307135426191" style="zoom:80%;" /></p>
<p>原型模式包含如下角色：</p>
<ol>
<li>Prototype：抽象原型类</li>
<li>ConcretePrototype：具体原型类</li>
<li>Client：客户类</li>
</ol>
<h3 id="5-4-模式分析"><a href="#5-4-模式分析" class="headerlink" title="5.4 模式分析"></a>5.4 模式分析</h3><p>在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自<code>java.lang.Object</code>，而Object类提供一个<code>clone()</code>方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。</p>
<p>能够实现克隆的Java类必须<code>实现一个标识接口Cloneable</code>，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个<code>CloneNotSupportedException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrototypeDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      object = <span class="hljs-built_in">super</span>.clone();<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException exception) &#123;<br>      System.err.println(<span class="hljs-string">&quot;Not support cloneable&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> object;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通常情况下，一个类包含一些成员对象，在使用原型模式克隆对象时，<strong>根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆和浅克隆</strong>。</p>
<p>Java语言提供的clone()方法将对象复制了一份并返回给调用者。一般而言，clone()方法满足:</p>
<ol>
<li>对任何的对象x，都有<code>x.clone() !=x</code>，即克隆对象与原对象不是同一个对象。</li>
<li>对任何的对象x，都有<code>x.clone().getClass()==x.getClass()</code>，即克隆对象与原对象的类型一样。</li>
<li>如果对象x的equals()方法定义恰当，那么<code>x.clone().equals(x)</code>应该成立。</li>
</ol>
<h3 id="5-5-原型模式实例与解析"><a href="#5-5-原型模式实例与解析" class="headerlink" title="5.5 原型模式实例与解析"></a>5.5 原型模式实例与解析</h3><h4 id="邮件复制（浅克隆）"><a href="#邮件复制（浅克隆）" class="headerlink" title="邮件复制（浅克隆）"></a>邮件复制（浅克隆）</h4><p>由于邮件对象包含的内容较多（如发送者、接收者、标题、内容、日期、附件等），某系统中现需要提供一个邮件复制功能，对于已经创建好的邮件对象，可以通过复制的方式创建一个新的邮件对象，如果需要改变某部分内容，无须修改原始的邮件对象，只需要修改复制后得到的邮件对象即可。使用原型模式设计该系统。在本实例中使用浅克隆实现邮件复制，即复制邮件(Email)的同时不复制附件(Attachment)。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307143946706.png" alt="image-20230307143946706" style="zoom:80%;" /></p>
<h3 id="5-6-模式优缺点"><a href="#5-6-模式优缺点" class="headerlink" title="5.6 模式优缺点"></a>5.6 模式优缺点</h3><p>原型模式的优点</p>
<ol>
<li>当创建新的对象实例较为复杂时，使用原型模式可以<strong>简化对象的创建过程</strong>，通过一个已有实例可以<strong>提高新实例的创建效率</strong>。</li>
<li>可以<strong>动态增加或减少产品类</strong>。</li>
<li>原型模式提供了<strong>简化的创建结构</strong>。</li>
<li>可以使用深克隆的方式<strong>保存对象的状态</strong>。</li>
</ol>
<p>原型模式的缺点</p>
<ol>
<li><strong>需要为每一个类配备一个克隆方法</strong>，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，<strong>必须修改其源代码，违背了”开闭原则”</strong>。</li>
<li>在<strong>实现深克隆时需要编写较为复杂的代码</strong>。</li>
</ol>
<h3 id="5-7-模式适用环境"><a href="#5-7-模式适用环境" class="headerlink" title="5.7 模式适用环境"></a>5.7 模式适用环境</h3><ol>
<li><strong>创建新对象成本较大</strong>，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其属性稍作修改。</li>
<li>如果<strong>系统要保存对象的状态</strong>，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用<strong>原型模式配合备忘录模式</strong>来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。</li>
<li>需要<strong>避免使用分层次的工厂类来创建分层次的对象</strong>，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li>
</ol>
<h3 id="5-8-模式应用"><a href="#5-8-模式应用" class="headerlink" title="5.8 模式应用"></a>5.8 模式应用</h3><p>原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。<strong>很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象</strong>，通过原型模式可以大大提高对象的创建效率。</p>
<p>在Struts2中为了保证线程的安全性，<strong>Action对象的创建使用了原型模式</strong>，访问一个已经存在的Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。</p>
<p>在Spring中，用户也可以<strong>采用原型模式来创建新的bean实例</strong>，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</p>
<h3 id="5-9-模式扩展"><a href="#5-9-模式扩展" class="headerlink" title="5.9 模式扩展"></a>5.9 模式扩展</h3><h4 id="带原型管理器的原型模式"><a href="#带原型管理器的原型模式" class="headerlink" title="带原型管理器的原型模式"></a>带原型管理器的原型模式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307144524359.png" alt="image-20230307144524359" style="zoom:80%;" /></p>
<h4 id="相似对象的复制"><a href="#相似对象的复制" class="headerlink" title="相似对象的复制"></a>相似对象的复制</h4><p>很多情况下，复制所得到的对象与原型对象并不是完全相同的，它们的某些属性值存在异同。<strong>通过原型模式获得相同对象后可以再对其属性进行修改，从而获取所需对象</strong>。如多个学生对象的信息的区别在于性别、姓名和年龄，而专业、学院、学校等信息都相同，为了简化创建过程，可以通过原型模式来实现相似对象的复制。</p>
<h2 id="6-单例模式-对象"><a href="#6-单例模式-对象" class="headerlink" title="6. 单例模式(对象)"></a>6. 单例模式(对象)</h2><h3 id="6-1-模式动机"><a href="#6-1-模式动机" class="headerlink" title="6.1 模式动机"></a>6.1 模式动机</h3><p>如何保证一个类只有一个实例并且这个实例易于被访问</p>
<ol>
<li>全局变量：可以确保对象随时都可以被访问，但不能防止创建多个对象</li>
<li>让类自身负责创建和保存它的唯一实例，并保证不能创建其他实例，它还提供一个访问该实例的方法</li>
</ol>
<h3 id="6-2-模式定义"><a href="#6-2-模式定义" class="headerlink" title="6.2 模式定义"></a>6.2 模式定义</h3><ul>
<li><p>单例模式：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</p>
</li>
<li><p>要点：</p>
<ul>
<li>某个类<strong>只能有一个实例</strong></li>
<li>必须<strong>自行创建这个实例</strong></li>
<li>必须<strong>自行向整个系统提供这个实例</strong></li>
</ul>
</li>
</ul>
<h3 id="6-3-模式结构"><a href="#6-3-模式结构" class="headerlink" title="6.3 模式结构"></a>6.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627172507606.png" alt="image-20230627172507606"></p>
<p>单例模式只包含一个单例角色：</p>
<ul>
<li>Singleton(单例)</li>
</ul>
<p>单例模式的实现：<strong>私有构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-literal">null</span>; <span class="hljs-comment">//静态私有成员变量</span><br>    <span class="hljs-comment">//私有构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">//静态公有工厂方法，返回唯一实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)<br>    		instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    	<span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-4-单例模式实例与解析"><a href="#6-4-单例模式实例与解析" class="headerlink" title="6.4 单例模式实例与解析"></a>6.4 单例模式实例与解析</h3><p>某软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系统的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627172750742.png" alt="image-20230627172750742"></p>
<h3 id="6-5-饿汉式单例与懒汉式单例"><a href="#6-5-饿汉式单例与懒汉式单例" class="headerlink" title="6.5 饿汉式单例与懒汉式单例"></a>6.5 饿汉式单例与懒汉式单例</h3><h4 id="6-5-1-饿汉式单例-Eager-Singleton"><a href="#6-5-1-饿汉式单例-Eager-Singleton" class="headerlink" title="6.5.1 饿汉式单例(Eager Singleton)"></a>6.5.1 饿汉式单例(Eager Singleton)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627172921770.png" alt="image-20230627172921770"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EagerSingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EagerSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagerSingleton</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">EagerSingleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="6-5-2-懒汉式单例-Lazy-Singleton"><a href="#6-5-2-懒汉式单例-Lazy-Singleton" class="headerlink" title="6.5.2 懒汉式单例(Lazy Singleton)"></a>6.5.2 懒汉式单例(Lazy Singleton)</h4><h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627173151750.png" alt="image-20230627173151750"></p>
<h5 id="锁方法"><a href="#锁方法" class="headerlink" title="锁方法"></a>锁方法</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627173318437.png" alt="image-20230627173318437"></p>
<h5 id="锁代码段"><a href="#锁代码段" class="headerlink" title="锁代码段"></a>锁代码段</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627173415062.png" alt="image-20230627173415062"></p>
<h5 id="双重检查锁定"><a href="#双重检查锁定" class="headerlink" title="双重检查锁定"></a>双重检查锁定</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627173603602.png" alt="image-20230627173603602"></p>
<h4 id="6-5-3-饿汉式单例类与懒汉式单例类的比较"><a href="#6-5-3-饿汉式单例类与懒汉式单例类的比较" class="headerlink" title="6.5.3 饿汉式单例类与懒汉式单例类的比较"></a>6.5.3 饿汉式单例类与懒汉式单例类的比较</h4><ul>
<li>饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长</li>
<li>懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响</li>
</ul>
<h4 id="6-5-4-使用静态内部类实现单例模式"><a href="#6-5-4-使用静态内部类实现单例模式" class="headerlink" title="6.5.4 使用静态内部类实现单例模式"></a>6.5.4 使用静态内部类实现单例模式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627173845855.png" alt="image-20230627173845855"></p>
<h3 id="6-6-模式优缺点"><a href="#6-6-模式优缺点" class="headerlink" title="6.6 模式优缺点"></a>6.6 模式优缺点</h3><p>模式优点：</p>
<ul>
<li>提供了对唯一实例的受控访问</li>
<li>可以节约系统资源，提高系统的性能</li>
<li>允许可变数目的实例（多例类）</li>
</ul>
<p>模式缺点：</p>
<ul>
<li>扩展困难（缺少抽象层）</li>
<li>单例类的职责过重、一定程度上违背单一职责原则</li>
<li>由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失</li>
</ul>
<h3 id="6-7-模式适用环境"><a href="#6-7-模式适用环境" class="headerlink" title="6.7 模式适用环境"></a>6.7 模式适用环境</h3><ul>
<li>系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">软件系统设计-设计(1) 软件设计原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-30 10:23:09" itemprop="dateCreated datePublished" datetime="2023-04-30T10:23:09+08:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-19 00:15:38" itemprop="dateModified" datetime="2023-08-19T00:15:38+08:00">2023-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">软件系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-软件设计原则"><a href="#1-软件设计原则" class="headerlink" title="1. 软件设计原则"></a>1. 软件设计原则</h2><blockquote>
<p>不会直接考，理解即可</p>
</blockquote>
<h3 id="1-1-面向对象设计原则概述"><a href="#1-1-面向对象设计原则概述" class="headerlink" title="1.1 面向对象设计原则概述"></a>1.1 面向对象设计原则概述</h3><p>知名软件大师Robert C.Martin认为一个可维护性(Maintainability)较低的软件设计，通常由于如下 4 个原因造成：</p>
<ol>
<li>过于僵硬(Rigidity)：硬编码等</li>
<li>过于脆弱(Fragility)：软件一个部分的修改会影响另一个未预期的部分</li>
<li>复用率低(Immobility)：期望类和子系统可以作为黑盒使用</li>
<li>黏度过高(Viscosity)：在架构层面上，如果修改时需要修改整体的架构</li>
</ol>
<p>软件工程和建模大师Peter Coad认为，一个好的系统设计应该具备如下三个性质：</p>
<ol>
<li>可扩展性(Extensibility)</li>
<li>灵活性(Flexibility)</li>
<li>可插入性(Pluggability)</li>
</ol>
<h4 id="软件的可维护性和可复用性"><a href="#软件的可维护性和可复用性" class="headerlink" title="软件的可维护性和可复用性"></a>软件的可维护性和可复用性</h4><ol>
<li><strong>软件的复用(Reuse)或重用</strong>拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本，<strong>恰当的复用还可以改善系统的可维护性。</strong></li>
<li>面向对象设计复用的目标在于<strong>实现支持可维护性的复用</strong>。</li>
<li>在面向对象的设计里面，<strong>可维护性复用都是以面向对象设计原则为基础的</strong>，这些设计原则首先都是复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。</li>
<li>面向对象设计原则也是对系统进行合理重构的指南针，<strong>重构(Refactoring)是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。</strong></li>
</ol>
<h4 id="面向对象设计原则简介"><a href="#面向对象设计原则简介" class="headerlink" title="面向对象设计原则简介"></a>面向对象设计原则简介</h4><ol>
<li>常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。</li>
<li>原则之间也会有相互的作用</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307105144843.png" alt="image-20230307105144843" style="zoom:80%;" /></p>
<h3 id="1-2-单一职责原则"><a href="#1-2-单一职责原则" class="headerlink" title="1.2 单一职责原则"></a>1.2 单一职责原则</h3><h4 id="单一职责原则定义"><a href="#单一职责原则定义" class="headerlink" title="单一职责原则定义"></a>单一职责原则定义</h4><p>单一职责原则(Single Responsibility Principle, SRP)定义如下：</p>
<ul>
<li>一个对象应该只包含<strong>单一的职责</strong>，并且该职责被完整地封装在一个类中。</li>
<li>Every object should have a <strong>single responsibility</strong>, and that responsibility should be entirely encapsulated by the class.</li>
</ul>
<p>另一种定义方式如下：</p>
<ul>
<li>就一个类而言，应该<strong>仅有一个引起它变化的原因</strong>。</li>
<li>There should <strong>never be more than one reason for a class to change</strong></li>
</ul>
<h4 id="单一职责原则分析"><a href="#单一职责原则分析" class="headerlink" title="单一职责原则分析"></a>单一职责原则分析</h4><ol>
<li><strong>一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小</strong>，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。</li>
<li><p>类的职责主要包括两个方面：</p>
<ul>
<li><p><strong>数据职责</strong>：通过其属性来体现。</p>
</li>
<li><p><strong>行为职责</strong>：通过其方法来体现。</p>
</li>
</ul>
</li>
<li>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</li>
</ol>
<h4 id="单一职责原则实例"><a href="#单一职责原则实例" class="headerlink" title="单一职责原则实例"></a>单一职责原则实例</h4><p>某基于Java的C/S系统的”登录功能”通过如下登录类(Login)实现：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/4.png" alt="img" style="zoom: 50%;" /></p>
<p>现使用单一职责原则对其进行重构</p>
<ul>
<li><p>我们将Login类拆分成了三个类</p>
</li>
<li><p>使用分层的方式修改</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/5.png" alt="img" style="zoom: 50%;" /></p>
<h3 id="1-3-开闭原则"><a href="#1-3-开闭原则" class="headerlink" title="1.3 开闭原则"></a>1.3 开闭原则</h3><h4 id="开闭原则定义"><a href="#开闭原则定义" class="headerlink" title="开闭原则定义"></a>开闭原则定义</h4><p>开闭原则(Open-Closed Principle, OCP)定义如下：</p>
<ul>
<li>一个软件实体应当<strong>对扩展开放，对修改关闭</strong>。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</li>
<li>Software entities should be <strong>open for extension</strong>, but <strong>closed for modification</strong></li>
</ul>
<h4 id="开闭原则分析"><a href="#开闭原则分析" class="headerlink" title="开闭原则分析"></a>开闭原则分析</h4><ol>
<li><p>在开闭原则的定义中，<strong>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong>。</p>
</li>
<li><p><strong>抽象化</strong>是开闭原则的关键。</p>
</li>
<li>开闭原则还可以通过一个更加具体的”<strong>对可变性封装原则</strong>“来描述，对可变性封装原则(<strong>Principle of Encapsulation of Variation, EVP</strong>)要求找到系统的可变因素并将其封装起来。</li>
<li>我们需要知道系统的哪些部分是变化的，开闭原则也是对单一职责原则的增强。而里氏代换原则和依赖倒置原则都是开闭原则的具体实现。</li>
</ol>
<h4 id="开闭原则实例"><a href="#开闭原则实例" class="headerlink" title="开闭原则实例"></a>开闭原则实例</h4><p>某图形界面系统提供了各种不同形状的按钮，客户端代码可针对这些按钮进行编程，用户可能会改变需求要求使用不同的按钮，原始设计方案如图所示</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/6.png" alt="img" style="zoom: 50%;" /></p>
<p>现对该系统进行重构，使之满足开闭原则的要求：尝试将代码变为数据(配置文件，Config.xml)，结合Java的反射机制来完成</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230610215106966.png" alt="image-20230610215106966"></p>
<h3 id="1-4-里氏代换原则"><a href="#1-4-里氏代换原则" class="headerlink" title="1.4 里氏代换原则"></a>1.4 里氏代换原则</h3><h4 id="里氏代换原则定义"><a href="#里氏代换原则定义" class="headerlink" title="里氏代换原则定义"></a>里氏代换原则定义</h4><p>里氏代换原则(Liskov Substitution Principle, LSP)有两种定义方式，第一种定义方式相对严格，其定义如下：</p>
<ul>
<li><p>如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o2 都代换成 o1 时，程序 P 的行为没有变化，那么类型 S 是类型 T 的子类型。</p>
</li>
<li><p>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</p>
</li>
</ul>
<p>第二种更容易理解的定义方式如下：</p>
<ul>
<li><p><strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong>。</p>
</li>
<li><p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
</li>
</ul>
<h4 id="里氏代换原则分析"><a href="#里氏代换原则分析" class="headerlink" title="里氏代换原则分析"></a>里氏代换原则分析</h4><ol>
<li>里氏代换原则可以通俗表述为：在<strong>软件中如果能够使用基类对象，那么一定能够使用其子类对象。</strong>把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。</li>
<li>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</li>
<li>Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T.</li>
<li><strong>子类不应该是父类的功能的扩展，我们可以使用组合的方式来扩展功能</strong></li>
</ol>
<h4 id="里氏代换原则实例"><a href="#里氏代换原则实例" class="headerlink" title="里氏代换原则实例"></a>里氏代换原则实例</h4><p>某系统需要实现对重要数据（如用户密码）的加密处理，在数据操作类(DataOperator)中需要调用加密类中定义的加密算法，系统提供了两个不同的加密类，CipherA 和 CipherB，它们实现不同的加密方法，在 DataOperator中 可以选择其中的一个实现加密操作。如图所示：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/8.png" alt="img" style="zoom: 50%;" /></p>
<p>也可以为CipherA和CipherB设计一个共同的父类，下面是指CipherB是在CipherA的基础上加密。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/9.png" alt="img" style="zoom:50%;" /></p>
<h3 id="1-5-依赖倒转原则"><a href="#1-5-依赖倒转原则" class="headerlink" title="1.5 依赖倒转原则"></a>1.5 依赖倒转原则</h3><h4 id="依赖倒转原则定义"><a href="#依赖倒转原则定义" class="headerlink" title="依赖倒转原则定义"></a>依赖倒转原则定义</h4><p>依赖倒转原则(Dependence Inversion Principle, DIP)的定义如下：</p>
<ul>
<li>高层模块<strong>不应该依赖低层模块</strong>，它们都应该<strong>依赖抽象</strong>。<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。</li>
<li>High level modules should not depend upon low level modules, both should depend upon abstractions. <strong>Abstractions should not depend upon details, details should depend upon abstractions</strong>.</li>
</ul>
<p>另一种表述为：</p>
<ul>
<li><p><strong>要针对接口编程，不要针对实现编程</strong>。</p>
</li>
<li><p>Program to an interface, not an implementation.</p>
</li>
</ul>
<h4 id="依赖倒转原则分析"><a href="#依赖倒转原则分析" class="headerlink" title="依赖倒转原则分析"></a>依赖倒转原则分析</h4><ol>
<li>简单来说，依赖倒转原则就是指：<strong>代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程</strong>。</li>
<li>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说<strong>开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段</strong>。</li>
<li>依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件<ul>
<li><strong>将抽象放进代码，将细节放进元数据</strong></li>
<li><strong>Put Abstractions in Code, Details in Metadata</strong></li>
</ul>
</li>
<li>类之间的耦合<ul>
<li><strong>零耦合</strong>关系：最好情况，但是不切实际</li>
<li><strong>具体耦合</strong>关系</li>
<li><strong>抽象耦合</strong>关系：依赖倒转要求至少一端是抽象的</li>
</ul>
</li>
<li>依赖倒转原则要求客户端依赖于抽象耦合，<strong>以抽象方式耦合是依赖倒转原则的关键</strong>。</li>
</ol>
<h4 id="依赖倒转原则实例"><a href="#依赖倒转原则实例" class="headerlink" title="依赖倒转原则实例"></a>依赖倒转原则实例</h4><p>某系统提供一个数据转换模块，可以将来自不同数据源的数据转换成多种格式，如可以转换来自数据库的数据(DatabaseSource)、也可以转换来自文本文件的数据(TextSource)，转换后的格式可以是XML文件(XMLTransformer)、也可以是XLS文件(XLSTransformer)等。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/11.png" alt="img" style="zoom:50%;" /></p>
<p>由于需求的变化，该系统可能需要增加新的数据源或者新的文件格式，每增加一个新的类型的数据源或者新的类型的文件格式，客户类MainClass都需要修改源代码，以便使用新的类，但违背了开闭原则。现使用依赖倒转原则对其进行重构。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/12.png" alt="img" style="zoom:50%;" /></p>
<h3 id="1-6-接口隔离原则"><a href="#1-6-接口隔离原则" class="headerlink" title="1.6 接口隔离原则"></a>1.6 接口隔离原则</h3><h4 id="接口隔离原则定义"><a href="#接口隔离原则定义" class="headerlink" title="接口隔离原则定义"></a>接口隔离原则定义</h4><p>接口隔离原则(Interface Segregation Principle, ISP)的定义如下：</p>
<ul>
<li><p>客户端<strong>不应该依赖</strong>那些<strong>它不需要的接口</strong>。</p>
</li>
<li><p>Clients should not be forced to depend upon interfaces that they do not use.</p>
</li>
<li><p>注意，在该定义中的接口指的是所定义的方法。</p>
</li>
</ul>
<p>另一种定义方法如下：</p>
<ul>
<li>一旦一个<strong>接口太大</strong>，则需要将它<strong>分割成一些更细小的接口</strong>，使用该接口的客户端仅需知道与之相关的方法即可。</li>
<li>Once an interface has gotten too ‘fat’ it needs to be <strong>split into smaller and more specific interfaces</strong> so that any clients of the interface will only know about the methods that pertain to them.</li>
</ul>
<h4 id="接口隔离原则分析"><a href="#接口隔离原则分析" class="headerlink" title="接口隔离原则分析"></a>接口隔离原则分析</h4><ol>
<li>接口隔离原则是指<strong>使用多个专门的接口，而不使用单一的总接口</strong>。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。<ol>
<li>一个接口就<strong>只代表一个角色</strong>，每个角色都有它特定的一个接口，此时这个原则可以叫做”角色隔离原则”。</li>
<li>接口<strong>仅仅提供客户端需要的行为</strong>，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li>
</ol>
</li>
<li>使用接口隔离原则拆分接口时，首先必须满足<strong>单一职责原则</strong>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</li>
<li>可以在进行系统设计时采用<strong>定制服务</strong>的方式，即<strong>为不同的客户端提供宽窄不同的接口</strong>，只提供用户需要的行为，而隐藏用户不需要的行为。</li>
</ol>
<h4 id="接口隔离原则实例"><a href="#接口隔离原则实例" class="headerlink" title="接口隔离原则实例"></a>接口隔离原则实例</h4><p>下图展示了一个拥有多个客户类的系统，在系统中定义了一个巨大的接口（胖接口）AbstractService来服务所有的客户类。可以使用接口隔离原则对其进行重构。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/13.png" alt="img" style="zoom:50%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230610221325326.png" alt="image-20230610221325326"></p>
<h3 id="1-7-合成复用原则"><a href="#1-7-合成复用原则" class="headerlink" title="1.7 合成复用原则"></a>1.7 合成复用原则</h3><h4 id="合成复用原则定义"><a href="#合成复用原则定义" class="headerlink" title="合成复用原则定义"></a>合成复用原则定义</h4><p>合成复用原则(Composite Reuse Principle, CRP)又称为组合/聚合复用原则(Composition/ Aggregate Reuse Principle,CARP)</p>
<p>其定义如下：</p>
<ul>
<li><p><strong>尽量使用对象组合</strong>，而<strong>不是继承</strong>来达到复用的目的。</p>
</li>
<li><p>Favor composition of objects over inheritance as a reuse mechanism.</p>
</li>
</ul>
<h4 id="合成复用原则分析"><a href="#合成复用原则分析" class="headerlink" title="合成复用原则分析"></a>合成复用原则分析</h4><ol>
<li>合成复用原则就是指在一个新的对象里通过<strong>关联关系（包括组合关系和聚合关系）</strong>来使用一些已有的对象，使之成为新对象的一部分；新对象<strong>通过委派调用已有对象的方法达到复用其已有功能的目的</strong>。简言之：<strong>要尽量使用组合/聚合关系，少用继承</strong>。</li>
<li>在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过<strong>组合/聚合关系</strong>或通过<strong>继承</strong>。<ul>
<li><em>继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（”<strong>白箱</strong>“复用）</em></li>
<li><em>组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（”<strong>黑箱</strong>“复用）</em></li>
</ul>
</li>
<li>组合/聚合可以<strong>使系统更加灵活</strong>，类与类之间的<strong>耦合度降低</strong>，一个类的变化对其他类造成的影响相对较少，因此一般<strong>首选使用组合/聚合来实现复用</strong>；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要<strong>慎重使用继承复用</strong>。</li>
</ol>
<h4 id="合成复用原则实例"><a href="#合成复用原则实例" class="headerlink" title="合成复用原则实例"></a>合成复用原则实例</h4><p>某教学管理系统部分数据库访问类设计如图所示</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230610221538019.png" alt="image-20230610221538019"></p>
<p>如果需要更换数据库连接方式，如原来采用 JDBC 连接数据库，现在采用数据库连接池连接，则需要修改DBUtil类源代码。如果 StudentDAO 采用 JDBC 连接，但是 TeacherDAO 采用连接池连接，则需要增加一个新的 DBUtil 类，并修改 StudentDAO 或 TeacherDAO 的源代码，使之继承新的数据库连接类，这将违背开闭原则，系统扩展性较差。</p>
<p>现使用合成复用原则对其进行重构。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/16.png" alt="img" style="zoom: 50%;" /></p>
<h3 id="1-8-最小知识原则-迪米特法则"><a href="#1-8-最小知识原则-迪米特法则" class="headerlink" title="1.8 最小知识原则(迪米特法则)"></a>1.8 最小知识原则(迪米特法则)</h3><h4 id="迪米特法则定义"><a href="#迪米特法则定义" class="headerlink" title="迪米特法则定义"></a>迪米特法则定义</h4><p>迪米特法则(Law of Demeter, LoD)又称为最少知识原则(Least Knowledge Principle, LKP)，它有多种定义方法，其中几种典型定义如下：</p>
<ol>
<li><strong>不要和”陌生人”说话</strong>。<ul>
<li>Don’t talk to strangers.</li>
</ul>
</li>
<li><strong>只与你的直接朋友通信</strong>。<ul>
<li>Talk only to your immediate friends.</li>
</ul>
</li>
<li><strong>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。<ul>
<li>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.</li>
</ul>
</li>
</ol>
<h4 id="迪米特法则分析"><a href="#迪米特法则分析" class="headerlink" title="迪米特法则分析"></a>迪米特法则分析</h4><ol>
<li><p>简单地说，迪米特法则就是指<strong>一个软件实体应当尽可能少的与其他实体发生相互作用</strong>。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。</p>
</li>
<li><p>在迪米特法则中，对于一个对象，其<strong>朋友</strong>包括以下几类：</p>
<ol>
<li>当前对象本身(this)</li>
<li>以参数形式传入到当前对象方法中的对象</li>
<li>当前对象的成员对象</li>
<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li>
<li>当前对象所创建的对象。</li>
</ol>
</li>
<li><p>任何一个对象，如果满足上面的条件之一，就是当前对象的”朋友”，否则就是”陌生人”。</p>
</li>
<li><p>迪米特法则可分为狭义法则和广义法则。在<strong>狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用</strong>，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过<strong>第三者转发这个调用</strong>。下图中，只允许 A 调用 B 对象的方法，但是不能调用 C 对象的方法(但是我们可以通过在 B 中添加一个 Wrapper 方法来间接调用 C)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/17.png" alt="img" style="zoom:50%;" /></p>
</li>
<li><p>狭义的迪米特法则：可以<strong>降低类之间的耦合</strong>，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会<strong>造成系统的不同模块之间的通信效率降低</strong>，使得系统的不同模块之间不容易协调。</p>
</li>
<li><p>广义的迪米特法则：指<strong>对对象之间的信息流量、流向以及信息的影响的控制</strong>，主要是<strong>对信息隐藏的控制</strong>。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。</p>
</li>
<li><p>迪米特法则的主要用途在于控制信息的过载：</p>
<ul>
<li>在类的划分上，应当尽量<strong>创建松耦合的类</strong>，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及</li>
<li>在类的结构设计上，每一个类都应当<strong>尽量降低其成员变量和成员函数的访问权限</strong></li>
<li>在类的设计上，只要有可能，<strong>一个类型应当设计成不变类</strong></li>
<li>在对其他类的引用上，<strong>一个对象对其他对象的引用应当降到最低</strong></li>
</ul>
</li>
</ol>
<h4 id="迪米特法则实例"><a href="#迪米特法则实例" class="headerlink" title="迪米特法则实例"></a>迪米特法则实例</h4><p>某系统界面类(如Form1、Form2等类)与数据访问类(如DAO1、DAO2等类)之间的调用关系较为复杂，如图所示：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/18.png" alt="img" style="zoom:50%;" /></p>
<p>使用迪米特法则修改</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/19.png" alt="img" style="zoom: 50%;" /></p>
<h3 id="1-9-小结"><a href="#1-9-小结" class="headerlink" title="1.9 小结"></a>1.9 小结</h3><ul>
<li>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</li>
<li>软件的复用可以提高软件的开发效率，提高软件质量，节约开发成本，恰当的复用还可以改善系统的可维护性。</li>
<li>单一职责原则要求在软件系统中，一个类只负责一个功能领域中的相应职责。</li>
<li>开闭原则要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</li>
<li><p>里氏代换原则可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p>
</li>
<li><p>依赖倒转原则要求抽象不应该依赖于细节，细节应该依赖于抽象；要针对接口编程，不要针对实现编程。</p>
</li>
<li>接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</li>
<li>合成复用原则要求复用时尽量使用对象组合，而不使用继承。</li>
<li><p>迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。</p>
</li>
<li><p>目标：开闭原则</p>
</li>
<li>指导：最小知识原则</li>
<li>基础：单一职责原则、可变性封装原则</li>
<li>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</li>
</ul>
<h2 id="2-设计模式概述"><a href="#2-设计模式概述" class="headerlink" title="2. 设计模式概述"></a>2. 设计模式概述</h2><p><a target="_blank" rel="noopener" href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Lec02-Strategy%20Pattern/">It is started with a simple SimUDuck application</a></p>
<h3 id="2-1-设计原则"><a href="#2-1-设计原则" class="headerlink" title="2.1 设计原则"></a>2.1 设计原则</h3><ul>
<li>封装各种变化<ul>
<li>对应实现的原则：<strong>开闭原则</strong></li>
</ul>
</li>
<li>面向接口编程，而不是面向实现<ul>
<li>对应实现的原则：<strong>依赖倒转原则</strong></li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302005659071.png" alt="image-20230302005659071" style="zoom:80%;" /></p>
<h3 id="2-2-HAS-A可以比IS-A更好"><a href="#2-2-HAS-A可以比IS-A更好" class="headerlink" title="2.2 HAS-A可以比IS-A更好"></a>2.2 HAS-A可以比IS-A更好</h3><blockquote>
<p>优先考虑组合而不是继承</p>
</blockquote>
<ol>
<li>组合提供了更多的灵活性</li>
<li>它不仅可以将一个算法族封装到自己的类集中，而且还可以在运行时更改行为</li>
</ol>
<h3 id="2-3-引入设计模式的作用"><a href="#2-3-引入设计模式的作用" class="headerlink" title="2.3 引入设计模式的作用"></a>2.3 引入设计模式的作用</h3><h4 id="2-3-1-共享词汇"><a href="#2-3-1-共享词汇" class="headerlink" title="2.3.1 共享词汇"></a>2.3.1 共享词汇</h4><ul>
<li>设计模式为您提供了与其他开发人员共享的词汇表。</li>
<li>通过让您在<strong>模式级别</strong>(而不是实质性对象级别)进行思考，还可以提高您对体系结构的思考。</li>
</ul>
<h4 id="2-3-2-共享模式词汇的力量"><a href="#2-3-2-共享模式词汇的力量" class="headerlink" title="2.3.2 共享模式词汇的力量"></a>2.3.2 共享模式词汇的力量</h4><ul>
<li>共享模式词汇很强大<ul>
<li>当您使用模式与其他开发人员或团队进行沟通时，您不仅在沟通模式名称，还传达了模式所代表的整套质量属性，特征和约束</li>
</ul>
</li>
<li>模式可以让您用更少的话表达更多。<ul>
<li>当您在描述中使用模式时，其他开发人员会快速准确地了解您所考虑的设计。</li>
</ul>
</li>
<li>在模式级别进行交谈可以使您在”设计中”停留的时间更长。<ul>
<li>不要迷失在细节中。</li>
</ul>
</li>
<li>共享词汇可以为您的开发团队提供强大的动力。</li>
<li>共享的词汇表鼓励更多的初级开发人员快速上手。</li>
</ul>
<h3 id="2-4-如何使用设计模式"><a href="#2-4-如何使用设计模式" class="headerlink" title="2.4 如何使用设计模式"></a>2.4 如何使用设计模式</h3><ul>
<li>依赖库和框架：提供了全部和必要的功能，一般可以直接直接复用</li>
<li>设计模式帮助我们构建自己的应用程序，以使其更具可维护性和灵活性</li>
<li>设计模式首先进入你的大脑</li>
</ul>
<h4 id="2-4-1-工具"><a href="#2-4-1-工具" class="headerlink" title="2.4.1 工具"></a>2.4.1 工具</h4><ul>
<li>面向对象的基础 OO Basics<ul>
<li>抽象 Abstraction</li>
<li>封装 Encapsulation</li>
<li>多态性 Polymorphism</li>
<li>继承 Inheritance</li>
</ul>
</li>
<li>面向对象原则 OO Principles<ul>
<li>封装可变性 Encapsulate what varies</li>
<li>选择组合而不是继承 Favor composition over inheritance</li>
<li>面向接口编程，而不是面向实现编程 Program to interfaces, not implementation</li>
</ul>
</li>
<li>面向对象模式 OO Patterns：<ul>
<li>策略 Strategy</li>
</ul>
</li>
</ul>
<h3 id="2-5-软件模式"><a href="#2-5-软件模式" class="headerlink" title="2.5 软件模式"></a>2.5 软件模式</h3><p>软件模式是将模式的一般概念应用于软件开发领域，即<strong>软件开发的总体指导思路或参照样板</strong>。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，<strong>在软件生存期的每一个阶段都存在着一些被认同的模式</strong>。</p>
<p>软件模式可以认为是<strong>对软件开发这一特定“问题”的“解法”的某种统一表示</strong>，<strong>软件模式等于一定条件下的出现的问题以及解法</strong>。软件模式的基础结构由 4 个部分构成：<strong>问题描述</strong>、<strong>前提条件（环境或约束条件）</strong>、<strong>解法</strong>和<strong>效果</strong>。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230613143450535.png" alt="image-20230613143450535" style="zoom:80%;" /></p>
<p>软件模式与具体的应用领域无关，在模式发现过程中需要遵循<strong>大三律(Rule of Three)</strong>，即只有经过<strong>三个以上不同类型（或不同领域）的系统</strong>的校验，一个解决方案才能从候选模式升格为模式。</p>
<h3 id="2-6-设计模式"><a href="#2-6-设计模式" class="headerlink" title="2.6 设计模式"></a>2.6 设计模式</h3><h4 id="2-6-1-定义"><a href="#2-6-1-定义" class="headerlink" title="2.6.1 定义"></a>2.6.1 定义</h4><p><strong>设计模式(Design Pattern)</strong>是一套<strong>被反复使用、多数人知晓的、经过分类编目的代码设计经验的总结</strong>，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
<h4 id="2-6-2-基本要素"><a href="#2-6-2-基本要素" class="headerlink" title="2.6.2 基本要素"></a>2.6.2 基本要素</h4><p>设计模式一般有如下几个<strong>基本要素</strong>：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素包括以下四个方面：</p>
<ul>
<li><strong>模式名称</strong> (Pattern name)</li>
<li><strong>问题</strong> (Problem)</li>
<li><strong>解决方案</strong> (Solution)</li>
<li><strong>效果</strong> (Consequences) </li>
</ul>
<h4 id="2-6-3-分类"><a href="#2-6-3-分类" class="headerlink" title="2.6.3 分类"></a>2.6.3 分类</h4><p>根据其<strong>目的</strong>（模式是用来做什么的）可分为<strong>创建型 (Creational)</strong>，<strong>结构型 (Structural)</strong>和<strong>行为型 (Behavioral)</strong>三种：</p>
<ul>
<li>创建型模式主要用于<strong>创建对象</strong>。</li>
<li>结构型模式主要用于<strong>处理类或对象的组合</strong>。</li>
<li>行为型模式主要用于<strong>描述对类或对象怎样交互和怎样分配职责</strong>。</li>
</ul>
<p>根据<strong>范围</strong>，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为<strong>类模式</strong>和<strong>对象模式</strong>两种：</p>
<ul>
<li>类模式<strong>处理类和子类之间的关系</strong>，这些关系通过<strong>继承</strong>建立，在编译时刻就被确定下来，是属于<strong>静态</strong>的。</li>
<li>对象模式<strong>处理对象间的关系</strong>，这些关系在运行时刻变化，更具<strong>动态</strong>性。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627114431082.png" alt="image-20230627114431082" style="zoom:80%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/13/Linux%E9%87%8D%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/Linux%E9%87%8D%E7%82%B9/" class="post-title-link" itemprop="url">Linux程序设计考试重点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-13 14:01:40" itemprop="dateCreated datePublished" datetime="2023-04-13T14:01:40+08:00">2023-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">Linux程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ch1-1-linux-basics"><a href="#ch1-1-linux-basics" class="headerlink" title="ch1-1 linux basics"></a>ch1-1 linux basics</h3><h4 id="谈谈linux理解"><a href="#谈谈linux理解" class="headerlink" title="谈谈linux理解"></a>谈谈linux理解</h4><p>linux是根据 GNU GPL 开发的免费类 Unix 操作系统。开源，受欢迎，支持大多数可用平台</p>
<p>创始人：Linus</p>
<p>发行版包括ubuntu、centos、debian、red hat等</p>
<h4 id="mbr，gpt"><a href="#mbr，gpt" class="headerlink" title="mbr，gpt"></a>mbr，gpt</h4><p>mbr</p>
<ul>
<li>在基于Intel的计算机上必须进行分区</li>
<li><strong>最多四个主分区</strong></li>
<li>一个主分区可以是扩展分区</li>
<li>扩展分区可以容纳无限数量的逻辑分区(Linux：最大59)</li>
</ul>
<p>gpt</p>
<ul>
<li>保留的 MBR 是为了在较老的机器上也能读取到磁盘上的信息</li>
<li>GPT 是 MBR 不够用了才会选择使用</li>
<li><strong>支持上百个主分区，不需要扩展分区(支持超过128，但是windows限制128)</strong></li>
<li>Header记录Entry信息，Entry记录Partition信息，形成三级结构</li>
<li><strong>Secondary GPT 是备份，因此 GPT 相较于 MBR 方式会有更多的空间无法使用</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230214162723879.png" alt="image-20230214162723879" style="zoom:67%;" /></p>
<h4 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h4><ul>
<li>操作系统中负责存取和管理文件的部分</li>
<li>VFS, EXT2, EXT3, FAT32</li>
</ul>
<h4 id="bootloader只要求grub"><a href="#bootloader只要求grub" class="headerlink" title="bootloader只要求grub"></a>bootloader只要求grub</h4><ul>
<li>程序存储在 MBR (第一阶段) 和 /boot/grub (第1.5和第二阶段) 中</li>
<li>了解文件系统结构；无需像LILO一样激活配置</li>
<li>配置文件：/boot/grub/grub.cfg<ul>
<li>最重要就是配置内核和init文件的位置</li>
</ul>
</li>
<li>通过grub-install安装在MBR中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs grub.cfg">title Ubuntu, kernel 2.6.20-16-generic<br>root (hd0,1)<br>kernel /boot/vmlinuz-2.6.20-16-generic root=UUID=3f784cd9-516f-4808-a601-b19356f6bdea ro quiet splash locale=zh_CN vga=0x318 // 内核与参数<br>initrd /boot/initrd.img-2.6.20-16-generic // init程序<br></code></pre></td></tr></table></figure>
<h4 id="编译开源软件流程"><a href="#编译开源软件流程" class="headerlink" title="编译开源软件流程"></a>编译开源软件流程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译源代码安装软件：automake模式</span><br>tar zxvf application.tar.gz<br><span class="hljs-built_in">cd</span> application<br>./configure<br>make<br>su - <span class="hljs-comment"># 只有make install需要切换root权限</span><br>make install <span class="hljs-comment"># 将编译后的二进制码安装到系统</span><br><br><span class="hljs-comment"># cmake模式</span><br>tar zxvf application.tar.gz<br><span class="hljs-built_in">cd</span> application<br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake ..	<span class="hljs-comment"># cmake后面跟application目录，..即上级目录</span><br>make VERBOSE=1	<span class="hljs-comment"># VERBOSE参数可选，仅多打印一些东西</span><br>su -<br>make install<br></code></pre></td></tr></table></figure>
<h4 id="命令行提示符"><a href="#命令行提示符" class="headerlink" title="命令行提示符"></a>命令行提示符</h4><ul>
<li>可以自己配置<ul>
<li>修改环境变量: <code>export SUDO_PS1=&quot;\u@\h:\w\$&quot;</code>, <code>export PS1=&quot;\u@\h:\w\$&quot;</code></li>
</ul>
</li>
<li><code>$</code>：以普通用户身份登录</li>
<li><code>#</code>：以root身份登录</li>
</ul>
<h4 id="所有ppt出现的命令"><a href="#所有ppt出现的命令" class="headerlink" title="所有ppt出现的命令"></a>所有ppt出现的命令</h4><ul>
<li>passwd：更改密码</li>
<li>mkpasswd：生成随机密码</li>
<li>date，cal：找出今天的日期并显示日历</li>
<li>who，finger：找出还有谁在系统上处于活动状态</li>
<li>clear：清除屏幕</li>
<li>echo：在屏幕上写一条消息</li>
<li>write、wall、talk、mesg<ul>
<li>write：给其他用户发信息</li>
<li>wall：write all, 给所有登录到系统的用户发信息</li>
<li>talk：建立聊天session</li>
<li>mesg：可以屏蔽用户发来的信息</li>
</ul>
</li>
<li>pwd：当前目录</li>
<li>cd：更改目录</li>
<li>mkdir：创建目录</li>
<li>rmdir：删除目录</li>
<li>ls -l -i -R -a</li>
<li>touch：更新文件的访问, 修改时间</li>
<li>cp：复制文件</li>
<li>mv：移动并重命名文件</li>
<li>ln：链接文件</li>
<li>rm：删除文件</li>
<li>cat：打印文件内容</li>
<li>more/less：逐页显示文件，more不可以回退，less可以回退</li>
<li>ps：报告进程状态</li>
<li>pstree：显示进程树</li>
<li>jobs, fg, bg, ctrl-z：作业控制<ul>
<li>bg: 后台执行</li>
<li>fg: 前台执行</li>
<li>ctrl-z: 暂停进程, 可通过fg, bg恢复</li>
</ul>
</li>
<li>kill：杀死进程</li>
<li>nohup：运行命令，忽略挂起信号</li>
<li>nice，renice：修改进程优先级</li>
<li><p>top：查看进程的cpu占用</p>
</li>
<li><p>文件操作</p>
<ul>
<li>列出目录内容: ls, (dir, vdir 与ls功能类似)</li>
<li>创建特殊文件: mkdir, mknod, mkfifo<ul>
<li>mknod: 创建设备文件</li>
<li>mkfifo: 创建管道</li>
</ul>
</li>
<li>文件操作: cp, mv, rm</li>
<li>修改文件属性: chmod, chown, chgrp, touch<ul>
<li>chown: 改文件拥有者、用户组</li>
<li>chgrp: 更改用户组</li>
</ul>
</li>
<li>查找文件: (locate), find<ul>
<li>locate: 功能和 find 类似</li>
</ul>
</li>
<li>字符串匹配: grep(egrep)<ul>
<li>grep: 在文本文件中搜索字符串</li>
<li>egrep: grep 扩展</li>
</ul>
</li>
<li>其它: pwd, cd, ar, file, tar, more, less, head, tail, cat<ul>
<li>ar: 打包库文件</li>
<li>file: 显示文件类型</li>
<li>more, less: 一页页显示</li>
<li>head, tail: 显示文件头部、尾部</li>
</ul>
</li>
</ul>
</li>
<li>进程操作：ps, kill, jobs, fg, bg, nice</li>
<li>其它<ul>
<li>who, whoami, passwd, su, uname, …<ul>
<li>whoami: 当前用户名</li>
<li>uname: 显示内核信息</li>
</ul>
</li>
<li>man</li>
</ul>
</li>
</ul>
<h4 id="七种文件类型必考"><a href="#七种文件类型必考" class="headerlink" title="七种文件类型必考"></a>七种文件类型必考</h4><ul>
<li>普通文件(regular file)：<ul>
<li>文本或代码数据；没有特别的内部结构</li>
</ul>
</li>
<li>字符型设备文件(character special file)</li>
<li>块型设备文件(block special file)<ul>
<li>special files：代表硬件或逻辑设备</li>
<li>位于 /dev 目录</li>
</ul>
</li>
<li>网络接口(socket)</li>
<li>符号链接(symbolic link)<ul>
<li>软链接：类似windows上的快捷方式</li>
<li>硬链接：<strong>同一个文件有两个文件名</strong>，创建出来的硬链接不占用磁盘空间和inode号。</li>
</ul>
</li>
<li>目录(directory)：该目录中的文件列表</li>
<li>管道(fifo)</li>
</ul>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230227143638153.png" alt="image-20230227143638153"></p>
<ul>
<li><code>/boot</code>：内核、bootloader的配置，包括引导加载程序相关的文件。内核的initrd、vmlinux、grub文件位于/boot下。</li>
<li><code>/etc</code>：系统的配置文件所在地，下载软件的配置文件在也在这里，包含所有程序所需的配置文件</li>
<li><code>/bin</code>：程序文件夹，包含二进制可执行文件，例如<code>ls</code>，其实是在执行一个程序；也有一部分程序在<code>/usr/bin</code>(在我的linux上，/bin是/usr/bin的软链接)</li>
<li><code>/mnt</code>：<strong>挂载目录</strong>，临时挂载目录，系统管理员可以挂载文件系统。</li>
<li><code>/sbin</code>：系统二进制文件，但是这个目录下的Linux命令通常<strong>由系统管理员使用，对系统进行维护</strong>，例如<code>ifconfig/fdisk</code>也有部分程序在<code>/sbin</code>，例如分区命令<code>fdisk</code></li>
<li><code>/usr</code>：资源文件夹(和编程相关的)；编译器、默认的头文件、系统中的库文件，包含二进制文件、库文件、文档和二级程序的源代码<ul>
<li><code>/usr/bin</code>中包含用户程序的二进制文件。<code>/bin</code></li>
<li><code>/usr/sbin</code>中包含系统管理员的二进制文件。<code>/sbin</code></li>
<li><code>/usr/lib</code>中包含了<code>/usr/bin</code>和<code>/usr/sbin</code>用到的库。</li>
<li><code>/usr/local</code>中包含了从源安装的用户程序。</li>
</ul>
</li>
<li><code>/lib</code>：系统库。包含<strong>支持位于/bin和/sbin下的二进制文件的库文件</strong>；库文件名为 <code>ld*或lib*.so.*</code></li>
<li><code>/proc</code>：包括<strong>系统进行相关信息</strong>。这是一个虚拟的文件系统，包含有关正在运行的进程的信息；系统资源以文本信息形式存在。</li>
<li><code>/var</code>：系统里的可变数据，变量文件，并不是存放在磁盘上的数据，一般是存放在内存中的数据。<ul>
<li>系统日志文件<code>/var/log</code></li>
<li>包和数据库文件<code>/var/lib</code></li>
<li>电子邮件<code>/var/mail</code></li>
<li>打印队列<code>/var/spool</code></li>
<li>锁文件<code>/var/lock</code></li>
<li>多次重新启动需要的临时文件<code>/var/tmp</code></li>
</ul>
</li>
<li><code>/dev</code>：包含<strong>设备文件</strong>，这些包括终端设备、USB或连接到系统的任何设备。例如<code>/dev/tty1</code></li>
<li><code>/tmp</code>：包含系统和用户创建的<strong>临时文件</strong>，当系统重新启动时，这个目录下的文件都将被删除。</li>
<li><code>/home</code>：用home目录来存储他们的个人档案。</li>
<li><code>/opt</code>：可选的附加应用程序</li>
<li><code>/media</code>：用于挂载<strong>可移动设备</strong>的临时目录。举例来说，挂载CD-ROM的/media/cdrom，挂载软盘驱动器的/media/floppy</li>
<li><code>/srv</code>：srv代表服务。包含服务器特定服务相关的数据。</li>
<li>修改环境变量PATH，临时修改可以直接<code>PATH=$PATH:/bin</code>，但是要永久生效得修改配置文件<code>/etc/profile</code></li>
</ul>
<h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><ul>
<li>三个访问级别：<ol>
<li>用户(User)：创建文件的用户</li>
<li>组(Group)：拥有文件的组中的所有用户</li>
<li>其他(Others)：其他</li>
</ol>
</li>
<li>三个权限：<ol>
<li>读取(r)：读取文件内容或目录内容</li>
<li>写(w)：更改文件内容或在目录中创建/删除文件</li>
<li>执行(x)：以程序执行文件或使用目录作为活动目录</li>
</ol>
</li>
<li><code>ls -l</code></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230227153229304.png" alt="image-20230227153229304"></p>
<ul>
<li><code>chmod &lt;who operator what&gt; filename</code><ul>
<li>who:<ul>
<li><code>u</code> = owner of file</li>
<li><code>g</code> = group</li>
<li><code>o</code> = other users on the system</li>
<li><code>a</code> = all(u + g + o)</li>
</ul>
</li>
<li>operator:<ul>
<li><code>+</code> = add permission</li>
<li><code>-</code> = remove permission</li>
<li><code>=</code> = clear permissions and set to mode specified</li>
</ul>
</li>
<li>what: <code>r, w, x</code></li>
</ul>
</li>
<li><code>chmod &lt;number&gt; file</code></li>
<li>Default File Permissions</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>权限</th>
<th>数字权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>File</td>
<td>-rw-r—r—</td>
<td>644</td>
</tr>
<tr>
<td>Directory</td>
<td>drwxr-xr-x</td>
<td>755</td>
</tr>
</tbody>
</table>
</div>
<h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><ul>
<li>进程是一个正在执行的程序实例。由执行程序，它的当前值，状态信息以及通过操作系统管理此进程执行情况的资源组成。</li>
</ul>
<h4 id="man，info"><a href="#man，info" class="headerlink" title="man，info"></a>man，info</h4><ul>
<li><p>man</p>
<ul>
<li><p>使用 man 命令，您可以阅读命令的手册页</p>
</li>
<li><p>手册页存储在 /usr/man</p>
</li>
</ul>
</li>
<li><p>info</p>
<ul>
<li><p>用于阅读文档的程序，有时可以代替手册页</p>
</li>
<li><p>有关信息的信息存储在 /usr/info</p>
</li>
</ul>
</li>
</ul>
<h4 id="linux层次图"><a href="#linux层次图" class="headerlink" title="linux层次图"></a>linux层次图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230303104322848.png" alt="image-20230303104322848" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230303105118990.png" alt="image-20230303105118990" style="zoom:80%;" /></p>
<h3 id="ch1-2-linux-basics"><a href="#ch1-2-linux-basics" class="headerlink" title="ch1-2 linux basics"></a>ch1-2 linux basics</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><ul>
<li>标准输入、标准输出、标准错误<ul>
<li>对应的文件描述符：0, 1, 2</li>
<li>C语言变量：stdin, stdout, stderr</li>
</ul>
</li>
<li><code>&lt;</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code>, <code>2&gt;&gt;</code>, <code>&amp;&gt;</code><ul>
<li>例: <code>kill –HUP 1234 &gt; killout.txt 2&gt; killerr.txt</code></li>
<li>例: <code>kill –HUP 1234 &gt; killout.txt 2&gt;&amp;1</code><ul>
<li><code>&amp;1</code>: 1号fd, 不加&amp;会重定向到名称为1的文件</li>
<li>为什么需要将标准错误重定向到标准输出: 标准错误没有缓冲区，⽽stdout有</li>
</ul>
</li>
<li><code>&lt;</code>: 重定向 0号fd</li>
<li><code>&gt;</code>: 重定向内容会覆盖掉文件, 默认重定向 1号fd</li>
<li><code>&gt;&gt;</code>: 重定向内容追加到文件末尾, 默认重定向 1号fd</li>
<li><code>2&gt;</code>: 只重定向 2号fd 的内容</li>
<li><code>&amp;&gt;</code>: 重定向 1,2号fd</li>
</ul>
</li>
</ul>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul>
<li>一个进程的输出作为另一个进程的输入</li>
<li>存在一个管道文件，这个文件作为输入传递给后面的命令</li>
<li>例:<ul>
<li><code>ls | wc –l</code></li>
<li><code>ls –lF | grep ^d</code></li>
<li><code>ar t /usr/lib/libc.a | grep printf | pr -4 -t</code></li>
</ul>
</li>
</ul>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul>
<li>环境变量<ul>
<li>操作环境的参数</li>
<li>查看和设置环境变量：echo, env, set<ul>
<li>env: 显示所有环境变量</li>
<li>set: 设置环境变量</li>
</ul>
</li>
</ul>
</li>
<li>例: PATH环境变量<ul>
<li><code>echo $PATH</code></li>
<li><code>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/song/bin</code></li>
<li><code>PATH=$PATH:.</code></li>
<li><code>export PATH</code></li>
</ul>
</li>
</ul>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>可能会出道简单题</p>
<h3 id="ch2-shell-programming"><a href="#ch2-shell-programming" class="headerlink" title="ch2 shell programming"></a>ch2 shell programming</h3><p>只考bash，知道有其他shell就行</p>
<h4 id="三种执行脚本方法"><a href="#三种执行脚本方法" class="headerlink" title="三种执行脚本方法"></a>三种执行脚本方法</h4><p>方法一：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh script_file <br></code></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x script_file(<span class="hljs-built_in">chown</span>, <span class="hljs-built_in">chgrp</span> optionally)<br>./script_file<br></code></pre></td></tr></table></figure>
<p>方法三：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> script_file<br>. script_file<br></code></pre></td></tr></table></figure>
<blockquote>
<p>方法一二原理相同：新启bash进程执行脚本</p>
<p>方法三使用当前bash进程执行脚本</p>
</blockquote>
<h4 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Enter your name: &quot;</span>       <span class="hljs-comment"># 参数-n的作用是不换行，echo默认是换行</span><br><span class="hljs-built_in">read</span> name                         <span class="hljs-comment">#从键盘输入</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello <span class="hljs-variable">$name</span>, welcome to my program&quot;</span><br><span class="hljs-built_in">exit</span> 0                            <span class="hljs-comment">#退出shell程序。</span><br><br><span class="hljs-comment">#! /bin/bash</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter your name:&quot;</span> name   <span class="hljs-comment">#-p参数，允许在read命令行中直接指定一个提示</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a number:&quot;</span> number<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$number</span><br><span class="hljs-built_in">exit</span> 0<br><br><span class="hljs-comment">#! /bin/bash</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">read</span> -t 5 -p <span class="hljs-string">&quot;please enter your name:&quot;</span> name  <span class="hljs-comment"># 5s内输入</span><br><span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello <span class="hljs-variable">$name</span>， welcome to my script&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sorry, too slow&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">exit</span> 0<br><br><span class="hljs-comment">#! /bin/bash</span><br><span class="hljs-built_in">read</span> -n1 -p <span class="hljs-string">&quot;Do you want to continue [Y/N] ?&quot;</span> answer <span class="hljs-comment"># 只读取一个字符</span><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$answer</span> <span class="hljs-keyword">in</span><br>Y|y)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;fine, continue&quot;</span>;;<br>N|n)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ok, good bye&quot;</span>;;<br>*)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;error choice&quot;</span>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">exit</span> 0<br><br><span class="hljs-comment">#! /bin/bash</span><br><span class="hljs-built_in">read</span> -s -p <span class="hljs-string">&quot;Enter your password: &quot;</span> pass	<span class="hljs-comment"># 不显示输入</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;your password is <span class="hljs-variable">$pass</span>&quot;</span><br><span class="hljs-built_in">exit</span> 0<br><br><span class="hljs-comment">#! /bin/bash</span><br>count=1<br><span class="hljs-built_in">cat</span> viewFile.sh| <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$count</span>:<span class="hljs-variable">$line</span>&quot;</span><br>  count=$((<span class="hljs-variable">$count</span> + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Total Count:<span class="hljs-variable">$count</span>&quot;</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<h4 id="引号的用法"><a href="#引号的用法" class="headerlink" title="引号的用法"></a>引号的用法</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412225511774.png" alt="image-20230412225511774"></p>
<h4 id="用户变量、环境变量，参数变量"><a href="#用户变量、环境变量，参数变量" class="headerlink" title="用户变量、环境变量，参数变量"></a>用户变量、环境变量，参数变量</h4><p>环境变量</p>
<ul>
<li><code>$HOME</code>: 当前用户的登陆目录</li>
<li><code>$PATH</code>: 以冒号分隔的用来搜索命令的目录清单</li>
<li><code>$PS1</code>：命令行提示符，通常是 “$” 字符</li>
<li><code>$PS2</code>：辅助提示符，用来提示后续输入，通常是 “&gt;” 字符</li>
<li><code>$IFS</code>：输入区分隔符。当 shell 读取输入数据时会把一组字符看成是单词之间的分隔符，通常是空格、制表符、换行符等。</li>
</ul>
<p>参数变量和内部变量</p>
<ul>
<li><code>$#</code>: 传递到脚本程序的参数个数</li>
<li><code>$0</code>: 脚本程序的名字</li>
<li><code>$1,$2,..</code>: 脚本程序的参数</li>
<li><code>$*</code>: 一个全体参数组成的清单，它是一个独立的变量，各个参数之间用环境变量IFS中的第一个字符分隔开</li>
<li><code>$@</code>: “$*”的一种变体，它不使用IFS环境变量。</li>
</ul>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412230512655.png" alt="image-20230412230512655" style="zoom:80%;" /></p>
<h4 id="算数比较"><a href="#算数比较" class="headerlink" title="算数比较"></a>算数比较</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412230755009.png" alt="image-20230412230755009" style="zoom:80%;" /></p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412230824083.png" alt="image-20230412230824083" style="zoom:80%;" /></p>
<h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412231419320.png" alt="image-20230412231419320" style="zoom:80%;" /></p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [expression]<br><span class="hljs-keyword">then</span><br>	statements<br><span class="hljs-keyword">elif</span> [expression]<br><span class="hljs-keyword">then</span><br>	statements<br><span class="hljs-keyword">elif</span>...<br><span class="hljs-keyword">else</span><br>	statements<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<ul>
<li>紧凑模式：使用 ; 分割</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ -f ~/.bashrc ]; <span class="hljs-keyword">then</span><br>	. ~/.bashrc<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><ul>
<li>双分号</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> str <span class="hljs-keyword">in</span><br>  str1 | str2) statements;;<br>  str3 | str4) statements;;<br>  *) statements;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Is this morning? Please answer yes or no.&quot;</span><br><span class="hljs-built_in">read</span> answer<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$answer</span>&quot;</span> <span class="hljs-keyword">in</span><br>  <span class="hljs-built_in">yes</span> | y | Yes | YES) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Good morning!&quot;</span>;;<br>  no | n | No | NO) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Good afternoon!&quot;</span>;;<br>  *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, answer not recognized.&quot;</span>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul>
<li>适用于对一系列字符串循环处理</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>	statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> f*.sh); <span class="hljs-keyword">do</span><br>	lpr <span class="hljs-variable">$file</span><br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> [expression]<br><span class="hljs-keyword">do</span><br>	statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">quit=n<br><span class="hljs-keyword">while</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$quit</span>&quot;</span> != <span class="hljs-string">&quot;y&quot;</span>]; <span class="hljs-keyword">do</span><br>	<span class="hljs-built_in">read</span> menu_choice<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$menu_choice</span>&quot;</span> <span class="hljs-keyword">in</span><br>		a) do_something;;<br>		b) do_anotherthing;;<br>		q|Q) quit=y;;<br>		*) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, choice not recognized.&quot;</span>;;<br>	<span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=0<br><span class="hljs-keyword">while</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> -le <span class="hljs-string">&quot;<span class="hljs-variable">$LIMIT</span>&quot;</span> ]; <span class="hljs-keyword">do</span><br>	a=$((<span class="hljs-variable">$a</span>+<span class="hljs-number">1</span>))<br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> gt 2 ]; <span class="hljs-keyword">then</span><br>		<span class="hljs-built_in">break</span>  <span class="hljs-comment"># Skip entire rest of loop.</span><br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p><strong>$(())整数运算，否则会看作字符串</strong></p>
</li>
<li><p>不推荐使用 until</p>
</li>
</ul>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>clear<br><span class="hljs-keyword">select</span> item <span class="hljs-keyword">in</span> Continue Finish<br><span class="hljs-keyword">do</span><br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$item</span>&quot;</span> <span class="hljs-keyword">in</span><br>        Continue) ;;<br>        Finish) <span class="hljs-built_in">break</span> ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Wrong choice! Please select again!&quot;</span> ;;<br>	<span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412233820317.png" alt="image-20230412233820317" style="zoom:80%;" /></p>
<h4 id="命令表"><a href="#命令表" class="headerlink" title="命令表"></a>命令表</h4><p>命令组合</p>
<ul>
<li><p>分号串联：command1 ; command2 ; …</p>
</li>
<li><p>&amp;&amp;: 前面成功才会执行后面的命令</p>
</li>
<li><p>||: 前面失败才会执行, 可用作备用命令</p>
</li>
<li><p>{statement1; statement2 ; … ;} 会看做一个命令</p>
</li>
</ul>
<p>…….都看了吧</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>定义时不带参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">func</span></span>()<br>&#123;<br>	statements<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>局部变量: local关键字</li>
<li>函数的调用: func para1 para2 …</li>
<li>返回值: return</li>
</ul>
<p>例子</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412235748650.png" alt="image-20230412235748650" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412235756115.png" alt="image-20230412235756115" style="zoom:80%;" /></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>杂项命令</p>
<ul>
<li>break: 从for/while/until循环退出 </li>
<li>continue: 跳到下一个循环继续执行</li>
<li>exit n: 以退出码”n”退出脚本运行</li>
<li>return: 函数返回</li>
<li>export: 将变量导出到shell，使之成为shell的环境变量</li>
<li>set: 为shell设置参数变量</li>
<li>unset: 从环境中删除变量或函数</li>
<li>trap: 指定在收到操作系统信号后执行的动作</li>
<li>“:”(冒号命令): 空命令</li>
<li>“.”(句点命令)或source: 在当前shell中执行命令</li>
</ul>
<p>捕获命令输出</p>
<ul>
<li><p>$(command) 或 `command`</p>
</li>
<li><p><code>$PWD 与 $(pwd)</code></p>
</li>
</ul>
<p>参数扩展</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230413000143071.png" alt="image-20230413000143071"></p>
<p>即时文档</p>
<ul>
<li>输入 !CATINPUT! 才会停止</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; !CATINPUT!<br>Hello, this is a here document.<br>!CATINPUT!<br></code></pre></td></tr></table></figure>
<h3 id="ch3-Programming-Prerequisite"><a href="#ch3-Programming-Prerequisite" class="headerlink" title="ch3 Programming Prerequisite"></a>ch3 Programming Prerequisite</h3><h4 id="知道什么是elf"><a href="#知道什么是elf" class="headerlink" title="知道什么是elf"></a>知道什么是elf</h4><ul>
<li>“ELF” 是 “Executable and Linkable Format” 的缩写，是一种二进制文件格式，用于可执行文件、目标文件和库文件</li>
<li>它是一种标准的二进制文件格式，可用于 Linux 操作系统下的可执行程序</li>
</ul>
<h4 id="程序设计语言是解释型还是编译型，什么意思"><a href="#程序设计语言是解释型还是编译型，什么意思" class="headerlink" title="程序设计语言是解释型还是编译型，什么意思"></a>程序设计语言是解释型还是编译型，什么意思</h4><ul>
<li><p>编译型语言是指在程序运行之前，需要先将源代码编译成机器码，然后再运行机器码。</p>
</li>
<li><p>解释型语言则是在程序运行时，逐行解释源代码并执行。</p>
</li>
</ul>
<h4 id="静态库与动态库联系和区别"><a href="#静态库与动态库联系和区别" class="headerlink" title="静态库与动态库联系和区别"></a>静态库与动态库联系和区别</h4><ul>
<li><p>静态库和动态库都是程序开发中常用的库文件。</p>
</li>
<li><p>静态库在链接时会完整地拷贝至可执行文件中，被多个依赖多次使用就会有多份冗余拷贝。</p>
</li>
<li><p>动态库则在链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存</p>
</li>
<li><p>静态库的扩展名一般为“.a”或“.lib”，而动态库的扩展名一般为“.so”或“.dll”。</p>
</li>
</ul>
<h4 id="java编译过程"><a href="#java编译过程" class="headerlink" title="java编译过程"></a>java编译过程</h4><p>Java文件从源文件创建到程序运行要经过两大步骤：</p>
<ol>
<li>源文件由编译器编译成字节码（ByteCode）</li>
<li>字节码由Java虚拟机解释运行</li>
</ol>
<h4 id="gcc参数"><a href="#gcc参数" class="headerlink" title="gcc参数"></a>gcc参数</h4><ul>
<li>-E: 只对源程序进行预处理(调用cpp预处理器)</li>
<li>-S: 只对源程序进行预处理、编译</li>
<li>-c: 执行预处理、编译、汇编而不链接</li>
<li>-o output_file: 指定输出文件名</li>
<li>-g: 产生调试工具必需的符号信息</li>
<li>-O/On: 在程序编译、链接过程中进行优化处理</li>
<li>-Wall: 显示所有的警告信息</li>
<li>-Idir: 指定额外的头文件搜索路径</li>
<li>-Ldir: 指定额外的库文件搜索路径</li>
<li>-lname: 链接时搜索指定的库文件</li>
<li>-DMACRO[=DEFN]: 定义MACRO宏</li>
</ul>
<h4 id="扩展名"><a href="#扩展名" class="headerlink" title="扩展名"></a>扩展名</h4><p>.h 头文件</p>
<p>.s 汇编</p>
<p>.o 目标文件</p>
<p>.a 静态库</p>
<p>.so 动态库</p>
<h4 id="gdb-正常不考-功能，原理"><a href="#gdb-正常不考-功能，原理" class="headerlink" title="gdb(正常不考) 功能，原理"></a>gdb(正常不考) 功能，原理</h4><ul>
<li>设置断点</li>
<li>监视变量值</li>
<li>单步执行</li>
<li>修改变量值</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230413142055943.png" alt="image-20230413142055943" style="zoom:80%;" /></p>
<h4 id="makefile掌握ppt涉及内容"><a href="#makefile掌握ppt涉及内容" class="headerlink" title="makefile掌握ppt涉及内容"></a>makefile掌握ppt涉及内容</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38391755/article/details/80380786">https://blog.csdn.net/weixin_38391755/article/details/80380786</a></p>
<ul>
<li>预定义变量可以看</li>
<li>不考复杂的、函数等</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230413142324080.png" alt="image-20230413142324080" style="zoom:80%;" /></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJECTS = main.o kbd.o command.o display.o \<br>    insert.o search.o files.o utils.o <br>edit : <span class="hljs-variable">$(OBJECTS)</span> <br>	gcc -o edit <span class="hljs-variable">$(OBJECTS)</span> <br>main.o : main.c defs.h <br>	gcc -c main.c <br>kbd.o : kbd.c defs.h command.h <br>	gcc -c kbd.c <br>command.o : command.c defs.h command.h <br>	gcc -c command.c <br>display.o : display.c defs.h buffer.h <br>	gcc -c display.c <br>insert.o : insert.c defs.h buffer.h <br>	gcc -c insert.c <br>search.o : search.c defs.h buffer.h <br>	gcc -c search.c <br>files.o : files.c defs.h buffer.h command.h <br>	gcc -c files.c <br>utils.o : utils.c defs.h <br>	gcc -c utils.c <br>clean : <br>	rm edit <span class="hljs-variable">$(OBJECTS)</span><br></code></pre></td></tr></table></figure>
<h3 id="ch3-1-Linux-System-Programming-–-File-System"><a href="#ch3-1-Linux-System-Programming-–-File-System" class="headerlink" title="ch3-1 Linux System Programming – File System"></a>ch3-1 Linux System Programming – File System</h3><h4 id="什么是文件、文件系统"><a href="#什么是文件、文件系统" class="headerlink" title="什么是文件、文件系统"></a>什么是文件、文件系统</h4><p>文件：可以写入、读取或两者兼有的对象，文件具有某些属性，包括访问权限和类型</p>
<p>文件系统：操作系统中负责存取和管理文件的部分，是文件及其属性的集合，为引用文件的文件序列号提供了名称空间。</p>
<h4 id="文件系统三层含义"><a href="#文件系统三层含义" class="headerlink" title="文件系统三层含义"></a>文件系统三层含义</h4><ol>
<li>一种特定的文件格式，例如EXT2, FAT16, FAT32</li>
<li>指按指定格式进行”格式化”的一块存储介质</li>
<li>指操作系统中(通常内核中)用来管理文件系统以及对文件进行操作的机制及其实现</li>
</ol>
<h4 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h4><p>采⽤标准的Unix系统调⽤读写位于不同物理介质上的不同⽂件系统，使得open()等系统调⽤不⽤关⼼底层的存储介质和⽂件类型</p>
<ol>
<li>超级块(super block)：某一个磁盘的某一个分区的文件系统的信息，记录了文件系统类型和参数。</li>
<li>i-node 对象(i-node object 索引节点)：<ul>
<li>记录真正的文件，文件存储在磁盘上时是按照索引号访问文件的</li>
</ul>
</li>
<li>文件对象(file object)：记录了文件描述符、索引号，不对应真正的文件，文件打开会创建出文件对象，文件关闭才会释放内核中的文件对象。记录了文件的读写状态。</li>
<li>目录项对象(dentry object)：在路径上，无论是目录还是文件，都是一个dentry对象对应到目录包含的i-node上，目录项包括索引节点编号，目录项名称长度以及名称。</li>
</ol>
<h4 id="硬链接软链接-重点"><a href="#硬链接软链接-重点" class="headerlink" title="硬链接软链接 重点"></a>硬链接软链接 重点</h4><ol>
<li>硬链接<ul>
<li>不同的文件名对应同一个inode</li>
<li>不能跨越文件系统</li>
<li>对应系统调用link</li>
<li>命令行使用 ln [文件名] [文件名]</li>
<li>应用程序使用 int link(const char <em>oldpath, const char </em>newpath);</li>
</ul>
</li>
<li>软链接<ul>
<li>存储被链接文件的文件名(而不是inode)实现链接</li>
<li>可以跨越文件系统</li>
<li>对应系统调用symlink</li>
<li>命令行使用 ln -s [文件名] [文件名]</li>
<li>应用程序使用 int symlink(const char <em>oldpath, const char </em>newpath);</li>
</ul>
</li>
</ol>
<h4 id="系统调用和c库的关系-重点"><a href="#系统调用和c库的关系-重点" class="headerlink" title="系统调用和c库的关系 重点"></a>系统调用和c库的关系 重点</h4><p>看清题目要求，要求系统调用还是c库</p>
<h4 id="系统调用部分："><a href="#系统调用部分：" class="headerlink" title="系统调用部分："></a>系统调用部分：</h4><ul>
<li><code>int open(const char *pathname, int flags, mode_t mode);</code><ul>
<li>flags<ul>
<li>O_RDONLY：只读</li>
<li>O_WRONLY：只写</li>
<li>O_RDWR：读写</li>
<li>O_APPEND：追加模式打开</li>
<li>O_TRUNC：覆盖模式</li>
<li>O_CREAT：文件不存在则创建</li>
<li>O_EXCL：和O_CREAT同时使用，存在时出错</li>
</ul>
</li>
</ul>
</li>
<li><code>int close(int fd);</code></li>
<li><code>ssize_t read(int fd, void *buf, size_t count);</code></li>
<li><code>ssize_t write(int fd, const void *buf, size_t count);</code></li>
<li><p><code>off_t lseek(int fd, off_t offset, int whence);</code></p>
<ul>
<li>用于设置文件读写指针的位置</li>
<li>whence: 起始位置<ul>
<li>SEEK_SET：从头偏移offset</li>
<li>SEEK_CUR：从当前偏移offset</li>
<li>SEEK_END：从尾偏移offset</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int dup(int oldfd);</code></p>
</li>
<li><p><code>int dup2(int oldfd, int newfd);</code></p>
<ul>
<li>dup2 可以指定新的fd，通常用于重定向</li>
</ul>
</li>
<li><p><code>int fcntl(int fd, int cmd, struct flock *lock);</code></p>
<ul>
<li><p>cmd</p>
<ul>
<li>F_DUPFD：复制文件描述符</li>
<li>F_GETFD/F_SETFD：获取/设置文件描述符标志，为解决fork子进程执行其他任务(exec等)导致父进程的文件描述符被复制到子进程中，使得对应文件描述符无法被之后需要的进程获取。设置了这个标记后可以使得子进程在执行exce等命令后释放对应的文件描述符资源。</li>
<li>F_GETFL/F_SETFL:获得/设置文件状态标志(open/creat中的flags 参数)</li>
<li>F_GETOWN/F_SETOWN: 管理 I/O 可用相关的信号。</li>
<li><strong>F_GETLK</strong>：获得文件的锁信息</li>
<li><strong>F_SETLK</strong>：设置文件锁，如果无法获取锁，则返回错误信息</li>
<li><strong>F_SETLKW</strong>：设置文件锁，如果无法获取锁，则等待直到可以获取为止</li>
</ul>
</li>
<li><p>文件锁部分要掌握</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//file:fcntl</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    fd = open( <span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_APPEND);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    #<span class="hljs-meta">#printf(<span class="hljs-string">&quot;open err/n&quot;</span>);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd = %d&quot;</span>,fd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork!/n&quot;</span>);<br>    fcntl(fd，F_SETFD, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *s=<span class="hljs-string">&quot;ooooooooooooooooooo&quot;</span>;<br>    pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    	execl(<span class="hljs-string">&quot;ass&quot;</span>, <span class="hljs-string">&quot;./ass&quot;</span>, &amp;fd, <span class="hljs-literal">NULL</span>);<br>    wait(<span class="hljs-literal">NULL</span>);<br>    write(fd,s,<span class="hljs-built_in">strlen</span>(s));<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//ass 源代码</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argc = %d&quot;</span>,argc);<br>    fd = *argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd = %d&quot;</span>,fd);<br>    <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;zzzzzzzzzzzzzzzzzzz&quot;</span>;<br>    write(fd，(<span class="hljs-type">void</span> *)s, <span class="hljs-built_in">strlen</span>(s));<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>fcntl(fd, F_SETFD, 1);</code>这里将<strong>close-on-exec</strong> flag设置为true，所以<strong>调用execl的时候，fd会关闭</strong>。</p>
</li>
<li><p>最后的执行结果：test.txt文件中只会有”ooooo”，不会有”zzzzz”</p>
</li>
<li><p><code>int stat(const char *filename, struct stat *buf);</code></p>
<ul>
<li>获取文件状态信息</li>
<li>结果写入 buf</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230413192000447.png" alt="image-20230413192000447"></p>
</li>
<li><p><code>int fstat(int fd, struct stat *buf);</code></p>
<ul>
<li>用于获取已打开文件的状态信息</li>
</ul>
</li>
<li><p><code>int lstat(const char *path, struct stat *buf);</code></p>
<ul>
<li>lstat函数类似于stat函数，但是对于符号链接文件，它返回符号链接本身的状态信息，而不是链接所指向的文件的状态信息</li>
</ul>
</li>
</ul>
<h4 id="库函数部分"><a href="#库函数部分" class="headerlink" title="库函数部分"></a>库函数部分</h4><ul>
<li>会自动处理缓存</li>
<li><p><code>FILE *fopen(const char *filename, const char *mode); int fclose(FILE *stream);</code></p>
<ul>
<li>r 读</li>
<li>w 清空写</li>
<li>a 追加</li>
<li>r+ 读写</li>
<li>w+ 清空读写</li>
<li>a+ 不清空读写</li>
</ul>
</li>
<li><p><code>int fclose(FILE *fp);</code></p>
</li>
<li><p>输入一个字符</p>
<ul>
<li><code>int getc(FILE *fp)</code>：是预定义宏，无函数副作用，更快</li>
<li><code>int fgetc(FILE *fp)</code>：常用，在用到函数副作用/函数指针用</li>
</ul>
</li>
<li><p>输出一个字符到文件</p>
<ul>
<li><code>int putc(int c, FILE *fp)</code></li>
<li><code>int fputc(int c, FILE *fp)</code></li>
</ul>
</li>
<li><p>输入字符串</p>
<ul>
<li><code>char *fgets(char *s, int size, FILE *stream);</code><ul>
<li>常用，最多从流中读取并存储size-1个字符，并最后添加一个\0</li>
</ul>
</li>
</ul>
</li>
<li><p>输出字符串</p>
<ul>
<li><code>int fputs(const char *s, FILE *stream);</code></li>
</ul>
</li>
<li><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code></p>
<ul>
<li>参数分别为 缓冲区指针，数据块大小，数据块数量，文件指针</li>
</ul>
</li>
<li><p><code>size fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code></p>
</li>
<li><code>int scanf(const char *format, ...);</code></li>
<li><p><code>int printf(const char *format, ...);</code></p>
</li>
<li><p><code>int fseek(FILE *stream, long int offset, int whence);</code></p>
<ul>
<li>用于移动文件内部的位置指针</li>
<li>whence<ul>
<li>SEEK_SET：从文件开头开始偏移。</li>
<li>SEEK_CUR：从当前位置开始偏移。</li>
<li>SEEK_END：从文件结尾开始偏移。</li>
</ul>
</li>
</ul>
</li>
<li><code>long ftell(FILE *stream);</code><ul>
<li>获取文件内部的位置指针相对于文件开头的偏移量</li>
</ul>
</li>
<li><code>void rewind(FILE *stream);</code><ul>
<li>将文件内部的位置指针重新指向文件开头</li>
</ul>
</li>
<li><code>int fflush(FILE *stream);</code><ul>
<li>刷新文件流。把流里的数据立刻写入文件</li>
</ul>
</li>
</ul>
<h4 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230413153957156.png" alt="image-20230413153957156" style="zoom:80%;" /></p>
<h4 id="权限、链接系统调用是重点"><a href="#权限、链接系统调用是重点" class="headerlink" title="权限、链接系统调用是重点"></a>权限、链接系统调用是重点</h4><p>来自 new bing</p>
<ul>
<li>SUID（Set User ID）：当一个可执行文件被设置了SUID权限后，它在执行时就会具有该文件所有者的权限。例如，如果一个文件的所有者是root，那么当一个普通用户执行该文件时，该文件就会以root的身份运行。SUID权限可以让普通用户执行一些只有root才能执行的任务。</li>
<li>SGID（Set Group ID）：当一个目录被设置了SGID权限后，该目录下新建的文件和子目录都会继承该目录的组ID。例如，如果一个目录的组ID是staff，那么在该目录下新建的文件和子目录都会属于staff组。SGID权限可以让多个用户共享同一个组。</li>
<li>Sticky bit：当一个目录被设置了Sticky bit权限后，只有该目录的所有者和root用户才能删除该目录下的文件。例如，/tmp目录就被设置了Sticky bit权限，这样其他用户就不能删除/tmp目录下的文件。</li>
</ul>
<p>系统调用</p>
<ul>
<li><p><code>int chmod(const char *path, mode_t mode);</code></p>
</li>
<li><p><code>int fchmod(int fildes, mode_t mode);</code></p>
</li>
<li><p><code>int chown(const char *path, uid_t owner, gid_t group);</code></p>
</li>
<li><p><code>int fchown(int fd, uid_t owner, gid_t group);</code></p>
</li>
<li><p><code>int lchown(const char *path, uid_t owner, gid_t group);</code></p>
</li>
<li><p><code>mode_t umask(mode_t mask);</code></p>
<ul>
<li>为进程设置文件存取权限屏蔽字，并返回以前的值</li>
</ul>
</li>
</ul>
<h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><ul>
<li><code>int mkdir(const char *pathname, mode_t mode);</code></li>
<li><code>int rmdir(const char *pathname);</code></li>
<li><code>int chdir(const char *path);</code></li>
<li><code>int fchdir(int fd);</code></li>
<li><code>char *getcwd(char *buf, size_t size);</code><ul>
<li>获得当前工作目录的绝对路径</li>
</ul>
</li>
</ul>
<h4 id="文件锁-重点"><a href="#文件锁-重点" class="headerlink" title="文件锁 重点"></a>文件锁 重点</h4><ul>
<li>记录锁：按记录加锁</li>
<li>劝告锁：<ol>
<li>检查，加锁由应用程序自己控制</li>
<li>不会强制应用程序不允许访问，只是提醒</li>
</ol>
</li>
<li>强制锁<ol>
<li>检查，加锁由内核控制</li>
<li>影响 open() read() write()</li>
</ol>
</li>
<li>共享锁：可以读</li>
<li>排他锁：读写均不可</li>
</ul>
<h4 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h4><ul>
<li><code>int fcntl(int fd, int cmd, struct flock *lock);</code><ul>
<li>cmd<ul>
<li>F_GETLK：获得文件的封锁信息</li>
<li>F_SETLK：对文件的某个区域封锁或解除封锁</li>
<li>F_SETLKW：功能同F_SETLK, wait方式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230413200327948.png" alt="image-20230413200327948"></p>
<h3 id="ch4-内核"><a href="#ch4-内核" class="headerlink" title="ch4 内核"></a>ch4 内核</h3><h4 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h4><ul>
<li><p>操作系统是一系列程序的集合，其中最重要的部分构成了内核</p>
</li>
<li><p>单内核/微内核</p>
<ul>
<li>单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制文件，模块间通讯通过直接调用函数实现</li>
<li>微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通信</li>
</ul>
</li>
<li>Linux内核的能力：内存管理，文件系统，进程管理，多线程支持，多处理支持，抢占式。</li>
<li>Linux内核区别于其他UNIX商业内核的优点<ul>
<li>单内核，模块支持</li>
<li>免费/开源</li>
<li>支持多种CPU，硬件支持能力非常强大</li>
<li>Linux开发者都是非常出色的程序员</li>
<li>通过学习Linux内核的源码可以了解现代操作系统的实现原理</li>
</ul>
</li>
</ul>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230413200446162.png" alt=""></p>
<h4 id="驱动与模块-重点"><a href="#驱动与模块-重点" class="headerlink" title="驱动与模块 重点"></a>驱动与模块 重点</h4><ul>
<li>形式为 .ko，<code>模块.ko</code></li>
<li><p><code>insmod &lt;module.ko&gt; [module parameters]</code></p>
<ul>
<li>加载模块</li>
</ul>
</li>
<li><p><code>rmmod</code></p>
</li>
<li><p><code>lsmod</code></p>
<ul>
<li>列出内核中的模块</li>
</ul>
</li>
<li><p><code>modprobe [-r] &lt;module.name&gt;</code></p>
<ul>
<li>载入指定模块及其依赖模块</li>
<li>-r 卸载模块</li>
</ul>
</li>
<li><p><code>modinfo</code></p>
<ul>
<li>显示模块信息</li>
</ul>
</li>
<li><p><code>depmod</code></p>
<ul>
<li>用于生成modules.dep文件，该文件记录了所有模块之间的依赖关系</li>
</ul>
</li>
</ul>
<h4 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖"></a>模块依赖</h4><ul>
<li>一个模块A引用另一个模块B所导出的符号，我们就说模块B被模块A引用。</li>
<li>如果要装载模块A，必须先要装载模块B。否则，模块B所导出的那些符号的引用就不可能被链接到模块A中。这种模块间的相互关系就叫做模块依赖。</li>
</ul>
<h4 id="模块之间的通讯"><a href="#模块之间的通讯" class="headerlink" title="模块之间的通讯"></a>模块之间的通讯</h4><ul>
<li>模块是为了完成某种特定任务而设计的。其功能比较的单一，为了丰富系统的功能，所以模块之间常常进行通信。其之间可以共享变量，数据结构，也可以调用对方提供的功能函数。</li>
</ul>
<h4 id="应用程序与内核的区别"><a href="#应用程序与内核的区别" class="headerlink" title="应用程序与内核的区别"></a>应用程序与内核的区别</h4><p>加上注意点一共9点，写出4点即可</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>c语言程序</th>
<th>内核模块</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行在用户空间</td>
<td>运行在内核空间</td>
</tr>
<tr>
<td>入口为 main()</td>
<td>入口由 module_init() 指定</td>
</tr>
<tr>
<td>没有出口</td>
<td>出口由 module_exit() 指定</td>
</tr>
<tr>
<td>直接运行</td>
<td>通过 insmod</td>
</tr>
<tr>
<td>通过 gdb 调试</td>
<td>通过 kdbug，kdb，kgdb等 调试</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>不能使用 c 库开发驱动程序</li>
<li>没有内存保护机制</li>
<li>小内核栈</li>
<li>并发上的考虑</li>
</ul>
<h3 id="华为-15分"><a href="#华为-15分" class="headerlink" title="华为 15分"></a>华为 15分</h3><p>openEuler 是一款<strong>通用</strong>服务器操作系统； </p>
<p><strong>支持 x86 和 ARM 等多种处理器架构；</strong></p>
<p><strong>2019年底开源</strong>，成为openEuler</p>
<p><strong>鲲鹏处理器</strong>：基于<strong>ARMv8-64</strong>指令集开发的通用处理器，openEuler对 <strong>鲲鹏处理器</strong> 做了增强，没有神经网络加速</p>
<p>openEuler优化鲲鹏的4个方面</p>
<ul>
<li><p>多核调度技术：Numa aware</p>
</li>
<li><p>软硬件协同：KAE</p>
</li>
<li><p>智能优化引擎：<strong>A-Tune</strong></p>
</li>
<li><p>轻量级虚拟化：提供 <strong>iSulad</strong> 轻量级容器全场景解决方案</p>
</li>
</ul>
<p>openEuler使用<strong>多队列调度策略</strong></p>
<p>openEuler 通信支持共享内存与消息传递</p>
<p>openEuler 内存管理有预测机制，不是100%准确</p>
<p>openEuler大量使用寄存器，使用精简指令集 risc</p>
<h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><p>使用C的库函数，编写一个函数void bindiff(char <em>file1,char </em>file2,char *fileo)，将文件从file1、file2对应的路径中读取并逐字节比对，将相同的字节输出到fileo对应的文件中。（25分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bindiff</span><span class="hljs-params">(<span class="hljs-type">char</span> *file1,<span class="hljs-type">char</span> *file2,<span class="hljs-type">char</span> *file3)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    bindiff(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>]);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bindiff</span><span class="hljs-params">(<span class="hljs-type">char</span> *file1,<span class="hljs-type">char</span> *file2,<span class="hljs-type">char</span> *file3)</span> &#123;<br>    FILE* fp1 = fopen(file1, <span class="hljs-string">&quot;r&quot;</span>);<br>    FILE* fp2 = fopen(file2, <span class="hljs-string">&quot;r&quot;</span>);<br>    FILE* fp3 = fopen(file3, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-type">char</span> ch1, ch2;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        ch1 = fgetc(fp1);<br>        ch2 = fgetc(fp2);<br>        <span class="hljs-keyword">if</span> (feof(fp1) || feof(fp2)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ch1 == ch2) &#123;<br>            fputc(ch1, fp3);<br>        &#125;<br>    &#125;<br>    fclose(fp1);<br>    fclose(fp2);<br>    fclose(fp3);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>shell获得用户输入的100个整数，并输出其最大值，最小值，总和。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">max=0<br>min=0<br><span class="hljs-built_in">sum</span>=0<br>i=1<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$i</span> -le 10 ]<br><span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;num: &quot;</span> num<br>        <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$i</span> -eq 1 ]; <span class="hljs-keyword">then</span><br>                max=<span class="hljs-variable">$num</span><br>                min=<span class="hljs-variable">$num</span><br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$num</span> -gt <span class="hljs-variable">$max</span> ]; <span class="hljs-keyword">then</span><br>                        max=<span class="hljs-variable">$num</span><br>                <span class="hljs-keyword">fi</span><br>                <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$num</span> -lt <span class="hljs-variable">$min</span> ]; <span class="hljs-keyword">then</span><br>                        min=<span class="hljs-variable">$num</span><br>                <span class="hljs-keyword">fi</span><br>        <span class="hljs-keyword">fi</span><br>        <span class="hljs-built_in">sum</span>=$((sum + num))<br>        i=$((i + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;最大值：<span class="hljs-variable">$max</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;最小值：<span class="hljs-variable">$min</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;总和：<span class="hljs-variable">$sum</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>用系统调用实现一个copy.cpp模块，输入两个参数（原文件名，目标文件名），将原文件中的内容复制到目标文件中。并且编写Makefile编译链接上述模块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 4096</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">int</span> sourece_fd = open(argv[<span class="hljs-number">1</span>], O_RDONLY);<br>    <span class="hljs-type">int</span> dest_fd = open(argv[<span class="hljs-number">2</span>], O_WRONLY | O_CREAT | O_TRUNC);<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-keyword">while</span>((size = read(source_fd, buf, BUFFER_SIZE)) &gt; <span class="hljs-number">0</span>) &#123;<br>        write(dest_fd, buf, size);<br>    &#125;<br>    close(sourece_fd);<br>    close(dest_fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">copy : copy.cpp<br>	g++ -o copy copy.cpp<br></code></pre></td></tr></table></figure>
<p>使用系统调用实现函数half(a, b)将a文件的一半拷贝到b文件，且b仅包含a文件的后一半的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 4096</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">int</span> fd1 = open(argv[<span class="hljs-number">1</span>], O_RDONLY);<br>    <span class="hljs-type">int</span> fd2 = open(argv[<span class="hljs-number">2</span>], O_WRONLY | O_CREAT | O_TRUNC);<br>    <span class="hljs-type">int</span> half_size = lseek(fd1, <span class="hljs-number">0</span>, SEEK_END) / <span class="hljs-number">2</span>;<br>    lseek(fd1, half_size, SEEK_SET);<br>    <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((size = read(fd1, buf, BUFFER_SIZE)) &gt; <span class="hljs-number">0</span>) &#123;<br>        write(fd2, buf, size);<br>    &#125;<br>    close(fd1);<br>    close(fd2);<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-9-Sentinel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-9-Sentinel/" class="post-title-link" itemprop="url">服务端开发(9) 基于Sentinel的流控与熔断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-08 14:33:56" itemprop="dateCreated datePublished" datetime="2023-04-08T14:33:56+08:00">2023-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Sentinel"><a href="#1-Sentinel" class="headerlink" title="1. Sentinel"></a>1. Sentinel</h3><ul>
<li>Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性</li>
<li>源代码：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">https://github.com/alibaba/Sentinel</a><ul>
<li>其中例子代码：Sentinel/sentinel-demo</li>
</ul>
</li>
<li>Dashboard下载：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></li>
<li>中文用户文档：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/introduction.html">https://sentinelguard.io/zh-cn/docs/introduction.html</a></li>
</ul>
<h4 id="Sentinel组成"><a href="#Sentinel组成" class="headerlink" title="Sentinel组成"></a>Sentinel组成</h4><ul>
<li>核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持</li>
<li>控制台（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408151555033.png" alt="image-20230408151555033"></p>
<blockquote>
<p>控制台不维护规则，仅会通过端口查看</p>
</blockquote>
<h3 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2. 使用步骤"></a>2. 使用步骤</h3><ol>
<li>定义资源<ul>
<li>代码直接定义</li>
<li>使用注解定义</li>
<li>自动定义</li>
</ul>
</li>
<li>定义规则<ul>
<li>流量控制规则</li>
<li>熔断降级规则</li>
<li>系统保护规则</li>
<li>来源访问控制规则</li>
<li>热点参数规则</li>
</ul>
</li>
<li>查看效果<ul>
<li>日志</li>
<li>Dashboard</li>
</ul>
</li>
</ol>
<h4 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h4><ul>
<li><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码</p>
</li>
<li><p>只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408152504931.png" alt="image-20230408152504931" style="zoom: 80%;" /></p>
<h4 id="定义规则"><a href="#定义规则" class="headerlink" title="定义规则"></a>定义规则</h4><ul>
<li>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408152626363.png" alt="image-20230408152626363"></p>
<ul>
<li>规则的种类<ul>
<li>流量控制规则</li>
<li>熔断降级规则</li>
<li>系统保护规则（CPU、内存占用等）</li>
<li>来源访问控制规则（客户端来源）</li>
<li>热点参数规则（依据请求的某一个参数来做限定）</li>
</ul>
</li>
</ul>
<h4 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h4><ul>
<li>QPS一般指每秒查询率。每秒查询率（QPS，Queries-per-second）是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准</li>
<li><p>日志路径：C:\Users\14669\logs\csp\com-alibaba-csp-sentinel-demo-flow-FlowQpsDemo-metrics.log.2023-04-08</p>
</li>
<li><p>—timestamp-|———date time——|—resource—|p|block|s|e|rt</p>
<ul>
<li>p 代表通过的请求, block 代表被阻止的请求, s 代表成功执行完成的请求个数, e 代表用户自定义的异常, rt 代表平均响应时长</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408155015781.png" alt="image-20230408155015781" style="zoom:80%;" /></p>
<h3 id="3-简单的例子"><a href="#3-简单的例子" class="headerlink" title="3. 简单的例子"></a>3. 简单的例子</h3><h4 id="SentinelResource-注解（基于Spring-Boot）"><a href="#SentinelResource-注解（基于Spring-Boot）" class="headerlink" title="@SentinelResource 注解（基于Spring Boot）"></a><code>@SentinelResource</code> 注解（基于Spring Boot）</h4><ul>
<li>文档（注解支持）：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/annotation-support.html">https://sentinelguard.io/zh-cn/docs/annotation-support.html</a></li>
<li>例子代码：Sentinel/sentinel-demo/sentinel-demo-annotation-spring-aop</li>
<li>依赖：sentinel-core、sentinel-annotation-aspectj、sentinel-transport-simple-http（与控制台连接）</li>
<li><p>配置Bean <code>SentinelResourceAspect</code>、注解 <code>@SentinelResource</code></p>
</li>
<li><p>sentinel.properties（配置项）</p>
<ul>
<li>文档：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/startup-configuration.html">https://sentinelguard.io/zh-cn/docs/startup-configuration.html</a></li>
<li><code>csp.sentinel.dashboard.server=www.sentinel.com:80</code></li>
<li><code>csp.sentinel.api.port=8719</code></li>
<li><code>project.name=mydemo</code></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cristianoxm/article/details/113745358">blockHandler与fallback的区别</a></p>
</li>
</ul>
<h4 id="Sentinel-控制台"><a href="#Sentinel-控制台" class="headerlink" title="Sentinel 控制台"></a>Sentinel 控制台</h4><ul>
<li>文档：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/dashboard.html">https://sentinelguard.io/zh-cn/docs/dashboard.html</a></li>
<li><p>配置控制台的参数传入</p>
<ul>
<li><code>java -Dcsp.sentinel.dashboard.server=www.sentinel.com:80 ......</code></li>
<li><code>mvn spring-boot:run -Dspring-boot.run.jvmArguments=&quot;-Dcsp.sentinel.dashboard.server=www.sentinel.com:80&quot;</code></li>
</ul>
</li>
<li><p>配置应用的端口号</p>
<ul>
<li>应用默认端口号：8719</li>
<li><code>csp.sentinel.api.port=8719</code></li>
</ul>
</li>
</ul>
<h3 id="4-限流"><a href="#4-限流" class="headerlink" title="4. 限流"></a>4. 限流</h3><ul>
<li>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 FlowException 异常</li>
<li>FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑</li>
<li>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果<ul>
<li>resource：资源名，即限流规则的作用对象</li>
<li>count: 限流阈值</li>
<li>grade: 限流阈值类型，QPS 或线程数</li>
<li>strategy: 根据调用关系选择策略</li>
</ul>
</li>
</ul>
<h4 id="并发线程数流量控制"><a href="#并发线程数流量控制" class="headerlink" title="并发线程数流量控制"></a>并发线程数流量控制</h4><ul>
<li>线程数限流用于保护业务线程数不被耗尽</li>
<li><p>Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝</p>
</li>
<li><p>代码：<code>Sentinel\sentinel-demo\sentinel-demo-basic\..\flow\FlowThreadDemo.java</code></p>
</li>
</ul>
<h4 id="QPS流量控制"><a href="#QPS流量控制" class="headerlink" title="QPS流量控制"></a>QPS流量控制</h4><ul>
<li>当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出 FlowException</li>
<li>代码：<code>Sentinel\sentinel-demo\sentinel-demo-basic\..\flow\FlowQpsDemo.java</code></li>
</ul>
<h3 id="5-熔断降级"><a href="#5-熔断降级" class="headerlink" title="5. 熔断降级"></a>5. 熔断降级</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408160644672.png" alt="image-20230408160644672"></p>
<h4 id="熔断策略—慢调用比例-SLOW-REQUEST-RATIO"><a href="#熔断策略—慢调用比例-SLOW-REQUEST-RATIO" class="headerlink" title="熔断策略—慢调用比例 (SLOW_REQUEST_RATIO)"></a>熔断策略—慢调用比例 (SLOW_REQUEST_RATIO)</h4><ul>
<li><p>代码：<code>Sentinel\sentinel-demo\sentinel-demo-basic\..\degrade\SlowRatioCircuitBreakerDemo.java</code></p>
</li>
<li><p>设置RT（最大的响应时间），用于判断慢调用</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408160732639.png" alt="image-20230408160732639"></p>
<h4 id="熔断策略—异常比例-ERROR-RATIO"><a href="#熔断策略—异常比例-ERROR-RATIO" class="headerlink" title="熔断策略—异常比例 (ERROR_RATIO)"></a>熔断策略—异常比例 (ERROR_RATIO)</h4><ul>
<li><p><code>代码：Sentinel\sentinel-demo\sentinel-demo-basic\..\degrade\ExceptionRatioCircuitBreakerDemo.java</code></p>
</li>
<li><p>异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408160803154.png" alt="image-20230408160803154"></p>
<h4 id="熔断策略—异常数-ERROR-COUNT"><a href="#熔断策略—异常数-ERROR-COUNT" class="headerlink" title="熔断策略—异常数 (ERROR_COUNT)"></a>熔断策略—异常数 (ERROR_COUNT)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408160814319.png" alt="image-20230408160814319"></p>
<h3 id="6-Spring-Cloud-Alibaba-Sentinel"><a href="#6-Spring-Cloud-Alibaba-Sentinel" class="headerlink" title="6. Spring Cloud Alibaba Sentinel"></a>6. Spring Cloud Alibaba Sentinel</h3><ul>
<li>文档：<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel">https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel</a></li>
<li>例子代码：<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba.git">https://github.com/alibaba/spring-cloud-alibaba.git</a><ul>
<li>子目录：spring-cloud-alibaba-examples</li>
</ul>
</li>
<li>增加依赖：spring-cloud-starter-alibaba-sentinel</li>
<li>配置控制台信息</li>
<li>HTTP 埋点（自动定义url资源）</li>
<li>Feign 支持，断路器支持</li>
<li>RestTemplate 支持</li>
<li>Spring Cloud Gateway 支持</li>
<li>Endpoint 支持（/actuator/sentinel）<ul>
<li>management.endpoints.web.exposure.include=*</li>
</ul>
</li>
</ul>
<h4 id="注册-DataSource"><a href="#注册-DataSource" class="headerlink" title="注册 DataSource"></a>注册 DataSource</h4><ul>
<li>目前支持file、nacos、zk、apollo、redis 这 5 种类型</li>
<li>FileRefreshableDataSource 和 NacosDataSource</li>
<li>nacos需要添加依赖sentinel-datasource-nacos</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408160946106.png" alt="image-20230408160946106"></p>
<h4 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408161036130.png" alt="image-20230408161036130"></p>
<h4 id="演示内容"><a href="#演示内容" class="headerlink" title="演示内容"></a>演示内容</h4><ul>
<li>访问sentinel控制台</li>
<li>访问get-licenses： <a target="_blank" rel="noopener" href="http://www.license.com/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a/licenses/">http://www.license.com/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a/licenses/</a></li>
<li>控制台查询：实时监控、簇点链路，可以看到已经自动创建了资源</li>
<li>定义流控规则（阈值0）、熔断规则</li>
<li>访问get-license-feign：<a target="_blank" rel="noopener" href="http://www.license.com/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a/licenses/f3831f8c-c338-4ebe-a82a-e2fc1d1ff78a/feign">http://www.license.com/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a/licenses/f3831f8c-c338-4ebe-a82a-e2fc1d1ff78a/feign</a></li>
<li>查看链路资源：<code>GET:http://organizationservice/v1/organizations/&#123;organizationId&#125;</code></li>
<li>定义熔断规则，测试发现返回了缺省值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/06/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-8-NACOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/06/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-8-NACOS/" class="post-title-link" itemprop="url">服务端开发(8) NACOS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-06 14:50:41" itemprop="dateCreated datePublished" datetime="2023-04-06T14:50:41+08:00">2023-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>nacos官方文档: <a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/v2/what-is-nacos.html">https://nacos.io/zh-cn/docs/v2/what-is-nacos.html</a></p>
</blockquote>
<h2 id="基于NACOS的数据配置"><a href="#基于NACOS的数据配置" class="headerlink" title="基于NACOS的数据配置"></a>基于NACOS的数据配置</h2><h3 id="1-配置信息"><a href="#1-配置信息" class="headerlink" title="1. 配置信息"></a>1. 配置信息</h3><h4 id="将服务配置信息与代码分开"><a href="#将服务配置信息与代码分开" class="headerlink" title="将服务配置信息与代码分开"></a>将服务配置信息与代码分开</h4><ul>
<li>配置信息硬编码到代码中</li>
<li>分离的外部属性文件</li>
<li>与物理部署分离，如外部数据库</li>
<li>k8s-configmap</li>
<li>配置数据作为单独的服务提供</li>
</ul>
<h4 id="微服务的配置数据来源"><a href="#微服务的配置数据来源" class="headerlink" title="微服务的配置数据来源"></a>微服务的配置数据来源</h4><ul>
<li>Spring Cloud Config：文件系统、Git、Eureka、Consul</li>
<li>nacos：mysql、h2、derby</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230407135021721.png" alt="image-20230407135021721"></p>
<h3 id="2-nacos"><a href="#2-nacos" class="headerlink" title="2. nacos"></a>2. nacos</h3><ul>
<li>Nacos 是 Dynamic Naming and Configuration Service 的首字母简称，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台</li>
<li>主要功能：动态配置服务、服务发现及管理</li>
<li>官网：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></li>
<li>新版本指南：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/v2/quickstart/quick-start.html">https://nacos.io/zh-cn/docs/v2/quickstart/quick-start.html</a></li>
</ul>
<h4 id="nacos在docker上的部署"><a href="#nacos在docker上的部署" class="headerlink" title="nacos在docker上的部署"></a>nacos在docker上的部署</h4><ul>
<li>下载脚本：<a target="_blank" rel="noopener" href="https://github.com/nacos-group/nacos-docker">https://github.com/nacos-group/nacos-docker</a></li>
<li>在Docker上直接部署<ul>
<li><code>docker run --name nacos-quick -e MODE=standalone -p 8848:8848 -p 9848:9848 -d nacos/nacos-server:v2.1.2</code></li>
</ul>
</li>
<li>docker-compose部署<ul>
<li><code>docker-compose -f example/standalone-derby.yaml up</code></li>
</ul>
</li>
</ul>
<h4 id="nacos在k8s上的部署"><a href="#nacos在k8s上的部署" class="headerlink" title="nacos在k8s上的部署"></a>nacos在k8s上的部署</h4><ul>
<li>下载脚本：<a target="_blank" rel="noopener" href="https://github.com/nacos-group/nacos-k8s">https://github.com/nacos-group/nacos-k8s</a></li>
<li>本机的hosts文件里配置域名<ul>
<li>127.0.0.1 www.nacos.com</li>
</ul>
</li>
<li>参考我提供的文件，修改文件 ./deploy/nacos/nacos-quick-start.yaml，改成 standalone 模式</li>
<li>部署<ul>
<li><code>kubectl create -f ./deploy/mysql/mysql-local.yaml</code></li>
<li><code>kubectl create -f ./deploy/nacos/nacos-quick-start.yaml</code></li>
</ul>
</li>
<li>通过 ingress 访问：www.nacos.com/nacos，用户名：nacos，密码：nacos</li>
<li>k8s集群内访问，服务名：nacos-headless，端口号：8848</li>
<li>去部署<ul>
<li><code>kubectl delete -f ./deploy/nacos/nacos-quick-start.yaml</code></li>
<li><code>kubectl delete -f ./deploy/mysql/mysql-local.yaml</code></li>
</ul>
</li>
</ul>
<h4 id="测试-配置数据更新获取"><a href="#测试-配置数据更新获取" class="headerlink" title="测试-配置数据更新获取"></a>测试-配置数据更新获取</h4><ul>
<li><p><code>curl -X POST &quot;http://www.nacos.com/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</code></p>
</li>
<li><p><code>curl -X GET &quot;http://www.nacos.com/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;</code></p>
</li>
<li><p>在pod中测试</p>
<ul>
<li><code>kubectl run -i -t --rm=true mycurl --image=curlimages/curl:latest --restart=Never --command -- sh</code></li>
<li><code>curl -X POST &quot;http://nacos-headless:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</code></li>
<li><code>curl -X GET &quot;http://nacos-headless:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;</code></li>
</ul>
</li>
</ul>
<h3 id="3-curl"><a href="#3-curl" class="headerlink" title="3. curl"></a>3. curl</h3><ul>
<li>curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具</li>
<li>安装：<a target="_blank" rel="noopener" href="https://curl.se/download.html">https://curl.se/download.html</a></li>
<li>Docker部署：<code>docker run --rm -it curlimages/curl:latest sh</code></li>
<li>k8s部署：<code>kubectl run -i -t --rm=true mycurl --image=curlimages/curl:latest --restart=Never --command -- sh</code></li>
</ul>
<h4 id="常用命令使用"><a href="#常用命令使用" class="headerlink" title="常用命令使用"></a>常用命令使用</h4><ul>
<li>-i 打印响应的标头<ul>
<li><code>curl -i http://spittr:8080/spittr/spittles</code></li>
</ul>
</li>
<li>要求客户端重定向<ul>
<li>-L 让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</li>
<li><code>curl -L http://spittr:8080/spittr/spittles</code></li>
</ul>
</li>
<li>-v 参数输出通信的整个过程，用于调试<ul>
<li><code>curl -v http://tzs919:123456@spittr:8080/spittr/spittles</code></li>
<li><code>curl --trace - http://tzs919:123456@spittr:8080/spittr/spittles</code> 输出二进制信息</li>
</ul>
</li>
<li>设置认证的用户名密码<ul>
<li><code>curl http://tzs919:123456@spittr:8080/spittr/spittles</code></li>
<li><code>curl -u tzs919:123456 http://spittr:8080/spittr/spittles</code> 等价</li>
</ul>
</li>
</ul>
<h3 id="4-简单的例子"><a href="#4-简单的例子" class="headerlink" title="4. 简单的例子"></a>4. 简单的例子</h3><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><ul>
<li>nacos的官方例子代码：<a target="_blank" rel="noopener" href="https://github.com/nacos-group/nacos-examples.git">https://github.com/nacos-group/nacos-examples.git</a></li>
<li>代码路径：nacos-examples\nacos-spring-boot-example\nacos-spring-boot-config-example</li>
<li>依赖：nacos-config-spring-boot-starter、nacos-config-spring-boot-actuator</li>
<li>使用到的注解：<code>@NacosPropertySource</code>、<code>@NacosValue</code></li>
<li><p>nacos上配置数据，可手工配置，可实时更新</p>
<ul>
<li><code>curl -X POST &quot;http://www.nacos.com/nacos/v1/cs/configs?dataId=example&amp;group=DEFAULT_GROUP&amp;content=useLocalCache=true&quot;</code></li>
</ul>
</li>
<li><p>获取配置数据</p>
<ul>
<li><code>curl -X GET &quot;http://localhost:8080/config/get&quot;</code></li>
</ul>
</li>
<li>信息查询<ul>
<li><code>curl -X GET &quot;http://localhost:8080/actuator/health&quot;|python -m json.tool</code></li>
<li><code>curl -X GET &quot;http://localhost:8080/actuator/nacos-config&quot; |python -m json.tool</code></li>
</ul>
</li>
</ul>
<h4 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h4><ul>
<li><p>nacos的官方例子代码：<a target="_blank" rel="noopener" href="https://github.com/nacos-group/nacos-examples.git">https://github.com/nacos-group/nacos-examples.git</a></p>
</li>
<li><p>代码路径：nacos-examples\nacos-spring-cloud-example\nacos-spring-cloud-config-example</p>
</li>
<li><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>bootstrap.properties，配置Nacos server地址</p>
</li>
<li><p><code>@Value</code> 指定要获取的属性名</p>
</li>
<li><p><code>@RefreshScope</code> 实时刷新，可以获取到来自nacos的最新修改</p>
</li>
<li><p>到nacos上手工创建data id：example.properties，内容：<code>useLocalCache=true</code></p>
</li>
<li><p>运行服务：<code>mvn spring-boot:run</code>  或者直接在IDEA里运行</p>
</li>
<li><p>访问：<code>curl -X GET &quot;http://localhost:8080/config/get&quot;</code></p>
</li>
</ul>
<h4 id="创建适用不同环境的属性数据"><a href="#创建适用不同环境的属性数据" class="headerlink" title="创建适用不同环境的属性数据"></a>创建适用不同环境的属性数据</h4><ul>
<li><code>@Profile</code></li>
<li>-Dspring.profiles.active=xxx</li>
<li>命名约定：应用程序名称-环境名称.yml</li>
</ul>
<h4 id="dataId-的完整格式"><a href="#dataId-的完整格式" class="headerlink" title="dataId 的完整格式"></a>dataId 的完整格式</h4><ul>
<li><code>$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</code></li>
<li>prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置</li>
<li>spring.profiles.active 即为当前环境对应的 profile</li>
<li>file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型</li>
</ul>
<h4 id="licensingservice服务部署"><a href="#licensingservice服务部署" class="headerlink" title="licensingservice服务部署"></a>licensingservice服务部署</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408130705587.png" alt="image-20230408130705587"></p>
<h4 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h4><ul>
<li>通过 Spring Cloud  原生注解 <code>@RefreshScope</code> 实现配置自动更新</li>
</ul>
<h4 id="如何知道一个服务可用"><a href="#如何知道一个服务可用" class="headerlink" title="如何知道一个服务可用"></a>如何知道一个服务可用</h4><ul>
<li>在镜像中添加 netcat</li>
<li><code>nc -z 服务名 端口号</code></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408131529514.png" alt="image-20230408131529514"></p>
<h4 id="敏感信息配置"><a href="#敏感信息配置" class="headerlink" title="敏感信息配置"></a>敏感信息配置</h4><ul>
<li><p>属性加密：对称加密（共享密钥）、非对称加密（公钥/私钥）</p>
</li>
<li><p>使用共享密钥加密后，属性值的前面加上 {cipher} 前缀</p>
</li>
<li><p>配置共享密钥：设置环境变量 ENCRYPT_KEY</p>
</li>
<li><p>添加以下依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-rsa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="基于NACOS的服务注册与发现"><a href="#基于NACOS的服务注册与发现" class="headerlink" title="基于NACOS的服务注册与发现"></a>基于NACOS的服务注册与发现</h2><h3 id="1-服务"><a href="#1-服务" class="headerlink" title="1. 服务"></a>1. 服务</h3><h4 id="nacos练习"><a href="#nacos练习" class="headerlink" title="nacos练习"></a>nacos练习</h4><ul>
<li><p>服务注册</p>
<ul>
<li><p><code>curl -X POST &quot;http://www.nacos.com/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080&quot;</code></p>
</li>
<li><p><code>curl -X GET &quot;http://www.nacos.com/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&quot; | python -m json.tool</code></p>
</li>
</ul>
</li>
<li><p>Nacos中临时实例基于心跳上报方式维持活性，基本的健康检查流程基本如下：Nacos客户端会维护一个定时任务，每隔5秒发送一次心跳请求，以确保自己处于活跃状态。Nacos服务端在15秒内如果没收到客户端的心跳请求，会将该实例设置为不健康，在30秒内没收到心跳，会将这个临时实例摘除</p>
<ul>
<li>“instanceHeartBeatInterval”: 5000, <strong>心跳间隔</strong></li>
<li>“instanceHeartBeatTimeOut”: 15000, <strong>心跳超时，超过这个时间将服务置不健康状态</strong></li>
<li>“ipDeleteTimeout”: 30000, <strong>超过这个时间将服务移除</strong></li>
</ul>
</li>
</ul>
<h4 id="服务发现的好处"><a href="#服务发现的好处" class="headerlink" title="服务发现的好处"></a>服务发现的好处</h4><ul>
<li>快速水平伸缩，而不是垂直伸缩，不影响客户端</li>
<li>提高应用程序的弹性</li>
</ul>
<h4 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408140342608.png" alt="image-20230408140342608"></p>
<blockquote>
<p>注: nacos 不负责转发请求, 仅用于存储各服务的访问地址</p>
</blockquote>
<h3 id="2-Spring-Cloud家族"><a href="#2-Spring-Cloud家族" class="headerlink" title="2. Spring Cloud家族"></a>2. Spring Cloud家族</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408140455307.png" alt="image-20230408140455307"></p>
<h4 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h4><ul>
<li>Spring Cloud Alibaba是Spring Cloud的子项目，符合Spring Cloud的标准，致力于提供微服务开发的一站式解决方案</li>
<li>官网文档：<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/README-zh.md</a></li>
<li>例子代码：<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/tree/2.2.x/spring-cloud-alibaba-examples">https://github.com/alibaba/spring-cloud-alibaba/tree/2.2.x/spring-cloud-alibaba-examples</a></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408140757600.png" alt="image-20230408140757600" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408140830205.png" alt="image-20230408140830205" style="zoom: 67%;" /></p>
<h3 id="3-nacos实现服务注册与发现"><a href="#3-nacos实现服务注册与发现" class="headerlink" title="3. nacos实现服务注册与发现"></a>3. nacos实现服务注册与发现</h3><h4 id="使用到的starter依赖"><a href="#使用到的starter依赖" class="headerlink" title="使用到的starter依赖"></a>使用到的starter依赖</h4><ul>
<li>服务配置：com.alibaba.cloud，spring-cloud-starter-alibaba-nacos-config</li>
<li>服务注册：com.alibaba.cloud，spring-cloud-starter-alibaba-nacos-discovery</li>
<li>客户端负载均衡：org.springframework.cloud，spring-cloud-starter-loadbalancer</li>
<li>简化客户端调用：org.springframework.cloud，spring-cloud-starter-openfeign</li>
</ul>
<h4 id="bootstrap-yml配置nacos"><a href="#bootstrap-yml配置nacos" class="headerlink" title="bootstrap.yml配置nacos"></a>bootstrap.yml配置nacos</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">nacos-headless:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yml</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">nacos-headless:8848</span><br></code></pre></td></tr></table></figure>
<h4 id="使用到的注解"><a href="#使用到的注解" class="headerlink" title="使用到的注解"></a>使用到的注解</h4><ul>
<li><code>@EnableDiscoveryClient</code></li>
<li><code>@EnableFeignClients</code></li>
<li><code>@LoadBalanced</code></li>
</ul>
<h3 id="4-调用服务的三种方式"><a href="#4-调用服务的三种方式" class="headerlink" title="4. 调用服务的三种方式"></a>4. 调用服务的三种方式</h3><ul>
<li>Spring DiscoveryClient</li>
<li>使用支持LoadBalanced的RestTemplate</li>
<li>使用OpenFeign（@FeignClient）<ul>
<li>OpenFeign是一款声明式、模板化的HTTP客户端，Feign可以帮助我们更快捷、优雅地调用HTTP API</li>
</ul>
</li>
</ul>
<h4 id="Spring-DiscoveryClient"><a href="#Spring-DiscoveryClient" class="headerlink" title="Spring DiscoveryClient"></a>Spring DiscoveryClient</h4><ul>
<li>启动类加 <code>@EnableDiscoveryClient</code></li>
<li>注入：<code>private DiscoveryClient discoveryClient;</code><ul>
<li><code>discoveryClient.getInstances</code></li>
<li><code>new RestTemplate</code></li>
<li><code>restTemplate.exchange</code></li>
</ul>
</li>
</ul>
<h4 id="使用支持LoadBalanced的RestTemplate"><a href="#使用支持LoadBalanced的RestTemplate" class="headerlink" title="使用支持LoadBalanced的RestTemplate"></a>使用支持LoadBalanced的RestTemplate</h4><ul>
<li><code>@LoadBalanced</code></li>
<li>注入: <code>RestTemplate restTemplate;</code></li>
<li><code>restTemplate.exchange</code>，指定要调用的服务名，而不是IP</li>
</ul>
<h4 id="使用OpenFeign（-FeignClient）"><a href="#使用OpenFeign（-FeignClient）" class="headerlink" title="使用OpenFeign（@FeignClient）"></a>使用OpenFeign（<code>@FeignClient</code>）</h4><ul>
<li>启动类加注解：<code>@EnableFeignClients</code></li>
<li>定义接口</li>
<li>接口加注解：<code>@FeignClient(&quot;organizationservice&quot;)</code></li>
</ul>
<h4 id="有用的命令"><a href="#有用的命令" class="headerlink" title="有用的命令"></a>有用的命令</h4><ul>
<li>查看日志：<code>kubectl logs -f -l app=organizationservice --all-containers=true</code></li>
<li>重部署：<code>kubectl rollout restart deployment organizationservice</code></li>
<li>扩容：<code>kubectl scale deployment organizationservice --replicas 5</code></li>
</ul>
<h3 id="5-健康检查"><a href="#5-健康检查" class="headerlink" title="5. 健康检查"></a>5. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/473494621">健康检查</a></h3><ol>
<li>临时实例的客户端主动上报机制，临时实例每隔 5s 发送一个心跳包给 Nacos 服务器端<ul>
<li>学习参考（源码剖析）：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/386647120">https://zhuanlan.zhihu.com/p/386647120</a></li>
<li>客户端调用如何应对服务状态不能及时更新，请参考学习：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fDtcQD1EL-NgVV1BMiPx4g">https://mp.weixin.qq.com/s/fDtcQD1EL-NgVV1BMiPx4g</a></li>
</ul>
</li>
<li>永久实例的服务端反向探测机制，永久实例支持 3 种探测协议，TCP、HTTP 和 MySQL，默认探测协议为 TCP， 也就是通过不断 ping 的方式来判断实例是否健康。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230408143113182.png" alt="image-20230408143113182"></p>
<h3 id="6-负载均衡策略"><a href="#6-负载均衡策略" class="headerlink" title="6. 负载均衡策略"></a>6. 负载均衡策略</h3><ul>
<li>roundLoadBalancer</li>
<li>randomLoadBalancer</li>
<li><code>@LoadBalancerClient(name = &quot;organizationservice&quot;, configuration = Application.class)</code></li>
<li>对第二、三种调用都有效</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/05/Docker-%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/05/Docker-%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Docker 镜像分层机制详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-05 16:34:30" itemprop="dateCreated datePublished" datetime="2023-04-05T16:34:30+08:00">2023-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-base-镜像"><a href="#1-base-镜像" class="headerlink" title="1. base 镜像"></a>1. base 镜像</h2><p>我们在打包项目时，实际上往往需要一个基本的操作系统环境，这样我们才可以在这个操作系统上安装各种依赖软件，比如数据库、缓存等，像这种基本的系统镜像，我们称为base镜像</p>
<p>base 镜像有两层含义：（1）不依赖其他镜像，从 scratch 构建；（2）其他镜像可以之为基础进行扩展。</p>
<p>所以，能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230405172002741.png" alt="image-20230405172002741"></p>
<p>可以看到，CentOS的base镜像下载完成后，不像我们使用完整系统一样，base镜像的CentOS省去了内核，所以大小只有231M</p>
<h3 id="1-1-base-镜像机制"><a href="#1-1-base-镜像机制" class="headerlink" title="1.1 base 镜像机制"></a>1.1 base 镜像机制</h3><p><strong>Linux 操作系统由内核空间和用户空间组成。</strong></p>
<p>典型的Linux启动到运行需要两个FS，<code>bootfs</code> + <code>rootfs</code>，如下图：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/dvmqAjKHkucbLFh.png" alt="image-20220701133111829"  /></p>
<p>Linux启动后首先会加载 <code>bootfs</code> 文件系统，加载完成后会自动卸载掉，之后会加载用户空间的文件系统，这一层是我们自己可以进行操作的部分：</p>
<ul>
<li><code>bootfs</code> 包含了 BootLoader 和 Linux 内核，用户是不能对这层作任何修改的，在内核启动之后，<code>bootfs</code> 会自动卸载。</li>
<li><code>rootfs</code> 则包含了系统上的常见的目录结构，包括<code>/dev</code>、<code>/proc</code>、<code>/bin</code>等等以及一些基本的文件和命令，也就是我们进入系统之后能够操作的整个文件系统，包括我们在Ubuntu下使用的apt和CentOS下使用的yum，都是用户空间上的。</li>
<li>由此可见对于不同的linux发行版, <code>bootfs</code>基本是一致的, <code>rootfs</code>会有差别, 因此<strong>不同的发行版可以公用<code>bootfs</code>。</strong></li>
</ul>
<p>base 镜像底层会<strong>直接使用宿主主机的内核</strong></p>
<ul>
<li>也就是说你的宿主机内核版本是多少，base镜像中的 CentOS 内核版本就是多少</li>
<li>因此 base 镜像只需要提供 <code>rootfs</code> 即可，而对于一个精简的 OS，<code>rootfs</code> 可以很小，只需要包括最基本的命令、工具和程序库就可以了，某些操作系统的base镜像甚至都不到10M。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>宿主机</th>
<th>容器</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230405172717255.png" alt="image-20230405172717255"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230405172808799.png" alt="image-20230405172808799"></td>
</tr>
</tbody>
</table>
</div>
<p>可以看到内核版本是一样的（这也是缺点所在，如果软件对内核版本有要求的话，那么此时使用 Docker 就不如使用虚拟机）</p>
<h2 id="2-镜像分层"><a href="#2-镜像分层" class="headerlink" title="2. 镜像分层"></a>2. 镜像分层</h2><h3 id="2-1-创建测试镜像"><a href="#2-1-创建测试镜像" class="headerlink" title="2.1 创建测试镜像"></a>2.1 创建测试镜像</h3><p>Docker Image 如何而来呢？</p>
<ul>
<li><p>简单来说，一个 Image 是通过一个 DockerFile 定义的，然后使用 docker build 命令构建它</p>
</li>
<li><p>DockerFile 中的<strong>每一条命令的执行结果</strong>都会成为 Image 中的一个 <strong>Layer</strong></p>
</li>
</ul>
<p>这里，我们通过 Build 一个简单的镜像，来观察 Image 的分层机制：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.15</span>.<span class="hljs-number">0</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=file1 bs=10M count=1 <span class="hljs-comment">#添加一个10M的文件file1</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=file2 bs=10M count=1 <span class="hljs-comment">#添加一个10M的文件file2</span></span><br></code></pre></td></tr></table></figure>
<p>构建结果：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230405170117559.png" alt="image-20230405170117559"></p>
<p>通过构建结果可以看出，构建的过程就是执行 Dockerfile 文件中我们写入的命令。</p>
<p>如果 Dockerfile 中的内容没有变动，那么相应的镜像在 build 的时候会<strong>复用之前的 Layer</strong>，以便提升构建效率。并且，即使文件内容有修改，那也只会重新 build 修改的 Layer，其他未修改的也仍然会复用。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230405170536609.png" alt="image-20230405170536609"></p>
<h3 id="2-2-查看镜像"><a href="#2-2-查看镜像" class="headerlink" title="2.2 查看镜像"></a>2.2 查看镜像</h3><p>有 2 种方法查看镜像：</p>
<ol>
<li>使用<code>docker inspect</code>：获取镜像的元数据</li>
<li>使用<code>docker history</code>：查看镜像的构建历史</li>
</ol>
<h4 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a><code>docker inspect</code></h4><p>使用 <code>docker inspect</code> 查看镜像的元数据。<br>其中<code>Parent</code>可以看到父镜像， <code>Layers</code>这一项下面可以看到镜像的所有层。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230405171059129.png" alt="image-20230405171059129"></p>
<h4 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a><code>docker history</code></h4><p>使用<code>docker history</code>可以看到镜像的构建历史。<br>每一行列出了镜像包含的层。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230405171130593.png" alt="image-20230405171130593"></p>
<h2 id="3-Copy-on-Write"><a href="#3-Copy-on-Write" class="headerlink" title="3. Copy-on-Write"></a>3. Copy-on-Write</h2><p>为什么 Docker 镜像要采用这种分层结构呢？</p>
<ul>
<li><p><strong>共享资源</strong></p>
<ul>
<li>比如有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</li>
<li><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。</p>
</li>
<li><p>而且镜像的每一层都可以被共享</p>
</li>
</ul>
</li>
</ul>
<p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是否也会被修改？</p>
<ul>
<li><strong>答案是不会！修改会被限制在单个容器内。这就是容器的 Copy-on-Write 特性。</strong></li>
</ul>
<p><strong>Copy-on-write是一种提高文件共享和复制效率的策略。</strong></p>
<ul>
<li><p>如果一个文件和目录在低一层的镜像层中存在，并且其它层想要读取这个文件，就直接使用这个文件。</p>
<ul>
<li>如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件。</li>
</ul>
</li>
<li><p>新数据会直接存放在最上面的容器层。</p>
</li>
<li>修改现有数据会<strong>先从镜像层将数据复制到容器层</strong>，修改后的数据直接保存在容器层中，<strong>镜像层保持不变。</strong></li>
</ul>
<h2 id="4-可写的容器层"><a href="#4-可写的容器层" class="headerlink" title="4. 可写的容器层"></a>4. 可写的容器层</h2><p><strong>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230405173314451.png" alt="image-20230405173314451" style="zoom:67%;" /></p>
<p>所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。<strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的。</strong></p>
<p>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。</p>
<p>只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p>
<p>这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/04/01/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84-1-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/01/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84-1-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">软件系统设计-架构(1) 概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-01 15:31:16" itemprop="dateCreated datePublished" datetime="2023-04-01T15:31:16+08:00">2023-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-19 00:14:12" itemprop="dateModified" datetime="2023-08-19T00:14:12+08:00">2023-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">软件系统设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-课程背景"><a href="#1-课程背景" class="headerlink" title="1. 课程背景"></a>1. 课程背景</h2><h3 id="1-1-为什么要研究软件设计与架构？Why-Study-Software-Design-amp-Architecture"><a href="#1-1-为什么要研究软件设计与架构？Why-Study-Software-Design-amp-Architecture" class="headerlink" title="1.1 为什么要研究软件设计与架构？Why Study Software Design &amp; Architecture?"></a>1.1 为什么要研究软件设计与架构？Why Study Software Design &amp; Architecture?</h3><ul>
<li>软件(IT)系统无处不在<br>Software(IT) systems are everywhere</li>
<li>每个<strong>软件密集型系统</strong>都有一个软件设计和架构<br>Every <strong>software intensive system</strong> has a sofftware design and architecture</li>
<li>软件设计和架构是实践，教育和研究中越来越重要的领域<br>Software design and architecture are an increasingly important area of practice, education, and research</li>
<li>专业: 软件架构师<br>As a profession: Software Architect</li>
<li>作为研究领域 As a research area<ul>
<li>最初于1960年左右开始 Originally started around 1960</li>
<li>自1990年以来备受关注 Attracting major attention since 1990</li>
</ul>
</li>
<li>本课程是关于<ul>
<li>软件设计和架构的概念，原理，方法和模式<br>Concepts, principles, methods, and patterns of software design and architecture</li>
<li>软件设计和架构的最新实践<br>State-of-the-art practices of software design and architecture</li>
</ul>
</li>
</ul>
<h3 id="1-2-学习目标-Learning-Objectives"><a href="#1-2-学习目标-Learning-Objectives" class="headerlink" title="1.2 学习目标 Learning Objectives"></a>1.2 学习目标 Learning Objectives</h3><ul>
<li>理解软件设计和架构的概念和原理<br>Understand concepts and principles of software design and architecture</li>
<li>通过考虑需求或通过反向架构来创建软件架构<br>Create software architecture by taking requirements or through reverse architecting</li>
<li>在创建软件架构和设计的时候应用设计模式、风格、中间件技术和框架<br>Apply patterns, styles, middleware technologies and frameworks in creating software architecture and design</li>
<li>分析软件设计和评估软件架构的系统性<br>Analyze software design and evaluate software architecture systematically</li>
<li>了解应用在软件设计和架构中的最先进的方法<br>Understand state-of-the-art methods applied in software design and architecture</li>
<li>理解软件设计与软件架构之间的关系，以及其他软件工程的领域话题<br>Understand relationships between software design and software architecture, and other software engineering topic areas</li>
</ul>
<h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h2><h3 id="2-1-理解软件工程-Understanding-Software-Engineering"><a href="#2-1-理解软件工程-Understanding-Software-Engineering" class="headerlink" title="2.1 理解软件工程 Understanding Software Engineering"></a>2.1 理解软件工程 Understanding Software Engineering</h3><ul>
<li>Software 和 Engineering</li>
<li>Software vs. Hardware<ul>
<li>软件是不可见的: 软件是虚拟的，而硬件是实体的。</li>
<li>软件制作出来就是为了被修改和改变的(软件的演化是他的本质属性)</li>
</ul>
</li>
<li>Science vs. Engineering: 科学的研究是研究这个世界既有的部分，而工程是研究的是人类创造新的世界(是不是因为人才产生的)，下面的图是很重要的。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230430160149409.png" alt="image-20230430160149409" style="zoom: 80%;" /></p>
<h3 id="2-2-什么是软件架构-What-is-Software-Architecture"><a href="#2-2-什么是软件架构-What-is-Software-Architecture" class="headerlink" title="2.2 什么是软件架构 What is Software Architecture"></a>2.2 什么是软件架构 What is Software Architecture</h3><ul>
<li>定义1: 程序或计算系统的软件架构是系统的一个或多个结构，它包括软件元素、这些元素的外部可见属性以及它们之间的关系。<br>Definition 1: “The software architecture of a program or computing system is the structure or structures of the system, which comprise software elements, the externally visible properties of those elements, and the relationships among them.” [Software Engineering Institute (SEI)] </li>
<li>定义2: 系统的基本组织，体现在其组件，它们之间的相互关系以及环境以及支配其<strong>设计和演进的原则</strong>。<br>Definition 2: “The fundamental organization of a system, embodied in its components, their relationships to each other and the environment, and the principles governing its design and evolution.” [IEEE 1471 -2000 “Recommended Practice for Architectural Description of Software-Intensive Systems”]</li>
</ul>
<blockquote>
<p>Module和Component的区别</p>
<ol>
<li>Component(组件): 是已经实现了的软件部分</li>
<li>Module(模块): 是还没有实现出来的软件部分</li>
<li>Element包含了Component和Module。</li>
</ol>
</blockquote>
<h3 id="2-3-架构-vs-设计-Architecture-vs-Design"><a href="#2-3-架构-vs-设计-Architecture-vs-Design" class="headerlink" title="2.3 架构 vs. 设计 Architecture vs. Design"></a>2.3 架构 vs. 设计 Architecture vs. Design</h3><ul>
<li><p>架构是关于软件设计 It’s about software design </p>
<ul>
<li>所有的架构都是软件设计，但不是所有的软件设计都是架构<br>All architecture is software design, but not all design is software architecture</li>
<li>架构是设计过程的一部分<br>“Architecting” is part of the design process </li>
</ul>
</li>
<li><p>其他观点 Other views</p>
<ul>
<li><p>架构是更高层的设计 <strong>High-level</strong> designs </p>
</li>
<li><p>架构是设计决策的组合 A set of design decisions</p>
</li>
<li><blockquote>
<p>架构是根据不同项目而不同的 Locality</p>
</blockquote>
</li>
</ul>
</li>
<li><p>系统的结构或组织 Structure/Organization of the system</p>
<ul>
<li>元素(Elements): 组件(Components)和连接件(Connectors)<br>Elements: components &amp; connectors</li>
<li>关系: 静态(static)和动态(dynamic)的关系<br>Relationships: static &amp; dynamic relationships</li>
</ul>
</li>
<li><p>属性: 元素，元素组和整个系统<br>Properties: elements, groups of elements &amp; overall system</p>
</li>
</ul>
<h3 id="2-4-架构-vs-结构-Architecture-vs-Structure"><a href="#2-4-架构-vs-结构-Architecture-vs-Structure" class="headerlink" title="2.4 架构 vs. 结构 Architecture vs. Structure"></a>2.4 架构 vs. 结构 Architecture vs. Structure</h3><ul>
<li>架构将系统分解成组件/模块/子系统，降低每一部分的复杂度<br>Decomposition of system into components/modules/subsystems </li>
<li>架构定义 Architecture defines<ul>
<li>组件接口: 组件可以做什么？<br>Component <strong>interfaces</strong>: What a component can do?</li>
<li>组件交流和依赖: 组件可以怎么沟通交流？<br>Component <strong>communications</strong> and <strong>dependencies</strong>: How components communicate? </li>
<li>组件职责: 当我们询问它时，组件需要精确的知道自己将要做什么？<br>Component <strong>responsibilities</strong>: Precisely what a component will do when you ask it?</li>
</ul>
</li>
</ul>
<h4 id="2-4-1-结构和架构-Structure-and-Architecture"><a href="#2-4-1-结构和架构-Structure-and-Architecture" class="headerlink" title="2.4.1 结构和架构 Structure and Architecture"></a>2.4.1 结构和架构 Structure and Architecture</h4><div class="table-container">
<table>
<thead>
<tr>
<th>结构</th>
<th>架构</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230430161802500.png" alt="image-20230430161802500"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230430161817061.png" alt="image-20230430161817061"></td>
</tr>
</tbody>
</table>
</div>
<p>图中左侧的设计: 第三方的模块与其他的四个模块直接耦合</p>
<p>图中右侧的设计: 我们加入了AL模块来屏蔽了变化</p>
<h4 id="2-4-2-架构确定通信-Architecture-Specifies-Communication"><a href="#2-4-2-架构确定通信-Architecture-Specifies-Communication" class="headerlink" title="2.4.2 架构确定通信 Architecture Specifies Communication"></a>2.4.2 架构确定通信 Architecture Specifies Communication</h4><p>通信涉及 Communication involves:</p>
<ul>
<li><strong>数据</strong>通过机器传递 Data passing mechanisms, for example:<ul>
<li>函数调用 Function call</li>
<li>远程方法调用 Remote method invocation</li>
<li>异步信息 Asynchronous message</li>
</ul>
</li>
<li><strong>控制</strong>流 Control flow<ul>
<li>组件间的信息流来实现需要的功能 Flow of messages between components to achieve required functionality</li>
<li>序列化的 Sequential</li>
<li>并发/并行 Concurrent/parallel</li>
<li>同步 Synchronization</li>
</ul>
</li>
</ul>
<h4 id="2-4-3-架构强调非功能性需求-NFA-Architecture-Address-NFRS"><a href="#2-4-3-架构强调非功能性需求-NFA-Architecture-Address-NFRS" class="headerlink" title="2.4.3 架构强调非功能性需求(NFA) Architecture Address NFRS"></a>2.4.3 架构强调非功能性需求(NFA) Architecture Address NFRS</h4><ul>
<li><strong>非功能性需求(Non-functional requirements)</strong>定义了<strong>系统运行的有多好</strong><br>Non-functional requirements (NFRs) define “how well a system works?”</li>
<li>当然也需要考虑功能性需求。</li>
<li>非功能性需求很少在功能性需求中被发现<br>NFRs rarely captured in functional requirements<ul>
<li>又名架构需求 Aka. architecture requirements</li>
<li>必须通过架构引出 Must be elicited by architect</li>
</ul>
</li>
<li>非功能性需求包括 NFRs include<ul>
<li>技术约束 Technical constraints</li>
<li>商业约束 Business constraints</li>
<li>质量属性 Quality attrilbutes</li>
</ul>
</li>
<li>讨论: 质量属性列表 Discussion: A list of quality attributes?</li>
</ul>
<h2 id="3-如何创建一个设计-How-to-Develop-a-Design"><a href="#3-如何创建一个设计-How-to-Develop-a-Design" class="headerlink" title="3. 如何创建一个设计 How to Develop a Design?"></a>3. 如何创建一个设计 How to Develop a Design?</h2><p>广义的设计策略 Generic Design Strategies:</p>
<ol>
<li>分解 Decomposition</li>
<li>抽象 Abstraction</li>
<li>逐步的: 分而治之 Stepwise: Divid and Conquer</li>
<li>生成和测试 Generate and Test</li>
<li>迭代: 渐进式细化 Iteration: Incremental Refinement</li>
<li>重用元素 Reuseable elements</li>
</ol>
<h3 id="3-1-设计是一种抽象-Design-is-an-Abstraction"><a href="#3-1-设计是一种抽象-Design-is-an-Abstraction" class="headerlink" title="3.1 设计是一种抽象 Design is an Abstraction"></a>3.1 设计是一种抽象 Design is an Abstraction</h3><ul>
<li>架构提供了设计的更高层抽象视角<br>Architecture provides an higher level abstract view of a design<ul>
<li>隐藏设计的复杂性和实现<br>Hides complexity and implementation of design</li>
<li>可能是或者可能不是架构元素和软件元素之间的直接映射<br>May or may not be a direct mapping between architecture elements and sottware elements </li>
</ul>
</li>
<li>黑盒设计 和 白盒设计 Blackbox design and Whitebox design<ul>
<li>是对系统结构和交互的非正式描述<br>Informal depiction of system’s structure and interactions.</li>
<li>描述在架构中内嵌的设计哲学<br>Portray the design philosophies embodied in the<br>architecture</li>
</ul>
</li>
<li>讨论: 为什么在设计中使用抽象？Discussion: Why abstraction in design?</li>
</ul>
<h3 id="3-2-架构视图-Architecture-Views"><a href="#3-2-架构视图-Architecture-Views" class="headerlink" title="3.2 架构视图 Architecture Views"></a>3.2 架构视图 Architecture Views</h3><ul>
<li>架构视图主要是为了应对软件不可见的问题，屏蔽其他没有影响的部分，将关注点进行分离</li>
<li>软件架构代表了一个复杂的设计制品<br>A software architecture represents a complex design artifact</li>
<li>很多架构的可能视图: 类比建筑-平面图，外部设计，电力设计，水暖，空气调节<br>Many possible ‘views’ of the architecture: Analogy with buildings-floor plan, external, electrical, plumbing, air-conditioning</li>
</ul>
<h4 id="3-2-1-P-Krutchen的4-1视图模型-P-Krutchen’s-4-1-View-Model"><a href="#3-2-1-P-Krutchen的4-1视图模型-P-Krutchen’s-4-1-View-Model" class="headerlink" title="3.2.1 P.Krutchen的4+1视图模型 P.Krutchen’s 4+1 View Model"></a>3.2.1 P.Krutchen的4+1视图模型 P.Krutchen’s 4+1 View Model</h4><ul>
<li>逻辑视图: 描述了架构中重要的架构元素以及它们之间的关系<br>Logical view: describes architecturally significant elements of the architecture and the relationships between them.</li>
<li>过程视图: 描述了架构中的并发和通信元素<br>Process view: describes the concurrency and communications elements of an architecture.</li>
<li>物理视图: 描述了主要进程和组件是如何映射到应用程序硬件上的<br>Physical view: depicts how the major processes and components are mapped on to the applications hardware.</li>
<li>开发视图: 描述了软件组件是如何在软件内部组织的，比如配置管理工具<br>Development view: captures the internal organization of the software components as held in e.g./ a configuration management tool.</li>
<li>用例场景: 捕获架构需求，与多个特定视图相关<br>Architecture use cases: capture the requirements for the architecture; related to more than one particular view<ul>
<li>四个视图在某一个场景下进行描述</li>
</ul>
</li>
</ul>
<h2 id="4-架构师和软件架构师-Architect-amp-Software-Architect"><a href="#4-架构师和软件架构师-Architect-amp-Software-Architect" class="headerlink" title="4. 架构师和软件架构师 Architect &amp; Software Architect"></a>4. 架构师和软件架构师 Architect &amp; Software Architect</h2><blockquote>
<p>架构师设计了满足人类需求的结构<br>Architects design structures to meet human needs. - James Fitch, 1972</p>
</blockquote>
<ul>
<li>架构师的角色保持不变 The role of the architect remains the same<ul>
<li>倾听用户，理解整体的需求<br>Listening to clients, understanding the totality of needs</li>
<li>审查可行性<br>Scrutinizing feasibilities</li>
<li>形成结构的实用愿景并创建蓝图<br>Forming a practical vision of a structure and creating a blueprint</li>
<li>监督构建过程，保证是符合计划的<br>Overseeing construction and ensuring compliance to the plan </li>
<li>引导在暴风雨式的设计变更、危机和歧义性中的愿景<br>Guiding the vision through the tempest of design changes, crises and ambiguities</li>
</ul>
</li>
<li>软件架构师监督软件构建专业人员: 开发人员、工程师和设计者<br>Software architects oversee software construction professionals: Programmers, Engineers, Designers</li>
<li>有名的软件架构师<ul>
<li>Bill Gates: Chief Software Architect of Microsoft</li>
<li>Tim Bernrs-Lee: Inventor and Chief Architect of World Wide Web</li>
<li>Roy Fielding: Representational State Transfer (REST)</li>
</ul>
</li>
</ul>
<h3 id="4-1-软件架构师做什么-What-Does-a-Software-Architect-Do"><a href="#4-1-软件架构师做什么-What-Does-a-Software-Architect-Do" class="headerlink" title="4.1 软件架构师做什么? What Does a Software Architect Do?"></a>4.1 软件架构师做什么? What Does a Software Architect Do?</h3><ul>
<li>联络 Liaison<ul>
<li>在客户、技术团队和商业/需求分析师之间<br>Among clients, technical team and business/requirements analysts</li>
<li>与管理或营销 With management or marketing</li>
</ul>
</li>
<li>软件工程: 软件工程的最佳实践<br>Software Engineering: Software engineering best practices</li>
<li>技术知识: 深入理解技术领域<br>Technology Knowledge: Deep understanding of technology domain</li>
<li>风险管理: Risk Management<ul>
<li>与设计、技术决策相关的风险<br>Risks associated with the design, technology choices</li>
<li>More?</li>
</ul>
</li>
</ul>
<h2 id="5-总体设计模型-A-General-Design-Model"><a href="#5-总体设计模型-A-General-Design-Model" class="headerlink" title="5. 总体设计模型 A General Design Model"></a>5. 总体设计模型 A General Design Model</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501133700017.png" alt="image-20230501133700017" style="zoom:80%;" /></p>
<p>开发和设计是在做减法</p>
<h3 id="5-1-软件设计过程-Software-Design-Process"><a href="#5-1-软件设计过程-Software-Design-Process" class="headerlink" title="5.1 软件设计过程 Software Design Process"></a>5.1 软件设计过程 Software Design Process</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501133822280.png" alt="image-20230501133822280" style="zoom:80%;" /></p>
<h3 id="5-2-架构活动-Architecture-Activities"><a href="#5-2-架构活动-Architecture-Activities" class="headerlink" title="5.2 架构活动 Architecture Activities"></a>5.2 架构活动 Architecture Activities</h3><ul>
<li>为系统创建业务案例 Creating the business case for the System</li>
<li>理解需求 Understanding the requirements</li>
<li>创建和选择架构 Creating and selecting architecture</li>
<li>沟通架构(包括开发人员在内的涉众)<br>Communicating the architecture (stakeholders including developers)</li>
<li>分析或评估架构 Analysing or evaluating the architecture<ul>
<li>整体的方法论 Overall methodologies</li>
<li>具体技术的质量 Quality specific techniques</li>
</ul>
</li>
<li>实现架构 Implementing the architecture</li>
<li>保证和架构的一致性 Ensuring conformance to an architecture</li>
</ul>
<h3 id="5-3-软件架构过程-Software-Architecture-Process"><a href="#5-3-软件架构过程-Software-Architecture-Process" class="headerlink" title="5.3 软件架构过程 Software Architecture Process"></a>5.3 软件架构过程 Software Architecture Process</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501134333853.png" alt="image-20230501134333853" style="zoom:80%;" /></p>
<h3 id="5-4-架构生命周期-Architecture-Lifecycle"><a href="#5-4-架构生命周期-Architecture-Lifecycle" class="headerlink" title="5.4 架构生命周期 Architecture Lifecycle"></a>5.4 架构生命周期 Architecture Lifecycle</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230501134425708.png" alt="image-20230501134425708" style="zoom:80%;" /></p>
<h3 id="5-5-软件设计和架构知识领域-Software-Design-amp-Architecture-Knowledge-Areas"><a href="#5-5-软件设计和架构知识领域-Software-Design-amp-Architecture-Knowledge-Areas" class="headerlink" title="5.5 软件设计和架构知识领域 Software Design &amp; Architecture Knowledge Areas"></a>5.5 软件设计和架构知识领域 Software Design &amp; Architecture Knowledge Areas</h3><ul>
<li>软件设计基本原理 Software Design Basic Concepts<ul>
<li>整体设计原理 General design concepts</li>
<li>上下文: 软件发展生命周期 - 需求、设计、编码和测试<br>Context: software development life cycle - requirements, design, construction and testing</li>
<li>设计过程: 角色、活动、工作产品 Design process(role, activity, work product)</li>
<li>软件设计的使能技术 Enabling techniques for software design</li>
</ul>
</li>
<li>核心问题(技术): 一致性、事件控制和处理、分发、异常处理、交互系统、持久化<br>Key Issues (technical): concurrency, control and handling of events, distribution, exception handling, interactive systems, persistence</li>
<li>软件结构和架构 Software Structure and Architecture<ul>
<li>架构结构和观点 Architecture Structures and viewpoints</li>
<li>架构风格和模式(宏观架构) Architectural styles and patterns (macro-architecture)</li>
<li>设计模式(微观架构) Design patterns (micro-architecture)</li>
</ul>
</li>
<li>软件设计方法 Software Design Methods<ul>
<li>架构方法，比如属性驱动的设计 Architecture Methods (e.g., Attribute-Driven Design)</li>
<li>设计方法，比如动态系统发展方法 Design Methods (e.g., Dynamic System Development Method)</li>
</ul>
</li>
<li>软件设计的质量分析和评估 Software Design Quality Analysis and Evaluation <ul>
<li>质量属性 Quality attributes</li>
<li>质量分析和评估方法、技术和工具 Quality analysis and evaluation methods, techniques and tools<ul>
<li>设计回顾: 比如SEI的架构权衡分析方法<br>Design reviews (e.g. SEI’s Architecture Trade-off Analysis Method)</li>
<li>静态分析和动态分析 Static analysis and dynamic analysis</li>
<li>模拟和原型 Simulation and prototyping</li>
</ul>
</li>
<li>度量 Measures:<ul>
<li>矩阵: 架构级别 Metrics: Architecture level</li>
<li>技术特有度量指标 Technique specific measures</li>
</ul>
</li>
</ul>
</li>
<li>设计建模和展示 Design Modeling and Representation<ul>
<li>架构和设计符号(架构描述语言，ADL)<br>Architecture and Design Notations (Architecture Description Languages(ADL))</li>
<li>统一建模语言 Unified Modelling Language (UML)</li>
<li>设计文档(意见或其他) Design Documentation (Views &amp; Beyond)</li>
<li>其他: 在活动、关注点和领域上的不同，比如 ACME，Rapide<br>Others: differ in ability, focus and domain (e.g. ACME, Rapide)</li>
</ul>
</li>
</ul>
<h2 id="6-讨论"><a href="#6-讨论" class="headerlink" title="6. 讨论"></a>6. 讨论</h2><ul>
<li>科学和工程有什么不同？What is Difference between Science and Engineering? <ul>
<li>科学的研究是研究这个世界既有的部分</li>
<li>工程是研究的是人类创造新的世界(是不是因为人才产生的)</li>
</ul>
</li>
<li>软件和硬件有什么不同？What is Difference between ‘Software’ and ‘Hardware’?<ul>
<li>软件是不可见的: 软件是虚拟的，而硬件是实体的。</li>
<li>软件制作出来就是为了被修改和改变的(软件的演化是他的本质属性)</li>
</ul>
</li>
<li>架构和设计有什么不同？What is Difference between Architecture and Design?<ul>
<li>所有的架构都是软件设计，但是不是所有的软件设计都是架构</li>
<li>架构是设计过程的一个过程。</li>
<li>其他观点<ul>
<li>架构是更高层的设计，是为了修改的</li>
<li>架构是设计决策的组合</li>
</ul>
</li>
</ul>
</li>
<li>架构和结构有什么不同？What is Difference between Architecture and Structure?<ul>
<li>架构定义了组件(Component)的接口，Component之间如何交流以及如何相互依赖，Component的职责。</li>
<li>架构提供了设计的更高层抽象视角，隐藏设计的复杂性和实现，更强调非功能性需求。</li>
<li>【标准】架构是包括结构信息的，因为结构是一种静态的、逻辑的、是关于系统如何构成。但是架构除了包含结构，还会增加组件的相互之间的关系接口，还会定义一些动态的行为(一个组件可能和谁进行交互)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/23/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-7-REST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/23/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-7-REST/" class="post-title-link" itemprop="url">服务端开发(7) REST服务、微服务开发与部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-23 19:29:47" itemprop="dateCreated datePublished" datetime="2023-03-23T19:29:47+08:00">2023-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-一个-Web-App-的开发和快速反馈"><a href="#1-一个-Web-App-的开发和快速反馈" class="headerlink" title="1. 一个 Web App 的开发和快速反馈"></a>1. 一个 Web App 的开发和快速反馈</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406005903378.png" alt="image-20230406005903378"></p>
<blockquote>
<p>华为云软件开发生产线 CodeArts</p>
<ul>
<li>集合业界先进理念，华为30年研发经验，可操作可落地的端到端一站式开发方法论和工具链。</li>
<li>学习链接:  <a target="_blank" rel="noopener" href="https://support.huaweicloud.com/devcloud/index.html">https://support.huaweicloud.com/devcloud/index.html</a></li>
<li>集华为研发实践、前沿研发理念、先进研发工具于一体，使能软件企业/开发者简单高效地向最终用户交付有价值的软件。</li>
</ul>
</blockquote>
<h2 id="2-开发模式"><a href="#2-开发模式" class="headerlink" title="2. 开发模式"></a>2. 开发模式</h2><p>前、后端不分离的开发模式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406134413889.png" alt="image-20230406134413889"></p>
<p>前后端分离的开发模式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406134433520.png" alt="image-20230406134433520"></p>
<h2 id="3-单体应用程序"><a href="#3-单体应用程序" class="headerlink" title="3. 单体应用程序"></a>3. 单体应用程序</h2><ul>
<li>数据库的表对所有模块可见</li>
<li>一个人的修改整个应用都要重新构建、测试、部署</li>
<li>整体复制分布式部署，不能拆分按需部署</li>
</ul>
<h2 id="4-微服务架构模式的特征"><a href="#4-微服务架构模式的特征" class="headerlink" title="4. 微服务架构模式的特征"></a>4. 微服务架构模式的特征</h2><ul>
<li>应用程序分解为具有明确定义了职责范围的细粒度组件</li>
<li>完全独立部署，独立测试，并可复用</li>
<li>使用轻量级通信协议，HTTP 和 JSON，松耦合</li>
<li>服务实现可使用多种编程语言和技术</li>
<li>将大型团队划分成多个小型开发团队，每个团队只负责他们各自的服务</li>
</ul>
<h2 id="5-Spring-Boot-和-Spring-Cloud"><a href="#5-Spring-Boot-和-Spring-Cloud" class="headerlink" title="5. Spring Boot 和 Spring Cloud"></a>5. Spring Boot 和 Spring Cloud</h2><ul>
<li>Spring Boot 提供了基于 Java 的、面向 REST 的微服务框架</li>
<li>Spring Cloud 使实施和部署微服务到私有云或公有云变得更加简单</li>
</ul>
<h3 id="5-1-Spring-Boot"><a href="#5-1-Spring-Boot" class="headerlink" title="5.1 Spring Boot"></a>5.1 Spring Boot</h3><ul>
<li>简化 Spring Web 开发</li>
<li>Spring Boot Starter<ul>
<li>自动管理依赖、版本号</li>
</ul>
</li>
<li>自动配置<ul>
<li>根据类路径加载的类自动创建需要的Bean</li>
<li>如: DataSource、JdbcTemplate、视图解析器等</li>
</ul>
</li>
<li><p>Actuator</p>
<ul>
<li>/autoconfig 使用了哪些自动配置（positiveMatches）</li>
<li>/beans，包含bean依赖关系</li>
</ul>
</li>
<li><p>Spring initializer: 生成初始框架代码</p>
<ul>
<li>访问: <a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a></li>
</ul>
</li>
</ul>
<h2 id="6-Rest原则"><a href="#6-Rest原则" class="headerlink" title="6. Rest原则"></a>6. Rest原则</h2><ul>
<li>Representational State Transfer，表现层状态转移</li>
<li>资源（Resources），就是网络上的一个实体，标识: URI</li>
<li>表现层（Representation）: json、xml、html、pdf、excel</li>
<li>状态转移（State Transfer）: 服务端—客户端</li>
<li>HTTP协议的四个操作方式的动词: GET、POST、PUT、DELETE<ul>
<li>CRUD: Create、Read、Update、Delete</li>
</ul>
</li>
<li>如果一个架构符合REST原则，就称它为RESTful架构。</li>
</ul>
<h2 id="7-客户端与服务的交互"><a href="#7-客户端与服务的交互" class="headerlink" title="7. 客户端与服务的交互"></a>7. 客户端与服务的交互</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406140432047.png" alt="image-20230406140432047"></p>
<h3 id="7-1-请求报文"><a href="#7-1-请求报文" class="headerlink" title="7.1 请求报文"></a>7.1 请求报文</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406140607318.png" alt="image-20230406140607318"></p>
<h4 id="请求头与请求体"><a href="#请求头与请求体" class="headerlink" title="请求头与请求体"></a>请求头与请求体</h4><p>请求头: 请求头由 key/value 对组成，每行为一对，key 和 value 之间通过冒号(:)分割。请求头的作用主要用于通知服务端有关于客户端的请求信息。</p>
<ul>
<li>User-Agent: 生成请求的浏览器类型</li>
<li>Accept: 客户端可识别的响应内容类型列表<ul>
<li>星号 $\ast$ 用于按范围将类型分组</li>
<li>$\ast / \ast$表示可接受全部类型</li>
<li>$\text{type}/\ast$ 表示可接受 type 类型的所有子类型</li>
</ul>
</li>
<li>Accept-Language: 客户端可接受的自然语言</li>
<li>Accept-Encoding: 客户端可接受的编码压缩格式</li>
<li>Accept-Charset: 可接受的字符集</li>
<li>Host: 请求的主机名，允许多个域名绑定同一 IP 地址</li>
<li>connection: 连接方式（close 或 keepalive）</li>
<li>Cookie: 存储在客户端的扩展字段</li>
<li>Content-Type:标识请求内容的类型</li>
<li>Content-Length:标识请求内容的长度</li>
</ul>
<p>请求体: 请求体主要用于 POST 请求，与 POST 请求方法配套的请求头一般有 Content-Type 和 Content-Length</p>
<h3 id="7-2-响应报文"><a href="#7-2-响应报文" class="headerlink" title="7.2 响应报文"></a>7.2 响应报文</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406141433436.png" alt="image-20230406141433436"></p>
<h4 id="响应头与响应体"><a href="#响应头与响应体" class="headerlink" title="响应头与响应体"></a>响应头与响应体</h4><p>状态行：由 HTTP 协议版本、状态码、状态码描述三部分构成，它们之间由空格隔开</p>
<p>状态码：由 3 位数字组成，第一位标识响应的类型，常用的 5 大类状态码如下：</p>
<ul>
<li>1xx：表示服务器已接收了客户端的请求，客户端可以继续发送请求</li>
<li>2xx：表示服务器已成功接收到请求并进行处理</li>
<li>3xx：表示服务器要求客户端重定向</li>
<li>4xx：表示客户端的请求有非法内容</li>
<li>5xx：标识服务器未能正常处理客户端的请求而出现意外错误</li>
</ul>
<p>响应头:</p>
<ul>
<li>Location：服务器返回给客户端，用于重定向到新的位置</li>
<li>Server：包含服务器用来处理请求的软件信息及版本信息Vary：标识不可缓存的请求头列表</li>
<li>Connection: 连接方式<ul>
<li>close 是告诉服务端，断开连接，不用等待后续的请求了</li>
<li>keep-alive 则是告诉服务端，在完成本次请求的响应后，保持连接</li>
</ul>
</li>
<li>Keep-Alive: 300，期望服务端保持连接多长时间（秒）</li>
</ul>
<p>响应内容：服务端返回给请求端的文本信息。</p>
<h3 id="7-3-客户端表述的两种方式"><a href="#7-3-客户端表述的两种方式" class="headerlink" title="7.3 客户端表述的两种方式"></a>7.3 客户端表述的两种方式</h3><p><strong>内容协商（Content negotiation）</strong></p>
<ul>
<li><code>ContentNegotiatingViewResolver</code> 是要创建的bean，基于内容协商生成表述，判断的依据有请求头的 Accept，URL请求路径加扩展名（优先）</li>
<li>然后会转向具体的视图解析器生成不同的视图表述</li>
<li><code>ContentNegotiationManager</code>（配置的作用）<ul>
<li>通过 setter 注入到 <code>ContentNegotiatingViewResolver</code> 中</li>
<li>创建这个 Bean 的方式是继承自 <code>WebMvcConfigerAdapter</code>（基于spring mvc）</li>
<li>覆盖方法 <code>configureContentNegotiation</code>，配置缺省内容类型等。</li>
</ul>
</li>
</ul>
<p><strong>消息转换器（Message conversion）</strong></p>
<ul>
<li>使用注解 <code>@ResponseBody</code> 或类级 <code>@RestController</code>，作用：指定使用消息转换器</li>
<li>没有 model 和视图，控制器产生数据，然后消息转换器转换数据之后的资源表述</li>
<li>spring 自动注册一些消息转换器（<code>HttpMethodConverter</code>），不过类路径下要有对应转换能力的库，如：Jackson Json processor、JAXB库</li>
<li>请求传入，<code>@RequestBody</code> 以及 <code>HttpMethodConverter</code></li>
</ul>
<h3 id="7-4-提供资源以外的其它内容"><a href="#7-4-提供资源以外的其它内容" class="headerlink" title="7.4 提供资源以外的其它内容"></a>7.4 提供资源以外的其它内容</h3><ul>
<li><code>@ResponseStatus(HttpStatus.CREATED)</code> 指定返回的状态码</li>
<li>控制器方法返回 <code>ResponseEntity</code> 对象，指定业务对象（负载）、状态码、响应头<ul>
<li>不用使用 <code>@ResponseBody</code> 注解</li>
</ul>
</li>
<li>异常处理器，<code>@ExceptionHandler</code>（异常类型），加在方法上</li>
<li>指定响应头信息，通过返回 <code>ResponseEntity</code> 对象的方式<ul>
<li><code>HttpHeaders</code> 类型<ul>
<li>注意与发出请求时的类型 <code>MultiValueMap</code> 区别</li>
</ul>
</li>
<li><code>setLocation</code></li>
</ul>
</li>
</ul>
<h2 id="8-Rest客户端"><a href="#8-Rest客户端" class="headerlink" title="8. Rest客户端"></a>8. Rest客户端</h2><ul>
<li><code>new RestTemplats()</code></li>
<li><code>getForObject()</code>, 指定返回类型，自动转换</li>
<li><code>getForEntity()</code>，返回 <code>ResponseEntity</code>, 有头部信息，<code>getBody()</code>可以转换</li>
<li><code>put()</code>，传递的对象存在转换问题，String 转成 test/plain，MultiValueMap 转成 x-www-form-urlncoded，对象可能转成json，要看 classpass 类路径下有无库</li>
<li><code>delete()</code>,删除一个资源，一般提供资源路径即可</li>
<li><code>postForObject()</code>/<code>postForEntity()</code>/<code>postForLocation()</code><ul>
<li>因为需要返回值</li>
<li><code>postForLocation</code>，只需要路径，不需要body，路径信息来源头部 Location 信息</li>
</ul>
</li>
<li><code>exchange()</code>, <strong>可指定请求头信息</strong><ul>
<li><code>MultiValueMap headers;</code></li>
<li><code>HttpEntity&lt;Object&gt; requestEntity = new HttpEntity&lt;Object&gt;(headers);</code></li>
<li><code>ResponseEntity&lt;Spitter&gt; response = rest.exchange()</code></li>
</ul>
</li>
</ul>
<h4 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h4><ul>
<li><code>@SpringBootApplication</code><ul>
<li>配置类 <code>@Configuration</code></li>
<li><code>@ComponentScan</code></li>
</ul>
</li>
<li><code>@RestController</code><ul>
<li><code>@Controller</code></li>
<li>请求响应，JSON编解码（序列化）</li>
</ul>
</li>
<li><code>mvn spring-boot:run</code></li>
<li>健康检查：<a target="_blank" rel="noopener" href="http://localhost:8080/actuator/health">http://localhost:8080/actuator/health</a></li>
</ul>
<h2 id="9-现实和挑战"><a href="#9-现实和挑战" class="headerlink" title="9. 现实和挑战"></a>9. 现实和挑战</h2><ul>
<li>程序规模越来越大、越来越复杂</li>
<li>客户期望快速频繁交付</li>
<li>性能和可伸缩性</li>
<li>弹性，应用程序中某个部分的故障或问题不应该导致整个应用程序崩溃</li>
<li>小型的、简单的和解耦的服务 = 可伸缩的、有弹性的和灵活的应用程序</li>
</ul>
<h3 id="9-1-云计算平台"><a href="#9-1-云计算平台" class="headerlink" title="9.1 云计算平台"></a>9.1 云计算平台</h3><ul>
<li>基础设施即服务（Infrastructure as a Service , IaaS）</li>
<li>平台即服务（Platform as a Service, PaaS）</li>
<li>软件即服务（Software as a Service, SaaS）</li>
<li>函数即服务（Functions as a Service, FaaS），将代码块以“无服务器”（serverless）的形式部署，无须管理任何服务器基础设施</li>
<li>容器即服务（Container as a Service, CaaS），如亚马逊ECS(Amazon’s Elastic Container Service）</li>
</ul>
<h3 id="9-2-微服务开发要考虑的问题"><a href="#9-2-微服务开发要考虑的问题" class="headerlink" title="9.2 微服务开发要考虑的问题"></a>9.2 微服务开发要考虑的问题</h3><ul>
<li>微服务划分，服务粒度、通信协议、接口设计、配置管理、使用事件解耦微服务</li>
<li>服务注册、发现和路由</li>
<li>弹性，负载均衡，断路器模式（熔断），容错</li>
<li>可伸缩</li>
<li>日志记录和跟踪</li>
<li>安全</li>
<li>构建和部署，基础设施即代码</li>
</ul>
<h3 id="9-3-Spring-Cloud的工具集成"><a href="#9-3-Spring-Cloud的工具集成" class="headerlink" title="9.3 Spring Cloud的工具集成"></a>9.3 Spring Cloud的工具集成</h3><ul>
<li>spring cloud alibaba<ul>
<li>数据配置，与 Nacos 集成</li>
<li>服务注册与发现，与 Nacos 集成<ul>
<li>Spring Cloud Loadbalancer</li>
<li>Spring Cloud openfeign</li>
</ul>
</li>
<li>限流、熔断，与 Sentinel 集成</li>
</ul>
</li>
<li>Spring Cloud gateway，网关服务</li>
<li>Spring Cloud Stream，与 RabbitMQ、Kafka 集成</li>
<li>Spring Cloud Sleuth，与日志聚合工具Papertrail、跟踪工具Zipkin集成</li>
<li>Spring Cloud Security，与OAuth2集成</li>
</ul>
<h3 id="9-4-微服务划分"><a href="#9-4-微服务划分" class="headerlink" title="9.4 微服务划分"></a>9.4 微服务划分</h3><ul>
<li>可以从数据模型入手，每个域的服务只能访问自己的表</li>
<li>刚开始粒度可以大一点，不要太细，由粗粒度重构到细粒度是比较容易的</li>
<li>设计是逐步演化的</li>
</ul>
<h3 id="9-5-接口设计"><a href="#9-5-接口设计" class="headerlink" title="9.5 接口设计"></a>9.5 接口设计</h3><ul>
<li>使用标准 HTTP 动词：GET、PUT、POST、DELETE，映射到 CRUD</li>
<li>使用 URI 来传达意图</li>
<li>请求和响应使用 JSON</li>
<li>使用 HTTP 状态码来传达结果</li>
</ul>
<h3 id="9-6-运维实践"><a href="#9-6-运维实践" class="headerlink" title="9.6 运维实践"></a>9.6 运维实践</h3><ul>
<li>都在源代码库中</li>
<li>指定 JAR 依赖的版本号</li>
<li>配置与源代码分开放</li>
<li>已构建的服务是不可变的，不能再被修改</li>
<li>微服务应该是无状态的</li>
<li>并发，通过启动更多的微服务实例横向扩展，多线程是纵向扩展</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/21/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-6-K8S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/21/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-6-K8S/" class="post-title-link" itemprop="url">服务端开发(6) K8S</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-21 19:52:35" itemprop="dateCreated datePublished" datetime="2023-03-21T19:52:35+08:00">2023-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h2><p>安装 k8s</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">https://github.com/AliyunContainerService/k8s-for-docker-desktop</a></li>
</ul>
<p>部署 dashboard</p>
<ul>
<li><code>kubectl apply -f kubernetes-dashboard.yaml</code></li>
<li>检查 kubernetes-dashboard 应用状态<ul>
<li><code>kubectl get pod -n kubernetes-dashboard</code></li>
</ul>
</li>
<li>将k8s server代理到本地端口：<code>kubectl proxy</code></li>
<li>配置控制台访问令牌</li>
</ul>
<p>启动ingress controller</p>
<ul>
<li><code>kubectl apply -f ingress-nginx-controller.yaml</code></li>
</ul>
<p>验证 Kubernetes 集群状态</p>
<ul>
<li><code>kubectl cluster-info</code></li>
<li><code>kubectl get nodes</code></li>
<li><code>kubectl get nodes --show-labels</code></li>
<li>给节点打标签：<code>kubectl label node docker-desktop disktype=ssd</code></li>
</ul>
<h2 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h2><h3 id="1-1-Kubernetes-基本架构"><a href="#1-1-Kubernetes-基本架构" class="headerlink" title="1.1 Kubernetes 基本架构"></a>1.1 Kubernetes 基本架构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406003846139.png" alt="image-20230406003846139" style="zoom:80%;" /></p>
<h3 id="1-2-k8s中的资源"><a href="#1-2-k8s中的资源" class="headerlink" title="1.2 k8s中的资源"></a>1.2 k8s中的资源</h3><ul>
<li>namespaces</li>
<li>Pods</li>
<li>ReplicaSet</li>
<li>Deployment</li>
<li>Service</li>
<li>Ingress</li>
<li>configmap</li>
<li>secrets</li>
<li>serviceaccounts</li>
<li>DaemonSet</li>
</ul>
<h3 id="1-3-核心概念"><a href="#1-3-核心概念" class="headerlink" title="1.3 核心概念"></a>1.3 核心概念</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406003955811.png" alt="image-20230406003955811"></p>
<h4 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406004020943.png" alt="image-20230406004020943"></p>
<h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ce71385e0370">Pod</a></h4><p>Pod 是 Kubernetes 调度的最小单元</p>
<p>一个 Pod 可以包含一个或多个容器，因此它可以被看作是内部容器的逻辑宿主机。Pod 的设计理念是为了支持多个容器在一个 Pod 中共享网络和文件系统</p>
<ul>
<li>PID 命名空间：Pod中不同的应用程序可以看到其他应用程序的进程ID</li>
<li>network 命名空间：Pod 中多个容器处于同一个网络命名空间，因此能够访问的 IP 和端口范围都是相同的。也可以通过 localhost 相互访问</li>
<li>IPC 命名空间：Pod 中的多个容器共享 Inner-process Communication 命名空间，因此可以通过 SystemV IPC 或 POSIX 进行进程间通信</li>
<li>UTS 命名空间：Pod 中的多个容器共享同一个主机名</li>
<li>Volumes：Pod 中各个容器可以共享在 Pod 中定义分存储卷（Volume）</li>
</ul>
<p>restartPolicy 字段</p>
<ul>
<li>Always：只要退出就重启</li>
<li>OnFailure：失败退出时（exit code不为0）才重启</li>
<li>Never：永远不重启</li>
</ul>
<h4 id="Pod、Container-与-Node-之间的关系"><a href="#Pod、Container-与-Node-之间的关系" class="headerlink" title="Pod、Container 与 Node 之间的关系"></a>Pod、Container 与 Node 之间的关系</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406004354883.png" alt="image-20230406004354883"  /></p>
<h2 id="2-K8S-操作"><a href="#2-K8S-操作" class="headerlink" title="2. K8S 操作"></a>2. K8S 操作</h2><h4 id="创建一个pod"><a href="#创建一个pod" class="headerlink" title="创建一个pod"></a>创建一个pod</h4><ul>
<li><p><code>kubectl run myspittr --image spittr:1.0-SNAPSHOT</code></p>
</li>
<li><p><code>kubectl get pods</code></p>
</li>
<li><p><code>kubectl logs -f myspittr</code></p>
</li>
<li><p>pod中执行一个命令</p>
<ul>
<li><code>kubectl exec myspittr -- ls /run/secrets/kubernetes.io/serviceaccount</code></li>
</ul>
</li>
<li><p><code>kubectl delete pod myspittr</code></p>
</li>
</ul>
<h4 id="如何将pod或service的端口快速映射到本机端口（调试用）"><a href="#如何将pod或service的端口快速映射到本机端口（调试用）" class="headerlink" title="如何将pod或service的端口快速映射到本机端口（调试用）"></a>如何将pod或service的端口快速映射到本机端口（调试用）</h4><ul>
<li><p><code>kubectl port-forward pod/myspittr 8081:8080</code></p>
<ul>
<li>访问：<a target="_blank" rel="noopener" href="http://localhost:8081/spittr/">http://localhost:8081/spittr/</a></li>
</ul>
</li>
<li><p><code>kubectl port-forward service/demo 8081:80</code></p>
</li>
</ul>
<h4 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h4><ul>
<li><p><code>kubectl expose pod myspittr --port 8080</code></p>
</li>
<li><p><code>kubectl get svc</code></p>
</li>
<li><p><code>kubectl delete service myspittr</code></p>
</li>
</ul>
<h4 id="创建-ingress"><a href="#创建-ingress" class="headerlink" title="创建 ingress"></a>创建 ingress</h4><ul>
<li><p><code>kubectl create ingress myspittr --class=nginx --rule=www.demo.com/*=myspittr:8080</code></p>
<ul>
<li>访问：<a target="_blank" rel="noopener" href="http://www.demo.com/spittr/">http://www.demo.com/spittr/</a></li>
</ul>
</li>
<li><p><code>kubectl delete ingress myspittr</code></p>
</li>
</ul>
<h4 id="如何使用命令行快捷创建deployment、service、ingress"><a href="#如何使用命令行快捷创建deployment、service、ingress" class="headerlink" title="如何使用命令行快捷创建deployment、service、ingress"></a>如何使用命令行快捷创建deployment、service、ingress</h4><ul>
<li><p><code>kubectl create deployment myspittr --image=spittr:1.0-SNAPSHOT --port=8080</code></p>
</li>
<li><p><code>kubectl expose deployment myspittr</code></p>
<ul>
<li>把上面的这个pod的8080端口暴露为myspittr服务</li>
</ul>
</li>
<li><p><code>kubectl create ingress myspittr --class=nginx --rule=www.demo.com/*=myspittr:8080</code></p>
</li>
<li><p>访问：<a target="_blank" rel="noopener" href="http://www.demo.com/spittr/">http://www.demo.com/spittr/</a></p>
</li>
</ul>
<p>删除：</p>
<ul>
<li><code>kubectl delete ingress myspittr</code></li>
<li><code>kubectl delete service myspittr</code></li>
<li><code>kubectl delete deployment myspittr</code></li>
</ul>
<h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h2><h4 id="使用yaml文件部署"><a href="#使用yaml文件部署" class="headerlink" title="使用yaml文件部署"></a>使用yaml文件部署</h4><ul>
<li><code>kubectl create -f k8s-deploy.yaml</code></li>
<li><code>kubectl delete -f k8s-deploy.yaml</code></li>
</ul>
<h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/029661f38674">Deployment</a></h4><ul>
<li>更新镜像重部署<ul>
<li><code>kubectl set image deployment/spittr spittr=spittr:1.0</code></li>
</ul>
</li>
<li>扩容<ul>
<li><code>kubectl scale deployment spittr --replicas 2</code></li>
</ul>
</li>
<li>自动<ul>
<li><code>kubectl autoscale deployment spittr --min=10 --max=15 --cpu-percent=80</code></li>
</ul>
</li>
<li>查看历史版本<ul>
<li><code>kubectl rollout history deployment/spittr</code></li>
</ul>
</li>
<li>回滚到前一个版本<ul>
<li><code>kubectl rollout undo deployment/spittr</code></li>
</ul>
</li>
</ul>
<h2 id="4-k8s常用命令"><a href="#4-k8s常用命令" class="headerlink" title="4. k8s常用命令"></a>4. k8s常用命令</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230406005721950.png" alt="image-20230406005721950"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91-3-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91-3-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">数据库开发(3) 数据表的物理实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-15 10:33:12" itemprop="dateCreated datePublished" datetime="2023-03-15T10:33:12+08:00">2023-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">数据库开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-物理组织"><a href="#1-物理组织" class="headerlink" title="1. 物理组织"></a>1. 物理组织</h2><h2 id="2-数据自动分组"><a href="#2-数据自动分组" class="headerlink" title="2. 数据自动分组"></a>2. 数据自动分组</h2><p>分区（partition）也是⼀种数据分组的⽅式</p>
<ul>
<li>提⾼并发性（concurrency）和并⾏性（parallelism）</li>
<li><p>从⽽增强系统架构的可伸缩性（scalable）</p>
</li>
<li><p>应用：滑动窗口（循环分区）</p>
</li>
</ul>
<h3 id="2-1-循环分区"><a href="#2-1-循环分区" class="headerlink" title="2.1 循环分区"></a>2.1 循环分区</h3><p>循环分区：不受数据影响的内部机制</p>
<ul>
<li>分区定义为各个磁盘的存储区域</li>
<li>可以看作是随意散布数据的机制</li>
<li>保持更改带来的磁盘I/O操作的平衡</li>
</ul>
<h3 id="2-2-数据驱动分区"><a href="#2-2-数据驱动分区" class="headerlink" title="2.2 数据驱动分区"></a>2.2 数据驱动分区</h3><p>根据⼀个或多个字段中的值（partition key）来定义分区</p>
<ul>
<li>⼀般叫分区视图（partitioned view），⽽MYSQL称为（merge table）</li>
</ul>
<p>分区的实现⽅式</p>
<ul>
<li>哈希分区（Hash-partitioning）<ul>
<li>按照 partition key 哈希后的值分区</li>
</ul>
</li>
<li>范围分区（Range-partitioning）<ul>
<li>对 partition key 的取值范围进行分区，重要应用为滑动窗口，最常见的就是按时间（往往不会被修改），与业务紧密相关</li>
</ul>
</li>
<li>列表分区（List-partitioning）<ul>
<li>对于一张大表，把部分字段的全部记录放到某个分区</li>
<li>有些字段经常被访问，有些字段访问频率很低</li>
</ul>
</li>
</ul>
<p>要点：partition key 均匀分布，不做修改</p>
<h3 id="2-3-分区是把双刃剑"><a href="#2-3-分区是把双刃剑" class="headerlink" title="2.3 分区是把双刃剑"></a>2.3 分区是把双刃剑</h3><p>分区能解决并发问题吗？</p>
<p>又回到了IOT类似的问题：“冲突”</p>
<ul>
<li>A. 通过分区键将数据聚集，利于⾼速检索</li>
<li>B. 对并发执⾏的更改操作，分散的数据可以避免访问过于集中的问题</li>
</ul>
<p>So，A or B……完全取决于您的需求</p>
<h3 id="2-4-分区与数据分布"><a href="#2-4-分区与数据分布" class="headerlink" title="2.4 分区与数据分布"></a>2.4 分区与数据分布</h3><ul>
<li>表非常⼤，且希望避免并发写⼊数据的冲突就⼀定要用分区吗？</li>
<li>例如客户订单明细表…… </li>
<li>对分区表进⾏查询，当数据按分区键均匀分布时，收益最⼤</li>
</ul>
<h3 id="2-5-数据分区的最佳方法"><a href="#2-5-数据分区的最佳方法" class="headerlink" title="2.5 数据分区的最佳方法"></a>2.5 数据分区的最佳方法</h3><p>整体改善业务处理的操作，才是选择非缺省的存储选项的目标</p>
<p>更新分区键会引起移动数据，似乎应该避免这么做</p>
<ul>
<li>例如实现服务队列，类型（T1…Tn）状态（{W|P|D}）</li>
<li>按请求类型分区：进程的等待降低</li>
<li>按状态分区：轮询的开销降低</li>
<li>取决于：服务器进程的数量、轮询频率、数据的相对流量、各类型请求的处理时间、已完成请求的移除频率</li>
</ul>
<p>对表分区有很多⽅法，显⽽易见的分区未必有效，⼀定要整体考虑</p>
<h3 id="2-6-数据分区的问题"><a href="#2-6-数据分区的问题" class="headerlink" title="2.6 数据分区的问题"></a>2.6 数据分区的问题</h3><p>分区的⼀些缺点，⼤数据量和⾼并发下</p>
<ul>
<li>如果SQL不⾛分区键，很容易造成全表锁</li>
<li>在分区中实现关联查询，就是⼀个灾难</li>
<li>分区表，隐藏复杂，使得⼯程师不可控</li>
<li>DBA给OP埋坑，容易⼤打出⼿，造成同事⽭盾</li>
</ul>
<h2 id="3-分区、分表、分库"><a href="#3-分区、分表、分库" class="headerlink" title="3. 分区、分表、分库"></a>3. 分区、分表、分库</h2><p>分区</p>
<ul>
<li>就是把⼀张表的数据分成 N 个区块，在逻辑上看最终只是⼀张表，但底层是由 N 个物理区块组成的</li>
</ul>
<p>分表</p>
<ul>
<li>就是把⼀张表按⼀定的规则分解成 N 个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</li>
</ul>
<p>分库</p>
<h3 id="3-1-瓶颈"><a href="#3-1-瓶颈" class="headerlink" title="3.1 瓶颈"></a>3.1 瓶颈</h3><p>IO瓶颈</p>
<ul>
<li>热点数据太多，数据缓存不够，每次查询产⽣⼤量IO——分库、垂直分表</li>
<li>⽹络IO瓶颈，请求的数据太多，带宽不够、连接数过多——分库</li>
</ul>
<p>CPU瓶颈</p>
<ul>
<li>SQL问题，join、group by、order by——SQL优化，构建索引</li>
<li>单表数据量过⼤，扫描⾏太多，SQL效率过低——⽔平分表</li>
</ul>
<h3 id="3-2-分表解决的问题"><a href="#3-2-分表解决的问题" class="headerlink" title="3.2 分表解决的问题"></a>3.2 分表解决的问题</h3><ol>
<li>分表后单表的并发能⼒提⾼了，磁盘I/O性能也提⾼了，写操作效率提⾼了</li>
<li>数据分布在不同的⽂件，磁盘I/O性能提⾼</li>
<li><strong>读写锁影响的数据量变小</strong></li>
<li><strong>插⼊数据库需要重新建立索引的数据减少</strong></li>
<li>分表的实现⽅式（复杂）<ul>
<li>需要业务系统配合迁移升级，⼯作量较⼤</li>
</ul>
</li>
</ol>
<h3 id="3-3-分区和分表的区别与联系"><a href="#3-3-分区和分表的区别与联系" class="headerlink" title="3.3 分区和分表的区别与联系"></a>3.3 分区和分表的区别与联系</h3><p>分区和分表的目的都是减少数据库的负担，提⾼表的增删改查效率。</p>
<p>分区只是⼀张表中的数据的存储位置发⽣改变，分表是将⼀张表分成多张表。</p>
<ul>
<li>当访问量⼤，且表数据比较⼤时，两种⽅式可以互相配合使用。</li>
<li>当访问量不⼤，但表数据比较多时，可以只进⾏分区。</li>
</ul>
<p>常见分区分表的规则策略（类似）</p>
<h3 id="3-4-分库"><a href="#3-4-分库" class="headerlink" title="3.4 分库"></a>3.4 分库</h3><p>什么时候考虑使用分库？</p>
<ul>
<li>单台DB的存储空间不够</li>
<li>随着查询量的增加单台数据库服务器已经没办法支撑</li>
</ul>
<p>分库解决的问题</p>
<ul>
<li>其主要目的是为突破单节点数据库服务器的 I/O 能⼒限制，解决数据库扩展性问题。</li>
</ul>
<h3 id="3-5-分库的方法"><a href="#3-5-分库的方法" class="headerlink" title="3.5 分库的方法"></a>3.5 分库的方法</h3><p>垂直拆分</p>
<ul>
<li>将不存在关联关系或者需要 join 的表可以放在不同的数据库不同的服务器中。</li>
<li>按照业务垂直划分。比如：可以按照业务分为资⾦、会员、订单三个数据库。</li>
<li>需要解决的问题：跨数据库的事务、join查询等问题。</li>
</ul>
<p>⽔平拆分</p>
<ul>
<li>例如，⼤部分的站点。数据都是和用户有关，那么可以根据用户，将数据按照用户⽔平拆分。</li>
<li>按照规则划分，⼀般⽔平分库是在垂直分库之后的。比如每天处理的订单数量是海量的，可以按照⼀定的规则⽔平划分。</li>
<li>需要解决的问题：数据路由、组装。</li>
</ul>
<p>读写分离</p>
<ul>
<li>对于时效性不⾼的数据，可以通过读写分离缓解数据库压⼒。</li>
<li>需要解决的问题：在业务上区分哪些业务上是允许⼀定时间延迟的，以及数据同步问题。</li>
</ul>
<h3 id="3-6-分库的问题和解决方案"><a href="#3-6-分库的问题和解决方案" class="headerlink" title="3.6 分库的问题和解决方案"></a>3.6 分库的问题和解决方案</h3><p>问题</p>
<ul>
<li>事务的支持，分库分表，就变成了分布式事务</li>
<li>join时跨库，跨表的问题</li>
<li>分库分表，读写分离使用了分布式，分布式为了保证强⼀致性，必然带来延迟，导致性能降低，系统的复杂度变⾼。</li>
</ul>
<p>常用的解决⽅案：</p>
<ul>
<li>对于不同的⽅式之间没有严格的界限，特点不同，侧重点不同。需要根据实际情况，结合每种⽅式的特点来进⾏处理。</li>
<li>选用第三⽅的数据库中间件（Atlas，Mycat，TDDL，DRDS），同时业务系统需要配合数据存储的升级。</li>
</ul>
<h3 id="3-7-全局ID生成策略"><a href="#3-7-全局ID生成策略" class="headerlink" title="3.7 全局ID生成策略"></a>3.7 全局ID生成策略</h3><p>自动增长列</p>
<ul>
<li>自带功能、有序、性能不错</li>
<li>单库单表没问题，但分库分表需要⼿动规划（自增偏移+步长；全局ID映射表Redis）</li>
</ul>
<p>UUID（128位）：</p>
<ul>
<li>简单，全球唯⼀</li>
<li>存储和传输空间⼤，⽆序，性能⽋佳</li>
</ul>
<p>COMB（组合）</p>
<ul>
<li>GUID（10字节）+时间（6字节）</li>
</ul>
<p>Snowflake（雪花算法）</p>
<ul>
<li>Twitter开源的分布式ID⽣成算法，结果是long（64bit）数值。</li>
<li>其特征是各个节点⽆需协调，按时间⼤致有序，且整个集群各个节点不重复。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230315112840218.png" alt="image-20230315112840218"  /></p>
<h3 id="3-8-Holy-Simplicity"><a href="#3-8-Holy-Simplicity" class="headerlink" title="3.8 Holy Simplicity"></a>3.8 Holy Simplicity</h3><p>除了堆⽂件之外的任何存储⽅法，都会带来复杂性</p>
<p>除了单库单表之外任何的存储⽅式，都会带来复杂性</p>
<p>选错存储⽅式会带来⼤幅度的性能降低</p>
<p>总结 ：</p>
<ol>
<li>测试，测试，测试</li>
<li>设计是最重要的</li>
<li>任何设计都有时效性</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/14/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-5-Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-5-Docker/" class="post-title-link" itemprop="url">服务端开发(5) Docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-14 15:22:21" itemprop="dateCreated datePublished" datetime="2023-03-14T15:22:21+08:00">2023-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1. 容器"></a>1. 容器</h2><h3 id="1-1-什么是容器"><a href="#1-1-什么是容器" class="headerlink" title="1.1 什么是容器"></a>1.1 什么是容器</h3><p>容器是另外一种轻量级的虚拟化，容器是共用主机内核，利用内核的虚拟化技术隔离出一个独立的运行环境，拥有独立的一个文件系统，网络空间，进程空间视图等</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314195622248.png" alt="image-20230314195622248" style="zoom:80%;" /></p>
<h3 id="1-2-容器与虚拟机"><a href="#1-2-容器与虚拟机" class="headerlink" title="1.2 容器与虚拟机"></a>1.2 容器与虚拟机</h3><p>从虚拟化层看容器，<strong>轻量级、高性能</strong>是核心价值</p>
<ul>
<li><p>容器是在Linux内核实现的轻量级资源隔离机制</p>
</li>
<li><p>虚拟机是操作系统级别的资源隔离，容器本质上是进程级的资源隔离</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314195912283.png" alt="image-20230314195912283" style="zoom:80%;" /></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314195927526.png" alt="image-20230314195927526" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-Docker"><a href="#2-Docker" class="headerlink" title="2. Docker"></a>2. Docker</h2><p>只能运行在 Linux 环境，即使在 windows 系统提供了 Docker Desktop，底层也是运行在 Linux 虚拟机中的</p>
<h3 id="2-1-Windows下的两类容器"><a href="#2-1-Windows下的两类容器" class="headerlink" title="2.1 Windows下的两类容器"></a>2.1 Windows下的两类容器</h3><p>Windows Container</p>
<p>Linux Container</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314202011156.png" alt="image-20230314202011156" style="zoom:80%;" /></p>
<h3 id="2-2-Docker-的三部分"><a href="#2-2-Docker-的三部分" class="headerlink" title="2.2 Docker 的三部分"></a>2.2 Docker 的三部分</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314202234086.png" alt="image-20230314202234086" style="zoom:80%;" /></p>
<h3 id="2-3-Docker-基本命令"><a href="#2-3-Docker-基本命令" class="headerlink" title="2.3 Docker 基本命令"></a>2.3 Docker 基本命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker<br>docker container --<span class="hljs-built_in">help</span><br>docker --version<br>docker version<br>docker info<br>docker image <span class="hljs-built_in">ls</span><br>docker pull<br></code></pre></td></tr></table></figure>
<h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><p>docker search mongo</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314204426093.png" alt="image-20230314204426093" style="zoom:80%;" /></p>
<h4 id="docker-run-命令"><a href="#docker-run-命令" class="headerlink" title="docker run 命令"></a>docker run 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run hello-world<br>-d: 后台运行容器，并返回容器ID<br>-i: 以交互模式运行容器，通常与 -t 同时使用<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用<br>-p: 指定（发布）端口映射，格式为：主机(宿主)端口:容器端口   <br>-P: 随机端口映射，容器内部端口随机映射到主机的高端口<br>--name=<span class="hljs-string">&quot;nginx-lb&quot;</span>: 为容器指定一个名称<br>-e username=<span class="hljs-string">&quot;ritchie&quot;</span>: 设置环境变量<br>--env-file=c:/temp1/t1.txt: 从指定文件读入环境变量<br>--expose=2000-2002: 开放（暴露）一个端口或一组端口；<br>--<span class="hljs-built_in">link</span> my-mysql:taozs : 添加链接到另一个容器<br>-v c:/temp1:/data: 绑定一个卷(volume)<br>--<span class="hljs-built_in">rm</span> 退出时自动删除容器<br>-w: 指定容器内的工作目录<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -it -p 8080:80 nginx<br><span class="hljs-comment"># 可以通过宿主机的8080端口访问容器的80端口</span><br></code></pre></td></tr></table></figure>
<p><strong>busybox镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -it busybox sh<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/hosts<br><span class="hljs-built_in">cat</span> /proc/version<br><span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure>
<h4 id="练习：gcc"><a href="#练习：gcc" class="headerlink" title="练习：gcc"></a>练习：gcc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -v E:\WorkSpace\Server\gcc-hw:/hw -w /hw –it --name=server nercury/cmake-cpp:gcc-5.2<br>docker run --<span class="hljs-built_in">rm</span> -v E:\WorkSpace\Server\gcc-hw:/hw -w /hw –it --name=client nercury/cmake-cpp:gcc-5.2<br></code></pre></td></tr></table></figure>
<h4 id="练习：-mysql的启动和访问"><a href="#练习：-mysql的启动和访问" class="headerlink" title="练习： mysql的启动和访问"></a>练习： mysql的启动和访问</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull mysql:5.7<br>docker run --name my-mysql -e MYSQL_ROOT_PASSWORD=exampledb20 -d mysql:5.7<br>docker run -it --<span class="hljs-built_in">rm</span> --<span class="hljs-built_in">link</span> my-mysql:server mysql:5.7 mysql –hserver -uroot -pexampledb20 <span class="hljs-comment"># 客户端</span><br></code></pre></td></tr></table></figure>
<h3 id="2-4-数据卷"><a href="#2-4-数据卷" class="headerlink" title="2.4 数据卷"></a>2.4 数据卷</h3><p>Docker-managed volume（docker管理卷）</p>
<p>Bind mount volume（绑定挂载卷）</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314211833037.png" alt="image-20230314211833037" style="zoom:80%;" /></p>
<p>volumes: Docker 管理宿主机文件系统的一部分，默认位于 /var/lib/docker/volumes</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume <span class="hljs-built_in">ls</span><br>docker volume create my_volume<br><span class="hljs-comment"># 使用</span><br>docker run -v my_volume:/data -it --<span class="hljs-built_in">rm</span> busybox sh<br><span class="hljs-comment"># 进入命令行后 /data 下的内容就永久存储在 my_volume</span><br></code></pre></td></tr></table></figure>
<h3 id="2-5-容器网络"><a href="#2-5-容器网络" class="headerlink" title="2.5 容器网络"></a>2.5 容器网络</h3><p>none网络，—net=none</p>
<p>host网络，—net=host</p>
<p>bridge网络，—net=bridge ， docker0 的 linux bridge</p>
<ul>
<li>创建的容器默认搭在桥上，不同容器可以通信，并可以路由到宿主机及外部网络</li>
</ul>
<p>container模式，—net=container:NAME_or_ID</p>
<ul>
<li>使两个容器使用完全相同的网络，可以共享 localhost</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314211920219.png" alt="image-20230314211920219" style="zoom:80%;" /></p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network <span class="hljs-built_in">ls</span><br>docker network create my_network<br>docker network inspect my_network <span class="hljs-comment"># 查看网络详细信息</span><br></code></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my_network&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;44348fb303ee38682ffa76afe17d9cc919ef29dc9de0d83689802952a82f94ac&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Created&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2023-03-16T11:46:54.154057664Z&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bridge&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;EnableIPv6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;IPAM&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;Subnet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.18.0.0/16&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;Gateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.18.0.1&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Internal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Attachable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Ingress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ConfigFrom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Network&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ConfigOnly&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Containers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>首先创建两台容器，使用自己创建的网络(172.18.0.1，网关)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -it --name=first --net=my_network busybox sh <span class="hljs-comment"># 搭载在刚刚创建的网络</span><br>docker run --<span class="hljs-built_in">rm</span> -it --name=second --net=my_network busybox sh <span class="hljs-comment"># 创建第二个容器</span><br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>First</th>
<th>Second</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316195016589.png" alt="image-20230316195016589" style="zoom:80%;" /></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316195107330.png" alt="image-20230316195107330" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<p>这两个容器可以 ping 通</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316195254960.png" alt="image-20230316195254960" style="zoom:80%;" /></p>
<p>再创建一个容器，使用默认的bridge网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -it --name=third busybox sh<br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Third</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316195400824.png" alt="image-20230316195400824" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<p>显然无法ping通上面两个容器</p>
<p>可以给这个容器再加一个”网卡”，搭载在创建的网络上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network connect my_network 562ff5169a <span class="hljs-comment"># 容器id</span><br></code></pre></td></tr></table></figure>
<p>在不同的网络中有各自的ip</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316195801223.png" alt="image-20230316195801223" style="zoom:80%;" /></p>
<p>现在就可以ping通了</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316195831410.png" alt="image-20230316195831410" style="zoom:80%;" /></p>
<h2 id="3-容器镜像构建与编排"><a href="#3-容器镜像构建与编排" class="headerlink" title="3. 容器镜像构建与编排"></a>3. 容器镜像构建与编排</h2><h3 id="3-1-由-Dockerfile-构建镜像"><a href="#3-1-由-Dockerfile-构建镜像" class="headerlink" title="3.1 由 Dockerfile 构建镜像"></a>3.1 由 Dockerfile 构建镜像</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316201145944.png" alt="image-20230316201145944" style="zoom:80%;" /></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基础镜像</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.9</span><br><br><span class="hljs-comment"># 元数据</span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=tzs919@163.com</span><br><br><span class="hljs-comment"># 在基础镜像的基础上执行的linux命令</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p /home/docker/code/app \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /root/.pip</span><br>    <br><span class="hljs-comment"># 拷贝命令，从当前上下文拷贝到目标容器的子目录下</span><br><span class="hljs-comment"># 上下文：Dockerfile所在的目录上下文</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> pip.conf /root/.pip/</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /home/docker/code/app</span><br><br><span class="hljs-comment"># 第二个点为WORKDIR</span><br><span class="hljs-comment"># 如果有不需要的文件或目录可以添加到.dockerignore</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><br><span class="hljs-comment"># 指定环境变量</span><br><span class="hljs-keyword">ENV</span> MYNAME=<span class="hljs-string">&quot;taozhaosheng&quot;</span>\<br>    APP_PORT=<span class="hljs-number">80</span><br><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /data</span><br><br><span class="hljs-comment"># 对外暴露端口号</span><br><span class="hljs-keyword">EXPOSE</span> $APP_PORT<br><br><span class="hljs-comment"># 容器启动后要执行的第一个程序</span><br><span class="hljs-comment">#CMD [&quot;uwsgi&quot;,&quot;--ini&quot;,&quot;uwsgi.ini&quot;]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>,<span class="hljs-string">&quot;manage.py&quot;</span>,<span class="hljs-string">&quot;runserver&quot;</span>,<span class="hljs-string">&quot;0.0.0.0:80&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<h4 id="Dockerfile文件的指令"><a href="#Dockerfile文件的指令" class="headerlink" title="Dockerfile文件的指令"></a>Dockerfile文件的指令</h4><ul>
<li><code>FROM</code>：指定基础镜像，必须为第一个命令</li>
<li><code>RUN</code>：构建镜像时执行的命令</li>
<li><code>ADD</code>：将本地文件添加到容器中，tar类型文件会自动解压</li>
<li><code>COPY</code>：功能类似ADD，但是不会自动解压文件</li>
<li><code>CMD</code>：构建容器后调用，也就是在容器启动时才进行调用</li>
<li><code>ENTRYPOINT</code>：配置容器，使其可执行化。配合CMD可省去“application”，只使用参数，用于<code>docker run</code>时根据不同参数执行不同功能</li>
<li><code>LABEL</code>：用于为镜像添加元数据</li>
<li><code>ENV</code>：设置环境变量</li>
<li><code>EXPOSE</code>：指定与外界交互的端口，容器内的端口号，<code>docker run</code>时加 -P 则会映射一个随机号（宿主机）</li>
<li><code>VOLUME</code>：用于指定持久化目录，docker run时如果没有指定挂载目录，会创建一个volume</li>
<li><code>WORKDIR</code>：工作目录，类似于cd命令</li>
<li><code>USER</code>：指定运行容器时的用户名或UID</li>
<li><code>ARG</code>：用于指定传递给构建运行时的变量</li>
<li><code>ONBUILD</code>：用于设置镜像触发器</li>
</ul>
<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成镜像</span><br><span class="hljs-comment"># 最后一个点为 context</span><br>docker build -t mysite:latest .<br><span class="hljs-comment"># 运行容器</span><br>docker run -d --name=mysite -p 8081:80 mysite:latest<br></code></pre></td></tr></table></figure>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:8081/admin/">http://localhost:8081/admin/</a></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/8081-admin.jpg" alt="8081-admin"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mysite bash <span class="hljs-comment"># 通过shell与容器交互</span><br>docker container inspect mysite <span class="hljs-comment"># 查看容器详细信息</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316204413073.png" alt="image-20230316204413073" style="zoom:80%;" /></p>
<h4 id="Docker-build"><a href="#Docker-build" class="headerlink" title="Docker build"></a>Docker build</h4><ul>
<li><code>docker build [OPTIONS] PATH | URL | -</code></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26904830">如何编写最佳的Dockerfile</a>：<ul>
<li>.dockerignore文件</li>
<li>容器只运行单个应用</li>
<li>将多个RUN指令合并为一个</li>
<li>基础镜像的标签不要用latest</li>
<li>每个RUN指令后删除多余文件</li>
<li>选择合适的基础镜像(alpine版本最好)</li>
<li>设置 WORKDIR 和 CMD</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/386986915">Docker 健康检查 HEALTHCHECK 的使用方法</a></li>
</ul>
<h3 id="3-2-镜像分层"><a href="#3-2-镜像分层" class="headerlink" title="3.2 镜像分层"></a>3.2 镜像分层</h3><p>写时复制(COW，Copy-On-Write)</p>
<p>docker history \<image name> 查看镜像的层</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230315231523381.png" alt="image-20230315231523381" style="zoom:80%;" /></p>
<p>将所有的 RUN 指令合并为一个</p>
<ul>
<li>Dockerfile 中的<strong>每个指令</strong>都会创建一个新的镜像层</li>
<li>镜像层将被缓存和复用</li>
<li>当 Dockerfile 的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效</li>
<li>某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效</li>
<li>镜像层是不可变的，如果我们在某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在 Docker 容器中不可见了)</li>
</ul>
<p>优化：<strong>把变化最少的部分放在Dockerfile的前面</strong>，这样可以充分利用镜像缓存</p>
<ul>
<li>例如将 <code>RUN pip install -r requirements.txt</code> 放在 <code>COPY . .</code> 之前</li>
</ul>
<h3 id="3-3-服务编排工具，docker-compose"><a href="#3-3-服务编排工具，docker-compose" class="headerlink" title="3.3 服务编排工具，docker-compose"></a>3.3 服务编排工具，docker-compose</h3><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排</p>
<p>一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目 （project）</p>
<p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理</p>
<p>Compose 中有两个重要的概念</p>
<ul>
<li>服务(service)：一个应用的容器（可能会有多个容器），实际上可以包括若干运行相同镜像的容器实例</li>
<li>项目(project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义</li>
</ul>
<p>使用微服务架构的系统一般包含若干个微服务，每个微服务一般部署多个实例。如果每个服务都要手动启停，那么效率低，维护量大</p>
<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46545831/article/details/112995427">Docker-compose指令详解</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93459395">Docker三剑客之docker-compose</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.6&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">fluentd:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">./fluentd</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ES_HOST=elasticsearch</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ES_PORT=9200</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;24224:24224&quot;</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch</span><br><br>  <span class="hljs-attr">flask:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">./container</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8090:80&quot;</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">fluentd</span><br>    <span class="hljs-attr">logging:</span><br>      <span class="hljs-attr">driver:</span> <span class="hljs-string">fluentd</span><br>      <span class="hljs-attr">options:</span><br>        <span class="hljs-attr">fluentd-address:</span> <span class="hljs-string">localhost:24224</span><br>        <span class="hljs-attr">tag:</span> <span class="hljs-string">docker.flask</span><br><br>  <span class="hljs-attr">elasticsearch:</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">docker.elastic.co/elasticsearch/elasticsearch:6.3.2</span><br>      <span class="hljs-attr">environment:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">cluster.name=docker-cluster</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">bootstrap.memory_lock=true</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br>      <span class="hljs-attr">ulimits:</span><br>        <span class="hljs-attr">memlock:</span><br>          <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span><br>          <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9200:9200&quot;</span><br>  <br>  <span class="hljs-attr">kibana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker.elastic.co/kibana/kibana:6.3.2</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5601:5601&quot;</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316210453332.png" alt="image-20230316210453332"></p>
<blockquote>
<h4 id="YAML-文件"><a href="#YAML-文件" class="headerlink" title="YAML 文件"></a>YAML 文件</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230316210159136.png" alt="image-20230316210159136" style="zoom:80%;" /></p>
</blockquote>
<h4 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h4><ul>
<li>docker-compose —help</li>
<li>docker-compose up -d<ul>
<li>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作</li>
</ul>
</li>
<li>docker-compose ps、docker-compose ps —services</li>
<li>docker-compose images</li>
<li>docker-compose stop<ul>
<li>终止整个服务集合</li>
</ul>
</li>
<li>docker-compose stop nginx<ul>
<li>终止指定的服务（这有个点就是启动的时候会先启动 depends_on 中的容器，关闭的时候不会影响到depends_on中的）</li>
</ul>
</li>
<li>docker-compose logs -f [services…]<ul>
<li>查看容器的输出日志</li>
</ul>
</li>
<li>docker-compose build  [SERVICE…]</li>
<li>docker-compose rm nginx<ul>
<li>移除指定的容器</li>
</ul>
</li>
<li>docker-compose up -d —scale flask=3  organizationservice=2<ul>
<li>设置指定服务运行的容器个数</li>
</ul>
</li>
</ul>
<h4 id="ports、expose、links、depends-on"><a href="#ports、expose、links、depends-on" class="headerlink" title="ports、expose、links、depends_on"></a>ports、expose、links、depends_on</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/382779508">docker-compose的ports、expose、links、depends_on使用技巧</a></p>
<h4 id="docker-compose-yml格式参考"><a href="#docker-compose-yml格式参考" class="headerlink" title="docker-compose.yml格式参考"></a>docker-compose.yml格式参考</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230327160829434.png" alt="image-20230327160829434"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Whale-lyi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Whale-lyi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
