<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="码农预备役">
<meta property="og:type" content="website">
<meta property="og:title" content="Whale&#39;s Blog">
<meta property="og:url" content="https://whale-lyi.github.io/page/5/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="码农预备役">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Whale">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://whale-lyi.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/11/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-4-Spring-Security/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/11/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-4-Spring-Security/" class="post-title-link" itemprop="url">服务端开发(4) Spring Security</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-11 17:10:45" itemprop="dateCreated datePublished" datetime="2023-03-11T17:10:45+08:00">2023-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="1-实现过程"><a href="#1-实现过程" class="headerlink" title="1. 实现过程"></a>1. 实现过程</h3><h4 id="1-1-依赖及配置"><a href="#1-1-依赖及配置" class="headerlink" title="1.1 依赖及配置"></a>1.1 依赖及配置</h4><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>两种配置</p>
<ul>
<li><p>纯Java配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>继承自WebSecurityConfigurerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>用户信息存储</p>
<ul>
<li>内存用户存储</li>
<li>JDBC用户存储</li>
<li>LDAP用户存储</li>
</ul>
<h4 id="1-2-UserDetails"><a href="#1-2-UserDetails" class="headerlink" title="1.2 UserDetails"></a>1.2 UserDetails</h4><p>使用Spring Data存储库来保存用户</p>
<p>定义领域对象：User，实现了UserDetails接口，Spring Security就可以做到基于用户名密码进行认证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// User.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetails</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// UserDetails.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; getAuthorities();<br><br>    String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span>;<br><br>    String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAccountNonExpired</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAccountNonLocked</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCredentialsNonExpired</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnabled</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义持久化接口：<code>UserRepository</code>，增加自定义方法：<code>findByUsername</code></p>
<h4 id="1-3-UserDetailsService"><a href="#1-3-UserDetailsService" class="headerlink" title="1.3 UserDetailsService"></a>1.3 UserDetailsService</h4><p>在配置类中添加 Bean，提供接口实现，Spring可以用于从用户名获取用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title function_">userDetailsService</span><span class="hljs-params">(UserRepository userRepo)</span> &#123;<br>    <span class="hljs-keyword">return</span> username -&gt; &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userRepo.findByUsername(username);<br>        <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) &#123;<br>        	<span class="hljs-keyword">return</span> user;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<br>                      <span class="hljs-string">&quot;User &#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; not found&quot;</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// UserDetailsService.class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br>    UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1-4-PasswordEncoder"><a href="#1-4-PasswordEncoder" class="headerlink" title="1.4 PasswordEncoder"></a>1.4 PasswordEncoder</h4><p>提供密码转换器，保证安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1-5-创建自定义登录页"><a href="#1-5-创建自定义登录页" class="headerlink" title="1.5 创建自定义登录页"></a>1.5 创建自定义登录页</h4><p>当需要认证时转向的登录页：<code>.loginPage(&quot;/login&quot;)</code></p>
<p>视图控制器，定义login请求对应的视图：<code>registry.addViewController(&quot;/login&quot;);</code></p>
<p>登录的post请求由Spring Security自动处理，名称默认：username、password，可配置</p>
<h4 id="1-6-保护Web请求"><a href="#1-6-保护Web请求" class="headerlink" title="1.6 保护Web请求"></a>1.6 保护Web请求</h4><p>在 Controller 前处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> http<br>        .authorizeRequests()<br>            .mvcMatchers(<span class="hljs-string">&quot;/design&quot;</span>, <span class="hljs-string">&quot;/orders&quot;</span>).hasRole(<span class="hljs-string">&quot;USER&quot;</span>)<br>            .anyRequest().permitAll()<br>        .and() <span class="hljs-comment">// 如果用户没有定义则重定向到登录</span><br>            .formLogin()<br>              .loginPage(<span class="hljs-string">&quot;/login&quot;</span>)<br>        .and()<br>            .logout()<br>              .logoutSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>)<br>        <span class="hljs-comment">// Make H2-Console non-secured; for debug purposes</span><br>        .and()<br>            .csrf()<br>              .ignoringAntMatchers(<span class="hljs-string">&quot;/h2-console/**&quot;</span>)<br>        <span class="hljs-comment">// Allow pages to be loaded in frames from the same origin; needed for H2-Console</span><br>        .and()  <br>            .headers()<br>              .frameOptions()<br>                .sameOrigin()<br>        .and()<br>        	.build();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-权限分类"><a href="#2-权限分类" class="headerlink" title="2. 权限分类"></a>2. 权限分类</h3><p>Authority，权限</p>
<p>Role，角色，===&gt;&gt;&gt;权限，加前缀：ROLE_</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// User.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;<br>	<span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleGrantedAuthority</span>(<span class="hljs-string">&quot;ROLE_USER&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-实现方法级别的安全"><a href="#3-实现方法级别的安全" class="headerlink" title="3. 实现方法级别的安全"></a>3. 实现方法级别的安全</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableGlobalMethodSecurity</span> <span class="hljs-comment">//注意要添加，注解才能生效</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;&#125;<br><br><span class="hljs-comment">// OrderAdminService.java</span><br><span class="hljs-meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAllOrders</span><span class="hljs-params">()</span> &#123;<br>	orderRepository.deleteAll();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-获取当前登录的用户"><a href="#4-获取当前登录的用户" class="headerlink" title="4. 获取当前登录的用户"></a>4. 获取当前登录的用户</h3><p>Principal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute(name = &quot;user&quot;)</span> <span class="hljs-comment">// jdk jaas java底层提供的框架</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">user</span><span class="hljs-params">(Principal principal)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> principal.getName();<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userRepo.findByUsername(username);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>@AuthenticationPrincipal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">processOrder</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> TacoOrder order, Errors errors,</span><br><span class="hljs-params">  	SessionStatus sessionStatus,</span><br><span class="hljs-params">  	<span class="hljs-meta">@AuthenticationPrincipal</span> User user)</span> &#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>安全上下文获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可用于任何地方</span><br><span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext().getAuthentication();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) authentication.getPrincipal();<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/07/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-3-JDBC%E3%80%81JPA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/07/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-3-JDBC%E3%80%81JPA/" class="post-title-link" itemprop="url">服务端开发(3) Spring Data JDBC、JPA</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-07 15:42:47" itemprop="dateCreated datePublished" datetime="2023-03-07T15:42:47+08:00">2023-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-使用原始JDBC访问数据库"><a href="#1-使用原始JDBC访问数据库" class="headerlink" title="1. 使用原始JDBC访问数据库"></a>1. 使用原始JDBC访问数据库</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select id, name, type from Ingredient&quot;</span>;<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery();<br><span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>    <span class="hljs-type">Ingredient</span> <span class="hljs-variable">ingredient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ingredient</span>(<br>            resultSet.getString(<span class="hljs-string">&quot;id&quot;</span>),<br>            resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>),<br>            Ingredient.Type.valueOf(resultSet.getString(<span class="hljs-string">&quot;type&quot;</span>)));<br>    ingredients.add(ingredient);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>问题：样板式代码、SQLException</p>
<h2 id="2-使用JdbcTemplate"><a href="#2-使用JdbcTemplate" class="headerlink" title="2. 使用JdbcTemplate"></a>2. 使用JdbcTemplate</h2><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.h2database<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>h2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-2-H2配置与访问"><a href="#2-2-H2配置与访问" class="headerlink" title="2.2 H2配置与访问"></a>2.2 H2配置与访问</h3><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">generate-unique-name:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">tacocloud</span><br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/h2-console">http://localhost:8080/h2-console</a></p>
<p>驱动：org.h2.Driver</p>
<p>JDBC URL：jdbc:h2:mem:tacocloud</p>
<p>用户名：sa</p>
<h3 id="2-3-IngredientRepository的实现"><a href="#2-3-IngredientRepository的实现" class="headerlink" title="2.3 IngredientRepository的实现"></a>2.3 IngredientRepository的实现</h3><p><strong>注入JdbcTemplate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">JdbcIngredientRepository</span><span class="hljs-params">(JdbcTemplate jdbcTemplate)</span> &#123;<br>	<span class="hljs-built_in">this</span>.jdbcTemplate = jdbcTemplate;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>@Repository</strong></p>
<p><strong>接口：RowMapper</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// jdbcTemplate方法</span><br>jdbcTemplate.query(<br>        <span class="hljs-string">&quot;select id, name, type from Ingredient&quot;</span>,<br>        <span class="hljs-built_in">this</span>::mapRowToIngredient);<br><br>jdbcTemplate.update(<br>        <span class="hljs-string">&quot;insert into Ingredient (id, name, type) values (?, ?, ?)&quot;</span>,<br>        ingredient.getId(),<br>        ingredient.getName(),<br>        ingredient.getType().toString());<br><br><span class="hljs-comment">// mapRowToIngredient</span><br><span class="hljs-keyword">private</span> Ingredient <span class="hljs-title function_">mapRowToIngredient</span><span class="hljs-params">(ResultSet row, <span class="hljs-type">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ingredient</span>(<br>        row.getString(<span class="hljs-string">&quot;id&quot;</span>),<br>        row.getString(<span class="hljs-string">&quot;name&quot;</span>),<br>        Ingredient.Type.valueOf(row.getString(<span class="hljs-string">&quot;type&quot;</span>)));<br>&#125;<br><br><span class="hljs-comment">// RowMapper</span><br>jdbcTemplate.queryForObject(<br>        <span class="hljs-string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RowMapper</span>&lt;Ingredient&gt;() &#123;<br>          <span class="hljs-keyword">public</span> Ingredient <span class="hljs-title function_">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-type">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ingredient</span>(<br>                rs.getString(<span class="hljs-string">&quot;id&quot;</span>),<br>                rs.getString(<span class="hljs-string">&quot;name&quot;</span>),<br>                Ingredient.Type.valueOf(rs.getString(<span class="hljs-string">&quot;type&quot;</span>)));<br>          &#125;;<br>        &#125;, id);<br></code></pre></td></tr></table></figure>
<h3 id="2-4-数据库表创建与数据初始化"><a href="#2-4-数据库表创建与数据初始化" class="headerlink" title="2.4 数据库表创建与数据初始化"></a>2.4 数据库表创建与数据初始化</h3><p>在resource目录下放置，名称固定</p>
<ul>
<li>schema.sql</li>
<li>data.sql</li>
</ul>
<h3 id="2-5-save-TacoOrder-order-的实现"><a href="#2-5-save-TacoOrder-order-的实现" class="headerlink" title="2.5 save(TacoOrder order)的实现"></a>2.5 save(TacoOrder order)的实现</h3><p>JdbcOrderRepository</p>
<p><strong>获取返回的ID，GeneratedKeyHolder</strong></p>
<h2 id="3-使用-Spring-Data-JDBC"><a href="#3-使用-Spring-Data-JDBC" class="headerlink" title="3. 使用 Spring Data JDBC"></a>3. 使用 Spring Data JDBC</h2><h3 id="3-1-Spring-Data项目"><a href="#3-1-Spring-Data项目" class="headerlink" title="3.1 Spring Data项目"></a>3.1 Spring Data项目</h3><ul>
<li>Spring Data JDBC</li>
<li>Spring Data JPA</li>
<li>Spring Data MongoDB</li>
<li>Spring Data Neo4j</li>
<li>Spring Data Redis</li>
<li>Spring Data Cassandra</li>
</ul>
<h3 id="3-2-引入依赖"><a href="#3-2-引入依赖" class="headerlink" title="3.2 引入依赖"></a>3.2 引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>用spring boot编译出支持不同版本的jdk</p>
<p>如果当前安装的jdk是17，则编译出的版本支持：1.8、11、17</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="3-3-定义持久化接口"><a href="#3-3-定义持久化接口" class="headerlink" title="3.3 定义持久化接口"></a>3.3 定义持久化接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IngredientRepository</span> <br>         <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CrudRepository</span>&lt;Ingredient, String&gt; &#123;&#125; <span class="hljs-comment">// &lt;操作的类型, 主键类型&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="3-4-为领域类添加持久化的注解"><a href="#3-4-为领域类添加持久化的注解" class="headerlink" title="3.4 为领域类添加持久化的注解"></a>3.4 为领域类添加持久化的注解</h3><p><code>@Table</code></p>
<p><code>@Id</code></p>
<p><code>@Column</code></p>
<h3 id="3-5-提高程序健壮性"><a href="#3-5-提高程序健壮性" class="headerlink" title="3.5 提高程序健壮性"></a>3.5 提高程序健壮性</h3><p>JVM 断言</p>
<p>开启debug模式</p>
<p>使用spring boot的Assert类</p>
<h3 id="3-6-程序预加载"><a href="#3-6-程序预加载" class="headerlink" title="3.6 程序预加载"></a>3.6 程序预加载</h3><p>org.springframework.boot.CommandLineRunner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CommandLineRunner <span class="hljs-title function_">dataLoader</span><span class="hljs-params">(IngredientRepository repo)</span> &#123; <span class="hljs-comment">// ApplicationRunner</span><br>    <span class="hljs-keyword">return</span> args -&gt; &#123;<br>        repo.deleteAll();<br>        repo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Ingredient</span>(<span class="hljs-string">&quot;FLTO&quot;</span>, <span class="hljs-string">&quot;Flour Tortilla&quot;</span>, Type.WRAP));<br>        repo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Ingredient</span>(<span class="hljs-string">&quot;COTO&quot;</span>, <span class="hljs-string">&quot;Corn Tortilla&quot;</span>, Type.WRAP));<br>        repo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Ingredient</span>(<span class="hljs-string">&quot;GRBF&quot;</span>, <span class="hljs-string">&quot;Ground Beef&quot;</span>, Type.PROTEIN));<br>        ...<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>org.springframework.boot.ApplicationRunner</p>
<h2 id="4-使用-Spring-Data-JPA"><a href="#4-使用-Spring-Data-JPA" class="headerlink" title="4. 使用 Spring Data JPA"></a>4. 使用 Spring Data JPA</h2><p>JPA：Java Persistence API</p>
<p>JPA的宗旨是为POJO提供持久化标准规范</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="4-1-Jpa、Hibernate、Spring-Data-Jpa三者之间的关系"><a href="#4-1-Jpa、Hibernate、Spring-Data-Jpa三者之间的关系" class="headerlink" title="4.1 Jpa、Hibernate、Spring Data Jpa三者之间的关系"></a>4.1 Jpa、Hibernate、Spring Data Jpa三者之间的关系</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230309163056920.png" alt="image-20230309163056920" style="zoom:80%;" /></p>
<h3 id="4-2-Entity"><a href="#4-2-Entity" class="headerlink" title="4.2 @Entity"></a>4.2 @Entity</h3><ul>
<li><p><code>javax.persistence.*</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18732646/name-attribute-in-entity-and-table">https://stackoverflow.com/questions/18732646/name-attribute-in-entity-and-table</a></p>
</li>
</ul>
<h3 id="4-3-自动生成的数据库表"><a href="#4-3-自动生成的数据库表" class="headerlink" title="4.3 自动生成的数据库表"></a>4.3 自动生成的数据库表</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230309163544196.png" alt="image-20230309163544196" style="zoom:80%;" /></p>
<h3 id="4-4-自定义的查询方法"><a href="#4-4-自定义的查询方法" class="headerlink" title="4.4 自定义的查询方法"></a>4.4 自定义的查询方法</h3><p>定义查询方法，无需实现</p>
<ul>
<li>领域特定语言（domain-specific language，DSL)，spring data的命名约定</li>
<li>查询动词 + 主题 + 断言</li>
<li>查询动词：get、read、find、count</li>
<li>例子： <code>List findByDeliveryZip(String deliveryZip);</code></li>
</ul>
<p>声明自定义查询</p>
<ul>
<li>不符合方法命名约定时，或者命名太长时</li>
<li><code>@Query(&quot;Order o where o.deliveryCity = &#39;Seattle&#39;&quot;)</code><br><code>List readOrdersDeliveredInSeattle( );</code></li>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-data-jpa-query">https://www.baeldung.com/spring-data-jpa-query</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/06/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-Linux-Programming-Prerequisite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/06/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-Linux-Programming-Prerequisite/" class="post-title-link" itemprop="url">Linux程序设计(3) Linux Programming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-06 14:01:40" itemprop="dateCreated datePublished" datetime="2023-03-06T14:01:40+08:00">2023-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">Linux程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-Programming-Prerequisite"><a href="#Linux-Programming-Prerequisite" class="headerlink" title="Linux Programming Prerequisite"></a>Linux Programming Prerequisite</h1><h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><h2 id="1-What-is-File-and-File-System"><a href="#1-What-is-File-and-File-System" class="headerlink" title="1. What is File and File System?"></a>1. What is File and File System?</h2><p>文件：可以写入或读取或两者兼有的对象。文件具有某些属性，包括访问权限和类型。</p>
<p>文件系统：文件及其某些属性的集合。它为引用这些文件的文件序列号提供了名称空间。</p>
<h3 id="1-1-文件系统的多种含义"><a href="#1-1-文件系统的多种含义" class="headerlink" title="1.1 文件系统的多种含义"></a>1.1 文件系统的多种含义</h3><ol>
<li>指一种特定的文件格式。例如，我们说Linux的文件系统是Ext2，MSDOS的文件系统是FATI6，而Windows NT的文件系统是NTFS或FAT32，就是指这个意思。</li>
<li>指按特定格式进行了”格式化”的一块存储介质。当我们说”安装”或”拆卸”一个文件系统时，指的就是这个意思。</li>
<li>指操作系统中(通常在内核中)用来管理文件系统以及对文件进行操作的机制及其实现，这就是本章的主要话题</li>
</ol>
<h3 id="1-2-文件类型与结构"><a href="#1-2-文件类型与结构" class="headerlink" title="1.2 文件类型与结构"></a>1.2 文件类型与结构</h3><p>文件类型</p>
<ol>
<li>普通文件(regular file)</li>
<li>字符型设备文件(character special file)</li>
<li>块型设备文件(block special file)</li>
<li>管道(fifo)</li>
<li>网络接口(socket)</li>
<li>符号链接(symbolic link)</li>
<li>目录(directory)：该目录中的文件列表</li>
</ol>
<p>文件结构：字节流，没有特别的内部结构</p>
<h3 id="1-3-Linux中的文件系统"><a href="#1-3-Linux中的文件系统" class="headerlink" title="1.3 Linux中的文件系统"></a>1.3 Linux中的文件系统</h3><h4 id="Virtual-File-system-Switch-VFS"><a href="#Virtual-File-system-Switch-VFS" class="headerlink" title="Virtual File system Switch (VFS)"></a>Virtual File system Switch (VFS)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230317104012704.png" alt="image-20230317104012704" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230317104034363.png" alt="image-20230317104034363" style="zoom:80%;" /></p>
<h4 id="VFS模型（会考）"><a href="#VFS模型（会考）" class="headerlink" title="VFS模型（会考）"></a>VFS模型（会考）</h4><p>虚拟；仅存在于内存中</p>
<p>组件：</p>
<ul>
<li>超级块(super block)：某一个磁盘的某一个分区的文件系统的信息<ul>
<li>记录文件系统类型</li>
<li>记录文件系统的参数</li>
</ul>
</li>
<li>i-node 对象(i-node object)：index<ul>
<li>记录的是真正的文件，文件存储在磁盘上时是按照索引号访问文件的</li>
</ul>
</li>
<li>文件对象(file object)<ul>
<li>记录的是文件描述符，索引号</li>
<li>不对应真正的文件，文件open后会创建出文件对象。</li>
<li>文件没有close，则内核中的文件对象就没有释放</li>
<li>fd 是文件对象数组的下标</li>
</ul>
</li>
<li>目录对象(dentry object)</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230317104621277.png" alt="image-20230317104621277" style="zoom:80%;" /></p>
<h4 id="Ext2-File-System（不考）"><a href="#Ext2-File-System（不考）" class="headerlink" title="Ext2 File System（不考）"></a>Ext2 File System（不考）</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/14.png" alt="img" style="zoom: 67%;" /></p>
<h3 id="1-4-硬链接和符号链接"><a href="#1-4-硬链接和符号链接" class="headerlink" title="1.4 硬链接和符号链接"></a>1.4 硬链接和符号链接</h3><p>Hard link</p>
<ol>
<li>不同的文件名对应同一个inode</li>
<li>不能跨越文件系统</li>
<li>对应系统调用link</li>
</ol>
<p>Symbolic link</p>
<ol>
<li>存储被链接文件的文件名(而不是inode)实现链接</li>
<li>可跨越文件系统</li>
<li>对应系统调用symlink</li>
</ol>
<blockquote>
<p>为了显示文件的可访问权限，我们在使用 ls 命令的时候同时使用 -l 参数</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230317105718162.png" alt="image-20230317105718162" style="zoom:80%;" /></p>
</blockquote>
<h2 id="2-系统调用和库函数"><a href="#2-系统调用和库函数" class="headerlink" title="2. 系统调用和库函数"></a>2. 系统调用和库函数</h2><p>都以C函数的形式出现</p>
<p>系统调用：Linux内核的对外接口; 用户程序和内核之间唯一的接口; 提供最小接口</p>
<p>库函数：依赖于系统调用; 提供较复杂功能</p>
<ul>
<li>例：标准I/O库</li>
</ul>
<h3 id="2-1-无缓冲-I-O-和缓冲-I-O"><a href="#2-1-无缓冲-I-O-和缓冲-I-O" class="headerlink" title="2.1 无缓冲 I/O 和缓冲 I/O"></a>2.1 无缓冲 I/O 和缓冲 I/O</h3><p>Unbuffered I/O</p>
<ul>
<li>read/write -&gt; System calls</li>
<li>File descriptor</li>
<li>Not in ANSI C, but in POSIX.1 and XPG3</li>
</ul>
<p>Buffered I/O</p>
<ul>
<li>在标准I/O库实现</li>
<li>处理很多细节, 如缓存分配, 以优化长度执行I/O等</li>
<li>Stream -&gt; a pointer to FILE</li>
</ul>
<h3 id="2-2-Basic-I-O-System-Calls"><a href="#2-2-Basic-I-O-System-Calls" class="headerlink" title="2.2 Basic I/O System Calls"></a>2.2 Basic I/O System Calls</h3><p>文件描述符</p>
<p>标准I/O</p>
<ol>
<li><code>open/creat, close, read, write, lseek</code></li>
<li><code>dup/dup2</code></li>
<li><code>fcntl</code></li>
<li><code>ioctl</code></li>
</ol>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p> File descriptor</p>
<ul>
<li>一个小的非负整数：<code>int fd;</code></li>
<li>(在<code>&lt;unistd.h&gt;</code>中)<ul>
<li>STDIN_FILENO(0)</li>
<li>STDOUT_FILENO(1)</li>
<li>STDERR_FILENO(2)</li>
</ul>
</li>
</ul>
<p>文件操作的一般步骤：open - read/write - [lseek] - close</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* a rudimentary example program */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br>main()&#123;<br>   <span class="hljs-type">int</span> fd, nread;<br>   <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>   <span class="hljs-comment">/*open file &quot;data&quot; for reading */</span><br>   fd = open(<span class="hljs-string">&quot;data&quot;</span>, O_RDONLY);<br>   <span class="hljs-comment">/* read in the data */</span><br>   nread = read(fd, buf, <span class="hljs-number">1024</span>);<br>   <span class="hljs-comment">/* close the file */</span><br>   close(fd); <span class="hljs-comment">// 关闭的时候也用文件描述符关闭，释放句柄</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="open-creat-函数"><a href="#open-creat-函数" class="headerlink" title="open/creat 函数"></a>open/creat 函数</h4><ol>
<li>打开和建立一个文件或设备</li>
<li>C语言不能够重载，为什么会有2个open？并不是通过重载实现的，两个open是以一个函数的形式提供的，C语言提供了变长参数的函数机制（<code>...</code>）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> <span class="hljs-comment">// sys:linux系统下提供的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// open 也可以创建文件，覆盖了creat的所有功能</span><br><span class="hljs-comment">// pathname 含路径的文件名</span><br><span class="hljs-comment">// flags 标志位，是一串二进制数字，可以进行按位或操作，所以是int类型</span><br><span class="hljs-comment">// mode 文件权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-comment">// 创建文件的系统调用接口</span><br><span class="hljs-comment">// flag 默认为只写O_WRONLY和清零O_TRUNC</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-comment">// (Return: a new file descriptor if success; -1 if failure)</span><br></code></pre></td></tr></table></figure>
<h4 id="参数-“flags”"><a href="#参数-“flags”" class="headerlink" title="参数 “flags”"></a>参数 “flags”</h4><p>“flags”：文件访问方式</p>
<p><code>O_RDONLY</code>，<code>O_WRONLY</code>或<code>O_RDWR</code>中的一个请求分别按以下方式对文件进行只读，只写或读/写操作，这些操作按零或多个进行按位或运算（全部在<code>/usr/include/fcntl.h</code>中定义 ）</p>
<ul>
<li><code>O_APPEND</code>：以附加模式打开文件</li>
<li><code>O_TRUNC</code>：如果文件已经存在并且是常规文件，并且打开方式允许写入，则会将其长度截断为0。</li>
<li><code>O_CREAT</code>：如果文件不存在，将创建它。</li>
<li><code>O_EXCL</code>：与O_CREAT一起使用时，如果文件已存在，则为错误，打开失败。</li>
</ul>
<p>“creat”函数：相当于以等于<code>O_CREAT | O_WRONLY | O_TRUNC</code>的标志打开</p>
<h4 id="参数-“mode”"><a href="#参数-“mode”" class="headerlink" title="参数 “mode”"></a>参数 “mode”</h4><p>mode：指定在创建新文件的情况下使用的权限</p>
<p>需要多个权限的话，也是按位或。<code>S_IRUSR|S_IWUSR</code>就表示<code>rw-</code>。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230317113601067.png" alt="image-20230317113601067" style="zoom: 67%;" /></p>
<p>umask：一种文件保护机制</p>
<p>新文件的初始访问方式：mode和~umask</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230317113821087.png" alt="image-20230317113821087" style="zoom:80%;" /></p>
<h4 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h4><h4 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h4><p>Manipulate a file descriptor</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">long</span> arg)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> flock *lock)</span>;<span class="hljs-comment">//可以对文件加锁</span><br><span class="hljs-comment">//(返回值: 若成功则依赖于cmd，若出错为-1)</span><br></code></pre></td></tr></table></figure>
<p>The‏ operation‏ is‏ determined ‏by‏”cmd”.</p>
<p>The‏ value‏ of‏”cmd”</p>
<ul>
<li><code>F_DUPFD</code>：Duplicate a file descriptor</li>
<li><code>F_GETFD/F_SETFD</code>：‏Get/set ‏the‏ file ‏descriptor’s close-on exec flag<ul>
<li>执行时是否关闭，文件描述符能否从父进程传递到子进程。</li>
</ul>
</li>
<li><code>F_GETFL/F_SETFL</code>：Get/set ‏the‏ file ‏descriptor’s <strong>‏flags</strong></li>
<li><code>F_GETOWN/F_SETOWN</code>：Manage I/O availability signals</li>
<li><code>F_GETLK/F_SETLK/F_SETLKW</code>：Get/set the file lock</li>
</ul>
<p>Example：dup/dup2 and fcntl</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//file:fcntl</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    fd = open( <span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_APPEND);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    #<span class="hljs-meta">#printf(<span class="hljs-string">&quot;open err/n&quot;</span>);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd = %d&quot;</span>,fd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork!/n&quot;</span>);<br>    fcntl(fd，F_SETFD, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *s=<span class="hljs-string">&quot;ooooooooooooooooooo&quot;</span>;<br>    pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    	execl(<span class="hljs-string">&quot;ass&quot;</span>, <span class="hljs-string">&quot;./ass&quot;</span>, &amp;fd, <span class="hljs-literal">NULL</span>);<br>    wait(<span class="hljs-literal">NULL</span>);<br>    write(fd,s,<span class="hljs-built_in">strlen</span>(s));<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//ass 源代码</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argc = %d&quot;</span>,argc);<br>    fd = *argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd = %d&quot;</span>,fd);<br>    <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;zzzzzzzzzzzzzzzzzzz&quot;</span>;<br>    write(fd，(<span class="hljs-type">void</span> *)s, <span class="hljs-built_in">strlen</span>(s));<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>pid保存进程id(可以理解为int类型，linux下做了类型的重定义)</li>
<li><code>if(fd == -1)</code>：异常处理(文件打开失败)</li>
<li><code>fcntl(fd, F_SETFD, 1);</code>这里将<strong>close-on-exec</strong> flag设置为true，所以<strong>调用execl的时候，fd会关闭</strong>。</li>
<li><code>fork()</code>：Linux下很特别的系统调用，是用来创建进程的；复制一份父进程，作为父进程的子进程。(注意：被启动的子进程，就从fork()之后继续执行；子进程并不重复执行，某种程度上子进程和父进程是完全一样的；只有fork()系统调用的返回值不一样)</li>
<li>父进程fork()函数的返回值就是子进程的pid，而子进程fork()函数的返回值是0。</li>
<li>子进程是复制了父进程，所以这里子进程有fd这个文件描述符。</li>
<li>exec系列函数的使用<ol>
<li><strong>用另外一个程序代替当前进程，不会新开进程</strong>(用当前进程执行新的程序)</li>
<li>启动一段新的程序，将新程序的内存覆盖掉当前进程的内存。</li>
<li>如果没有fork就执行execl，则当前shell的进程没有了(呗新的程序占用了)</li>
</ol>
</li>
<li>注意：<ol>
<li>这里是<code>pid==0</code>，才会执行execl。所以是<strong>子进程执行了这个execl</strong>。</li>
<li><code>execl(&quot;ass&quot;, &quot;./ass&quot;, &amp;fd, NULL)</code>：传递的是fd所在地址，这里是int类型的地址，而execl函数要求的传输类型是char类型的地址，所以这里是类型转换。(但是这里的fd的值不能太大，因为是按照char类型读取的，所以fd的值在128以内应该没有问题)</li>
<li><code>wait(NULL)</code>：父进程就在这里等待，直到子进程执行完ass</li>
<li>最后的执行结果：test.txt文件中只会有”ooooo”，不会有”zzzzz”</li>
</ol>
</li>
</ol>
<h4 id="ioctl-函数"><a href="#ioctl-函数" class="headerlink" title="ioctl 函数"></a>ioctl 函数</h4><p>控制设备驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> request, ...)</span>;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-Standard-I-O-Library"><a href="#2-3-Standard-I-O-Library" class="headerlink" title="2.3 Standard I/O Library"></a>2.3 Standard I/O Library</h3><ul>
<li>File stream</li>
<li>Standard I/O functions</li>
</ul>
<h4 id="File-stream"><a href="#File-stream" class="headerlink" title="File stream"></a>File stream</h4><p>流和”FILE”结构</p>
<ul>
<li><code>FILE * fp;</code></li>
<li>预定义指针：<code>stdin, stdout, stderr</code>(封装了012号文件描述符)</li>
</ul>
<p>缓冲I/O</p>
<ul>
<li>三类缓冲<ol>
<li>全缓冲</li>
<li>行缓冲</li>
<li>无缓冲</li>
</ol>
</li>
<li><code>setbuf/setvbuf</code> 函数</li>
</ul>
<h4 id="Stream-Buffering-Operations"><a href="#Stream-Buffering-Operations" class="headerlink" title="Stream Buffering Operations"></a>Stream Buffering Operations</h4><p>Three types of buffering</p>
<ul>
<li>block buffered (fully buffered)‏</li>
<li>line buffered</li>
<li>unbuffered</li>
</ul>
<p><code>setbuf, setvbuf</code> functions</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> type, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>
<p>type：<code>_IOFBF</code>(满缓冲）<code>_IOLBF</code>(行缓冲） <code>_IONBF</code>(无缓冲）</p>
<h4 id="Standard-I-O-functions"><a href="#Standard-I-O-functions" class="headerlink" title="Standard I/O functions"></a>Standard I/O functions</h4><p>Stream open/close</p>
<p>Stream read/write</p>
<ul>
<li>每次一个字符的I/O</li>
<li>每次一行的I/O</li>
<li>直接I/O(二进制I/O)‏</li>
<li>格式化I/O</li>
</ul>
<p>Stream reposition</p>
<p>Stream flush</p>
<h4 id="Stream-open-close"><a href="#Stream-open-close" class="headerlink" title="Stream open/close"></a>Stream open/close</h4><p>Open a stream</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure>
<p>Parameter‏”mode”</p>
<ul>
<li><code>&quot;r&quot;</code>：Open text file for <strong>reading</strong>.</li>
<li><code>&quot;w&quot;</code>：Truncate file to zero length or create text file for writing.</li>
<li><code>&quot;a&quot;</code>：Open for <strong>appending</strong>(追加).</li>
<li><code>&quot;r+&quot;</code>：Open for <strong>reading and writing</strong>.</li>
<li><code>&quot;w+&quot;</code>：Open for reading and writing. The file is created if it does not exist, <strong>otherwise it is truncated</strong>.</li>
<li><code>&quot;a+&quot;</code>：Open for <strong>reading and appending</strong>. The file is created if does not exist.</li>
</ul>
<p>Close a stream</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">(FILE *fp)</span>;<br><span class="hljs-comment">// (Return: 0 if success; -1 if failure)</span><br></code></pre></td></tr></table></figure>
<h4 id="Input-of-a-character"><a href="#Input-of-a-character" class="headerlink" title="Input of a character"></a>Input of a character</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">// (Result: Reads the next character from a stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.)</span><br></code></pre></td></tr></table></figure>
<p>Three functions：<code>ferror, feof, clearerr</code></p>
<p><code>ungetc</code> function：push a character back to a stream</p>
<h4 id="Output-of-a-Character"><a href="#Output-of-a-Character" class="headerlink" title="Output of a Character"></a>Output of a Character</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *fp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">putchar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br><span class="hljs-comment">// (Return: the character if success; -1 if failure)</span><br></code></pre></td></tr></table></figure>
<h4 id="Input-of-a-Line-of-String"><a href="#Input-of-a-Line-of-String" class="headerlink" title="Input of a Line of String"></a>Input of a Line of String</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span>; <span class="hljs-comment">//not recommended.</span><br></code></pre></td></tr></table></figure>
<p><code>fgets</code>：最多从流中读 <strong>size-1</strong> 字节并存储到 s 指向的缓冲区，读到 EOF或新行结束，“\0” 会存储到缓冲区结尾</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/06/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-Shell-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/06/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-Shell-Programming/" class="post-title-link" itemprop="url">Linux程序设计(2) Shell Programming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-06 12:41:35" itemprop="dateCreated datePublished" datetime="2023-03-06T12:41:35+08:00">2023-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-18 16:12:32" itemprop="dateModified" datetime="2023-08-18T16:12:32+08:00">2023-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">Linux程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-What-is-Shell"><a href="#1-What-is-Shell" class="headerlink" title="1. What is Shell?"></a>1. What is Shell?</h2><ul>
<li>Shell: A command interpreter and programming environment</li>
<li>用户和操作系统之间的接口</li>
<li>作为核外程序而存在</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>用户和操作系统之间的接口</th>
<th>作为核外程序而存在</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230306124606364.png" alt="image-20230306124606364" style="zoom:80%;" /></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230306124706409.png" alt="image-20230306124706409" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-1-各种不同的Shell"><a href="#1-1-各种不同的Shell" class="headerlink" title="1.1 各种不同的Shell"></a>1.1 各种不同的Shell</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230306124806455.png" alt="image-20230306124806455" style="zoom:80%;" /></p>
<h3 id="1-2-Shell-的双重角色"><a href="#1-2-Shell-的双重角色" class="headerlink" title="1.2 Shell 的双重角色"></a>1.2 Shell 的双重角色</h3><ul>
<li>命令解释程序<ul>
<li>Linux的开机启动过程；进程树</li>
<li>Shell的工作步骤：打印提示符；得到命令行；解析命令；查找文件；准备参数；执行命令</li>
</ul>
</li>
<li>独立的程序设计语言解释器<ul>
<li>KISS (Keep It Small and Stupid)</li>
<li>Reusable tools</li>
<li>Redirection and pipe</li>
</ul>
</li>
</ul>
<h2 id="2-脚本"><a href="#2-脚本" class="headerlink" title="2. 脚本"></a>2. 脚本</h2><h3 id="2-1-使用命令行"><a href="#2-1-使用命令行" class="headerlink" title="2.1 使用命令行"></a>2.1 使用命令行</h3><p>脚本是能在命令行直接输入的，但仅会执行一次</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230313132013304.png" alt="image-20230313132013304" style="zoom:80%;" /></p>
<h3 id="2-2-编写脚本文件"><a href="#2-2-编写脚本文件" class="headerlink" title="2.2 编写脚本文件"></a>2.2 编写脚本文件</h3><p>脚本文件</p>
<ul>
<li>注释</li>
<li>退出码(exit code)</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230313132145225.png" alt="image-20230313132145225" style="zoom:80%;" /></p>
<h3 id="2-3-执行脚本文件"><a href="#2-3-执行脚本文件" class="headerlink" title="2.3 执行脚本文件"></a>2.3 执行脚本文件</h3><p>方法一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sh script_file <br></code></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x script_file(<span class="hljs-built_in">chown</span>, <span class="hljs-built_in">chgrp</span> optionally)<br>./script_file<br></code></pre></td></tr></table></figure>
<p>方法三：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> script_file<br>. script_file<br></code></pre></td></tr></table></figure>
<blockquote>
<p>方法一二原理相同：新启bash进程执行脚本</p>
<p>方法三使用当前bash进程执行脚本</p>
</blockquote>
<h3 id="2-4-用户环境"><a href="#2-4-用户环境" class="headerlink" title="2.4 用户环境"></a>2.4 用户环境</h3><p><code>.bash_profile</code>，<code>.bash_logout</code>，<code>.bashrc</code> files</p>
<ul>
<li><code>.bash_profile</code>: 用户登录时被读取，其中包含的命令被bash执行</li>
<li><code>.bashrc</code>: 启动一个新的shell时读取并执行</li>
<li><code>.bash_logout</code>: 登录退出时读取执行</li>
</ul>
<p>Alias</p>
<ul>
<li>alias/unaliascommand</li>
</ul>
<p>环境变量</p>
<ul>
<li><p>export command</p>
</li>
<li><p>export, env &amp; set command</p>
</li>
</ul>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><h3 id="3-1-用户变量"><a href="#3-1-用户变量" class="headerlink" title="3.1 用户变量"></a>3.1 用户变量</h3><ul>
<li><p>用户变量：</p>
<ul>
<li>用户在shell脚本里定义的变量</li>
</ul>
</li>
<li><p>变量的赋值和使用</p>
<ul>
<li><p><code>var=value</code></p>
</li>
<li><p><code>echo $var</code></p>
</li>
</ul>
</li>
<li><p>read命令</p>
<ul>
<li><p>用法：<code>read var</code> 或<code>read</code></p>
</li>
<li><p><code>REPLY variable</code></p>
</li>
</ul>
</li>
<li><p>引号的用法</p>
<ul>
<li><p>双引号，单引号</p>
</li>
<li><p>转义符 <code>\</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>=两侧不能加空格</p>
<p>变量没有类型，或者可以认为是字符串</p>
</blockquote>
<h4 id="Read用法"><a href="#Read用法" class="headerlink" title="Read用法"></a>Read用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Enter your name: &quot;</span>       <span class="hljs-comment"># 参数-n的作用是不换行，echo默认是换行</span><br><span class="hljs-built_in">read</span> name                         <span class="hljs-comment">#从键盘输入</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello <span class="hljs-variable">$name</span>, welcome to my program&quot;</span><br><span class="hljs-built_in">exit</span> 0                            <span class="hljs-comment">#退出shell程序。</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter your name:&quot;</span> name   <span class="hljs-comment">#-p参数，允许在read命令行中直接指定一个提示</span><br><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a number:&quot;</span> number<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$number</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-comment"># 5s内输入</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">read</span> -t 5 -p <span class="hljs-string">&quot;please enter your name:&quot;</span> name<br><span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello <span class="hljs-variable">$name</span>， welcome to my script&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sorry, too slow&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-comment"># 只读取一个字符</span><br><span class="hljs-built_in">read</span> -n1 -p <span class="hljs-string">&quot;Do you want to continue [Y/N] ?&quot;</span> answer<br><span class="hljs-keyword">case</span> <span class="hljs-variable">$answer</span> <span class="hljs-keyword">in</span><br>Y|y)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;fine, continue&quot;</span>;;<br>N|n)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ok, good bye&quot;</span>;;<br>*)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;error choice&quot;</span>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-comment"># 不显示输入</span><br><span class="hljs-built_in">read</span> -s -p <span class="hljs-string">&quot;Enter your password: &quot;</span> pass<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;your password is <span class="hljs-variable">$pass</span>&quot;</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br>count=1<br><span class="hljs-built_in">cat</span> viewFile.sh| <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Scount:<span class="hljs-variable">$line</span>&quot;</span><br>  count=$((<span class="hljs-variable">$count</span> + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Total Count:<span class="hljs-variable">$count</span>&quot;</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<h4 id="引号的用法"><a href="#引号的用法" class="headerlink" title="引号的用法"></a>引号的用法</h4><p>单引号内的所有字符都保持它本身字符的意思，而不会被bash进行解释，例如，\$就是\$本身而不再是bash的变量引用符；<code>\</code>就是<code>\</code>本身而不再是bash的转义字符。</p>
<p>除了<code>$</code>、``（不是单引号）和  外，双引号内的所有字符将保持字符本身的含义而不被bash解释</p>
<h3 id="3-2-环境变量"><a href="#3-2-环境变量" class="headerlink" title="3.2 环境变量"></a>3.2 环境变量</h3><p>Shell环境提供的变量。通常使用大写字母做名字</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230313143814653.png" alt="image-20230313143814653" style="zoom:80%;" /></p>
<h3 id="3-3-参数变量和内部变量"><a href="#3-3-参数变量和内部变量" class="headerlink" title="3.3 参数变量和内部变量"></a>3.3 参数变量和内部变量</h3><p>调用脚本程序时如果带有参数，对应的参数和额外产生的一些变量。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230313143945908.png" alt="image-20230313143945908" style="zoom:80%;" /></p>
<h2 id="4-语句"><a href="#4-语句" class="headerlink" title="4. 语句"></a>4. 语句</h2><h3 id="4-1-条件测试"><a href="#4-1-条件测试" class="headerlink" title="4.1 条件测试"></a>4.1 条件测试</h3><p>退出码</p>
<p>test命令：<code>test expression</code> 或 <code>[ expression ]</code></p>
<p>test命令支持的条件测试</p>
<ol>
<li>字符串比较</li>
<li>算术比较</li>
<li>与文件有关的条件测试</li>
<li>逻辑操作</li>
</ol>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230313144119488.png" alt="image-20230313144119488" style="zoom:80%;" /></p>
<h4 id="算术比较"><a href="#算术比较" class="headerlink" title="算术比较"></a>算术比较</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230313144151627.png" alt="image-20230313144151627" style="zoom:80%;" /></p>
<h4 id="与文件有关的条件测试"><a href="#与文件有关的条件测试" class="headerlink" title="与文件有关的条件测试"></a>与文件有关的条件测试</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412230824083.png" alt="image-20230412230824083" style="zoom:80%;" /></p>
<h4 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412231419320.png" alt="image-20230412231419320" style="zoom:80%;" /></p>
<h3 id="4-2-if语句"><a href="#4-2-if语句" class="headerlink" title="4.2 if语句"></a>4.2 if语句</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [expression]<br><span class="hljs-keyword">then</span><br>	statements<br><span class="hljs-keyword">elif</span> [expression]<br><span class="hljs-keyword">then</span><br>	statements<br><span class="hljs-keyword">elif</span>...<br><span class="hljs-keyword">else</span><br>	statements<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<ul>
<li>紧凑模式：使用 ; 分割</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ -f ~/.bashrc ]; <span class="hljs-keyword">then</span><br>	. ~/.bashrc<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<h3 id="4-3-case语句"><a href="#4-3-case语句" class="headerlink" title="4.3 case语句"></a>4.3 case语句</h3><ul>
<li>双分号</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> str <span class="hljs-keyword">in</span><br>  str1 | str2) statements;;<br>  str3 | str4) statements;;<br>  *) statements;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Is this morning? Please answer yes or no.&quot;</span><br><span class="hljs-built_in">read</span> answer<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$answer</span>&quot;</span> <span class="hljs-keyword">in</span><br>  <span class="hljs-built_in">yes</span> | y | Yes | YES) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Good morning!&quot;</span>;;<br>  no | n | No | NO) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Good afternoon!&quot;</span>;;<br>  *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, answer not recognized.&quot;</span>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<h3 id="4-4-for语句"><a href="#4-4-for语句" class="headerlink" title="4.4 for语句"></a>4.4 for语句</h3><ul>
<li>适用于对一系列字符串循环处理</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>	statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> f*.sh); <span class="hljs-keyword">do</span><br>	lpr <span class="hljs-variable">$file</span><br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<h3 id="4-5-while语句"><a href="#4-5-while语句" class="headerlink" title="4.5 while语句"></a>4.5 while语句</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> [expression]<br><span class="hljs-keyword">do</span><br>	statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">quit=n<br><span class="hljs-keyword">while</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$quit</span>&quot;</span> != <span class="hljs-string">&quot;y&quot;</span>]; <span class="hljs-keyword">do</span><br>	<span class="hljs-built_in">read</span> menu_choice<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$menu_choice</span>&quot;</span> <span class="hljs-keyword">in</span><br>		a) do_something;;<br>		b) do_anotherthing;;<br>		q|Q) quit=y;;<br>		*) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, choice not recognized.&quot;</span>;;<br>	<span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">a=0<br><span class="hljs-keyword">while</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> -le <span class="hljs-string">&quot;<span class="hljs-variable">$LIMIT</span>&quot;</span> ]; <span class="hljs-keyword">do</span><br>	a=$((<span class="hljs-variable">$a</span>+<span class="hljs-number">1</span>))<br>	<span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> gt 2 ]; <span class="hljs-keyword">then</span><br>		<span class="hljs-built_in">break</span>  <span class="hljs-comment"># Skip entire rest of loop.</span><br>	<span class="hljs-keyword">fi</span><br>	<span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p><strong>$(())整数运算，否则会看作字符串</strong></p>
</li>
<li><p>不推荐使用 until</p>
</li>
</ul>
<h3 id="4-6-select语句"><a href="#4-6-select语句" class="headerlink" title="4.6 select语句"></a>4.6 select语句</h3><p>生成菜单列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>clear<br><span class="hljs-keyword">select</span> item <span class="hljs-keyword">in</span> Continue Finish<br><span class="hljs-keyword">do</span><br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$item</span>&quot;</span> <span class="hljs-keyword">in</span><br>        Continue) ;;<br>        Finish) <span class="hljs-built_in">break</span> ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Wrong choice! Please select again!&quot;</span> ;;<br>	<span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412233820317.png" alt="image-20230412233820317" style="zoom:80%;" /></p>
<h3 id="4-7-命令表和语句块"><a href="#4-7-命令表和语句块" class="headerlink" title="4.7 命令表和语句块"></a>4.7 命令表和语句块</h3><h4 id="命令表"><a href="#命令表" class="headerlink" title="命令表"></a>命令表</h4><p>命令组合</p>
<ul>
<li><p>分号串联：command1 ; command2 ; …</p>
</li>
<li><p>AND命令表(&amp;&amp;): 前面成功才会执行后面的命令</p>
</li>
<li><p>OR命令表(||): 前面失败才会执行, 可用作备用命令</p>
</li>
<li><p>{statement1; statement2 ; … ;} 会看做一个命令</p>
</li>
</ul>
<h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">&#123;<br>    statement1<br>    statement2<br>    ...<br>&#125;<br>或<br>&#123;statement1; statement2 ; ... ;&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-8-函数"><a href="#4-8-函数" class="headerlink" title="4.8 函数"></a>4.8 函数</h3><p>定义时不带参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">func</span></span>()<br>&#123;<br>	statements<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>局部变量: local关键字</li>
<li>函数的调用: func para1 para2 …</li>
<li>返回值: return</li>
</ul>
<p>例子</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412235748650.png" alt="image-20230412235748650" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230412235756115.png" alt="image-20230412235756115" style="zoom:80%;" /></p>
<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><h3 id="5-1-杂项命令"><a href="#5-1-杂项命令" class="headerlink" title="5.1 杂项命令"></a>5.1 杂项命令</h3><ul>
<li>break: 从for/while/until循环退出 </li>
<li>continue: 跳到下一个循环继续执行</li>
<li>exit n: 以退出码”n”退出脚本运行</li>
<li>return: 函数返回</li>
<li>export: 将变量导出到shell，使之成为shell的环境变量</li>
<li>set: 为shell设置参数变量</li>
<li>unset: 从环境中删除变量或函数</li>
<li>trap: 指定在收到操作系统信号后执行的动作</li>
<li>“:”(冒号命令): 空命令</li>
<li>“.”(句点命令)或source: 在当前shell中执行命令</li>
</ul>
<h3 id="5-2-捕获命令输出"><a href="#5-2-捕获命令输出" class="headerlink" title="5.2 捕获命令输出"></a>5.2 捕获命令输出</h3><ul>
<li><p>$(command) 或 `command`</p>
</li>
<li><p><code>$PWD 与 $(pwd)</code></p>
</li>
</ul>
<h3 id="5-3-算术扩展"><a href="#5-3-算术扩展" class="headerlink" title="5.3 算术扩展"></a>5.3 算术扩展</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230818160959917.png" alt="image-20230818160959917" style="zoom:80%;" /></p>
<h3 id="5-4-参数扩展"><a href="#5-4-参数扩展" class="headerlink" title="5.4 参数扩展"></a>5.4 参数扩展</h3><p>问题：批处理 1_tmp, 2_tmp, …</p>
<p>方法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#! /bin/sh</span><br>i=1<br><span class="hljs-keyword">while</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> -ne 10 ]; <span class="hljs-keyword">do</span><br>	<span class="hljs-built_in">touch</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;i&#125;</span>_tmp&quot;</span><br>	i=$((<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>
<p>参数扩展更复杂的形式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230413000143071.png" alt="image-20230413000143071"></p>
<h3 id="5-5-即时文档"><a href="#5-5-即时文档" class="headerlink" title="5.5 即时文档"></a>5.5 即时文档</h3><ul>
<li><p>在shell脚本中向一条命令传送输入数据</p>
</li>
<li><p>例如: 输入 !CATINPUT! 才会停止</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; !CATINPUT!<br><br>Hello, this is a here document.<br>!CATINPUT!<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/03/02/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-2-Web-MVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-2-Web-MVC/" class="post-title-link" itemprop="url">服务端开发(2) Web MVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-02 19:35:35" itemprop="dateCreated datePublished" datetime="2023-03-02T19:35:35+08:00">2023-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Taco示例"><a href="#Taco示例" class="headerlink" title="Taco示例"></a>Taco示例</h2><h3 id="1-lombok"><a href="#1-lombok" class="headerlink" title="1. lombok"></a>1. lombok</h3><p>编译期后就不需要了，要排除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-DesignTacoController控制器实现"><a href="#2-DesignTacoController控制器实现" class="headerlink" title="2. DesignTacoController控制器实现"></a>2. DesignTacoController控制器实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/design&quot;)</span><br><span class="hljs-meta">@SessionAttributes(&quot;tacoOrder&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DesignTacoController</span> &#123;<br>    ...<br>    <span class="hljs-comment">/** <span class="hljs-doctag">@Slf</span>4j 可替代 </span><br><span class="hljs-comment">     *	private static final org.slf4j.Logger log = </span><br><span class="hljs-comment">     *  	org.slf4j.LoggerFactory.getLogger(DesignTacoController.class);</span><br><span class="hljs-comment">   	 */</span> <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-Spring-MVC的请求映射注解"><a href="#3-Spring-MVC的请求映射注解" class="headerlink" title="3. Spring MVC的请求映射注解"></a>3. Spring MVC的请求映射注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-meta">@PutMapping</span><br><span class="hljs-meta">@DeleteMapping</span><br><span class="hljs-meta">@PatchMapping</span><br></code></pre></td></tr></table></figure>
<h3 id="4-设计视图"><a href="#4-设计视图" class="headerlink" title="4. 设计视图"></a>4. 设计视图</h3><p>使用 thymeleaf</p>
<h3 id="5-处理表单提交"><a href="#5-处理表单提交" class="headerlink" title="5. 处理表单提交"></a>5. 处理表单提交</h3><h4 id="5-1-Converter"><a href="#5-1-Converter" class="headerlink" title="5.1 Converter"></a>5.1 Converter</h4><p>前端返回的是String, 后端需要的是 Ingredient, 如何解决</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">th:field</span>=<span class="hljs-string">&quot;*&#123;ingredients&#125;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NotNull</span><br><span class="hljs-meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span><br><span class="hljs-keyword">private</span> List&lt;Ingredient&gt; ingredients;<br></code></pre></td></tr></table></figure>
<p>使用 Spring 提供的 Converter 来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IngredientByIdConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Converter</span>&lt;String, Ingredient&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> Map&lt;String, Ingredient&gt; ingredientMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Ingredient <span class="hljs-title function_">convert</span><span class="hljs-params">(String id)</span> &#123;<br>    <span class="hljs-keyword">return</span> ingredientMap.get(id);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-2-rediect重定向"><a href="#5-2-rediect重定向" class="headerlink" title="5.2 rediect重定向"></a>5.2 rediect重定向</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/orders/current&quot;</span>;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302210339075.png" alt="image-20230302210339075"></p>
<h3 id="6-校验表单输入"><a href="#6-校验表单输入" class="headerlink" title="6. 校验表单输入"></a>6. 校验表单输入</h3><ul>
<li>JavaBean Validation API</li>
<li>spring-boot-starter-validation</li>
<li>领域类上添加校验规则</li>
<li>控制器中声明校验：@Valid</li>
<li>修改表单视图以展现校验错误</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Taco</span> &#123;<br><br>  <span class="hljs-meta">@NotNull</span><br>  <span class="hljs-meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span><br>  <span class="hljs-keyword">private</span> String name;<br><br>  <span class="hljs-meta">@NotNull</span><br>  <span class="hljs-meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span><br>  <span class="hljs-keyword">private</span> List&lt;Ingredient&gt; ingredients;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">processTaco</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> Taco taco,</span><br><span class="hljs-params">                          Errors errors,</span><br><span class="hljs-params">                          <span class="hljs-meta">@ModelAttribute</span> TacoOrder tacoOrder)</span> &#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-使用视图控制器"><a href="#7-使用视图控制器" class="headerlink" title="7. 使用视图控制器"></a>7. 使用视图控制器</h3><ul>
<li>接口 WebMvcConfigurer，用于配置</li>
<li>简单的从请求URL到视图<ul>
<li><code>registry.addViewController(&quot;/&quot;).setViewName(&quot;home&quot;);</code></li>
<li>如果路径是 “/“, 直接返回 home 视图</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91-2-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91-2-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">数据库开发(2) 索引结构及使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-27 17:05:22" itemprop="dateCreated datePublished" datetime="2023-02-27T17:05:22+08:00">2023-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">数据库开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-索引是一种快捷访问方式"><a href="#1-索引是一种快捷访问方式" class="headerlink" title="1. 索引是一种快捷访问方式"></a>1. 索引是一种快捷访问方式</h2><h3 id="二分搜索树（BST，Binary-Search-Trees）"><a href="#二分搜索树（BST，Binary-Search-Trees）" class="headerlink" title="二分搜索树（BST，Binary Search Trees）"></a>二分搜索树（BST，Binary Search Trees）</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314161009595.png" alt="image-20230314161009595" style="zoom:80%;" /></p>
<p>为什么要 Tree Balancing？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$O(log_2N)$</th>
<th>$O(N)$</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314161419104.png" alt="image-20230314161419104" style="zoom:80%;" /></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314161432799.png" alt="image-20230314161432799" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<p>怎么做 Tree Balancing？</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314161528646.png" alt="image-20230314161528646" style="zoom:80%;" /></p>
<h3 id="HDD和SSDs的差异"><a href="#HDD和SSDs的差异" class="headerlink" title="HDD和SSDs的差异"></a>HDD和SSDs的差异</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314161855859.png" alt="image-20230314161855859" style="zoom:80%;" /></p>
<p>Block：最小的写单元，64-512 Page</p>
<p>Page：最小的读单元，2KB-16KB</p>
<p>SSD不过于像HDD⼀样非常强调随机 I/O和顺序I/O的差别，因为延迟差异不是很⼤。但是，预取、读取连续页和内部并⾏等⽅面，⼆者差距依旧存在[GOOSSAERT14] </p>
<h3 id="逻辑图和实现结构图的差异"><a href="#逻辑图和实现结构图的差异" class="headerlink" title="逻辑图和实现结构图的差异"></a>逻辑图和实现结构图的差异</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314162451882.png" alt="image-20230314162451882" style="zoom:80%;" /></p>
<h3 id="基于磁盘的索引结构"><a href="#基于磁盘的索引结构" class="headerlink" title="基于磁盘的索引结构"></a>基于磁盘的索引结构</h3><p>对于特定数据结构，有些更适用于磁盘，⽽有些更适用于内存</p>
<p>平台级软件，和硬件的关系非常⼤（操作系统、数据库、嵌⼊式、芯片……）</p>
<p>更适合磁盘实现的树必须具备以下属性</p>
<ul>
<li>⾼扇出，以改善临近键的数据局限性</li>
<li>低⾼度，以减少遍历期间的寻道次数</li>
</ul>
<h2 id="2-B树索引的结构和应用"><a href="#2-B树索引的结构和应用" class="headerlink" title="2. B树索引的结构和应用"></a>2. B树索引的结构和应用</h2><h3 id="B-Tree（B-Tree）结构"><a href="#B-Tree（B-Tree）结构" class="headerlink" title="B-Tree（B+Tree）结构"></a>B-Tree（B+Tree）结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314162720655.png" alt="image-20230314162720655"></p>
<h3 id="B树查找算法"><a href="#B树查找算法" class="headerlink" title="B树查找算法"></a>B树查找算法</h3><p>查找，从根节点到叶节点的单向遍历</p>
<p>从根节点上执⾏⼆分搜索算法，将要搜索的$K$，与存储在根节点中的$K_n$进⾏比较，直到找到⼤于$K$的第⼀个分隔键，这样定位了⼀个要搜索的⼦树，顺着相应指针继续相同的搜索过程，直到目标叶节点，找到数据主⽂件指针</p>
<h3 id="B-Tree（B-Tree）的逻辑存储结构"><a href="#B-Tree（B-Tree）的逻辑存储结构" class="headerlink" title="B-Tree（B+Tree）的逻辑存储结构"></a>B-Tree（B+Tree）的逻辑存储结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314163035891.png" alt="image-20230314163035891" style="zoom:80%;" /></p>
<ul>
<li><p>一次I/O：一次 Block 的读写，每个矩形就是一个 Block</p>
</li>
<li><p>对于硬件，只有 Block 锁，可以在内存添加 Page 锁</p>
</li>
<li><p>B+树深度固定在3-4</p>
</li>
<li><p>rowid：指向基本表的指针</p>
</li>
</ul>
<h3 id="B-树索引能做什么？"><a href="#B-树索引能做什么？" class="headerlink" title="B+树索引能做什么？"></a>B+树索引能做什么？</h3><ol>
<li>全键值：<code>where x = 123</code> (depth + 1次的固定次数)</li>
<li>键值范围：<code>where 45 &lt; x &lt; 123</code> (先进行x=45，然后顺序读取直到x&gt;=123)</li>
<li>键前缀查找：<code>where x LIKE &#39;J%&#39;</code></li>
</ol>
<h3 id="索引对数据的访问只是第一步"><a href="#索引对数据的访问只是第一步" class="headerlink" title="索引对数据的访问只是第一步"></a>索引对数据的访问只是第一步</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314163536609.png" alt="image-20230314163536609" style="zoom:80%;" /></p>
<p>主键默认增加索引</p>
<p>两种方案：</p>
<ul>
<li>方案一数据更新时会影响多个索引，但是快</li>
<li>方案二数据更新时只会影响一个索引</li>
</ul>
<h2 id="3-索引的另一面（问题）"><a href="#3-索引的另一面（问题）" class="headerlink" title="3. 索引的另一面（问题）"></a>3. 索引的另一面（问题）</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/02/16/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-1-Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-1-Spring/" class="post-title-link" itemprop="url">服务端开发(1) Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-16 17:01:42" itemprop="dateCreated datePublished" datetime="2023-02-16T17:01:42+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">服务端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-Web-App开发"><a href="#1-Web-App开发" class="headerlink" title="1. Web App开发"></a>1. Web App开发</h3><h4 id="1-1-前、后端不分离的开发模式"><a href="#1-1-前、后端不分离的开发模式" class="headerlink" title="1.1 前、后端不分离的开发模式"></a>1.1 前、后端不分离的开发模式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230216170527653.png" alt="image-20230216170527653" style="zoom: 50%;" /></p>
<h4 id="1-2-前、后端分离的开发模式"><a href="#1-2-前、后端分离的开发模式" class="headerlink" title="1.2 前、后端分离的开发模式"></a>1.2 前、后端分离的开发模式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230216170540465.png" alt="image-20230216170540465" style="zoom: 67%;" /></p>
<h4 id="1-3-微服务架构-Microservices-Architecture-模式"><a href="#1-3-微服务架构-Microservices-Architecture-模式" class="headerlink" title="1.3 微服务架构(Microservices Architecture)模式"></a>1.3 微服务架构(Microservices Architecture)模式</h4><p>微服务架构时将应用拆分成小业务单元开发和部署，使用轻量级协议通信，通过协同工作实现应用逻辑的架构模式</p>
<p>微服务的特性：小，且指责单一、独立的进程、轻量级通信机制、独立部署</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230216170820095.png" alt="image-20230216170820095" style="zoom:80%;" /></p>
<h3 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2. Spring"></a>2. Spring</h3><h4 id="2-1-Spring是Java生态圈的主流开发框架"><a href="#2-1-Spring是Java生态圈的主流开发框架" class="headerlink" title="2.1 Spring是Java生态圈的主流开发框架"></a>2.1 Spring是Java生态圈的主流开发框架</h4><ul>
<li>轻量级（Lightweight）</li>
<li>非侵入性（No intrusive）</li>
<li>容器（Container）</li>
<li><strong>Inversion of Control 与 Dependency Injection</strong></li>
<li><strong>AOP(Aspect Oriented Programming)</strong></li>
<li>持久层（JDBC封装、事务管理、ORM工具整合）</li>
<li>Web框架（MVC、其它WEB框架整合）</li>
<li>其他企业服务的封装</li>
</ul>
<h4 id="2-2-Spring的核心是提供了一个容器-container"><a href="#2-2-Spring的核心是提供了一个容器-container" class="headerlink" title="2.2 Spring的核心是提供了一个容器(container)"></a>2.2 Spring的核心是提供了一个容器(container)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230216171148852.png" alt="image-20230216171148852" style="zoom: 67%;" /></p>
<h4 id="2-3-Spring的衍生"><a href="#2-3-Spring的衍生" class="headerlink" title="2.3 Spring的衍生"></a>2.3 Spring的衍生</h4><p>Spring：核心、基础框架</p>
<p>Spring Boot：简化基于Spring的开发，自动配置</p>
<p>Spring Cloud：基于云的、分布式系统开发，相关技术：容器、微服务、DevOps</p>
<h4 id="2-4-Spring的模块组成"><a href="#2-4-Spring的模块组成" class="headerlink" title="2.4 Spring的模块组成"></a>2.4 Spring的模块组成</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307152941773.png" alt="image-20230307152941773" style="zoom:80%;" /></p>
<h4 id="2-5-Spring的两个核心技术"><a href="#2-5-Spring的两个核心技术" class="headerlink" title="2.5 Spring的两个核心技术"></a>2.5 Spring的两个核心技术</h4><p><strong>DI(Dependency Injection)</strong></p>
<ul>
<li>保留抽象接口，让组件(Component)依赖于抽象接口，当组件要与其他实际的对象发生依赖关系时，由抽象接口来注入依赖的实际对象</li>
</ul>
<p><strong>AOP(Aspect Oriented Programming)</strong></p>
<ul>
<li>通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术</li>
<li>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率</li>
</ul>
<h2 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入(DI)"></a>依赖注入(DI)</h2><h3 id="1-Spring配置方案"><a href="#1-Spring配置方案" class="headerlink" title="1. Spring配置方案"></a>1. Spring配置方案</h3><h4 id="1-1-自动化配置"><a href="#1-1-自动化配置" class="headerlink" title="1.1 自动化配置"></a>1.1 自动化配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CDPlayer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MediaPlayer</span> &#123;<br>    <span class="hljs-keyword">private</span> CompactDisc cd;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CDPlayer</span><span class="hljs-params">(CompactDisc cd)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cd = cd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        cd.play();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>组件扫描(component scanning)</li>
<li>自动装配(autowiring)</li>
</ul>
<h5 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br></code></pre></td></tr></table></figure>
<p>等价于: <code>&lt;context:component-scan base-package=&quot;soundsystem&quot; /&gt;</code></p>
<p>可以为 <strong>@ComponentScan</strong> 设置 <strong>basePackages</strong> 属性来显式指定要扫描的基础包。指定时有三种实现方式：</p>
<ul>
<li>以字符串的形式来指定: <code>@ComponentScan(basePackages = &#123;&quot;xxx&quot;, &quot;xxx&quot;&#125;)</code> <ul>
<li>此方式类型不安全(not type-safe)，重构代码后指定的基础包可能会出现错误。</li>
</ul>
</li>
<li>指定为包中所含的类或接口: <code>@ComponentScan(basePackages=&quot;Student.class&quot;)</code>。</li>
<li>创建一个用来进行扫描的空标记接口(Marker interface)</li>
</ul>
<h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br></code></pre></td></tr></table></figure>
<ul>
<li>可用于构造器</li>
<li>用在属性 Setter 方法</li>
<li><code>@Autowired(required = false)</code><ul>
<li>将 required 属性设置为 false 时，Spring 会尝试执行自动装配，但是如果没有匹配的 bean 的话，Spring 将会让这个 bean 处于未装配的状态</li>
</ul>
</li>
</ul>
<h4 id="1-2-JavaConfig"><a href="#1-2-JavaConfig" class="headerlink" title="1.2 JavaConfig"></a>1.2 JavaConfig</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CDPlayerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CompactDisc <span class="hljs-title function_">compactDisc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SgtPeppers</span>();<br>    &#125;<br><br><span class="hljs-comment">//    @Bean</span><br><span class="hljs-comment">//    public CDPlayer cdPlayer(CompactDisc cd) &#123;</span><br><span class="hljs-comment">//        return new CDPlayer(cd);</span><br><span class="hljs-comment">//    &#125;</span><br>    <br>    <span class="hljs-meta">@Bean(name=&quot;myCdPlayer&quot;)</span><br>    <span class="hljs-keyword">public</span> CDPlayer <span class="hljs-title function_">cdPlayer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 不会实例化多个CompactDisc</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CDPlayer</span>(compactDisc());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>自动化配置有时会行不通，如第三方库，此时需要我们手动创建 Bean</p>
<ul>
<li>注入<ul>
<li>调用方法()</li>
<li>通过方法参数自动装配(其他配置类，其他方式创建的Bean)</li>
</ul>
</li>
<li><p><code>@Bean(name=&quot;xxx&quot;)</code>: 声明一个Bean，并且可以自定义名称</p>
<ul>
<li>Bean的默认名称为方法名</li>
<li>可以通过name字段修改bean的名称</li>
</ul>
</li>
<li><p>注意与业务逻辑和领域代码分开</p>
</li>
</ul>
<h4 id="1-3-XML配置"><a href="#1-3-XML配置" class="headerlink" title="1.3 XML配置"></a>1.3 XML配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;compactDisc&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;soundsystem.SgtPeppers&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cdPlayer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;soundsystem.CDPlayer&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;compactDisc&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>&lt;bean&gt;&lt;/bean&gt;</code></li>
<li>不能类型检查</li>
<li>构造器注入<ul>
<li><code>&lt;comstructor-arg&gt;</code></li>
<li>c-命名空间</li>
<li>注入字面量值</li>
<li>注入集合</li>
</ul>
</li>
<li>属性注入<ul>
<li>p-命名空间</li>
<li>util-命名空间</li>
</ul>
</li>
<li>建议：强依赖使用构造器注入</li>
</ul>
<h4 id="1-4-混合配置"><a href="#1-4-混合配置" class="headerlink" title="1.4 混合配置"></a>1.4 混合配置</h4><p>JavaConfig 中的导入</p>
<ul>
<li><code>@Import(配置类.class, ...)</code></li>
<li><code>@ImportResource(xml文件)</code></li>
</ul>
<p>XML 中的导入</p>
<ul>
<li><code>&lt;import resource=&quot;xml文件&quot; /&gt;</code></li>
<li><code>&lt;bean class=&quot;配置类&quot; /&gt;</code></li>
</ul>
<h4 id="1-5-根配置"><a href="#1-5-根配置" class="headerlink" title="1.5 根配置"></a>1.5 根配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@Import(其他配置类.class)</span><br><span class="hljs-meta">@ImportResource(xml文件)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BootConfig</span>()&#123;&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-Profile"><a href="#2-Profile" class="headerlink" title="2. @Profile"></a>2. @Profile</h3><p>根据不同环境创造不同的 Bean</p>
<p>在 Java 配置中，可以使用 @Profile 注解指定某个 bean 属于哪一个 profile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Profile(&quot;dev&quot;)</span><br><br><span class="hljs-comment">// 方法</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Profile(&quot;prov&quot;)</span><br></code></pre></td></tr></table></figure>
<p>激活</p>
<ul>
<li>spring.profiles.default</li>
<li>spring.profiles.active</li>
<li><code>@ActiveProfiles(&quot;dev&quot;)</code></li>
</ul>
<h3 id="3-Conditonal"><a href="#3-Conditonal" class="headerlink" title="3. @Conditonal"></a>3. @Conditonal</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MagicConfig.java</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Conditional(MagicExistsCondition.class)</span><br><span class="hljs-keyword">public</span> MagicBean <span class="hljs-title function_">magicBean</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MagicBean</span>();<br>&#125;<br><br><span class="hljs-comment">// 实现 Condition 接口，重写 match 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicExistsCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;<br>        <span class="hljs-type">Environment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> context.getEnvironment();<br>        <span class="hljs-keyword">return</span> env.containsProperty(<span class="hljs-string">&quot;magic&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-自动装配的歧义性"><a href="#4-自动装配的歧义性" class="headerlink" title="4. 自动装配的歧义性"></a>4. 自动装配的歧义性</h3><ul>
<li><code>@Component</code> 或 <code>@Bean</code></li>
<li><code>@Primary</code>: 标识首选的 Bean</li>
<li>定义时<ol>
<li><code>@Componet</code>或<code>@Bean</code></li>
<li><code>@Qualifier(&quot;...&quot;)</code> 自定义限定符，通过使用<code>@Qualifier</code>注解，我们可以消除需要注入哪个bean的问题。</li>
</ol>
</li>
<li>使用时<ol>
<li><code>@Autowired</code></li>
<li><code>@Qualifier(&quot;...&quot;)</code> bean名称或自定义限定符，默认Bean名是限定符</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904035342893063">Spring 注解 @Qualifier 详细解析</a></li>
<li>可以自定义注解，这些注解本身也加了@Qualifier注解<ol>
<li><code>@Cold</code></li>
<li><code>@Creamy</code></li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Cold&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-Bean的作用域"><a href="#5-Bean的作用域" class="headerlink" title="5. Bean的作用域"></a>5. Bean的作用域</h3><p>@Scope 可以与 @Component 和 @Bean 一起使用，指定作用域</p>
<ul>
<li>Singleton，单例，在整个应用中，只创建 bean 的一个实例</li>
<li>Prototype，原型，每次注入或者通过Spring应用上下文获取的时候，都会创建一个新 bean 实例</li>
<li>Session，会话，在Web应用中，为每个会话创建一个bean实例</li>
<li>Request，请求，在Web应用中，为每个请求创建一个bean实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用会话和请求作用域</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(value=WebApplicationContext.SCOPE_SESSION,</span><br><span class="hljs-meta">       proxyMode=ScopedProxyMode.INTERFACES)</span><br><span class="hljs-keyword">public</span> ShoppingCart <span class="hljs-title function_">cart</span><span class="hljs-params">()</span>&#123;....&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-通过代理注入给单例对象"><a href="#6-通过代理注入给单例对象" class="headerlink" title="6. 通过代理注入给单例对象"></a>6. 通过代理注入给单例对象</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230219235848176.png" alt="image-20230219235848176" style="zoom:67%;" /></p>
<h2 id="面向切面编程-AOP"><a href="#面向切面编程-AOP" class="headerlink" title="面向切面编程(AOP)"></a>面向切面编程(AOP)</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>软件编程方法的发展</p>
<ul>
<li>面向过程编程(POP, Procedure Oriented Programming)</li>
<li>面向对象编程(OOP, Object Oriented Programming)</li>
<li>面向切面编程(AOP, Aspect Oriented Programming)</li>
<li>函数式编程(FP, Functional Programming)</li>
<li>反应式编程(RP, Reactive Programming)</li>
</ul>
<h3 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2. AOP"></a>2. AOP</h3><div class="table-container">
<table>
<thead>
<tr>
<th>切入前</th>
<th>切入后</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230228194342301.png" alt="image-20230228194342301" style="zoom:80%;" /></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230228194429951.png" alt="image-20230228194429951" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-1-横切关注点-cross-cutting-concern"><a href="#2-1-横切关注点-cross-cutting-concern" class="headerlink" title="2.1 横切关注点(cross-cutting concern)"></a>2.1 横切关注点(cross-cutting concern)</h4><ul>
<li>日志</li>
<li>安全</li>
<li>事务</li>
<li>缓存</li>
</ul>
<blockquote>
<p>除了使用 AOP，还可选择</p>
<ul>
<li><p>继承(inheritance): 父类添加日志方法</p>
</li>
<li><p>委托(delegation): 通过引用日志对象</p>
</li>
</ul>
</blockquote>
<h4 id="2-2-AOP-图解"><a href="#2-2-AOP-图解" class="headerlink" title="2.2 AOP 图解"></a>2.2 AOP 图解</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230228194822706.png" alt="image-20230228194822706" style="zoom:80%;" /></p>
<h4 id="2-3-AOP-术语"><a href="#2-3-AOP-术语" class="headerlink" title="2.3 AOP 术语"></a>2.3 AOP 术语</h4><ul>
<li>通知(Advice)：切面做什么？什么时候做？代表了切面的逻辑。</li>
<li>切点(Pointcut)：指定通知要切入到代码的哪些位置，切点表达式</li>
<li>切面(Aspect)：通知 + 切点</li>
<li>连接点(Join point)：方法(Spring只支持对方法添加通知)、字段修改、构造方法</li>
<li>引入(Introduction)：(给对象)引入新的行为和状态</li>
<li>织入(Weaving)：切面应用到目标对象的过程</li>
</ul>
<h4 id="2-4-通知-Advice-类型"><a href="#2-4-通知-Advice-类型" class="headerlink" title="2.4 通知(Advice)类型"></a>2.4 通知(Advice)类型</h4><ul>
<li><code>@Before</code>：在调用目标之前</li>
<li><code>@After</code>：被切的对象方法执行之后，等于<code>@AfterReturnning</code> + <code>@AfterThrowing</code></li>
<li><code>@AfterReturning</code>：被切对象方法返回后，有异常但是没有return的话不执行AfterReturning</li>
<li><code>@AfterThrowing</code>：被切对象方法出现异常之后</li>
<li><code>@Around</code>：被切对象方法的执行前和执行后，等于<code>@Before</code> + <code>@After</code></li>
</ul>
<h4 id="2-5-织入时机"><a href="#2-5-织入时机" class="headerlink" title="2.5 织入时机"></a>2.5 织入时机</h4><ul>
<li>编译器：编译的时候将Aspect织入进去，需要使用特别的编译器。</li>
<li>类加载期：需要类加载器的处理</li>
<li>运行期：Spring所采纳的方式，使用代理对象，只支持方法级别的连接点</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230228200339433.png" alt="image-20230228200339433" style="zoom:80%;" /></p>
<h3 id="3-Spring-AOP"><a href="#3-Spring-AOP" class="headerlink" title="3. Spring AOP"></a>3. Spring AOP</h3><ul>
<li><code>@AspectJ</code> 注解驱动的切面</li>
<li><code>@EnableAspectJAutoProxy</code> 配置类中，开启AspectJ的自动代理机制</li>
</ul>
<h4 id="3-1-定义切面-Aspect"><a href="#3-1-定义切面-Aspect" class="headerlink" title="3.1 定义切面(@Aspect)"></a>3.1 定义切面(<code>@Aspect</code>)</h4><ul>
<li>加注解的普通POJO</li>
<li>定义可重用的切点(<code>@Pointcut</code>)</li>
<li>Around通知(<code>proceedigJoinPoint.proceed()</code>)</li>
<li>定义参数(<code>args()</code>)</li>
</ul>
<h4 id="3-2-AspectJ-切点指示器-pointcut-designator"><a href="#3-2-AspectJ-切点指示器-pointcut-designator" class="headerlink" title="3.2 AspectJ 切点指示器(pointcut designator)"></a>3.2 AspectJ 切点指示器(pointcut designator)</h4><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(</span><br><span class="hljs-meta">	&quot;execution(* soundsystem.CompactDisc.playTrack( int ))&quot; +</span><br><span class="hljs-meta">	&quot;&amp;&amp; args(trackNumber)&quot; +  //获取参数</span><br><span class="hljs-meta">	&quot;&amp;&amp; within(soundsystem.*)&quot; + //限定包路径, 只有该包下面的方法可以使用切面</span><br><span class="hljs-meta">	&quot;&amp;&amp; bean(sgtPeppers)&quot; //限定bean名称，或者： &amp;&amp; !bean(sgtPeppers)</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure>
<p>获取参数例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(</span><br><span class="hljs-meta">	&quot;execution(* soundsystem.CompactDisc.playTrack( int )) &quot; +</span><br><span class="hljs-meta">	&quot;&amp;&amp; args(trackNumber)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trackPlayed</span><span class="hljs-params">(<span class="hljs-type">int</span> trackNumber)</span> &#123;&#125;<br><br><span class="hljs-meta">@Before(&quot;trackPlayed(trackNumber)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> trackNumber)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">currentCount</span> <span class="hljs-operator">=</span> getPlayCount(trackNumber);<br>    trackCounts.put(trackNumber, currentCount + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注解例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;@annotation(innerAuth)&quot;)</span> <span class="hljs-comment">//限定注解</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">innerAround</span><span class="hljs-params">(ProceedingJoinPoint point, InnerAuth innerAuth)</span> &#123; ... &#125;<br><br><span class="hljs-meta">@InnerAuth</span><br><span class="hljs-keyword">public</span> R&lt;Boolean&gt; <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SysUser sysUser)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-3-引入接口-introduction"><a href="#3-3-引入接口-introduction" class="headerlink" title="3.3 引入接口(introduction)"></a>3.3 引入接口(introduction)</h4><ul>
<li><code>@DeclareParents</code></li>
<li>增加新的行为、属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoreableIntroducer</span> &#123;<br>    <span class="hljs-meta">@DeclareParents(value = &quot;concert.Performance+&quot;,//后面的+表示应用到所有实现了该接口的Bean</span><br><span class="hljs-meta">            		defaultImpl = DefaultEncoreable.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Encoreable encoreable;<br>&#125;<br><br><span class="hljs-comment">// DefaultEncoreable.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultEncoreable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Encoreable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performEncore</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230228212114724.png" alt="image-20230228212114724" style="zoom:80%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/02/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91-1/" class="post-title-link" itemprop="url">数据库开发(1) 开发成功数据库的要点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-14 15:50:29" itemprop="dateCreated datePublished" datetime="2023-02-14T15:50:29+08:00">2023-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">数据库开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0-你应该了解的"><a href="#0-你应该了解的" class="headerlink" title="0. 你应该了解的"></a>0. 你应该了解的</h2><ul>
<li>关系代数<ul>
<li>选择（select）、投影（project）、连接（join）、联合（union）、差（difference）、乘积 （product）</li>
</ul>
</li>
<li>DB，DBMS，基于数据库的应用程序</li>
<li>数据库的基本特性（表、KEY、完整性约束、锁、视图、事务…）</li>
<li>SQL：基本的DDL，DML，触发器，存储过程等的语法和基本用法</li>
<li>数据库设计的基本原则</li>
</ul>
<h2 id="1-开发成功数据库的要点"><a href="#1-开发成功数据库的要点" class="headerlink" title="1. 开发成功数据库的要点"></a>1. 开发成功数据库的要点</h2><ul>
<li>需要理解数据库体系结构</li>
<li>需要理解锁和并发控制特性：每个数据库都以不同的方式实现</li>
<li>不要把数据库当”黑盒”</li>
<li>性能、安全性都是适当的被设计出来的</li>
<li>用尽可能简单的方法解决问题：”创造”永远追不上开发的步伐</li>
<li>DBA和RD之间的关系</li>
</ul>
<h3 id="1-1-数据库体系结构的差异"><a href="#1-1-数据库体系结构的差异" class="headerlink" title="1.1 数据库体系结构的差异"></a>1.1 数据库体系结构的差异</h3><ul>
<li><strong>不能把数据库当成”黑盒”使用，因为每个数据库都是非常不同的</strong></li>
<li>Oracle和MySQL的差别，类似<ul>
<li>Windows和Linux的差别</li>
<li>iOS和Android的差别</li>
<li>虽然都是DBMS，但它们也有相当的差异</li>
</ul>
</li>
<li>了解这种差异，了解你所使用数据库的特性，是开发成功数据库应用的基础</li>
</ul>
<h3 id="1-2-并发控制的问题"><a href="#1-2-并发控制的问题" class="headerlink" title="1.2 并发控制的问题"></a>1.2 并发控制的问题</h3><ul>
<li>现实存在并发，我们需要保持数据的一致性，所以要做并发控制</li>
<li>锁机制，使得并发控制成为可能</li>
<li><strong>不同的数据库，实现锁机制是不一样的</strong></li>
</ul>
<h4 id="比如：Oracle的锁机制就比较特别"><a href="#比如：Oracle的锁机制就比较特别" class="headerlink" title="比如：Oracle的锁机制就比较特别"></a>比如：Oracle的锁机制就比较特别</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230215103012132.png" alt="image-20230215103012132" style="zoom:80%;" /></p>
<p>这个时候，Transaction1能提交吗？</p>
<ul>
<li>可以的，结果是1000</li>
</ul>
<h4 id="Oracle存在有时读不到正确数据的现象"><a href="#Oracle存在有时读不到正确数据的现象" class="headerlink" title="Oracle存在有时读不到正确数据的现象"></a>Oracle存在有时读不到正确数据的现象</h4><p>Oracle的多版本控制，读一致性的并发模型</p>
<ul>
<li>读一致查询：对于一个时间点（point time），查询会产生一致的结果</li>
<li>非阻塞查询：查询不会被写入器阻塞，<em>但在其它数据库中可能不是这样的</em></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/2.png" alt="img" style="zoom: 50%;" /></p>
<blockquote>
<p>对于左侧，打开游标时，不会读取数据，只有在读取游标时才会读取数据</p>
<p>对于右侧，如果我们删除了所有的表，但是我们在Oracle中仍然可以使用之前打开的游标来读取那个时刻的数据</p>
<p>事实上，打开游标的时候确实没有复制，删除数据的时候也确实删除了，但是删除数据的时候Oracle为我们使用Undo日志来保存了下来(我们记作Undo statement)，是删除的回滚段，游标从快照读出修改前的数据</p>
</blockquote>
<h4 id="Oracle这种锁机制的好处是什么？"><a href="#Oracle这种锁机制的好处是什么？" class="headerlink" title="Oracle这种锁机制的好处是什么？"></a>Oracle这种锁机制的好处是什么？</h4><ul>
<li>读不阻塞写，可以极大程度上提高数据库的吞吐能力<ul>
<li>读操作仅对业务有影响而对DB影响不大</li>
</ul>
</li>
</ul>
<h4 id="Oracle-MySQL和其它数据库在并发上的差别"><a href="#Oracle-MySQL和其它数据库在并发上的差别" class="headerlink" title="Oracle/MySQL和其它数据库在并发上的差别"></a>Oracle/MySQL和其它数据库在并发上的差别</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230215104203198.png" alt="image-20230215104203198" style="zoom: 67%;" /></p>
<h4 id="从体系结构和特性中了解具体数据库的锁机制"><a href="#从体系结构和特性中了解具体数据库的锁机制" class="headerlink" title="从体系结构和特性中了解具体数据库的锁机制"></a>从体系结构和特性中了解具体数据库的锁机制</h4><p>比如Oracle实现的锁机制</p>
<ul>
<li><strong>只有修改才加行级锁</strong></li>
<li>Read绝对不会对数据加锁</li>
<li>Writer不会阻塞Reader</li>
<li><strong>读写器绝对不会阻塞写入器</strong></li>
</ul>
<h3 id="1-3-开发成功数据库应用的要点-黑盒的问题"><a href="#1-3-开发成功数据库应用的要点-黑盒的问题" class="headerlink" title="1.3 开发成功数据库应用的要点-黑盒的问题"></a>1.3 开发成功数据库应用的要点-黑盒的问题</h3><p><em>对大多数码农而言，数据库锁机制好像都是自动和透明实现的，那么深入了解每个数据库的锁机制实现细节，对码农编码有什么影响嘛？</em></p>
<h4 id="问题是：这对我们码农有什么影响吗？"><a href="#问题是：这对我们码农有什么影响吗？" class="headerlink" title="问题是：这对我们码农有什么影响吗？"></a>问题是：这对我们码农有什么影响吗？</h4><p>Oracle的无阻塞设计有一个副作用，就是如果确实想保证一次最多只有一个用户访问一行数据，就得开发人员自己做一些工作</p>
<ul>
<li>通过使用 <code>FOR UPDATE</code> 手动加锁</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230215104534691.png" alt="image-20230215104534691" style="zoom:80%;" /></p>
<h4 id="黑盒和数据库独立性的问题"><a href="#黑盒和数据库独立性的问题" class="headerlink" title="黑盒和数据库独立性的问题"></a>黑盒和数据库独立性的问题</h4><ul>
<li>数据库有脱离实现级别的使用方法</li>
<li>我的观点是<ul>
<li>要构建一个完全数据库独立的应用，而且是高度可扩展的应用是极其困难的</li>
<li>实际上，这几乎是不可能的</li>
</ul>
</li>
<li>要构建一个完全数据库独立的应用<ul>
<li>你必须真正了解每个数据库具体如何工作</li>
<li>如果你清楚每个数据库工作的具体细节，你就会知道，数据库独立性可能并不是你真正想要的</li>
</ul>
</li>
</ul>
<h4 id="例如：Null值造成的数据库迁移障碍"><a href="#例如：Null值造成的数据库迁移障碍" class="headerlink" title="例如：Null值造成的数据库迁移障碍"></a>例如：Null值造成的数据库迁移障碍</h4><blockquote>
<p>null: 空值表示<strong>有一个值但是<em>我不知道</em></strong></p>
<p>对索引列进行空值比较将使 ORACLE 停用该索引，而一些条件判断可以通过索引高效完成，因此会极大影响效率</p>
</blockquote>
<p>例子：在表T中，如果不满足某个条件，则找出X为NULL的所有行，如果满足就找出X等于某个特定值的所有行。</p>
<ul>
<li>Oracle并没有返回NULL(不知道)的所有行</li>
<li>Oracle中NULL = NULL 返回 NULL</li>
<li>那么我们使用了is null关键字，但是Oracle不会为空值建立聚簇索引，导致性能会大幅度下降</li>
<li>于是我们通过创建了一个<strong>基于函数的索引</strong>来解决这个问题</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230215105546447.png" alt="image-20230215105546447" style="zoom: 67%;" /></p>
<h4 id="关于黑盒的问题总结几点"><a href="#关于黑盒的问题总结几点" class="headerlink" title="关于黑盒的问题总结几点"></a>关于黑盒的问题总结几点</h4><ul>
<li>数据库是不同的。在一个数据库上取得的经验也许可以部分应用于另一个数据库，但是必须有心理准备，二者之间可能存在一些基本差别，可能还有一些细微的差别。</li>
<li>细微的差别（比如对NULL的处理）与基本差别（如并发控制机制）可能有同样显著的影响。</li>
<li>应当了解数据库，知道它是如何工作的，他的特性如何实现，这是解决这些问题的唯一途径。</li>
</ul>
<h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2. 优化"></a>2. 优化</h2><h3 id="2-1-设计问题"><a href="#2-1-设计问题" class="headerlink" title="2.1 设计问题"></a>2.1 设计问题</h3><h4 id="我能不能找一个大牛帮我调优"><a href="#我能不能找一个大牛帮我调优" class="headerlink" title="我能不能找一个大牛帮我调优"></a>我能不能找一个大牛帮我调优</h4><ul>
<li>先把程序写出来，之后再让专家在生产环境中帮我<strong>调优</strong>：<strong>这个想法是错误的</strong>。</li>
<li>性能调优(目前情况下性能优化至最优)<ol>
<li>根据当前CPU能力、可用内存、I/O子系统等资源情况来设置相应参数</li>
<li>通过<strong>索引、物理结构、SQL</strong>的优化，具体提高某一个查询的性能</li>
</ol>
</li>
</ul>
<blockquote>
<p>如果有个专家能通过一些参数、技巧提高了你的系统一个数量级的性能：不能说这个专家牛逼，大概只能说明你的程序太烂了。</p>
</blockquote>
<h4 id="性能拙劣的罪魁祸首是错误的设计"><a href="#性能拙劣的罪魁祸首是错误的设计" class="headerlink" title="性能拙劣的罪魁祸首是错误的设计"></a>性能拙劣的罪魁祸首是错误的设计</h4><ul>
<li>提高整体性能<ol>
<li>技巧决定系统性能的下限</li>
<li>设计决定系统性能的上限</li>
</ol>
</li>
<li>比如，新闻的门户网站<ol>
<li>动态页面 vs 静态页面：百万量级的高并发下的动态网页导致大量的连接创建、I/O资源、CPU资源被消耗，导致负担过重</li>
<li>静态页面 + 内容管理系统：这个管理系统远远复杂于动态页面，使用触发器等自动化部署手段来生成静态网页</li>
</ol>
</li>
<li>为什么微信不支持信息的修改？<ol>
<li>因为微信朋友圈后台使用的NoSQL的非关系型数据库，所有的数据都是顺序存储，才能满足大量的读写效率。</li>
<li>顺序文件的修改是非常麻烦的，因此也就不支持了。</li>
</ol>
</li>
</ul>
<h3 id="2-2-性能优化"><a href="#2-2-性能优化" class="headerlink" title="2.2 性能优化"></a>2.2 性能优化</h3><h4 id="性能优化要考虑整体"><a href="#性能优化要考虑整体" class="headerlink" title="性能优化要考虑整体"></a>性能优化要考虑整体</h4><ul>
<li>性能指标都是有成本的、安全和优化中寻找平衡</li>
<li>性能指标以吞吐量为核心（每秒处理多少事务）<ul>
<li>而尽量不用一个事务几秒能处理完成</li>
</ul>
</li>
<li>性能指标要考虑整体性<ul>
<li>优化手段本身就有很大的风险，只不过你没意识到罢了</li>
<li><strong>任何一个技术可以解决一个问题，但必然存在另一个问题的风险</strong></li>
<li>对于带来的风险，控制在可接受的范围才是有成果</li>
<li>性能优化技术，使得性能变好，维持和变差是等概率的事件</li>
</ul>
</li>
</ul>
<h4 id="使用优化工具"><a href="#使用优化工具" class="headerlink" title="使用优化工具"></a>使用优化工具</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230215112738722.png" alt="image-20230215112738722" style="zoom:67%;" /></p>
<h4 id="整体层面的性能优化考虑"><a href="#整体层面的性能优化考虑" class="headerlink" title="整体层面的性能优化考虑"></a>整体层面的性能优化考虑</h4><p>问题一：CPU负载高，IO负载低</p>
<ul>
<li>内存不够</li>
<li>磁盘性能差（磁盘问题、raid设计不好、raid降级）</li>
<li><strong>SQL的问题</strong></li>
<li><strong>并发锁机制的问题</strong></li>
<li><strong>事务设计问题，大量小数据IO</strong></li>
<li><strong>大量的全表扫描</strong></li>
</ul>
<p>问题二：IO负载高，CPU负载低</p>
<ul>
<li><strong>大量小的IO执行写操作</strong></li>
<li><strong>Autocommit，产生大量小IO</strong></li>
<li><strong>大量大的IO执行写操作</strong></li>
<li><strong>SQL的问题</strong></li>
<li>IO/PS磁盘限定一个每秒最大IO次数</li>
</ul>
<p>问题三：IO和CPU负载都高</p>
<ul>
<li>硬件不够用了</li>
<li>SQL存在问题</li>
</ul>
<blockquote>
<p>性能问题，90%的问题来源都是程序员的问题，开发环境到生产环境是一场灾难</p>
</blockquote>
<h4 id="SQL优化的方向"><a href="#SQL优化的方向" class="headerlink" title="SQL优化的方向"></a>SQL优化的方向</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230215113804909.png" alt="image-20230215113804909" style="zoom:80%;" /></p>
<h4 id="限用Boolean型字段"><a href="#限用Boolean型字段" class="headerlink" title="限用Boolean型字段"></a>限用Boolean型字段</h4><ul>
<li>SQL中并不存在Boolean类型</li>
<li>实现flag表示标志位的Y/N或T/F<ul>
<li>例如：order_completed</li>
<li>但是…往往增加信息字段能包含更多的信息量</li>
<li>例如：completion_date completion_by</li>
<li>或者增加order更多状态标示</li>
</ul>
</li>
<li>极端的例子：四个属性取值都是T/F，可以用0-15这16个数值代表四个属性所有组合状态<ul>
<li>技巧可能违反了原子性的原则</li>
<li>为数据而数据，是通向灾难之路</li>
</ul>
</li>
</ul>
<h4 id="理解子类型-SubType"><a href="#理解子类型-SubType" class="headerlink" title="理解子类型(SubType)"></a>理解子类型(SubType)</h4><ul>
<li>表过”宽”(有太多属性)的另一个原因，是对数据项之间的关系了解不够深入</li>
<li>一般情况下，给子类型表指定完全独立于父表主键的主键，是极其错误的</li>
</ul>
<h4 id="约束应明确说明"><a href="#约束应明确说明" class="headerlink" title="约束应明确说明"></a>约束应明确说明</h4><ul>
<li>数据中存在隐含约束是一种不良设计</li>
<li>字段的性质随着环境变化而变化时设计的错误和不稳定性</li>
<li>数据语义属于DBMS，别放到应用程序中</li>
</ul>
<h4 id="过于灵活的危险性"><a href="#过于灵活的危险性" class="headerlink" title="过于灵活的危险性"></a>过于灵活的危险性</h4><ul>
<li>“真理向前跨一步就是谬误”</li>
<li>不可思议的四通用表设计<ul>
<li>Objects(oid, name), Attributes(attrid, attrname, type)</li>
<li>Object_Attributes(oid,attrid,value)</li>
<li>Link(oid1,oid2)</li>
</ul>
</li>
<li>随意增加属性，避免NULL</li>
<li>成本急剧上升，性能令人失望</li>
</ul>
<h4 id="如何处理历史数据"><a href="#如何处理历史数据" class="headerlink" title="如何处理历史数据"></a>如何处理历史数据</h4><ul>
<li>历史数据：例如：商品在某一时刻的价格</li>
<li>Price_history(article_id, effective_from_date, price)</li>
<li>缺点在于查询当前价格比较笨拙</li>
<li>其他方案<ul>
<li>定义终止时间</li>
<li>同时保持价格生效和失效日期，或生效日期和有效天数等等</li>
<li>当前价格表+历史价格表</li>
</ul>
</li>
</ul>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><ul>
<li>操作模式(operating mode)<ul>
<li>异步模式处理(批处理)</li>
<li>同步模式处理(实时交易)</li>
</ul>
</li>
<li>处理数据的方式会影响我们物理结构的设计</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/02/14/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/14/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1/" class="post-title-link" itemprop="url">Linux程序设计(1) Linux Basics</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-14 15:50:16" itemprop="dateCreated datePublished" datetime="2023-02-14T15:50:16+08:00">2023-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-18 15:56:02" itemprop="dateModified" datetime="2023-08-18T15:56:02+08:00">2023-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">Linux程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-What-is-Linux"><a href="#1-What-is-Linux" class="headerlink" title="1. What is Linux?"></a>1. What is Linux?</h2><p>根据 GNU 通用公共许可证开发的免费类 Unix 操作系统。</p>
<ol>
<li>开源</li>
<li>受欢迎</li>
<li>支持大多数可用平台</li>
</ol>
<h3 id="1-1-GNU-amp-Linux"><a href="#1-1-GNU-amp-Linux" class="headerlink" title="1.1 GNU &amp; Linux"></a>1.1 GNU &amp; Linux</h3><p>GNU/Linux System</p>
<ul>
<li>Linux kernel</li>
<li>GNU software/library</li>
</ul>
<p>Distributions(发行版)：</p>
<ul>
<li>Ubuntu, Debian, Mint, Red Hat, Fodore, SuSe, Mandrake, Redflag…</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230214155540587.png" alt="image-20230214155540587" style="zoom:80%;" /></p>
<h4 id="What-is-So-Special-for-Linux"><a href="#What-is-So-Special-for-Linux" class="headerlink" title="What is So Special for Linux?"></a>What is So Special for Linux?</h4><ul>
<li>大多数软件(包括Linux内核)均为 GPL 版(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU General Public License</a>)</li>
<li>称为”<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Copyleft">copyleft</a>“(而不是”copyright”)<ol>
<li>你可以复制软件</li>
<li>你可以获得源代码</li>
<li>你可以更改源代码并重新编译</li>
<li>你可以分发更改后的源和二进制文件</li>
<li>你可能会为此付费</li>
</ol>
</li>
<li>你只是<strong>不能更改许可证</strong><ul>
<li>因此，所有客户都享有与您相同的权利</li>
<li>因此，您真的不能单靠销售软件赚钱</li>
</ul>
</li>
<li>其他开源许可证 (例如BSD) 也可用</li>
</ul>
<h2 id="2-Linux-Installation"><a href="#2-Linux-Installation" class="headerlink" title="2. Linux Installation"></a>2. Linux Installation</h2><h3 id="2-1-Installing-Linux"><a href="#2-1-Installing-Linux" class="headerlink" title="2.1 Installing Linux"></a>2.1 Installing Linux</h3><ol>
<li>从可启动媒体启动系统</li>
<li>所有安装程序都需要执行本质上相同的步骤：<ol>
<li>选择语言，键盘类型，鼠标类型</li>
<li>磁盘分区(Create partitions)</li>
<li>设置引导加载程序(Setup a boot loader)</li>
<li>配置网络</li>
<li>配置用户和认证</li>
<li>选择包装组</li>
<li>配置X</li>
<li>安装软件包</li>
<li>创建启动盘</li>
</ol>
</li>
</ol>
<h3 id="2-2-Partitioning-Theory"><a href="#2-2-Partitioning-Theory" class="headerlink" title="2.2 Partitioning Theory"></a>2.2 Partitioning Theory</h3><p>硬盘的分区组织方式</p>
<h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><ol>
<li>在基于Intel的计算机上必须进行分区</li>
<li>最多四个主分区</li>
<li>一个主分区可以是扩展分区</li>
<li>扩展分区可以容纳无限数量的逻辑分区(Linux：最大59)<ul>
<li>扩展分区可以放4个逻辑分区，或者将其中的逻辑分区换为二级的扩展分区</li>
</ul>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230214162131763.png" alt="image-20230214162131763" style="zoom:80%;" /></p>
<blockquote>
<p>上图中表示是一个双系统，所以同时有windows和linux</p>
<ol>
<li>hda：磁盘的第一个扇区包含 MBR 和分区表(早期的都是 MBR 组织的，后面使用了 GPT (使用GUID分区表))</li>
<li>hda1：第一个主分区包含Windows 95文件系统</li>
<li>hda2：第二主分区是扩展分区，拥有三个逻辑分区</li>
<li>hda5：第一个逻辑分区包含一个Linux文件系统，该文件系统将被安装为/</li>
<li>hda6：第二个逻辑分区包含一个Linux文件系统，该文件系统将挂载为/home</li>
<li>hda7：第三个逻辑分区拥有一个Linux交换空间</li>
</ol>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">MBR(Master Boot Record)</a></p>
<ul>
<li>Size: 512 bytes (硬盘的首个扇区)</li>
<li>Addressed by BIOS(由 BIOS 寻址)</li>
<li>Content:<ul>
<li>446 bytes program code (to boot an OS)</li>
<li>64 bytes partition table with max 4 entries</li>
<li>2 bytes “magic number” (0x55AA)</li>
</ul>
</li>
</ul>
<h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230214162723879.png" alt="image-20230214162723879" style="zoom:80%;" /></p>
<ul>
<li>保留的 MBR 是为了在较老的机器上也能读取到磁盘上的信息</li>
<li>GPT 是 MBR 不够用了才会选择使用</li>
<li>支持上百个主分区，不需要扩展分区(支持超过128，但是windows限制128)</li>
<li>Header记录Entry信息，Entry记录Partition信息，形成三级结构</li>
<li>Secondary GPT 是备份，因此 GPT 相较于 MBR 方式会有更多的空间无法使用</li>
</ul>
<h3 id="2-3-File-System"><a href="#2-3-File-System" class="headerlink" title="2.3 File System"></a>2.3 File System</h3><p>什么是文件系统</p>
<ul>
<li>操作系统中负责存取和管理文件的部分</li>
<li>A collection of files and certain of their attributes. It provides a name space for file serial numbers referring to those files. (susv3)</li>
</ul>
<p>Linux 中的文件系统:</p>
<ul>
<li>VFS</li>
<li>EXT2, EXT3, FAT32…</li>
</ul>
<h3 id="2-4-Disk-Partitioning"><a href="#2-4-Disk-Partitioning" class="headerlink" title="2.4 Disk Partitioning"></a>2.4 Disk Partitioning</h3><ul>
<li>至少要创建<ul>
<li>根目录(/)，750MB(建议1.5G或更高)，需要指定一个主分区</li>
<li>交换分区(swap)，大小等于内存量,用于虚拟内存</li>
</ul>
</li>
<li>推荐：/boot(16MB)，用于启动，常存放boot loader</li>
<li>可能需要/想要创建其他分区：/usr，/usr/local，/var，/tmp，/opt，/home<ul>
<li>例如可以将 /home 指定一个主分区，那么向 home 文件夹存放数据会存放到对应的分区，形成挂载结构</li>
</ul>
</li>
<li>Linux下的默认分区程序是fdisk，发行版可以添加自己的分区程序</li>
</ul>
<h3 id="2-5-Linux-Startup-Flow"><a href="#2-5-Linux-Startup-Flow" class="headerlink" title="2.5 Linux Startup Flow"></a>2.5 Linux Startup Flow</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230217103017442.png" alt="image-20230217103017442" style="zoom:80%;" /></p>
<blockquote>
<p>BIOS 通过查找硬盘，启动boot loader</p>
<p>init 是第一个启动的应用程序，是个用户态程序</p>
</blockquote>
<ol>
<li>BIOS：<ul>
<li>检查内存，从非易失性内存中加载选项，检查启动设备，加载启动设备的MBR并执行它</li>
</ul>
</li>
<li>MBR<ul>
<li>包含一个”boot loader”和分区表</li>
<li>传统上由 LILO/GRUB 设置</li>
</ul>
</li>
<li>Boot loader<ul>
<li>将压缩的内核映像加载到内存中</li>
<li>内核解压缩并启动</li>
</ul>
</li>
<li>初始化过程<ul>
<li>配置文件 /etc/inittab</li>
<li>运行水平</li>
</ul>
</li>
</ol>
<h4 id="Basic-Input-Output-System-BIOS"><a href="#Basic-Input-Output-System-BIOS" class="headerlink" title="Basic Input Output System(BIOS)"></a>Basic Input Output System(BIOS)</h4><ul>
<li>检查内存和硬件是否正常(POST)</li>
<li>从非易失性存储器中加载选项<ol>
<li>内存时序</li>
<li>启动设备顺序</li>
</ol>
</li>
<li>检查启动设备：软盘，CD-ROM，硬盘等</li>
<li>加载启动设备的 MBR 并执行</li>
</ul>
<h4 id="EFI"><a href="#EFI" class="headerlink" title="EFI"></a>EFI</h4><p>增强版的BIOS, 支持GPT，支持更多的设备</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230217103757283.png" alt="image-20230217103757283" style="zoom:80%;" /></p>
<h4 id="Boot-loader"><a href="#Boot-loader" class="headerlink" title="Boot loader"></a>Boot loader</h4><ul>
<li>引导加载程序加载并启动Linux内核<ol>
<li>可以将启动参数传递给Linux内核，例如设备信息</li>
<li>可以选择加载初始根磁盘</li>
<li>也可以启动其他操作系统</li>
</ol>
</li>
<li>通用引导加载程序：<ol>
<li>LILO：Linux Loader(很古老，不考)</li>
<li>GRUB：Grand Unified Boot Loader</li>
</ol>
</li>
<li>除非使用其他引导加载程序，否则通常在/dev/hda中进行配置。</li>
</ul>
<h4 id="GRUB-Grand-Unified-Boot-Loader"><a href="#GRUB-Grand-Unified-Boot-Loader" class="headerlink" title="GRUB(Grand Unified Boot Loader)"></a>GRUB(Grand Unified Boot Loader)</h4><ul>
<li>程序存储在 MBR (第一阶段) 和 /boot/grub (第1.5和第二阶段) 中</li>
<li>了解文件系统结构；无需像LILO一样激活配置</li>
<li>配置文件：/boot/grub/grub.cfg<ul>
<li>最重要就是配置内核和init文件的位置</li>
</ul>
</li>
<li>通过grub-install安装在MBR中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs grub.cfg">title Ubuntu, kernel 2.6.20-16-generic<br>root (hd0,1)<br>kernel /boot/vmlinuz-2.6.20-16-generic root=UUID=3f784cd9-516f-4808-a601-b19356f6bdea ro quiet splash locale=zh_CN vga=0x318 // 内核与参数<br>initrd /boot/initrd.img-2.6.20-16-generic // init程序<br><br>// 配置 windows<br>title Microsoft Windows XP<br>Professional<br>root	(hd0, 0) // 0号磁盘0号分区<br>savedefault<br>makeactive<br>chainloader +1 // 找新的引导程序，windows有自己的<br></code></pre></td></tr></table></figure>
<h2 id="3-Using-the-System"><a href="#3-Using-the-System" class="headerlink" title="3. Using the System"></a>3. Using the System</h2><h3 id="3-1-Basic-Knowledge"><a href="#3-1-Basic-Knowledge" class="headerlink" title="3.1 Basic Knowledge"></a>3.1 Basic Knowledge</h3><h4 id="Installing-Software-on-Linux"><a href="#Installing-Software-on-Linux" class="headerlink" title="Installing Software on Linux"></a>Installing Software on Linux</h4><ul>
<li>From a tarball</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译源代码安装软件：automake模式</span><br>tar zxvf application.tar.gz<br><span class="hljs-built_in">cd</span> application<br>./configure<br>make<br>su - <span class="hljs-comment"># 只有make install需要切换root权限</span><br>make install <span class="hljs-comment"># 将编译后的二进制码安装到系统</span><br><br><span class="hljs-comment"># cmake模式</span><br>tar zxvf application.tar.gz<br><span class="hljs-built_in">cd</span> application<br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake ..	<span class="hljs-comment"># cmake后面跟application目录，..即上级目录</span><br>make VERBOSE=1	<span class="hljs-comment"># VERBOSE参数可选，仅多打印一些东西</span><br>su -<br>make install<br></code></pre></td></tr></table></figure>
<ul>
<li>yum + rpm (red hat系列使用rpm安装包)<ul>
<li>RPM: RPM Package Management<ul>
<li>rpm –q –a，查询</li>
<li>rpm –ivh package-name，安装</li>
<li>rpm –e package-name，卸载</li>
</ul>
</li>
<li>单独使用rpm会造成可能需要下载无数的依赖，因此需要管理工具的存在-yum</li>
</ul>
</li>
<li>dpkg：ubuntu系列,类似rpm</li>
<li>apt-get command *：在线下载<ul>
<li>update：下载最新的软件包列表</li>
</ul>
</li>
<li>aptitude：可能能解决版本冲突</li>
</ul>
<h4 id="Multi-user-and-Multi-tasking"><a href="#Multi-user-and-Multi-tasking" class="headerlink" title="Multi-user and Multi-tasking"></a>Multi-user and Multi-tasking</h4><ul>
<li>Linux是一个<strong>多用户，多任务</strong>的操作系统：多个用户可以同时运行多个彼此独立的任务。</li>
<li>在使用系统之前，总是需要”登录”：用<strong>用户名，密码</strong>识别</li>
<li>多种登录系统的方式<ol>
<li>控制台：直接连接的键盘，鼠标，显示器</li>
<li>串口</li>
<li>网络连接</li>
</ol>
</li>
</ul>
<h4 id="Virtual-Terminal"><a href="#Virtual-Terminal" class="headerlink" title="Virtual Terminal"></a>Virtual Terminal</h4><ul>
<li>在大多数Linux发行版中，控制台模拟许多虚拟终端</li>
<li>每个虚拟终端都可以看作是一个单独的直接连接的控制台：不同的用户可以使用不同的虚拟终端</li>
<li>典型设置：<ol>
<li>VT 1-6：<strong>文本模式登录</strong></li>
<li>VT 7：图形模式登录提示(如果启用)</li>
</ol>
</li>
<li>使用Alt-Fn(如果在X中为Ctrl-Alt-Fn)在VT之间切换</li>
</ul>
<h4 id="Linux-Commands"><a href="#Linux-Commands" class="headerlink" title="Linux Commands"></a>Linux Commands</h4><ul>
<li>Linux系统上的所有操作都可以通过键入命令来完成：<ul>
<li>运行Linux系统不需要GUI(X-Window)，图形界面是一个用户态程序</li>
</ul>
</li>
<li>为了在 X-Window 中键入命令，您需要启动 终端模拟器(即图形界面中的终端)</li>
<li>命令提示<ul>
<li>可以自己配置<ul>
<li>修改环境变量: <code>export SUDO_PS1=&quot;\u@\h:\w\$&quot;</code>, <code>export PS1=&quot;\u@\h:\w\$&quot;</code></li>
</ul>
</li>
<li><code>$</code>：以普通用户身份登录</li>
<li><code>#</code>：以root身份登录</li>
</ul>
</li>
<li>命令提示符：<code>用户名@计算机名:当前目录$</code></li>
</ul>
<h4 id="Command-Syntax"><a href="#Command-Syntax" class="headerlink" title="Command Syntax"></a>Command Syntax</h4><ul>
<li>Linux命令具有以下格式：<ul>
<li><code>$ command option(s) argument(s)</code></li>
</ul>
</li>
</ul>
<h3 id="3-2-Working-with-Files-and-Directories"><a href="#3-2-Working-with-Files-and-Directories" class="headerlink" title="3.2 Working with Files and Directories"></a>3.2 Working with Files and Directories</h3><ul>
<li>什么是文件？<ul>
<li>数据的集合</li>
<li>可以写入或读取或两者兼有的对象。文件具有某些属性，包括访问权限和类型(susv3)</li>
</ul>
</li>
<li>文件结构<ul>
<li>通常：字节流，记录序列，记录树</li>
<li>在Linux中：<strong>字节流</strong></li>
</ul>
</li>
</ul>
<h4 id="File-Types"><a href="#File-Types" class="headerlink" title="File Types"></a>File Types</h4><ol>
<li>普通文件(regular file)：<ul>
<li>文本或代码数据；没有特别的内部结构</li>
</ul>
</li>
<li>字符型设备文件(character special file)</li>
<li>块型设备文件(block special file)<ul>
<li><strong>special files：代表硬件或逻辑设备</strong></li>
<li>位于 /dev 目录</li>
</ul>
</li>
<li>网络接口(socket)</li>
<li>符号链接(symbolic link)<ul>
<li>软链接：类似windows上的快捷方式</li>
<li>硬链接：<strong>同一个文件有两个文件名</strong>，创建出来的硬链接不占用磁盘空间和inode号。</li>
</ul>
</li>
<li>目录(directory)：该目录中的文件列表</li>
<li>管道(fifo)</li>
</ol>
<blockquote>
<p>驱动程序留给应用程序的接口, 只有三种</p>
<ul>
<li>character special file</li>
<li>block special file</li>
<li>socket</li>
</ul>
</blockquote>
<h4 id="Directory-Structure"><a href="#Directory-Structure" class="headerlink" title="Directory Structure"></a>Directory Structure</h4><ul>
<li>所有Linux目录都包含在一个虚拟的”统一文件系统”中。</li>
<li>物理设备挂载在挂载点上<ul>
<li>软盘</li>
<li>硬盘分区</li>
<li>CD-ROM驱动器</li>
</ul>
</li>
<li>没有驱动器号，例如A:，C:，…</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230227143200633.png" alt="image-20230227143200633" style="zoom:80%;" /></p>
<h4 id="Main-Directories-in-Linux"><a href="#Main-Directories-in-Linux" class="headerlink" title="Main Directories in Linux"></a>Main Directories in Linux</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230227143638153.png" alt="image-20230227143638153" style="zoom:80%;" /></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.pathname.com/fhs">Linux Filesystem Hierarchy Standard</a></p>
</blockquote>
<h4 id="Basic-Commands"><a href="#Basic-Commands" class="headerlink" title="Basic Commands"></a>Basic Commands</h4><ul>
<li>passwd：更改密码</li>
<li>mkpasswd：生成随机密码</li>
<li>date，cal：找出今天的日期并显示日历</li>
<li>who，finger：找出还有谁在系统上处于活动状态</li>
<li>clear：清除屏幕</li>
<li>echo：在屏幕上写一条消息</li>
<li>write、wall、talk、mesg<ul>
<li>write：给其他用户发信息</li>
<li>wall：write all, 给所有登录到系统的用户发信息</li>
<li>talk：建立聊天session</li>
<li>mesg：可以屏蔽用户发来的信息</li>
</ul>
</li>
<li>pwd：当前目录</li>
<li>cd：更改目录</li>
<li>mkdir：创建目录</li>
<li>rmdir：删除目录</li>
<li>ls：列出目录的内容，-l，-a(显示隐藏文件, 形如<code>.*</code>)，-R(递归打印所有的子目录中的文件)选项，-i</li>
<li>touch：更新文件的访问, 修改时间</li>
<li>cp：复制文件</li>
<li>mv：移动并重命名文件</li>
<li>ln：链接文件</li>
<li>rm：删除文件</li>
<li>cat：打印文件内容</li>
<li>more/less：逐页显示文件，more不可以回退，less可以回退</li>
<li>ps：报告进程状态</li>
<li>pstree：显示进程树</li>
<li>jobs, fg, bg, ctrl-z：作业控制<ul>
<li>bg: 后台执行</li>
<li>fg: 前台执行</li>
<li>ctrl-z: 暂停进程, 可通过fg, bg恢复</li>
</ul>
</li>
<li>kill：杀死进程</li>
<li>nohup：运行命令，忽略挂起信号</li>
<li>nice，renice：修改进程优先级</li>
<li><p>top：查看进程的cpu占用</p>
</li>
<li><p>文件操作</p>
<ul>
<li>列出目录内容: ls, (dir, vdir 与ls功能类似)</li>
<li>创建特殊文件: mkdir, mknod, mkfifo<ul>
<li>mknod: 创建设备文件</li>
<li>mkfifo: 创建管道</li>
</ul>
</li>
<li>文件操作: cp, mv, rm</li>
<li>修改文件属性: chmod, chown, chgrp, touch<ul>
<li>chown: 改文件拥有者、用户组</li>
<li>chgrp: 更改用户组</li>
</ul>
</li>
<li>查找文件: (locate), find<ul>
<li>locate: 功能和 find 类似</li>
</ul>
</li>
<li>字符串匹配: grep(egrep)<ul>
<li>grep: 在文本文件中搜索字符串</li>
<li>egrep: grep 扩展</li>
</ul>
</li>
<li>其它: pwd, cd, ar, file, tar, more, less, head, tail, cat<ul>
<li>ar: 打包库文件</li>
<li>file: 显示文件类型</li>
<li>more, less: 一页页显示</li>
<li>head, tail: 显示文件头部、尾部</li>
</ul>
</li>
</ul>
</li>
<li>进程操作：ps, kill, jobs, fg, bg, nice</li>
<li>其它<ul>
<li>who, whoami, passwd, su, uname, …<ul>
<li>whoami: 当前用户名</li>
<li>uname: 显示内核信息</li>
</ul>
</li>
<li>man</li>
</ul>
</li>
</ul>
<h4 id="File-Permission"><a href="#File-Permission" class="headerlink" title="File Permission"></a>File Permission</h4><ul>
<li><p>文件权限可帮助保护文件免受其他用户侵害</p>
</li>
<li><p>三个访问级别：</p>
<ol>
<li>用户(User)：创建文件的用户</li>
<li>组(Group)：拥有文件的组中的所有用户</li>
<li>其他(Others)：其他</li>
</ol>
</li>
<li><p>三个权限：</p>
<ol>
<li>读取(r)：读取文件内容或目录内容</li>
<li>写(w)：更改文件内容或在目录中创建/删除文件</li>
<li>执行(x)：以程序执行文件或使用目录作为活动目录</li>
</ol>
</li>
<li><p><code>ls -l</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230227153229304.png" alt="image-20230227153229304" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="Changing-Permissions"><a href="#Changing-Permissions" class="headerlink" title="Changing Permissions"></a>Changing Permissions</h4><ul>
<li><p><code>chmod &lt;who operator what&gt; filename</code></p>
<ul>
<li><p>who:</p>
<ul>
<li><code>u</code> = owner of file</li>
<li><code>g</code> = group</li>
<li><code>o</code> = other users on the system</li>
<li><code>a</code> = all(u + g + o)</li>
</ul>
</li>
<li><p>operator:</p>
<ul>
<li><p><code>+</code> = add permission</p>
</li>
<li><p><code>-</code> = remove permission</p>
</li>
<li><code>=</code> = clear permissions and set to mode specified</li>
</ul>
</li>
<li><p>what: <code>r, w, x</code></p>
</li>
</ul>
</li>
<li><p><code>chmod &lt;number&gt; file</code></p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230227154029252.png" alt="image-20230227154029252" style="zoom:80%;" /></p>
<h4 id="Default-File-Permissions"><a href="#Default-File-Permissions" class="headerlink" title="Default File Permissions"></a>Default File Permissions</h4><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>权限</th>
<th>数字权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>File</td>
<td>-rw-r—r—</td>
<td>644</td>
</tr>
<tr>
<td>Directory</td>
<td>drwxr-xr-x</td>
<td>755</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Editing-Files"><a href="#Editing-Files" class="headerlink" title="Editing Files"></a>Editing Files</h4><ul>
<li>vi、emacs、gedit</li>
</ul>
<h3 id="3-3-Working-with-Processes"><a href="#3-3-Working-with-Processes" class="headerlink" title="3.3 Working with Processes"></a>3.3 Working with Processes</h3><p>什么是进程</p>
<ul>
<li>A process is a task.</li>
<li>进程是一个正在执行的程序实例。由执行程序，它的当前值，状态信息以及通过操作系统管理此进程执行情况的资源组成。</li>
<li>An address space with one or more threads executing within that address space, and the required system resources for those threads. (susv3)</li>
<li>正在运行的程序就是进程的一个示例</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230303101357067.png" alt="image-20230303101357067" style="zoom:80%;" /></p>
<ul>
<li>shell是一个读取命令并启动适当进程的进程<ul>
<li><code>echo $$</code></li>
</ul>
</li>
</ul>
<h4 id="Starting-and-Stopping-a-Process"><a href="#Starting-and-Stopping-a-Process" class="headerlink" title="Starting and Stopping a Process"></a>Starting and Stopping a Process</h4><ul>
<li>所有进程均由其他进程启动<ol>
<li>父子关系</li>
<li>一个例外：init (PID 1) 由内核本身启动</li>
<li>树层次结构</li>
</ol>
</li>
<li>可以终止进程的原因有两个：<ol>
<li>该进程完成后会自行终止。</li>
<li>该进程被另一个进程的信号终止</li>
</ol>
</li>
</ul>
<h4 id="Daemons"><a href="#Daemons" class="headerlink" title="Daemons"></a>Daemons</h4><p>“守护进程”一词指的是一个永不停止的进程，通常是控制诸如打印机队列之类的系统资源或执行网络服务的系统进程。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230303103555052.png" alt="image-20230303103555052" style="zoom:80%;" /></p>
<h3 id="3-4-Linux-Documentation"><a href="#3-4-Linux-Documentation" class="headerlink" title="3.4 Linux Documentation"></a>3.4 Linux Documentation</h3><h4 id="How-to-Find-Help"><a href="#How-to-Find-Help" class="headerlink" title="How to Find Help?"></a>How to Find Help?</h4><ul>
<li><code>man</code></li>
<li><code>info</code></li>
<li><code>command –-help</code></li>
<li>HOWTO 文档</li>
<li>参考互联网</li>
</ul>
<h4 id="The-man-command"><a href="#The-man-command" class="headerlink" title="The man command"></a>The man command</h4><ul>
<li>使用 man 命令，您可以阅读命令的手册页</li>
<li>手册页存储在 /usr/man</li>
<li>手册页包括：<ol>
<li>名称：命令名称和在线说明</li>
<li>概要：命令的语法</li>
<li>描述：有关命令的工作方式及其作用的说明</li>
<li>文件：命令使用的文件</li>
<li>错误：已知的错误和错误</li>
<li>另请参阅：与此命令相关的其他命令</li>
</ol>
</li>
<li>“-k”选项：<ul>
<li><code>man –k</code>: 是否还有其他版本说明书</li>
<li>要选择正确的部分，请添加部分编号：man 1 passwd，man 5 passwd</li>
</ul>
</li>
<li>手册分为8个部分：<ol>
<li>用户命令</li>
<li>系统调用</li>
<li>库调用</li>
<li>设备</li>
<li>文件格式和协议</li>
<li>游戏</li>
<li>公约，宏程序包等</li>
<li>系统管理</li>
</ol>
</li>
</ul>
<h4 id="The-info-command"><a href="#The-info-command" class="headerlink" title="The info command"></a>The info command</h4><ul>
<li>用于阅读文档的程序，有时可以代替手册页</li>
<li>有关信息的信息存储在 /usr/info</li>
<li>一些信息命令：<ol>
<li>space：下一屏文字</li>
<li>delete：上一屏文字</li>
<li>n：下一个节点</li>
<li>p：上一个节点</li>
<li>u：上节点</li>
<li>q：退出信息</li>
<li>tab：跳至下一个菜单项</li>
</ol>
</li>
</ul>
<h2 id="4-Linux-UNIX-Overview"><a href="#4-Linux-UNIX-Overview" class="headerlink" title="4. Linux/UNIX Overview"></a>4. Linux/UNIX Overview</h2><ul>
<li>早期的UNIX<ul>
<li>一个简单的文件系统</li>
<li>一个进程子系统和一个Shell</li>
</ul>
</li>
<li>内核和核外程序</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230303104322848.png" alt="image-20230303104322848" style="zoom:80%;" /></p>
<h4 id="Programmer’s-Viewpoint"><a href="#Programmer’s-Viewpoint" class="headerlink" title="Programmer’s Viewpoint"></a>Programmer’s Viewpoint</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230303105118990.png" alt="image-20230303105118990" style="zoom:80%;" /></p>
<h2 id="5-Linux-System-Basic"><a href="#5-Linux-System-Basic" class="headerlink" title="5. Linux System Basic"></a>5. Linux System Basic</h2><h3 id="5-1-重定向"><a href="#5-1-重定向" class="headerlink" title="5.1 重定向"></a>5.1 重定向</h3><ul>
<li><p>标准输入、标准输出、标准错误</p>
<ul>
<li>对应的文件描述符：0, 1, 2</li>
<li>C语言变量：stdin, stdout, stderr</li>
</ul>
</li>
<li><p><code>&lt;</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code>, <code>2&gt;&gt;</code>, <code>&amp;&gt;</code></p>
<ul>
<li>例: <code>kill –HUP 1234 &gt; killout.txt 2&gt; killerr.txt</code></li>
<li>例: <code>kill –HUP 1234 &gt; killout.txt 2&gt;&amp; 1</code><ul>
<li><code>&amp;1</code>: 1号fd, 不加&amp;会重定向到名称为1的文件</li>
</ul>
</li>
<li><code>&lt;</code>: 重定向 0号fd</li>
<li><code>&gt;</code>: 重定向内容会覆盖掉文件, 默认重定向 1号fd</li>
<li><code>&gt;&gt;</code>: 重定向内容追加到文件末尾, 默认重定向 1号fd</li>
<li><code>2&gt;</code>: 只重定向 2号fd 的内容</li>
<li><code>&amp;&gt;</code>: 重定向 1,2号fd</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt; abc.txt<br><span class="hljs-built_in">cat</span> 文件名<br><br><span class="hljs-comment"># 这里的文件名作为cat参数存在</span><br><span class="hljs-comment"># 类似于C语言中，main(int argc, char** argv)</span><br><span class="hljs-comment"># 当argc等于0，在system.in中读，再system.out打印</span><br><span class="hljs-comment"># 当cat后面加上参数，就读出文件内容，输出在屏幕上</span><br><span class="hljs-comment"># cat &lt; 文件名，这里是重定向</span><br><span class="hljs-comment"># 执行流程完全不一样，仍然是走else分支</span><br></code></pre></td></tr></table></figure>
<h3 id="5-2-管道"><a href="#5-2-管道" class="headerlink" title="5.2 管道"></a>5.2 管道</h3><ul>
<li>一个进程的输出作为另一个进程的输入</li>
<li>存在一个管道文件，这个文件作为输入传递给后面的命令</li>
<li>例:<ul>
<li><code>ls | wc –l</code></li>
<li><code>ls –lF | grep ^d</code></li>
<li><code>ar t /usr/lib/libc.a | grep printf | pr -4 -t</code></li>
</ul>
</li>
</ul>
<h3 id="5-3-环境变量"><a href="#5-3-环境变量" class="headerlink" title="5.3 环境变量"></a>5.3 环境变量</h3><ul>
<li>环境变量<ul>
<li>操作环境的参数</li>
<li>查看和设置环境变量：echo, env, set<ul>
<li>env: 显示所有环境变量</li>
<li>set: 设置环境变量</li>
</ul>
</li>
</ul>
</li>
<li>例: PATH环境变量<ul>
<li><code>echo $PATH</code></li>
<li><code>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/song/bin</code></li>
<li><code>PATH=$PATH:.</code></li>
<li><code>export PATH</code></li>
</ul>
</li>
</ul>
<h3 id="5-4-高级命令与正则表达式"><a href="#5-4-高级命令与正则表达式" class="headerlink" title="5.4 高级命令与正则表达式"></a>5.4 高级命令与正则表达式</h3><ul>
<li>find: 查找磁盘上的文件<ul>
<li>可以使用通配符, 可以通过文件大小查找, 可以使用逻辑表达式</li>
<li>可以对找到的每一个文件执行一个命令</li>
<li><code>find / -name &#39;*.cpp&#39; | xargs grep main -n 2&gt; /dev/null</code></li>
</ul>
</li>
<li>sed: 用于做替换<ul>
<li>可以把文本文件里的一段内容替换为其他内容</li>
<li><code>sed &#39;s/\([0-9A-Za-z_]\&#123;1,\&#125;\)\[ \&#123;0,\&#125;\]\[ \&#123;0,\&#125;\]/*\1\[\]/g&#39; code1.cpp</code><ul>
<li>‘s/…/…/g’</li>
<li>将第一个省略号内容替换为第二个省略号内容</li>
<li>g表示每行全部都匹配, 不加每行最多匹配一次</li>
</ul>
</li>
</ul>
</li>
<li>grep</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/01/31/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-10-HTTP%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/31/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-10-HTTP%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Web前端开发(10) HTTP、性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-31 16:51:19" itemprop="dateCreated datePublished" datetime="2023-01-31T16:51:19+08:00">2023-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="12-HTTP协议"><a href="#12-HTTP协议" class="headerlink" title="12-HTTP协议"></a>12-HTTP协议</h1><h2 id="1-Web-与-HTTP"><a href="#1-Web-与-HTTP" class="headerlink" title="1. Web 与 HTTP"></a>1. Web 与 HTTP</h2><ul>
<li>Web页面由对象组成</li>
<li>对象可以是HTML文件、JPEG图像、音频文件…</li>
<li>Web页面由基本html文件组成, 其中包含几个引用对象</li>
<li>每个对象都可以通过URL寻址</li>
<li>示例URL(统一资源定位器)<ul>
<li><code>www.someschool.edu/someDept/pic.gif</code></li>
</ul>
</li>
</ul>
<h4 id="HTTP-总览"><a href="#HTTP-总览" class="headerlink" title="HTTP 总览"></a>HTTP 总览</h4><ul>
<li>HTTP: 超文本传输协议</li>
<li>Web的应用层协议</li>
<li><p>客户机/服务器模型</p>
<ul>
<li>客户端: 请求、接收、显示Web对象的浏览器</li>
<li>服务器: Web服务器发送对象以响应请求</li>
</ul>
</li>
<li><p>使用 TCP:</p>
<ul>
<li>客户端启动 TCP 连接(创建套接字)到服务器, 端口80</li>
<li>服务器接受来自客户端的 TCP 连接</li>
<li>浏览器(HTTP客户端)和 Web 服务器(HTTP服务器)之间交换 HTTP 消息(应用层协议消息)</li>
<li>TCP连接关闭</li>
</ul>
</li>
</ul>
<blockquote>
<p>HTTP是无状态的</p>
<ul>
<li>服务器不维护关于过去客户端请求的信息</li>
</ul>
<p>维护”状态”的协议非常复杂! </p>
<ul>
<li>必须保留过去的历史(状态)</li>
<li>如果服务器/客户端崩溃, 它们的”状态”视图可能不一致, 必须进行协调</li>
</ul>
</blockquote>
<h4 id="RFC-的定义"><a href="#RFC-的定义" class="headerlink" title="RFC 的定义"></a>RFC 的定义</h4><p>超文本传输协议 (HTTP) 是用于分布式、协作、超媒体信息系统的应用程序级协议。它是一种通用的、无状态的协议, 通过扩展其请求方法、错误代码和标头, 可用于超文本以外的许多任务, 例如名称服务器和分布式对象管理系统。HTTP 的一个特性是数据表示的类型化和协商, 允许独立于传输的数据构建系统</p>
<blockquote>
<p>The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers . A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred.</p>
<p><a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">https://www.w3.org/Protocols/rfc2616/rfc2616.html</a></p>
</blockquote>
<h4 id="HTTP-历史"><a href="#HTTP-历史" class="headerlink" title="HTTP 历史"></a>HTTP 历史</h4><ul>
<li>HTTP Version 0.9</li>
<li>HTTP 1.0: RFC 1945</li>
<li>HTTP 1.1: RFC 2616</li>
<li>HTTPS (HTTP over TLS, HTTP over SSL, HTTP Secure)</li>
<li>2009 Google 设计了基于TCP的SPDY</li>
<li>HTTP/2 (originally named HTTP/2.0)<ul>
<li>Hypertext Transfer Protocol version 2 - RFC7540 /9113</li>
<li>HPACK - Header Compression for HTTP/2 - RFC7541</li>
</ul>
</li>
<li>HTTP/3: RFC9114<ul>
<li>QUIC(Quick UDP Internet Connections, 快速UDP网络连接)</li>
</ul>
</li>
</ul>
<h4 id="HTTP-协议的演进"><a href="#HTTP-协议的演进" class="headerlink" title="HTTP 协议的演进"></a>HTTP 协议的演进</h4><ul>
<li>HTTP over QUIC</li>
<li>UDP</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131205509308.png" alt="image-20230131205509308" style="zoom:80%;" /></p>
<h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><ul>
<li>HTTP/2 是 HTTP 网络协议的一个重要版本。HTTP/2 的主要目标是通过启用完整的请求和响应多路复用来减少延迟, 通过有效压缩 HTTP 标头字段来最小化协议开销, 并增加对请求优先级和服务器推送的支持</li>
<li>HTTP/2 不会修改 HTTP 协议的语义。HTTP 1.1 中的所有核心概念(例如 HTTP 方法, 状态码, URI 和 headers)都得以保留。而是修改了 HTTP/2 数据在客户端和服务器之间的格式(帧)和传输方式, 这两者都管理整个过程, 并在新的框架层内隐藏了应用程序的复杂性。所以, 所有现有的应用程序都可以不经修改地交付</li>
</ul>
<h4 id="请求-响应"><a href="#请求-响应" class="headerlink" title="请求-响应"></a>请求-响应</h4><ul>
<li>HTTP的结构很简单:<ul>
<li>客户端发送请求</li>
<li>服务器返回一个响应</li>
</ul>
</li>
<li>HTTP可以在单个TCP连接上支持多个请求-应答交换</li>
</ul>
<h4 id="HTTP-客户端和服务器端使用-TCP-套接字接口进行通信"><a href="#HTTP-客户端和服务器端使用-TCP-套接字接口进行通信" class="headerlink" title="HTTP 客户端和服务器端使用 TCP 套接字接口进行通信"></a>HTTP 客户端和服务器端使用 TCP 套接字接口进行通信</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131205812002.png" alt="image-20230131205812002" style="zoom:80%;" /></p>
<h4 id="HTTP-事务延迟"><a href="#HTTP-事务延迟" class="headerlink" title="HTTP 事务延迟"></a>HTTP 事务延迟</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131205937674.png" alt="image-20230131205937674" style="zoom:80%;" /></p>
<h4 id="影响HTTP的常见的与tcp相关的延迟"><a href="#影响HTTP的常见的与tcp相关的延迟" class="headerlink" title="影响HTTP的常见的与tcp相关的延迟"></a>影响HTTP的常见的与tcp相关的延迟</h4><ul>
<li>TCP连接建立(三次握手)</li>
<li>TCP慢启动拥塞控制</li>
<li>Nagle的数据聚合算法(预防小分组)</li>
<li>TCP用于承载确认的延迟确认算法</li>
<li>TIME_WAIT延迟和端口耗尽</li>
</ul>
<h2 id="2-HTTP-1-x-的连接管理"><a href="#2-HTTP-1-x-的连接管理" class="headerlink" title="2. HTTP/1.x 的连接管理"></a>2. <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x">HTTP/1.x 的连接管理</a></h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131210040526.png" alt="image-20230131210040526" style="zoom:80%;" /></p>
<h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><ul>
<li>每一个 HTTP 请求都由它自己独立的连接完成; 这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手, 而且是连续不断的</li>
<li>这是 HTTP/1.0 的默认模型 (如果没有指定 Connection 协议头, 或者是值被设置为 close)。而在 HTTP/1.1 中, 只有当 Connection 被设置为 close 时才会用到这个模型</li>
<li>短连接有两个比较大的问题: 创建新连接耗费的时间尤为明显, 另外 TCP 连接的性能只有在该连接被使用一段时间后 (热连接) 才能得到改善</li>
</ul>
<h4 id="长连接-持久连接"><a href="#长连接-持久连接" class="headerlink" title="长连接/持久连接"></a>长连接/持久连接</h4><ul>
<li>一个长连接会保持一段时间, 重复用于发送一系列请求, 节省了新建 TCP 连接握手的时间, 还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着: 连接在空闲一段时间后会被关闭(服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)</li>
<li>长连接也还是有缺点的; 就算是在空闲状态, 它还是会消耗服务器资源, 而且在重负载时, 还有可能遭受 DoS attacks 攻击。这种场景下, 可以使用非长连接, 即尽快关闭那些空闲的连接, 也能对性能有所提升</li>
<li>HTTP/1.0 里默认并不使用长连接。把 Connection 设置成 close 以外的其它参数都可以让其保持长连接, 通常会设置为 retry-after</li>
<li>在 HTTP/1.1 里, 默认就是长连接的, 协议头都不用再去声明它 (但我们还是会把它加上, 万一某个时候因为某种原因要退回到 HTTP/1.0 呢)</li>
</ul>
<h4 id="HTTP-流水线"><a href="#HTTP-流水线" class="headerlink" title="HTTP 流水线"></a>HTTP 流水线</h4><ul>
<li>默认情况下, HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制, 在下一个请求被发送到服务器之前, 可能需要等待很长时间</li>
<li>流水线是在同一条长连接上发出连续的请求, 而不用等待应答返回。这样可以避免连接延迟。理论上讲, 性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。就算 HTTP 请求不断的继续, 尺寸会增加, 但设置 TCP 的 MSS(Maximum Segment Size)选项, 仍然足够包含一系列简单的请求</li>
<li>并不是所有类型的 HTTP 请求都能用到流水线: 只有 idempotent 方式, 比如 GET、HEAD、PUT 和 DELETE 能够被安全的重试: 如果有故障发生时, 流水线的内容要能被轻易的重试</li>
<li>今天, 所有遵循 HTTP/1.1 的代理和服务器都应该支持流水线, 虽然实际情况中还是有很多限制: 一个很重要的原因是, 目前没有现代浏览器默认启用这个特性</li>
</ul>
<h4 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h4><ul>
<li>如果服务器端想要更快速的响应网站或应用程序的应答, 它可以迫使客户端建立更多的连接。例如, 不要在同一个域名下获取所有资源, 假设有个域名是 www.example.com, 我们可以把它拆分成好几个域名: www1.example.com、www2.example.com、www3.example.com。所有这些域名都指向同一台服务器, 浏览器会同时为每个域名建立 6 条连接 (在我们这个例子中, 连接数会达到 18 条)。这一技术被称作域名分片</li>
<li>备注: 除非你有紧急而迫切的需求, 不要使用这一过时的技术, 升级到 HTTP/2 就好了。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131211311309.png" alt="image-20230131211311309" style="zoom:80%;" /></p>
<h4 id="HTTP-事务"><a href="#HTTP-事务" class="headerlink" title="HTTP 事务"></a>HTTP 事务</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131211512396.png" alt="image-20230131211512396" style="zoom:80%;" /></p>
<h2 id="3-HTTP-消息"><a href="#3-HTTP-消息" class="headerlink" title="3. HTTP 消息"></a>3. HTTP 消息</h2><ul>
<li>HTTP 消息是服务器和客户端之间交换数据的方式</li>
<li>HTTP 消息由采用 ASCII 编码的多行文本构成</li>
<li>有两种类型的消息:<ul>
<li>请求(requests) — 由客户端发送用来触发一个服务器上的动作</li>
<li>响应(responses) — 来自服务器的应答</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131211618355.png" alt="image-20230131211618355" style="zoom:80%;" /></p>
<h4 id="消息组成"><a href="#消息组成" class="headerlink" title="消息组成"></a>消息组成</h4><ul>
<li>HTTP 请求和响应具有相似的结构, 由以下部分组成︰<ul>
<li>一行起始行用于描述要执行的请求, 或者是对应的状态, 成功或失败。这个起始行总是单行的</li>
<li>一个可选的 HTTP 头集合指明请求或描述消息正文</li>
<li>一个空行指示所有关于请求的元数据已经发送完毕</li>
<li>一个可选的包含请求相关数据的正文 (比如 HTML 表单内容), 或者响应相关的文档。正文的大小有起始行的 HTTP 头来指定</li>
</ul>
</li>
<li>起始行和 HTTP 消息中的 HTTP 头统称为请求头, 而其有效负载被称为消息正文</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131211840418.png" alt="image-20230131211840418" style="zoom:80%;" /></p>
<h4 id="HTTP-请求消息"><a href="#HTTP-请求消息" class="headerlink" title="HTTP 请求消息"></a>HTTP 请求消息</h4><p>HTTP请求消息:</p>
<ul>
<li>ASCII</li>
<li>行以CRLF”\r\n”结尾</li>
<li>第一行叫做”请求行”</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131212054367.png" alt="image-20230131212054367" style="zoom:80%;" /></p>
<h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><ul>
<li>GET: 从服务器获取URL对应的资源</li>
<li>HEAD: 除了服务器响应中不能包含消息体, 该方法与GET一样。用于只需少数元信息的情况</li>
<li>POST: 被设计用来注解、修改URL所对应的资源</li>
<li>PUT: 被设计用来修改或创建资源。当URL对应的资源存在时, 则提交的作为新版本, 否则新建资源</li>
<li>DELETE: 被设计用来删除 URL 对应的资源</li>
<li>TRACE: 主要用来测试。服务器将最终接收到的请求本身发送回来, 作为客户端诊断依据</li>
<li>OPTIONS: 客户端查询服务器对与某 URL 允许的通信选项</li>
<li>CONNECT: 保留的方法名, 用于代理切换隧道</li>
<li>支持扩展</li>
</ul>
<h4 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h4><p>GET</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131212557826.png" alt="image-20230131212557826" style="zoom:80%;" /></p>
<p>POST</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131212729403.png" alt="image-20230131212729403" style="zoom:80%;" /></p>
<h4 id="头域"><a href="#头域" class="headerlink" title="头域"></a>头域</h4><ul>
<li>由主键/值对组成, 描述客户端或者服务器的属性、被传输的资源以及应该实现连接</li>
<li><p>四种不同类型的头标: </p>
<ul>
<li>通用头标: 即可用于请求, 也可用于响应, 是作为一个整体而不是特定资源与事务相关联</li>
<li>请求头标: 允许客户端传递关于自身的信息和希望的响应形式</li>
<li>响应头标: 服务器和于传递自身信息的响应</li>
<li>实体头标: 定义被传送资源的信息。即可用于请求, 也可用于响应</li>
</ul>
</li>
<li><p>实例</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Accept: text/html<br>Host: www.nju.edu.cn<br>From: abc@nju.edu.cn<br>User-Agent: Mozilla/4.0<br>Referer: http://test.com/abc<br></code></pre></td></tr></table></figure>
<h4 id="HTTP-响应消息"><a href="#HTTP-响应消息" class="headerlink" title="HTTP 响应消息"></a>HTTP 响应消息</h4><ul>
<li><p>ASCII 状态行</p>
<ul>
<li><p>HTTP-Version Status-Code Reason-Phrase</p>
<p>http协议版本、状态码(三位数字)、状态描述</p>
</li>
</ul>
</li>
<li><p>头域</p>
</li>
<li><p>内容</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131213125614.png" alt="image-20230131213125614" style="zoom:80%;" /></p>
<h2 id="4-状态码"><a href="#4-状态码" class="headerlink" title="4. 状态码"></a>4. <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">状态码</a></h2><blockquote>
<p>请点击标题阅读文档</p>
</blockquote>
<p>HTTP 响应状态码用来表明特定 HTTP 请求是否成功完成。响应被归为以下五大类: </p>
<ul>
<li>信息响应 (100–199)</li>
<li>成功响应 (200–299)</li>
<li>重定向消息 (300–399)</li>
<li>客户端错误响应 (400–499)</li>
<li>服务端错误响应 (500–599)</li>
</ul>
<p>常用状态码</p>
<ul>
<li>200 OK</li>
<li>301 Moved Permanently</li>
<li>400 Bad Request</li>
<li>401 Unauthorized</li>
<li>403 forbidden</li>
<li>404 Not Found</li>
<li>500 Internal Server Error</li>
</ul>
<h4 id="301-永久重定向"><a href="#301-永久重定向" class="headerlink" title="301 - 永久重定向"></a>301 - 永久重定向</h4><p>什么情况下使用 301 重定向</p>
<ul>
<li>迁移到另外一个域名时, 通过 301 永久重定向将旧域名重定向至新域名, 挽回流量损失和SEO</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Redirections#%E4%BF%9D%E6%8C%81%E9%93%BE%E6%8E%A5%E6%9C%89%E6%95%88">保持链接有效</a><ul>
<li>当重构 Web 站点的时候, 资源的 URL 会发生改变。你并不想因此而使旧链接失效, 因为它们会带来宝贵的用户(并且帮助优化你的 SEO), 所以需要建立从旧链接到新链接的重定向映射</li>
</ul>
</li>
<li>如果有多个闲置域名需要指向同一网站时, 通过 301 永久重定向可以实现</li>
<li>打算实现网址规范化</li>
<li>强制使用 HTTPS 协议。对于 HTTP 版本站点的请求会被重定向至采用了 HTTPS 协议的版本</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131214331499.png" alt="image-20230131214331499" style="zoom:80%;" /></p>
<h4 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h4><ul>
<li>有时候请求的资源无法从其标准地址访问, 但是却可以从另外的地方访问。在这种情况下可以使用临时重定向</li>
<li>搜索引擎不会记录该新的、临时的链接。在创建、更新或者删除资源的时候, 临时重定向也可以用于显示临时性的进度页面</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>编码</th>
<th>含义</th>
<th>处理方法</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>302</td>
<td>Found</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 方法不会发生变更, 其他方法有可能会变更为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 方法</td>
<td>由于不可预见的原因该页面暂不可用。在这种情况下, 搜索引擎不会更新它们的链接</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 方法不会发生变更, 其他方法会<strong>变更</strong>为 GET 方法(消息主体会丢失)</td>
<td>用于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT"><code>PUT</code></a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 请求完成之后进行页面跳转来防止由于页面刷新导致的操作的重复触发</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>方法和消息主体都不发生变化</td>
<td>由于不可预见的原因该页面暂不可用。在这种情况下, 搜索引擎不会更新它们的链接。当站点支持非 GET 方法的链接或操作的时候, 该状态码优于 302 状态码</td>
</tr>
</tbody>
</table>
</div>
<h4 id="特殊重定向"><a href="#特殊重定向" class="headerlink" title="特殊重定向"></a>特殊重定向</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131214759453.png" alt="image-20230131214759453" style="zoom:80%;" /></p>
<h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><ul>
<li>请求/响应的最后一部分是它的 body<ul>
<li>不是所有的请求都有一个 body: 例如获取资源的请求, GET, HEAD, DELETE 和 OPTIONS, 通常它们不需要 body。有些请求将数据发送到服务器以便更新数据: 常见的的情况是 POST 请求(包含 HTML 表单数据)</li>
<li>不是所有的响应都有 body: 具有状态码 (如 201 或 204) 的响应, 通常不会有 body</li>
</ul>
</li>
<li>任何信息</li>
<li>需要Content-Length、Content-Type</li>
</ul>
<h4 id="HTTP-1-x-报文缺点"><a href="#HTTP-1-x-报文缺点" class="headerlink" title="HTTP/1.x 报文缺点"></a>HTTP/1.x 报文缺点</h4><ul>
<li>Header 不像 body, 它不会被压缩</li>
<li>两个报文之间的 header 通常非常相似, 但它们仍然在连接中重复传输</li>
<li>无法复用。当在同一个服务器打开几个连接时: TCP 热连接比冷连接更加有效</li>
</ul>
<h2 id="5-HTTP-2-为了更优异的表现"><a href="#5-HTTP-2-为了更优异的表现" class="headerlink" title="5. HTTP/2 - 为了更优异的表现"></a>5. <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">HTTP/2</a> - 为了更优异的表现</h2><ul>
<li>在 2010 年到 2015 年, 谷歌通过实践了一个实验性的 SPDY 协议, 证明了一个在客户端和服务器端交换数据的另类方式。其收集了浏览器和服务器端的开发者的焦点问题。明确了响应数量的增加和解决复杂的数据传输, SPDY 成为了 HTTP/2 协议的基础</li>
<li>HTTP/2 在 HTTP/1.1 有几处基本的不同: <ul>
<li>HTTP/2 是二进制协议而不是文本协议。不再可读, 也不可无障碍的手动创建, 改善的优化技术现在可被实施</li>
<li>这是一个复用协议。并行的请求能在同一个链接中处理, 移除了 HTTP/1.x 中顺序和阻塞的约束</li>
<li>压缩了 headers。因为 headers 在一系列请求中常常是相似的, 其移除了重复和传输重复数据的成本</li>
<li>其允许服务器在客户端缓存中填充数据, 通过一个叫服务器推送的机制来提前请求</li>
</ul>
</li>
</ul>
<h4 id="流、消息、帧"><a href="#流、消息、帧" class="headerlink" title="流、消息、帧"></a>流、消息、帧</h4><ul>
<li>流(Stream): 是在 HTTP/2 连接中在客户端和服务器之间交换的独立双向帧序列。流是连接中的一个虚拟信道, 可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流 ID 冲突, 客户端发起的流具有奇数ID, 服务器端发起的流具有偶数ID。能携带一个至多个消息</li>
<li>消息(Message): 一个完整的请求或者响应, 由一个或多个帧组成</li>
<li>帧(Frame): 在 HTTP/2 通信的最小单元。每个桢包括一个帧头, 里面有个很小标志, 来区别是属于哪个流</li>
</ul>
<h4 id="流的重要特征"><a href="#流的重要特征" class="headerlink" title="流的重要特征"></a>流的重要特征</h4><ul>
<li>一个HTTP/2连接可以包含多个同时打开的流, 并且可以从多个流中交叉帧</li>
<li>流可以单独建立和使用, 也可以由客户端或服务器共享</li>
<li>流可以由任一端点关闭</li>
<li>帧在流上发送的顺序非常重要。收件人按收到的顺序处理框架。特别是, HEADERS 和 DATA 帧的顺序在语义上很重要</li>
<li>流用无符号的 31 位整数标识。流标识符由启动流的端点分配给流。客户端发起的流必须使用奇数流标识符; 那些由服务器发起的必须使用偶数流标识符</li>
</ul>
<h4 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h4><div class="table-container">
<table>
<thead>
<tr>
<th>协议</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP/1.x</td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201112704210.png" alt="image-20230201112704210" style="zoom:80%;" /></td>
</tr>
<tr>
<td>HTTP/2 帧结构</td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201112713749.png" alt="image-20230201112713749" style="zoom:80%;" /></td>
</tr>
</tbody>
</table>
</div>
<h4 id="二进制帧层"><a href="#二进制帧层" class="headerlink" title="二进制帧层"></a>二进制帧层</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201112801708.png" alt="image-20230201112801708" style="zoom:80%;" /></p>
<p>流:</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201112923283.png" alt="image-20230201112923283" style="zoom:80%;" /></p>
<h4 id="请求和响应多路复用"><a href="#请求和响应多路复用" class="headerlink" title="请求和响应多路复用"></a>请求和响应多路复用</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201113240975.png" alt="image-20230201113240975" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201113306270.png" alt="image-20230201113306270" style="zoom:80%;" /></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul>
<li>流量控制特定于连接。两种类型的流量控制都位于单跳的端点之间, 而不是整个端到端路径</li>
<li>流量控制基于 WINDOW_UPDATE 帧。接收者宣告他们准备在一个流上以及整个连接上接收多少个字节</li>
<li>流量控制是由接收器提供的全面控制方向。接收者可以选择为每个流和整个连接设置它想要的任何窗口大小。发送方必须遵守接收方施加的流量控制限制。客户端, 服务器和中介都独立地将其流量控制窗口作为接收者进行通告, 并遵守发送时由对等方设置的流量控制限制</li>
<li>对于新流和整个连接, 流量控制窗口的初始值为 65,535 个八比特组</li>
<li>帧类型决定流量控制是否适用于帧。在本文档中指定的帧中, 只有数据帧受流量控制; 所有其他帧类型不会占用通告的流量控制窗口中的空间。这确保了重要的控制框架不会被流量控制阻塞</li>
<li>流量控制不能禁用</li>
<li>HTTP/2 仅定义 WINDOW_UPDATE 帧的格式和语义</li>
</ul>
<h4 id="优先级和依赖性"><a href="#优先级和依赖性" class="headerlink" title="优先级和依赖性"></a>优先级和依赖性</h4><ul>
<li>每个流都包含一个优先级(也就是”权重”), 它被用来告诉对端哪个流更重要。当资源有限的时候, 服务器会根据优先级来选择应该先发送哪些流</li>
<li>客户端可以通过在打开流的 HEADERS 帧中包含优先级信息来为新流分配优先级。在其他任何时候, PRIORITY 帧都可以用来改变流的优先级</li>
<li>每个流可以被赋予对另一个流的显式依赖。包括依赖关系表示优先将资源分配给识别的流而不是依赖流。借助于 PRIORITY 帧, 客户端同样可以告知服务器当前的流依赖于其他哪个流。该功能让客户端能建立一个优先级”树”, 所有”子流”会依赖于”父流”的传输完成情况</li>
<li>优先级和依赖关系可以在传输过程中被动态的改变。这样当用户滚动一个全是图片的页面的时候, 浏览器就能够指定哪个图片拥有更高的优先级。或者是在你切换标签页的时候, 浏览器可以提升新切换到页面所包含流的优先级</li>
</ul>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><ul>
<li>这个功能通常被称作”缓存推送”。主要的思想是: 当一个客户端请求资源 X, 而服务器知道它很可能也需要资源 Z 的情况下, 服务器可以在客户端发送请求前, 主动将资源 Z 推送给客户端。这个功能帮助客户端将 Z 放进缓存以备将来之需</li>
<li>服务器推送需要客户端显式的允许服务器提供该功能。但即使如此, 客户端依然能自主选择是否需要中断该推送的流。如果不需要的话, 客户端可以通过发送一个 RST_STREAM 帧来中止</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201113851686.png" alt="image-20230201113851686" style="zoom:80%;" /></p>
<h4 id="头压缩"><a href="#头压缩" class="headerlink" title="头压缩"></a>头压缩</h4><ul>
<li>http/1.x 的头带有大量信息, 而且每次都要重复发送。http/2 使用 encoder 来减少需要传输的 header 大小, 通讯双方各自缓存一份头部字段表, 既避免了重复 header 的传输, ⼜减小了需要传输的大小</li>
<li>对于相同的数据, 不再通过每次请求和响应发送, 通信期间几乎不会改变通用键值对(用户代理、可接受的媒体类型, 等等), 只需发送一次</li>
<li>事实上,如果请求中不包含首部(例如对同一资源的轮询请求), 那么, 首部开销就是零字节, 此时所有首部都自动使用之前请求发送的首部</li>
<li>如果首部发生了变化, 则<strong>只需将变化的部分加入到 header 帧中, 改变的部分会加入到头部字段表中</strong>, 首部表在 http/2.0 的连接存续期内始终存在, 由客户端和服务器共同渐进地更新</li>
<li>需要注意的是, http/2.0关注的是首部压缩, 而我们常用的 gzip 等是报文内容(body)的压缩, 二者不仅不冲突, 且能够一起达到更好的压缩效果</li>
<li>http/2 使用的是专门为首部压缩而设计的 HPACK 算法</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201114416399.png" alt="image-20230201114416399" style="zoom:80%;" /></p>
<h4 id="协商示例"><a href="#协商示例" class="headerlink" title="协商示例"></a>协商示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET /page HTTP/1.1<br>Host: server.example.com<br>Connection: Upgrade, HTTP2-Settings<br>Upgrade: HTTP/2.0  // 协商升级协议到 2.0<br>HTTP2-Settings: (SETTINGS payload)<br><br>HTTP/1.1 200 OK<br>Content-length: 243<br>Content-type: text/html<br>(... HTTP 1.1 response ...)<br><br>(or)<br><br>HTTP/1.1 101 Switching Protocols<br>Connection: Upgrade<br>Upgrade: HTTP/2.0<br>(... HTTP 2.0 response ...)<br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 服务端启动 http2</span><br><span class="hljs-keyword">const</span> http2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http2&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> server = http2.<span class="hljs-title function_">createSecureServer</span>(&#123;<br> 	<span class="hljs-attr">key</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;localhost-privkey.pem&#x27;</span>),<br> 	<span class="hljs-attr">cert</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;localhost-cert.pem&#x27;</span>)<br>&#125;);<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err));<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;stream&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stream, headers</span>) =&gt;</span> &#123;<br> 	<span class="hljs-comment">// stream is a Duplex</span><br> 	stream.<span class="hljs-title function_">respond</span>(&#123;<br> 		<span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span>,<br> 		<span class="hljs-string">&#x27;:status&#x27;</span>: <span class="hljs-number">200</span><br> 	&#125;);<br> 	stream.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);<br>&#125;);<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8443</span>);<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/api/http2.html#http2_server_side_example">https://nodejs.org/api/http2.html#http2_server_side_example</a></p>
</blockquote>
<h2 id="6-为何需要-HTTP-3"><a href="#6-为何需要-HTTP-3" class="headerlink" title="6. 为何需要 HTTP/3"></a>6. 为何需要 HTTP/3</h2><ul>
<li><a target="_blank" rel="noopener" href="https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/">TCP 队头阻塞问题</a></li>
<li>TCP握手时长</li>
<li>移动场景的网络切换成本<ul>
<li>IP地址会发生变化, 而TCP协议是根据四元组来确定一个连接的, 需要重新建立连接</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201114832016.png" alt="image-20230201114832016" style="zoom:80%;" /></p>
<h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><ul>
<li>HTTP/3 基于 UDP 协议重新定义了连接, 在 QUIC 层实现了无序、并发字节流的传输, 解决了队头阻塞问题(包括基于 QPACK 解决了动态表的队头阻塞)</li>
<li>HTTP/3 重新定义了 TLS 协议加密 QUIC 头部的方式, 既提高了网络攻击成本, ⼜降低了建立连接的速度(仅需 1 个 RTT 就可以同时完成建链与密钥协商)</li>
<li>HTTP/3 将 Packet、QUIC Frame、HTTP3 Frame 分离, 实现了连接迁移功能, 降低了 5G 环境下高速移动设备的连接维护成本</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201115255145.png" alt="image-20230201115255145" style="zoom:80%;" /></p>
<h1 id="13-前端性能优化"><a href="#13-前端性能优化" class="headerlink" title="13-前端性能优化"></a>13-前端性能优化</h1><h2 id="1-前端性能"><a href="#1-前端性能" class="headerlink" title="1. 前端性能"></a>1. 前端性能</h2><h4 id="为什么网站性能很重要"><a href="#为什么网站性能很重要" class="headerlink" title="为什么网站性能很重要?"></a>为什么网站性能很重要?</h4><ul>
<li>40% 在等待页面加载 3 秒后放弃网站</li>
<li>80% 的人不会再回来</li>
<li>几乎一半的人会告诉别人他们的负面经历</li>
<li>亚马逊: 每提高 100MS, 收入增加 1%</li>
</ul>
<h4 id="网站速度与SEO"><a href="#网站速度与SEO" class="headerlink" title="网站速度与SEO"></a>网站速度与SEO</h4><p>网站速度对你的SEO工作很重要, 因为更快的网站是:</p>
<ul>
<li>更容易爬取</li>
<li>更容易访问</li>
<li>更有利于排名(尽管这是边际的)</li>
<li>最重要的是, 更有可能留住访客!</li>
</ul>
<h2 id="2-Web-性能优化-web-performance-optimization-WPO"><a href="#2-Web-性能优化-web-performance-optimization-WPO" class="headerlink" title="2. Web 性能优化 web performance optimization (WPO)"></a>2. Web 性能优化 web performance optimization (WPO)</h2><ul>
<li>网站越快, 用户的黏性越高; 参与度</li>
<li>网站越快, 用户忠诚度更高; 留存率</li>
<li>网站越快, 用户转化率越高</li>
</ul>
<h4 id="延迟与带宽"><a href="#延迟与带宽" class="headerlink" title="延迟与带宽"></a>延迟与带宽</h4><p>延迟: 分组从信息源发送到目的地所需的时间</p>
<p>带宽: 逻辑或物理通信路径最大的吞吐量</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201154810793.png" alt="image-20230201154810793" style="zoom:80%;" /></p>
<h4 id="延迟的构成要素"><a href="#延迟的构成要素" class="headerlink" title="延迟的构成要素"></a>延迟的构成要素</h4><ul>
<li>传播延迟: 消息从发送端到接收端需要的时间, 是信号传播距离和速度的函数</li>
<li>传输延迟: 把消息中的所有比特转移到链路中需要的时间, 是消息长度和链路速率的函数</li>
<li>处理延迟: 处理分组首部、检查位错误及确定分组目标所需的时间</li>
<li>排队延迟: 到来的分组排队等待处理的时间</li>
</ul>
<h4 id="Web性能要点"><a href="#Web性能要点" class="headerlink" title="Web性能要点"></a>Web性能要点</h4><ul>
<li>延迟和带宽对Web性能的影响</li>
<li>传输协议(TCP)对HTTP的限制</li>
<li>HTTP协议自身的功能和缺陷</li>
<li>Web应用的发展趋势及性能需求</li>
<li>浏览器局限性和优化思路</li>
<li>不同层之间总是相互依赖, 但优化方式却有很多可能性。任何优化建议和最佳做法都不是一成不变的, 涉及的每个要素都是动态发展的:<ul>
<li>浏览器越来越快</li>
<li>用户上网条件不断改善</li>
<li>Web应用的功能和复杂度也与日俱增</li>
</ul>
</li>
</ul>
<h2 id="3-浏览器页面渲染机制"><a href="#3-浏览器页面渲染机制" class="headerlink" title="3. 浏览器页面渲染机制"></a>3. 浏览器页面渲染机制</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work">https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.logrocket.com/how-browser-rendering-works-behind-the-scenes-6782b0e8fb10">https://blog.logrocket.com/how-browser-rendering-works-behind-the-scenes-6782b0e8fb10</a></p>
<h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#dns_查询">DNS 查询</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#tcp_握手">TCP 握手</a><ul>
<li>一旦获取到服务器 IP 地址, 浏览器就会通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/TCP_handshake">TCP”三次握手” (en-US)</a>与服务器建立连接。TCP 的”三次握手”技术经常被称为”SYN-SYN-ACK”</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#tls_协商">TLS 协商</a><ul>
<li>为了在 HTTPS 上建立安全连接, 另一种握手是必须的。更确切的说是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/TLS">TLS</a> 协商, 它决定了什么密码将会被用来加密通信, 验证服务器, 在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201155559322.png" alt="image-20230201155559322"></p>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ul>
<li>初始请求的响应包含所接收数据的第一个字节。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/time_to_first_byte">Time to First Byte</a>(TTFB)是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间</li>
<li>初始页面加载的 14KB 规则, 第一个内容分块通常是 14KB 的数据</li>
<li>TCP 慢启动 / 14KB 规则<ul>
<li>第一个响应数据包是 14KB 大小的。这是慢启动的一部分, 慢启动是一种均衡网络连接速度的算法。慢启动逐渐增加发送数据的数量直到达到网络的最大带宽</li>
<li>在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/TCP_slow_start">TCP 慢启动</a> 中, 在收到初始包之后, 服务器会将下一个数据包的大小加倍到大约 28KB。后续的数据包依次是前一个包大小的二倍直到达到预定的阈值, 或者遇到拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201160017470.png" alt="image-20230201160017470" style="zoom:80%;" /></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>一旦浏览器收到数据的第一块, 它就可以开始解析收到的信息。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Parse">“解析”</a>是浏览器将通过网络接收的数据转换为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/DOM">DOM</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSSOM">CSSOM</a> 的步骤, 通过渲染器把 DOM 和 CSSOM 在屏幕上绘制成页面。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201160548507.png" alt="image-20230201160548507" style="zoom:80%;" /></p>
<h4 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#构建_dom_树">构建 DOM 树</a></h4><ul>
<li><p>第一步是处理 HTML 标记并构造 DOM 树。HTML 解析涉及到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMTokenList">tokenization</a> 和树的构造</p>
</li>
<li><p>当解析器发现非阻塞资源, 例如一张图片, 浏览器会请求这些资源并且继续解析。当遇到一个 CSS 文件时, 解析也可以继续进行, 但是对于 <code>&lt;script&gt;</code> 标签(特别是没有 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code></a> 或者 <code>defer</code> 属性的)会阻塞渲染并停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程, 但过多的脚本仍然是一个重要的瓶颈</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201160935986.png" alt="image-20230201160935986" style="zoom:80%;" /></p>
<h4 id="预加载扫描器"><a href="#预加载扫描器" class="headerlink" title="预加载扫描器"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#预加载扫描器">预加载扫描器</a></h4><ul>
<li>浏览器构建 DOM 树时, 这个过程占用了主线程。当这种情况发生时, 预加载扫描仪将解析可用的内容并请求高优先级资源, 如 CSS、JavaScript 和 web 字体。多亏了预加载扫描器, 我们不必等到解析器找到对外部资源的引用来请求它。它将在后台检索资源, 以便在主 HTML 解析器到达请求的资源时, 它们可能已经在运行, 或者已经被下载。预加载扫描仪提供的优化减少了阻塞。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;styles.css&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;myscript.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;myimage.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;image description&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;anotherscript.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="构建-CSSOM-树"><a href="#构建-CSSOM-树" class="headerlink" title="构建 CSSOM 树"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#构建_cssom_树">构建 CSSOM 树</a></h4><ul>
<li><p>CSS 对象模型, 简称为 CSSOM</p>
</li>
<li><p>第二步是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM 是两棵树。它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集, 根据 CSS 选择器创建具有父、子和兄弟关系的节点树</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201162043473.png" alt="image-20230201162043473" style="zoom:80%;" /></p>
<h4 id="其他过程"><a href="#其他过程" class="headerlink" title="其他过程"></a>其他过程</h4><p><strong>JavaScript 编译</strong></p>
<ul>
<li>当 CSS 被解析并创建 CSSOM 时, 其他资源, 包括 JavaScript 文件正在下载(借助预加载扫描器)。JavaScript 被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/抽象语法树">抽象语法树</a>并将其传递到解释器中, 输出在主线程上执行的字节码。这就是所谓的 JavaScript 编译。</li>
</ul>
<p><strong>构建辅助功能树</strong></p>
<ul>
<li><p>浏览器还构建辅助设备用于分析和解释内容的辅助功能(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility">accessibility</a>)树。无障碍对象模型(AOM)类似于 DOM 的语义版本。当 DOM 更新时, 浏览器会更新辅助功能树。辅助技术本身无法修改无障碍树。</p>
</li>
<li><p>在构建 AOM 之前, 屏幕阅读器(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Screen_Reader_Implementors_Guide">screen readers (en-US)</a>)无法访问内容。</p>
</li>
</ul>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><ul>
<li>渲染步骤包括样式、布局、绘制, 在某些情况下还包括合成。在解析步骤中创建的 CSSOM 树和 DOM 树组合成一个 Render 树, 然后用于计算每个可见元素的布局, 然后将其绘制到屏幕上。在某些情况下, 可以将内容提升到它们自己的层并进行合成, 通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高性能, 从而释放主线程</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201162428370.png" alt="image-20230201162428370" style="zoom:80%;" /></p>
<h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#style">Style</a></h4><ul>
<li><p>第三步是将 DOM 和 CSSOM 组合成一个 Render 树, 计算样式树或渲染树从 DOM 树的根开始构建, 遍历每个可见节点。</p>
</li>
<li><p>像 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head"><code>&lt;head&gt;</code></a> 和它的子节点以及任何具有 <code>display: none</code> 样式的结点, 例如 <code>script &#123; display: none; &#125;</code>(在 user agent stylesheets 可以看到这个样式)这些标签将不会显示, 也就是它们不会出现在 Render 树上。具有 <code>visibility: hidden</code> 的节点会出现在 Render 树上, 因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理的默认值, 因此上面代码示例中的 <code>script</code> 节点将不会包含在 Render 树中。</p>
</li>
<li><p>每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点, 并根据 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade">CSS 级联</a> 确定每个节点的计算样式。</p>
</li>
</ul>
<h4 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局(Layout)"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#layout">布局(Layout)</a></h4><ul>
<li><p>第四步是在渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置, 以及确定页面上每个对象的大小和位置的过程。回流 (reflow) 是对页面的任何部分或整个文档的任何后续大小和位置的确定</p>
<ul>
<li>第一次确定节点的大小和位置称为布局</li>
<li>随后对节点大小和位置的重新计算称为回流</li>
</ul>
</li>
<li><p>构建渲染树后, 开始布局。渲染树标识显示哪些节点(即使不可见)及其计算样式, 但不标识每个节点的尺寸或位置。为了确定每个对象的确切大小和位置, 浏览器从渲染树的根开始遍历它</p>
</li>
</ul>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#绘制">绘制</a></h4><ul>
<li><p>最后一步是将各个节点绘制到屏幕上, 第一次出现的节点称为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/First_meaningful_paint">first meaningful paint (en-US)</a>。在绘制或光栅化阶段, 浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素</p>
</li>
<li><p>为了确保平滑滚动和动画, 占据主线程的所有内容, 包括计算样式, 以及回流和绘制, 必须让浏览器在 16.67 毫秒内完成</p>
</li>
<li><p>为了确保重绘的速度比初始绘制的速度更快, 屏幕上的绘图通常被分解成数层。如果发生这种情况, 则需要进行合成</p>
</li>
<li><p>绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层(而不是 CPU 上的主线程)可以提高绘制和重新绘制性能</p>
</li>
<li><p>分层确实可以提高性能, 但是它以内存管理为代价, 因此不应作为 web 性能优化策略的一部分过度使用</p>
</li>
<li>当文档的各个部分以不同的层绘制, 相互重叠时, 必须进行合成, 以确保它们以正确的顺序绘制到屏幕上, 并正确显示内容</li>
</ul>
<h4 id="交互"><a href="#交互" class="headerlink" title="交互"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#交互">交互</a></h4><ul>
<li><p>一旦主线程绘制页面完成, 你会认为我们已经”准备好了”, 但事实并非如此。如果加载包含 JavaScript(并且延迟到 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/load_event"><code>onload</code></a> 事件激发后执行), 则主线程可能很忙, 无法用于滚动、触摸和其他交互</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Time_to_interactive">Time to Interactive (en-US)</a>(TTI)是测量从第一个请求导致 DNS 查询和 SSL 连接到页面可交互时所用的时间——可交互是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_paint">First Contentful Paint (en-US)</a> 之后的时间点, 页面在 50ms 内响应用户的交互。如果主线程正在解析、编译和执行 JavaScript, 则它不可用, 因此无法及时(小于 50ms)响应用户交互</p>
</li>
<li><p>每当浏览器遇到脚本标签时, DOM 构造就会暂停！整个 DOM 构建过程都将停止, 直到脚本执行完成</p>
<ul>
<li>JavaScript 可以同时修改 DOM 和 CSSOM</li>
</ul>
</li>
<li>在默认情况下, 每个脚本都是一个解析器阻断器<ul>
<li>例外, async</li>
</ul>
</li>
</ul>
<h4 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h4><ul>
<li>周密的关键渲染路径(CRP)优化策略使浏览器能够通过确定优先加载的资源以及资源加载的顺序来尽可能快地加载页面</li>
<li>优化 CRP<ul>
<li>提升页面加载速度需要通过被加载资源的优先级、控制它们加载的顺序和减小这些资源的体积。</li>
<li>性能提示包含<ul>
<li>通过异步、延迟加载或者消除非关键资源来减少关键资源的请求数量</li>
<li>优化必须的请求数量和每个请求的文件体积</li>
<li>通过区分关键资源的优先级来优化被加载关键资源的顺序, 来缩短关键路径长度</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201163719221.png" alt="image-20230201163719221" style="zoom:80%;" /></p>
<h2 id="4-现代Web应用程序剖析"><a href="#4-现代Web应用程序剖析" class="headerlink" title="4. 现代Web应用程序剖析"></a>4. 现代Web应用程序剖析</h2><p><a target="_blank" rel="noopener" href="https://httparchive.org/reports/page-weight#bytesTotal">https://httparchive.org/reports/page-weight#bytesTotal</a></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201164108418.png" alt="image-20230201164108418" style="zoom:80%;" /></p>
<h4 id="性能要素-计算、渲染、网络"><a href="#性能要素-计算、渲染、网络" class="headerlink" title="性能要素:计算、渲染、网络"></a>性能要素:计算、渲染、网络</h4><p>web程序的执行主要包括三个任务: 获取资源, 页面布局和渲染, 以及 JavaScript执行</p>
<ul>
<li>更多带宽并不重要</li>
<li>延迟是性能瓶颈</li>
</ul>
<h4 id="Benchmark工具"><a href="#Benchmark工具" class="headerlink" title="Benchmark工具"></a>Benchmark工具</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201164817954.png" alt="image-20230201164817954"></p>
<h4 id="影响基准数据的因素"><a href="#影响基准数据的因素" class="headerlink" title="影响基准数据的因素"></a>影响基准数据的因素</h4><ul>
<li>地理位置、网络问题、响应大小、代码处理、浏览器的行为、Web服务器配置</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>人造测试不能发现所有性能瓶颈</p>
<ul>
<li>场景及页面选择: 很难重复真实用户的导航模式</li>
<li>浏览器缓存: 用户缓存不同, 性能差别很大</li>
<li>中介设施: 中间代理和缓存对性能影响很大</li>
<li>硬件多样化: 不同的 CPU、GPU 和内存比比皆是</li>
<li>浏览器多样化: 各种浏览器版本, 有新有旧</li>
<li>上网方式: 真实连接的带宽和延迟可能不断变化</li>
</ul>
<h4 id="性能监控指标"><a href="#性能监控指标" class="headerlink" title="性能监控指标"></a>性能监控指标</h4><ul>
<li>FP(全称”First Paint”, “首次绘制”): 对于应用页面, 首次出现视觉上不同于跳转之前内容的时间点, 或者说是页面发生第一次绘制的时间点</li>
<li>FCP(全称”First Contentful Paint”, “首次内容绘制”): 指浏览器完成渲染 DOM 中第一部分内容(可能是文本、图像或其他任何元素)的时间点, 此时用户应该在视觉上有直观的感受<ul>
<li>注意: 只有首次绘制文本、图片(包含背景图)、非白色的 canvas 或 SVG 时才被算作 FCP</li>
</ul>
</li>
<li>FP 与 FCP 这两个指标之间的主要区别是: <ul>
<li>FP 是当浏览器开始绘制内容到屏幕上的时候, 只要在视觉上开始发生变化, 无论是什么内容触发的视觉变化, 在这一刻, 这个时间点, 叫做 FP</li>
<li>相比之下, FCP 指的是浏览器首次绘制来自 DOM 的内容。例如: 文本, 图片, SVG, canvas 元素等, 这个时间点叫 FCP</li>
<li>FP 和 FCP 可能是相同的时间, 也可能是先 FP 后 FCP</li>
</ul>
</li>
<li><p>FMP(全称”First Meaningful Paint”, 翻译为”首次有意义绘制”): 指页面关键元素的渲染时间</p>
<ul>
<li>没有标准化定义, 因为关键元素可以由开发者自行定义</li>
<li>FMP 本质上是通过一个算法来猜测某个时间点可能是 FMP, 所以有时候不准。</li>
</ul>
</li>
<li><p>首屏时间: 进入页面之后, 应用渲染完成整个⼿机屏幕(未滚动之前)内容的时间</p>
<ul>
<li>业界对于这个指标没有确切定论, 比如是否包含屏幕内图片的渲染完成时间</li>
</ul>
</li>
<li>用户可交互时间: 用户可以与应用进行交互的时间<ul>
<li>一般来说, 是 DOMReady 的时间, 因为通常会在这时绑定事件操作</li>
<li>如果页面中涉及交互的脚本没有下载完成, 那么当然没有到达所谓的用户可交互时间</li>
</ul>
</li>
<li>总下载时间: 页面所有资源加载完成所需要的时间<ul>
<li>一般可以统计 window.onload 时间, 这样可以统计出同步加载的资源全部加载完的耗时</li>
<li>如果页面中存在较多的异步渲染, 那么可以将异步渲染全部完成的时间做为总下载时间</li>
</ul>
</li>
<li>自定义指标: 由于应用特点不同, 可以根据需求自定义时间<ul>
<li>比如, 一个类似 Instagram 的页面由图片瀑布流组成, 那么可能非常关心屏幕中第一排图片渲染完成的时间</li>
</ul>
</li>
</ul>
<h4 id="导航计时-Navigation-Timing-2"><a href="#导航计时-Navigation-Timing-2" class="headerlink" title="导航计时 Navigation Timing 2"></a>导航计时 Navigation Timing 2</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201165615835.png" alt="image-20230201165615835" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201165736167.png" alt="image-20230201165736167" style="zoom:80%;" /></p>
<h4 id="Performance-API"><a href="#Performance-API" class="headerlink" title="Performance API"></a>Performance API</h4><ul>
<li><p>Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分, 同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。</p>
</li>
<li><p>该类型的对象可以通过调用只读属性 Window.performance 来获得。</p>
</li>
<li><p>功能强大, 但并不适用于所有场景。</p>
<ul>
<li>比如, 如果在单页应用中改变 URL 但不刷新页面(单页应用的典型路由方案), 那么使用 window.performance.timing 所获取的数据是不会更新的, 还需要开发者重新设计统计方案。同时, window.performance.timing 可能无法满足一些自定义的数据。</li>
</ul>
</li>
</ul>
<h4 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h4><p>基于网页分析工具: </p>
<ul>
<li>Web PageTest, <a target="_blank" rel="noopener" href="http://www.webpagetest.org/">http://www.webpagetest.org/</a></li>
<li>PingDom Tools</li>
<li>GTmetrix, <a target="_blank" rel="noopener" href="https://gtmetrix.com/">https://gtmetrix.com/</a></li>
<li>Google PageSpeed, <a target="_blank" rel="noopener" href="https://developers.google.com/speed/">https://developers.google.com/speed/</a></li>
<li>whatsmydns, <a target="_blank" rel="noopener" href="https://www.whatsmydns.net/">https://www.whatsmydns.net</a></li>
</ul>
<p>基于浏览器分析工具: </p>
<ul>
<li>Chrome 自带工具 F12</li>
<li>Firefox 插件: YSlow(Yahoo 工具)</li>
<li>Page Speed(google)</li>
</ul>
<h4 id="浏览器优化"><a href="#浏览器优化" class="headerlink" title="浏览器优化"></a>浏览器优化</h4><p>可行的优化手段会因浏览器而异, 但从核心优化策略来说, 可以宽泛地分为两类: </p>
<ul>
<li>基于文档的优化: 熟悉网络协议, 了解文档、CSS 和 JavaScript 解析管道, 发现和优先安排关键网络资源, 尽早分派请求并取得页面, 使其尽快达到可交互的状态。主要方法是优先获取资源、提前解析等</li>
<li>推测性优化: 浏览器可以学习用户的导航模式, 执行推测性优化, 尝试预测用户的下一次操作。然后, 预先解析 DNS、预先连接可能的目标</li>
</ul>
<h4 id="大多数浏览器利用的四种技术"><a href="#大多数浏览器利用的四种技术" class="headerlink" title="大多数浏览器利用的四种技术"></a>大多数浏览器利用的四种技术</h4><p>好消息是, 所有这些优化都由浏览器替我们自动完成, 经常可以节省几百 ms 的网络延迟。既然如此, 那理解这些优化背后的原理就至关重要了, 这样才能利用浏览器的这些特性, 提升应用性能。大多数浏览器都利用了如下四种技术</p>
<ul>
<li>资源预取和排定优先次序: 文档、CSS 和 JavaScript 解析器可以与网络协议层沟通, 声明每种资源的优先级: 初始渲染必需的阻塞资源具有最高优先级, ⽽低优先级的请求可能会被临时保存在队列中</li>
<li>DNS 预解析: 对可能的域名进行提前解析, 避免将来 HTTP 请求时的 DNS 延迟。预解析可以通过学习导航历史、用户的鼠标悬停, 或其他页面信号来触发</li>
<li>TCP 预连接: DNS 解析之后, 浏览器可以根据预测的 HTTP 请求, 推测性地打开 TCP 连接。 如果猜对的话, 则可以节省一次完整的往返(TCP 握⼿)时间</li>
<li>页面预渲染: 某些浏览器可以让我们提示下一个可能的目标, 从而在隐藏的标签页中预先渲染整个页面。这样, 当用户真的触发导航时, 就能立即切换过来</li>
</ul>
<h4 id="推测优化"><a href="#推测优化" class="headerlink" title="推测优化"></a>推测优化</h4><p>预解析特定的域名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//hostname_to_resolve.com&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>预取得页面后面要用到的关键性资源</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;subresource&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/javascript/myapp.js&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>预取得将来导航要用的资源</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/images/big.jpeg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>根据对用户下一个目标的预测, 预渲染特定页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prerender&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//example.org/next_page.html&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="优化应用程序交付"><a href="#优化应用程序交付" class="headerlink" title="优化应用程序交付"></a>优化应用程序交付</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201170625047.png" alt="image-20230201170625047" style="zoom:80%;" /></p>
<h2 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a>5. 最佳实践</h2><p>两个准则: </p>
<ol>
<li>消除或减少不必要的网络延迟</li>
<li>将需要传输的数据压缩至最少</li>
</ol>
<h4 id="性能准则"><a href="#性能准则" class="headerlink" title="性能准则"></a>性能准则</h4><ul>
<li><p>减少 DNS 查找: </p>
<ul>
<li>每一次主机名解析都需要一次网络往返, 从而增加请求的延迟时间, 同时还会阻塞后续请求</li>
</ul>
</li>
<li><p>重用 TCP 连接: </p>
<ul>
<li>尽可能使用持久连接, 以消除 TCP 握手和慢启动延迟</li>
</ul>
</li>
<li><p>减少 HTTP 重定向: </p>
<ul>
<li>HTTP 重定向极费时间, 特别是不同域名之间的重定向, 更加费时；这里面既有额外的 DNS 查询、TCP 握手, 还有其他延迟。最佳的重定向次数为零</li>
</ul>
</li>
<li><p>使用 CDN(内容分发网络): </p>
<ul>
<li>把数据放到离用户地理位置更近的地方, 可以显著减少每次 TCP 连接的网络延迟, 增大吞吐量。这一条既适用于静态内容, 也适用于动态内容</li>
</ul>
</li>
<li><p>去掉不必要的资源: </p>
<ul>
<li>任何请求都不如没有请求快</li>
</ul>
</li>
</ul>
<h4 id="其他准则"><a href="#其他准则" class="headerlink" title="其他准则"></a>其他准则</h4><ul>
<li><p>在客户端缓存资源: </p>
<ul>
<li>应该缓存应用资源, 从而避免每次请求都发送相同的内容。</li>
</ul>
</li>
<li><p>传输压缩过的内容: </p>
<ul>
<li>传输前应该压缩应用资源, 把要传输的字节减至最少: 确保对每种要传输的资源采用最好的压缩手段。</li>
</ul>
</li>
<li><p>消除不必要的请求开销: </p>
<ul>
<li>减少请求的 HTTP 首部数据(比如 HTTP cookie), 节省的时间相当于几次往返的延迟时间。</li>
</ul>
</li>
<li><p>并行处理请求和响应: </p>
<ul>
<li>请求和响应的排队都会导致延迟, 无论是客户端还是服务器端。这一点经常被忽视, 但却会无谓地导致很长延迟。</li>
</ul>
</li>
<li><p>针对协议版本采取优化措施: </p>
<ul>
<li>HTTP 1.x 支持有限的并行机制, 要求打包资源、跨域分散资源, 等等。相对而言, HTTP2.0 只要建立一个连接就能实现最优性能, 同时无需针对 HTTP 1.x 的那些优化方法。</li>
</ul>
</li>
</ul>
<h4 id="在客户端缓存资源"><a href="#在客户端缓存资源" class="headerlink" title="在客户端缓存资源"></a>在客户端缓存资源</h4><p>要说最快的网络请求, 那就是不用发送请求就能获取资源。将之前下载过的数据缓存并维护好, 就可以做到这一点。对于通过 HTTP 传输的资源, 要保证首部包含适当的缓存字段: </p>
<ul>
<li>Cache-Control 首部用于指定缓存时间</li>
<li>Last-Modified 和 ETag 首部提供验证机制</li>
</ul>
<h4 id="压缩传输的数据"><a href="#压缩传输的数据" class="headerlink" title="压缩传输的数据"></a>压缩传输的数据</h4><p>利用本地缓存可以让客户端避免每次请求都重复取得数据。不过, 还是有一些资源是必须取得的, 比如原来的资源过期了, 或者有新资源, 再或者资源不能缓存。对于这些资源, 应该保证传输的字节数最少。因此要保证对它们进行最有效的压缩。</p>
<p>HTML、CSS 和 JavaScript 等文本资源的大小经过 gzip 压缩平均可以减少 60%~80%。而图片则需要仔细考量:</p>
<ol>
<li>图片一般会占到一个网页需要传输的总字节数的一半；</li>
<li>通过去掉不必要的元数据可以把图片文件变小；</li>
<li>要调整大小就在服务器上调整, 避免传输不必要的字节；</li>
<li>应该根据图像选择最优的图片格式；</li>
<li>尽可能使用有损压缩。</li>
</ol>
<h4 id="消除不必要的请求字节"><a href="#消除不必要的请求字节" class="headerlink" title="消除不必要的请求字节"></a>消除不必要的请求字节</h4><p>HTTP 是一种无状态协议, 也就是说服务器不必保存每次请求的客户端的信息。然而, 很多应用又依赖于状态信息以实现会话管理、个性化、分析等功能。为了实现这些功能, HTTP State Management Mechanism(RFC 2965) 作为扩展, 允许任何网站针对自身来源关联和更新 cookie 元数据: 浏览器保存数据, 而在随后发送给来源的每一个请求的 Cookie 首部中自动附加这些信息。</p>
<p>上述标准并未规定 cookie 最大不能超过多大, 但实践中大多数浏览器都将其限制为 4 KB。与此同时, 该标准还规定每个站点针对其来源可以有多个关联的 cookie。于是, 一个来源的 cookie 就有可能多达几十 KB！不用说, 这么多元数据随请求传递, 必然会给应用带来明显的性能损失: </p>
<ol>
<li>浏览器会在每个请求中自动附加关联的 cookie 数据；</li>
<li>在 HTTP 1.x 中, 包括 cookie 在内的所有 HTTP 首部都会在不压缩的状态下传输；</li>
<li>在 HTTP 2.0 中, 这些元数据经过压缩了, 但开销依然不小；</li>
<li>最坏的情况下, 过大的 HTTP cookie 会超过初始的 TCP 拥塞窗口, 从而导致多余的网络往返。</li>
</ol>
<h4 id="并行处理请求和响应"><a href="#并行处理请求和响应" class="headerlink" title="并行处理请求和响应"></a>并行处理请求和响应</h4><p>要是想实现最佳性能, 就要记住以下几点: </p>
<ol>
<li>使用持久连接, 从 HTTP 1.0 升级到 HTTP 1.1；</li>
<li>利用多个 HTTP 1.1 连接实现并行下载；</li>
<li>可能的情况下利用 HTTP 1.1 管道；</li>
<li>考虑升级到 HTTP 2.0 以提升性能；</li>
<li>确保服务器有足够的资源并行处理请求。</li>
</ol>
<h4 id="HTTP-1-x-优化建议"><a href="#HTTP-1-x-优化建议" class="headerlink" title="HTTP/1.x 优化建议"></a>HTTP/1.x 优化建议</h4><p>针对 HTTP 1.x 的优化次序很重要: 首先要配置服务器以最大限度地保证 TCP 和 TLS 的性能最优, 然后再谨慎地选择和采用移动及经典的应用最佳实践, 之后再度量, 迭代。</p>
<p>采用了经典的应用优化措施和适当的性能度量手段, 还要进一步评估是否有必要为应用采取特定于 HTTP 1.x 的优化措施(其实是权宜之计)。</p>
<ul>
<li>利用 HTTP 管道: <ul>
<li>如果你的应用可以控制客户端和服务器这两端, 那么使用管道可以显著减少网络延迟。</li>
</ul>
</li>
<li>采用域名分区: <ul>
<li>如果你的应用性能受限于默认的每来源 6 个连接, 可以考虑将资源分散到多个来源。</li>
</ul>
</li>
<li>打包资源以减少 HTTP 请求: <ul>
<li>拼接和精灵图等技巧有助于降低协议开销, 又能达成类似管道的性能提升。</li>
</ul>
</li>
<li>嵌入小资源: <ul>
<li>考虑直接在父文档中嵌入小资源, 从而减少请求数量。</li>
</ul>
</li>
</ul>
<p>管道缺乏支持, 而其他优化手段又各有各的利弊。事实上, 这些优化措施如果过于激进或使用不当, 反倒会伤害性能。总之, 要有务实的态度, 通过度量来评估各种措施对性能的影响, 在此基础上再迭代改进。 天底下就没有包治百病的灵丹妙药！！！</p>
<h4 id="针对-HTTP-2-0-的优化"><a href="#针对-HTTP-2-0-的优化" class="headerlink" title="针对 HTTP 2.0 的优化"></a>针对 HTTP 2.0 的优化</h4><p>HTTP 2.0 的主要目标就是提升传输性能, 实现客户端与服务器间较低的延迟和较高的吞吐量。显然, 在 TCP 和 TLS 之上实现最佳性能, 同时消除不必要的网络延迟, 从来没有如此重要过。</p>
<ul>
<li>服务器的初始 cwnd 应该是 10 个分组；TCP 的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制, 在之前我们还讨论过 TCP 还有一个对端通告的接收窗口(rwnd)用于流量控制。</li>
<li>服务器应该通过 ALPN(针对 SPDY 则为 NPN)协商支持 TLS；<ul>
<li>ALPN(Application Layer Protocol Negotiation, 应用层协议协商), ALPN 是客户端发送所支持的 HTTP 协议列表, 由服务端选择</li>
<li>NPN(Next Protocol Negotiation, 下一代协议协商)是服务端发送所支持的 HTTP 协议列表, 由客户端选择</li>
</ul>
</li>
<li>服务器应该支持 TLS 恢复以最小化握手延迟</li>
</ul>
<p>要通过 HTTP 2.0 获得最佳性能, 特别是从每个来源仅用一个连接的角度说, 的确需要各层协议的紧密配合。</p>
<p>接下来, 或许有点意外, 那就是采用移动及其他经典的最佳做法: 少发数据、削减请求, 根据无线网络情况调整资源供给。不管使用什么版本的协议, 减少传输的数据量和消除不必要的网络延迟, 对任何应用都是最有效的优化手段。</p>
<p>最后, 杜绝和忘记域名分区、文件拼接、图片精灵等不良的习惯, 这些做法在 HTTP 2.0 之上完全没有必要。事实上, 继续使用这些手段反而有害！可以利用 HTTP 2.0 内置的多路分发以及服务器推送等新功能。</p>
<h4 id="去掉对-1-x-的优化"><a href="#去掉对-1-x-的优化" class="headerlink" title="去掉对 1.x 的优化"></a>去掉对 1.x 的优化</h4><p>每个来源使用一个连接: </p>
<ul>
<li>HTTP 2.0 通过将一个 TCP 连接的吞吐量最大化来提升性能。事实上, 在 HTTP 2.0 之下再使用多个连接(比如域名分区)反倒成了一种反模式, 因为多个连接会抵消新协议中首部压缩和请求优先级的效用。</li>
</ul>
<p>去掉不必要的文件合并和图片拼接: </p>
<ul>
<li>打包资源的缺点很多, 比如缓存失效、占用内存、延缓执行, 以及增加应用复杂性。有了 HTTP 2.0, 很多小资源都可以并行发送, 导致打包资源的效率反而更低。</li>
</ul>
<p>利用服务器推送: </p>
<ul>
<li>之前针对 HTTP 1.x 而嵌入的大多数资源, 都可以而且应该通过服务器推送来交付。这样一来, 客户端就可以分别缓存每个资源, 并在页面间实现重用, 而不必把它们放到每个页面里了。</li>
</ul>
<p>要获得最佳性能, 应该尽可能把所有资源都集中在一个域名之下。域名分区在 HTTP 2.0 之下属于反模式, 对发挥协议的性能有害: 分区是开始, 之后影响会逐渐扩散。打包资源不会影响 HTTP 2.0 协议本身, 但对缓存性能和执行速度有负面影响。</p>
<h4 id="双协议应用策略-—"><a href="#双协议应用策略-—" class="headerlink" title="双协议应用策略(—)"></a>双协议应用策略(—)</h4><ul>
<li><p>相同的应用代码, 双协议部署: </p>
<ul>
<li>相同的应用代码可能通过 HTTP 1.x 也可能通过 HTTP 2.0 交付。可能任何一种协议之下都达不到最佳性能, 但可以追求性能足够好。所谓足够好, 需要通过针对每一种应用单独度量来保证。这种情况下, 第一步可以先撤销域名分区以实现 HTTP 2.0 交付。然后, 随着更多用户迁移到 HTTP 2.0, 可以继续撤销资源打包并尽可能利用服务器推送。</li>
</ul>
</li>
<li><p>分离应用代码, 双协议部署: </p>
<ul>
<li>根据协议不同分别交付不同版本的应用。这样会增加运维的复杂性, 但实践中对很多应用倒是十分可行。比如, 一台负责完成连接的边界服务器可以根据协商后的协议版本, 把客户端请求引导至适当的服务器。</li>
</ul>
</li>
<li><p>动态 HTTP 1.x 和 HTTP 2.0 优化: </p>
<ul>
<li>某些自动化的 Web 优化框架, 以及开源及商业产品, 都可以在响应请求时动态重写交付的应用代码(包括连接、拼合、分区, 等等)。此时, 服务器也可以考虑协商的协议版本, 并动态采用适当的优化策略。</li>
</ul>
</li>
<li><p>HTTP 2.0, 单协议部署: </p>
<ul>
<li>如果应用可以控制服务器和客户端, 那没理由不只使用 HTTP 2.0。事实上, 如果真有这种可能, 那就应该专一使用 HTTP 2.0。</li>
</ul>
</li>
<li><p>谷歌的 PageSpeed Optimization Libraries(PSOL) 提供了 40 多种”Web 优化过滤器”的开源实现, 可以集成到任何服务器运行时, 动态应用各种优化策略。</p>
</li>
</ul>
<h4 id="指标-—"><a href="#指标-—" class="headerlink" title="指标(—)"></a>指标(—)</h4><p>可以使用 WebpageTest 对网页进行测试</p>
<ul>
<li><p>网页级指标 (Page-level Metrics): 这些是为整个页面捕获并显示的顶级度量值。</p>
</li>
<li><p>整页加载时间 (Load Time): 测量的时间是从初始化请求, 到开始执行 window.onload 事件。</p>
</li>
<li><p>页面所有元素加载时间 (Fully Loaded): 从初始化请求, 到 Document Complete 后, 2 秒内(中间几百毫秒轮询)没有网络活动的时间, 但这 2 秒是不包括在测量中的, 所以会出现两个差值大于或小于 2 秒。</p>
</li>
<li><p>第一个字节加载时间 (First Byte): 第一个字节时间(通常缩写为 TTFB)被测量为从初始化请求, 到服务器响应的第一个字节, 被浏览器接收的时间(不包括 DNS 查询、TCP 连接的时间)。</p>
</li>
<li><p>页面渲染时间 (Start Render): 测量的时间是从初始化请求, 到第一个内容被绘制到浏览器显示的时间。在瀑布图中有两个参数指标 Start Render 和 msFirstPaint。</p>
<ul>
<li><p>Start Render 是通过捕获页面加载的视频, 并在浏览器第一次显示除空白页之外的其他内容时查看每个帧来衡量的。它只能在实验室测量, 通常是最准确的测量。</p>
</li>
<li><p>msFirstPaint(IE 专用属性)是由浏览器本身报告的一个测量, 它认为绘制的第一个内容。通常是相当准确, 但有时它报告的时候, 浏览器只画一个空白屏幕。</p>
</li>
</ul>
</li>
<li><p>首屏展现平均值 (Speed Index): 表示页面呈现用户可见内容的速度(越低越好)。有关如何计算的更多信息, 请参见: Speed Index。</p>
</li>
<li><p>DOM 元素数量 (DOM Elements): 在测试结束时测试页面上的 DOM 元素的计数。</p>
</li>
<li><p>请求级度量标准 (Request-level Metrics): 这些是为每个请求捕获和显示的度量。</p>
</li>
</ul>
<h2 id="6-网飞网络性能案例研究"><a href="#6-网飞网络性能案例研究" class="headerlink" title="6. 网飞网络性能案例研究"></a>6. 网飞网络性能案例研究</h2><p>改善 Netflix.com 在桌面的交互时间</p>
<p>通过改进 Netflix.com 注册过程中所使用的 JavaScript 及预加载技术, 开发团队能够为移动用户和桌面用户提供更好的用户体验, 主要改进如下: </p>
<ul>
<li>加载和交互时间减少了 50%(Netflix.com 桌面登录主页)</li>
<li>在从 React 和其他客户端库切换到普通的 JavaScript 之后, JavaScript 包大小减少了 200KB。服务器端仍然使用 React</li>
<li>HTML、CSS、JavaScript(React)预加载使后续页面的浏览交互时间减少了 30%</li>
</ul>
<h4 id="减少-JavaScript-传输-缩短交互时间"><a href="#减少-JavaScript-传输-缩短交互时间" class="headerlink" title="减少 JavaScript 传输, 缩短交互时间"></a>减少 JavaScript 传输, 缩短交互时间</h4><p>Netflix 针对其登录主页的性能进行了优化: </p>
<ul>
<li>这个页面最初包含 300KB 的 JavaScript, 其中一些是 React 和其他客户端代码(比如像 Lodash 这样的实用程序库), 还有一些是补充 React 状态所需的上下文数据。</li>
</ul>
<p>使用 Chrome 的开发工具和 Lighthouse 模拟在 3G 连接上加载登录主页, 结果显示, 登录主页需要 7 秒的加载时间, 对于一个简单的登录页面来说太长了, 因此需要研究改进的可能。通过一些性能审计, Netflix 发现他们客户端的 JS 开销很高。</p>
<p>登录主页是否真得需要 React？用 Vanilla JavaScript 替换！！！</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>移植到原生 JavaScript 的组件列表: </p>
<ul>
<li>基础交互(主页选项卡)</li>
<li>语言切换器</li>
<li>“Cookie 横幅(Cookie banner)”(针对非美国用户)</li>
<li>客户端日志分析</li>
<li>性能度量和记录</li>
<li>广告归属检测引导代码(出于安全考虑, 放在沙箱式 iFrame 中)</li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>尽管 React 最初占用的空间仅为 45KB, 但将 React、几个库和相应的应用程序代码从客户端移除后, JavaScript 的总量减少了 200KB 以上, 这使得 Netflix 在登录主页的交互时间减少了 50% 以上。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201173307351.png" alt="image-20230201173307351"></p>
<h4 id="后续页面的-React-预加载"><a href="#后续页面的-React-预加载" class="headerlink" title="后续页面的 React 预加载"></a>后续页面的 React 预加载</h4><p>预加载: </p>
<ul>
<li>通过浏览器内置的 API 和 XHR 预加载</li>
<li>交互时间减少了 30%</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230201173330145.png" alt="image-20230201173330145"></p>
<h2 id="7-Robots-txt"><a href="#7-Robots-txt" class="headerlink" title="7. Robots.txt"></a>7. Robots.txt</h2><p>“网络爬虫排除标准”(Robots Exclusion Protocol), 网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取, 哪些页面不能抓取。</p>
<ul>
<li>源自 1994</li>
<li><a target="_blank" rel="noopener" href="https://www.robotstxt.org/robotstxt.html">https://www.robotstxt.org/robotstxt.html</a></li>
</ul>
<p>Robots 协议是国际互联网界通行的道德规范, 基于以下原则建立: </p>
<ol>
<li>搜索技术应服务于人类, 同时尊重信息提供者的意愿, 并维护其隐私权；</li>
<li>网站有义务保护其使用者的个人信息和隐私不被侵犯。</li>
</ol>
<p>robots 是一个协议。robots.txt 文件是一个文本文件, 放置在网站根目录下。</p>
<h4 id="Robots-txt-例子"><a href="#Robots-txt-例子" class="headerlink" title="Robots.txt 例子"></a>Robots.txt 例子</h4><p>任何机器人都不应该访问任何以”/yoursite/temp/“开头的 URL, 除了名为”IxeBot”的机器人: </p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">User-agent: *<br>Disallow: /yoursite/temp/<br><br>User-agent: IxeBot<br>Disallow:<br></code></pre></td></tr></table></figure>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>密切关注 JavaScript 的开销</p>
<p>Netflix 的折中方案是, 使用 React 在服务器端渲染登录页面, 但同时也为注册过程的其他部分预取 React 代码。这不仅优化了首次加载性能, 还优化了注册过程其余部分的加载时间, 因为它是单页应用, 所以有更大的 JS 包需要下载。</p>
<p>补充: </p>
<ul>
<li>Netflix 考虑过 Preact, 但是, 对于一个交互性比较低的简单页面流, 使用普通的 JavaScript 是一个更简单的选择</li>
<li>Netflix 尝试使用 Service Workers 进行静态资源缓存。当时, Safari 不支持这个 API(现在支持了), 但他们现在又在探索这个 API。Netflix 的注册过程需要比客户体验更多的遗留浏览器支持。许多用户会在旧的浏览器上注册, 但会在他们本地的移动应用程序或电视设备上观看 Netflix</li>
<li>Netflix 的登录页面极为动态。这是他们的注册过程中进行 A/B 测试最多的页面, 机器学习模型用于根据位置、设备类型和许多其他因素定制消息和图像。支持近 200 个国家, 每个派生页面都面对着不同的本地化、法律和价值信息挑战</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/01/29/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-9-AJAX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/29/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-9-AJAX/" class="post-title-link" itemprop="url">Web前端开发(9) AJAX</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-29 18:06:51" itemprop="dateCreated datePublished" datetime="2023-01-29T18:06:51+08:00">2023-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="11-Asynchronous-JavaScript-and-XML-AJAX"><a href="#11-Asynchronous-JavaScript-and-XML-AJAX" class="headerlink" title="11-Asynchronous JavaScript and XML (AJAX)"></a>11-Asynchronous JavaScript and XML (AJAX)</h1><h2 id="1-RIA"><a href="#1-RIA" class="headerlink" title="1. RIA"></a>1. RIA</h2><h4 id="从网站到web应用"><a href="#从网站到web应用" class="headerlink" title="从网站到web应用"></a>从网站到web应用</h4><ul>
<li>Client/Server</li>
<li>三层架构 Three-Tier<ul>
<li>将业务应用规划中的表示层 UI、数据访问层 DAL 以及业务逻辑层 BLL, 其分层的核心任务是”高内聚低耦合”的实现</li>
</ul>
</li>
<li>Model-View-Controller</li>
<li>富互联网应用 Rich Internet</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129195934874.png" alt="image-20230129195934874" style="zoom:80%;" /></p>
<h4 id="传统的web应用"><a href="#传统的web应用" class="headerlink" title="传统的web应用"></a>传统的web应用</h4><ul>
<li>瘦客户端架构<ul>
<li>服务器完成大部分⼯作并保存大部分数据 -&gt; 更高的流量</li>
</ul>
</li>
<li>同步通信<ul>
<li>对于作为某些操作的结果发送的每个请求, 客户机在服务器完成响应之前不能与应用程序交互</li>
<li>也就是说, 缺少交互性的用户体验</li>
</ul>
</li>
</ul>
<h4 id="Rich-Internet-Applications"><a href="#Rich-Internet-Applications" class="headerlink" title="Rich Internet Applications"></a>Rich Internet Applications</h4><p>MVC 的 RIA 实现</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129200104861.png" alt="image-20230129200104861" style="zoom:80%;" /></p>
<h4 id="RIA-优势与不足"><a href="#RIA-优势与不足" class="headerlink" title="RIA: 优势与不足"></a>RIA: 优势与不足</h4><p>优势</p>
<ul>
<li>不需要安装、易于升级、可以通过互联网/内部网轻松获取、丰富的用户界面、更好的响应性、客户机/服务器平衡、异步通信、网络效率</li>
</ul>
<p>不足</p>
<ul>
<li>搜索引擎不够友好、专有的(相对于开放标准)、完整性丧失(RIA通常不能很好地与HTML混合)、软件开发的复杂性(在客户端计算机上缓存或不缓存什么?)、RIA体系结构打破了 Web 页面范式</li>
</ul>
<h4 id="RIA-的实现方式"><a href="#RIA-的实现方式" class="headerlink" title="RIA 的实现方式"></a>RIA 的实现方式</h4><p>浏览器插件</p>
<ul>
<li>Flash/Flex, Java Swing, Silverlight</li>
<li>潜在的更强的交互性, 更高的应用障碍</li>
<li>关注开放/控制</li>
</ul>
<p>在浏览器中, 不需要插件</p>
<ul>
<li>AJAX</li>
<li>更低的采用⻔槛</li>
<li>跨浏览器问题?</li>
</ul>
<h2 id="2-Ajax"><a href="#2-Ajax" class="headerlink" title="2. Ajax"></a>2. Ajax</h2><h4 id="web同步通信模型"><a href="#web同步通信模型" class="headerlink" title="web同步通信模型"></a>web同步通信模型</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129201002280.png" alt="image-20230129201002280" style="zoom:80%;" /></p>
<ul>
<li><p>同步: 用户必须等待新页面加载</p>
<ul>
<li>网页中使用的典型通信模式(点击-等待-刷新)</li>
</ul>
</li>
<li><p>几乎所有对新数据的更改都会导致页面刷新</p>
</li>
</ul>
<h4 id="web异步通信模型"><a href="#web异步通信模型" class="headerlink" title="web异步通信模型"></a>web异步通信模型</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129201105411.png" alt="image-20230129201105411" style="zoom:80%;" /></p>
<ul>
<li>异步: 用户可以在数据加载时继续与页面交互<ul>
<li>Ajax使通信模式成为可能</li>
</ul>
</li>
<li>使用新数据进行更改, 但不刷新页面</li>
</ul>
<h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><ul>
<li>AJAX(Asynchronous JavaScript And XML)是一种使用 XMLHttpRequest 技术构建更复杂, 动态的网页的编程实践</li>
<li>Asynchronous JavaScript + XML(异步 JavaScript 和 XML), 其本身不是一种新技术, 而是一个在 2005 年被 Jesse James Garrett 提出的新术语, 用来描述一种使用现有技术集合的’新’方法, 包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML (en-US), XSLT, 以 及最重要的 XMLHttpRequest</li>
<li>AJAX 允许只更新一个 HTML 页面的部分 DOM, 而无须重新加载整个页面。AJAX 还允许异步⼯作, 这意味着当网页的一部分正试图重新加载时, 您的代码可以继续运行(相比之下, 同步会阻止代码继续运行, 直到这部分的网页完成重新加载)</li>
<li>尽管 X 在 Ajax 中代表 XML, 但由于 JSON 的许多优势, 比如更加轻量以及作为 Javascript 的一部分, ⽬前 JSON 的使用比 XML 更加普遍。JSON 和 XML 都被用于在 Ajax 模型中打包信息</li>
<li>通过交互式网站和现代 Web 标准, AJAX 正在逐渐被 JavaScript 框架中的函数和官方的 Fetch API 标准取代。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129201143208.png" alt="image-20230129201143208" style="zoom:80%;" /></p>
<h4 id="AJAX-事件处理"><a href="#AJAX-事件处理" class="headerlink" title="AJAX 事件处理"></a>AJAX 事件处理</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131130418795.png" alt="image-20230131130418795" style="zoom:80%;" /></p>
<h4 id="AJAX-优缺点"><a href="#AJAX-优缺点" class="headerlink" title="AJAX 优缺点"></a>AJAX 优缺点</h4><p>优点</p>
<ul>
<li>更好的交互性和响应性</li>
<li>页面将更易于使用</li>
<li>由于部分呈现, 减少了到Web服务器的连接</li>
<li>因为只加载更新页面所需的数据, 而不是刷新整个页面, 因此节省了带宽</li>
<li>有助于减少网络流量。</li>
</ul>
<p>缺点</p>
<ul>
<li>后退和刷新按钮变得不可用</li>
<li>收藏网页将变得不可用</li>
<li>要求在Web浏览器上启用 JavaScript</li>
<li>网络延迟可能会破坏可用性</li>
<li>通过AJAX加载的数据不会被任何主要搜索引擎索引。因此, 使其SEO不友好</li>
</ul>
<h4 id="使用AJAX的真实场景"><a href="#使用AJAX的真实场景" class="headerlink" title="使用AJAX的真实场景"></a>使用AJAX的真实场景</h4><p>下面的列表描述了AJAX可以发挥作用的一些现实场景:</p>
<ul>
<li>自动完成搜索文本框</li>
<li>级联下拉列表框</li>
<li>实时通信, 如即时消息传递</li>
<li>实时数据更新, 如分数更新</li>
<li>即时表单验证反馈</li>
<li>自动保存用户信息</li>
</ul>
<h2 id="3-XMLHttpRequest"><a href="#3-XMLHttpRequest" class="headerlink" title="3. XMLHttpRequest"></a>3. XMLHttpRequest</h2><h4 id="AJAX-组件"><a href="#AJAX-组件" class="headerlink" title="AJAX 组件"></a>AJAX 组件</h4><ul>
<li>AJAX不能独立⼯作</li>
<li>与其他技术结合使用, 以创建以下列表中描述的交互式Web页面:<ul>
<li>JavaScript:<ul>
<li>松散类型的脚本语言</li>
<li>当页面中发生事件时调用 JavaScript 函数</li>
<li>整个AJAX操作的胶水</li>
</ul>
</li>
<li>DOM:<ul>
<li>用于访问和操作结构化文档的 API</li>
<li>表示XML和HTML文档的结构</li>
</ul>
</li>
<li>CSS:<ul>
<li>允许将表示样式与内容清晰分离, 并且可以通过JavaScript以编程方式更改</li>
</ul>
</li>
<li>XMLHttpRequest:<ul>
<li>JavaScript对象, 它执行与服务器的异步交互</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="XMLHttpRequest-对象简介"><a href="#XMLHttpRequest-对象简介" class="headerlink" title="XMLHttpRequest 对象简介"></a>XMLHttpRequest 对象简介</h4><ul>
<li>是AJAX最重要的组件</li>
<li>自2000年7月Internet Explorer 5.5发布以来一直可用</li>
<li>是一个API, 可以被 JavaScript、JScript、VBScript 和其他 Web 浏览器脚本语言使用</li>
<li>用于使用 HTTP 在 Web 服务器之间传输和操作 XML 数据</li>
<li>在 Web 页面的客户端和服务器端之间建立独立的连接通道</li>
<li>除了XML, XMLHttpRequest还可以用于获取其他格式的数据, 比如 JSON 甚⾄纯文本</li>
<li>执行如下操作:<ul>
<li>在后台从客户端发送数据</li>
<li>从服务器接收数据</li>
<li>更新网页, 无需重新加载</li>
</ul>
</li>
</ul>
<h4 id="AJAX-Web应用程序模型的处理周期"><a href="#AJAX-Web应用程序模型的处理周期" class="headerlink" title="AJAX Web应用程序模型的处理周期"></a>AJAX Web应用程序模型的处理周期</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131131459962.png" alt="image-20230131131459962" style="zoom:80%;" /></p>
<h4 id="XMLHttpRequest对象的常见属性"><a href="#XMLHttpRequest对象的常见属性" class="headerlink" title="XMLHttpRequest对象的常见属性"></a>XMLHttpRequest对象的常见属性</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131131646027.png" alt="image-20230131131646027" style="zoom:80%;" /></p>
<h4 id="XMLHttpRequest对象的基本方法"><a href="#XMLHttpRequest对象的基本方法" class="headerlink" title="XMLHttpRequest对象的基本方法"></a>XMLHttpRequest对象的基本方法</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131131718361.png" alt="image-20230131131718361" style="zoom:80%;" /></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>为了使用 JavaScript 向服务器发送一个 http 请求, 需要一个包含必要函数功能的 XMLHttpRequest 对象实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> httpRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// Old compatibility code, no longer needed.</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">XMLHttpRequest</span>) &#123; <span class="hljs-comment">// Mozilla, Safari, IE7+ ...</span><br>	httpRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">ActiveXObject</span>) &#123; <span class="hljs-comment">// IE 6 and older</span><br>	httpRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>创建 XMLHttpRequest 对象后, 需要决定在收到服务器对请求的响应后要做什么</li>
<li>在这一步, 需要定义 JavaScript 函数, 该函数将处理服务器响应</li>
<li>这可以使用 XMLHttpRequest 对象的 onreadystatechange 属性来完成, 如下所示的代码片段</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">httpRequest.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>	<span class="hljs-comment">//process the server response</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>设置响应功能后, 需要进行请求</li>
<li>为了发出请求, 需要调用 XMLHttpRequest 对象的 open() 和 send() 方法, 如下所示:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">httpRequest.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;serverpage.php&#x27;</span>,<span class="hljs-literal">true</span>);<br>httpRequest.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>下面的列表描述了前面代码片段中传递给 open() 方法的参数:</p>
<ul>
<li>第一个参数是HTTP请求方法, 例如GET、POST和HEAD</li>
<li>第⼆个参数是请求的 Web 页面的 URL</li>
<li>第三个参数(可选)设置请求是否是异步的</li>
</ul>
</li>
<li><p>处理服务器的响应:</p>
<ul>
<li>首先, 响应函数需要检查请求的就绪状态<ul>
<li>如果就绪状态的值为 4, 则可以进一步执行</li>
</ul>
</li>
<li>接下来, 需要检查HTTP服务器响应的响应代码</li>
</ul>
</li>
<li>下面的代码片段描述了如何处理服务器的响应:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">httpRequest.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (httpRequest.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>     	<span class="hljs-comment">// everything is good, the response is received</span><br>     	<span class="hljs-keyword">if</span> (httpRequest.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123; <br>            <span class="hljs-comment">// process the response </span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-comment">// request encountered some problem,</span><br>     		<span class="hljs-comment">// for example, the response may contain a HTTP 404 (Not Found) response code</span><br>    	&#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-comment">// still not ready </span><br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="使用-XMLHttpRequest-获取数据"><a href="#使用-XMLHttpRequest-获取数据" class="headerlink" title="使用 XMLHttpRequest 获取数据"></a>使用 XMLHttpRequest 获取数据</h4><ul>
<li>下面的代码片段描述了如何在Web页面上显示来自 Web 服务器的响应</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ajaxButton&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Make a request<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> httpRequest;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ajaxButton&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, makeRequest);</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">makeRequest</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        httpRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (!httpRequest) &#123;</span><br><span class="language-javascript">        	<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Giving up :( Cannot create an XMLHTTP instance&#x27;</span>);</span><br><span class="language-javascript">        	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        httpRequest.<span class="hljs-property">onreadystatechange</span> = alertContents;</span><br><span class="language-javascript">        httpRequest.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;test.html&#x27;</span>);</span><br><span class="language-javascript">        httpRequest.<span class="hljs-title function_">send</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">alertContents</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (httpRequest.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property">DONE</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (httpRequest.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;</span><br><span class="language-javascript">            	<span class="hljs-title function_">alert</span>(httpRequest.<span class="hljs-property">responseText</span>);</span><br><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">            	<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;There was a problem with the request.&#x27;</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;)();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="跨站的-XMLHttpRequest"><a href="#跨站的-XMLHttpRequest" class="headerlink" title="跨站的 XMLHttpRequest"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest">跨站的 XMLHttpRequest</a></h4><ul>
<li>现代浏览器可以通过执行 WebApps ⼯作小组通过的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">Access Control for Cross-Site Requests</a> 标注来支持跨站请求。只要服务器端的配置允许您从您的 Web 应用发送请求, 就可以使用 XMLHttpRequest。否则, 会抛出一个 INVALID_ACCESS_ERR 异常</li>
<li>跨源资源共享(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">CORS</a>, 或通俗地译为跨域资源共享)是一种基于 HTTP 头的机制, 该机制通过允许服务器标示除了它自⼰以外的其它源(域、协议和端口), 使得浏览器允许这些 origin 访问加载自⼰的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求, 该机制通过浏览器发起一个到服务器托管的跨源资源的”<strong>预检</strong>“请求。在预检中, 浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头</li>
<li>跨源 HTTP 请求的一个例子: 运行在 <a target="_blank" rel="noopener" href="https://domain-a.com">https://domain-a.com</a> 的 JavaScript 代码使用 XMLHttpRequest 来发起一个到 <a target="_blank" rel="noopener" href="https://domain-b.com/data.json">https://domain-b.com/data.json</a> 的请求</li>
<li>出于安全性, 浏览器限制脚本内发起的跨源 HTTP 请求。例如, XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源, 除非响应报文包含了正确 CORS 响应头</li>
<li>CORS 机制允许 Web 应用服务器进行跨源访问控制, 从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中(例如 XMLHttpRequest 或 Fetch)使用 CORS, 以降低跨源 HTTP 请求所带来的风险</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131150700326.png" alt="image-20230131150700326" style="zoom:80%;" /></p>
<h4 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h4><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch</a> 是一个现代的概念, 等同于 XMLHttpRequest。它提供了许多与 XMLHttpRequest 相同的功能, 但被设计成更具可扩展性和高效性</li>
<li>Fetch API 提供了一个 JavaScript 接口, 用于访问和操纵 HTTP 管道的一些具体部分, 例如请求和响应。它还提供了一个全局 fetch() 方法, 该方法提供了一种简单, 合理的方式来跨网络异步获取资源</li>
<li>这种功能以前是使用 XMLHttpRequest 实现的。Fetch 提供了一个更理想的替代方案, 可以很容易地被其他技术使用, 例如 Service Workers。Fetch 还提供了专⻔的逻辑空间来定义其他与 HTTP 相关的概念, 例如 CORS 和 HTTP 的扩展</li>
</ul>
<h4 id="基本的-fetch-请求"><a href="#基本的-fetch-请求" class="headerlink" title="基本的 fetch 请求"></a>基本的 fetch 请求</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">使用 fetch</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com/movies.json&#x27;</span>)<br> .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br> .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br></code></pre></td></tr></table></figure>
<h2 id="4-Ajax的局限"><a href="#4-Ajax的局限" class="headerlink" title="4. Ajax的局限"></a>4. Ajax的局限</h2><h4 id="Ajax-风险"><a href="#Ajax-风险" class="headerlink" title="Ajax 风险"></a>Ajax 风险</h4><p>浏览器后退机制的破坏, 后退和前进按钮问题、安全风险、搜索引擎、书签的问题</p>
<h4 id="并发连接数限制"><a href="#并发连接数限制" class="headerlink" title="并发连接数限制"></a>并发连接数限制</h4><ul>
<li>HTTP 1.1 (RFC 2616)建议单用户客户端不应该与任何服务器或代理保持超过2个连接</li>
<li>大多数浏览器(包括IE)都遵守这个规则</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230131151621856.png" alt="image-20230131151621856" style="zoom:80%;" /></p>
<h2 id="5-提示"><a href="#5-提示" class="headerlink" title="5. 提示"></a>5. 提示</h2><h4 id="Ajax-优化"><a href="#Ajax-优化" class="headerlink" title="Ajax 优化"></a>Ajax 优化</h4><ul>
<li>优化任何 Ajax 应用程序的方法是找到优化其中的每个元素的最佳方法。应用程序尽可能快速高效地运行是很重要的</li>
</ul>
<h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>当从服务器接收新数据时没有巨大的延迟时, Ajax应用程序是快速的。优化两个方面将有助于应用程序成功</p>
<ul>
<li>第一种是压缩从服务器发送到客户端的所有数据。这对于快速数据传输非常重要</li>
<li>第⼆个问题与数据本身有关。从客户机和服务器来回发送的数据也应该尽可能地优化。</li>
</ul>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul>
<li>向服务器发送数据时, 发送最小数量的信息。如果要发送键/值对, 请保持键和值都小。尽可能列举选择。而不是像这样:<ul>
<li>user_choice=add_data_to_database&amp;data1=value1&amp;data2=value2</li>
</ul>
</li>
<li>考虑将每个选项设置为单个值, 并发送该值:<ul>
<li>c=3&amp;d1=value1&amp;d2=value2</li>
</ul>
</li>
<li>更小的数据使得被拦截的信息更难被解释(一个很好的安全好处), 并保持需要发送和解析的数据的大小更小</li>
</ul>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul>
<li>Ajax 优化的另一个重要部分是优化在客户机上执行的 JavaScript 代码, 并创建尽可能快的数据检索<ul>
<li>内联 SQL 查询</li>
<li>存储过程</li>
</ul>
</li>
<li>在客户机上, 许多 JavaScript 技术将有助于增加代码的执行时间。当接收到 Ajax 响应时代码可能需要执行的 DOM 操作时, 这一点尤其重要</li>
<li>没有人说 Ajax 应用程序在没有任何优化的情况下不能平稳有效地运行。在大多数情况下, 以太网连接的速度、计算机的处理能力以及浏览器中 JavaScript 的更好实现将确保应用程序运行良好。优化将使应用程序运行得更快。对于用户来说, 越快越好</li>
</ul>
<h4 id="AJAX实现的最佳实践"><a href="#AJAX实现的最佳实践" class="headerlink" title="AJAX实现的最佳实践"></a>AJAX实现的最佳实践</h4><ul>
<li>理解这一切意味着什么<ul>
<li>维基百科</li>
</ul>
</li>
<li>检查合适的使用场景</li>
<li>学会用原始代码实现它</li>
</ul>
<h4 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h4><ul>
<li>库不仅提供了可以使用的详尽特性集, 而且还确保代码与所有浏览器兼容, 而无需做任何额外的⼯作<ul>
<li>axios</li>
<li>AngularJS</li>
</ul>
</li>
<li>掌握一个库</li>
</ul>
<h4 id="了解-Ajax-库的局限性"><a href="#了解-Ajax-库的局限性" class="headerlink" title="了解 Ajax 库的局限性"></a>了解 Ajax 库的局限性</h4><ul>
<li>所有 JavaScript 库都允许访问 Ajax 对象, 该对象规范了浏览器之间的差异, 并提供了一致的界面。然而, 在提供统一的界面时, 这些库也必须简化界面, 因为不是每个浏览器都实现每个特性。这将阻止您访问 XMLHttpRequest 的全部功能</li>
<li>直接与 XHR 对象交互还减少了函数开销, 进一步提高了性能。只是要注意, 如果放弃使用 Ajax 库, 可能会在使用更⽼、更晦涩的浏览器时遇到一些问题</li>
</ul>
<h4 id="利用适当的事件和回调函数"><a href="#利用适当的事件和回调函数" class="headerlink" title="利用适当的事件和回调函数"></a>利用适当的事件和回调函数</h4><ul>
<li>正确使用这些事件和它们各自的回调来操作 UI, 以获得更好的用户体验。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-comment">//Other code</span><br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;<br>        <span class="hljs-comment">// Update the UI here to reflect that the request was successful.</span><br>        <span class="hljs-title function_">doSomethingClever</span>();<br>    &#125;,<br>    <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;<br>        <span class="hljs-comment">// Update the UI here to reflect that the request was unsuccessful</span><br>        <span class="hljs-title function_">doSomethingMoreClever</span>();<br>    &#125;,<br>    <span class="hljs-attr">complete</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;<br>        <span class="hljs-comment">// Update the UI here to reflect completion</span><br>        <span class="hljs-title function_">doSomethingEvenMoreClever</span>();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="选择合适的格式"><a href="#选择合适的格式" class="headerlink" title="选择合适的格式"></a>选择合适的格式</h4><ul>
<li>在考虑数据传输技术时, 必须考虑以下几个因素: 特性集、兼容性、性能和方向(到服务器或从服务器)</li>
<li>在考虑数据格式时, 唯一需要比较的尺度是速度</li>
<li>没有一种数据格式总是比其他格式更好。根据正在传输的数据及其在页面上的预期用途, 一个可能下载得更快, 而另一个可能解析得更快</li>
</ul>
<h4 id="数据格式-XML"><a href="#数据格式-XML" class="headerlink" title="数据格式 - XML"></a>数据格式 - XML</h4><ul>
<li>XML<ul>
<li>极大的互操作性(在服务器端和客户端都有出⾊的支持)</li>
<li>严格的格式</li>
<li>容易验证</li>
<li>非常详细。每一个离散的数据都需要大量的结构, 而数据与结构的比率极低</li>
<li>XML的语法也有点模糊</li>
<li>解析这个语法同样是不明确的</li>
</ul>
</li>
<li>XML 在高性能 Ajax 中没有一席之地</li>
</ul>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul>
<li>JSON(JavaScript Object Notation)由Douglas Crockford形式化并推⼴开来, 是一种使用 JavaScript 对象和数组文字语法编写的轻量级且易于解析的数据格式。基于 ECMAScript 的一个子集</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// Verbose JSON 信息最多, 可读性好</span><br><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span> <br>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>     	<span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alice&quot;</span><span class="hljs-punctuation">,</span><br>     	<span class="hljs-attr">&quot;realname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Alice Smith&quot;</span><span class="hljs-punctuation">,</span> <br>     	<span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alice@alicesmith.com&quot;</span> <br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> ...<br><span class="hljs-punctuation">]</span><br><br><span class="hljs-comment">// Simple JSON 简化形式</span><br><span class="hljs-punctuation">[</span><br>	<span class="hljs-punctuation">&#123;</span> <br>    	<span class="hljs-attr">&quot;i&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    	<span class="hljs-attr">&quot;u&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alice&quot;</span><span class="hljs-punctuation">,</span><br>    	<span class="hljs-attr">&quot;r&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Alice Smith&quot;</span><span class="hljs-punctuation">,</span><br>    	<span class="hljs-attr">&quot;e&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alice@alicesmith.com&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> ...<br><span class="hljs-punctuation">]</span><br><br><span class="hljs-comment">// Array JSON</span><br><span class="hljs-punctuation">[</span><br>	<span class="hljs-punctuation">[</span><br>        <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <br>     	<span class="hljs-string">&quot;alice&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;Alice Smith&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;alice@alicesmith.com&quot;</span> <br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> ...<br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<h4 id="JSON-P"><a href="#JSON-P" class="headerlink" title="JSON-P"></a>JSON-P</h4><ul>
<li>Jsonp(JSON with Padding) 是 json 的一种”使用模式”, 可以让网页从别的域名(网站)那获取资料, 即跨域读取数据<ul>
<li>当使用动态脚本标记插⼊时, JSON 数据被视为另一个 JavaScript 文件, 并作为本机代码执行。为了实现这一点, 必须将数据包装在回调函数中</li>
</ul>
</li>
<li>由于数据被视为原生 JavaScript, 因此它将以原生 JavaScript 速度进行解析</li>
<li>有一个避免使用 JSON-P 的原因与性能无关: 由于 JSON-P 必须是可执行的 JavaScript, 任何人都可以调用它, 并在任何使用动态脚本标签插⼊的网站中包含它</li>
<li>不要在 JSON-P 中编码任何敏感数据, 因为即使使用随机 url 或 cookie, 也不能确保它保持私有</li>
</ul>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><ul>
<li>HTML作为一种数据格式, 既缓慢⼜臃肿</li>
</ul>
<h4 id="自定义格式"><a href="#自定义格式" class="headerlink" title="自定义格式"></a>自定义格式</h4><ul>
<li>这种格式非常简洁, 并提供了非常高的数据结构比(显著高于任何其他格式, 不包括纯文本)</li>
<li>最重要的决定之一是使用什么作为分隔符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1:alice:Alice Smith:alice@alicesmith.com;<br>2:bob:Bob Jones:bob@bobjones.com;<br></code></pre></td></tr></table></figure>
<h4 id="数据格式总结"><a href="#数据格式总结" class="headerlink" title="数据格式总结"></a>数据格式总结</h4><p>一般支持轻量级格式; 最好的格式是 JSON 和字符分隔的自定义格式。如果数据集很大, 解析时间成为问题, 可以使用以下两种技术之一:</p>
<ul>
<li>JSON-P 数据, 使用动态脚本标记插⼊获取。这将数据视为可执行的 JavaScript, 而不是字符串, 并允许极快的解析。这可以跨域使用, 但不应该用于敏感数据</li>
<li>字符分隔的自定义格式, 使用 XHR 或动态脚本标记插⼊获取, 并使用 split() 进行解析。这种技术解析超大数据集的速度略快于 JSON-P 技术, 而且通常具有较小的文件大小</li>
</ul>
<h4 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h4><p>最快的Ajax请求是不必发出的请求。防止不必要的请求有两种主要方法:</p>
<ul>
<li>在服务器端, 设置HTTP报头, 以确保响应将缓存在浏览器中</li>
<li>在客户端, 将获取的数据存储在本地, 这样就不会再次请求它</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/01/28/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-8-%E9%89%B4%E6%9D%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/28/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-8-%E9%89%B4%E6%9D%83/" class="post-title-link" itemprop="url">Web前端开发(8) 鉴权</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-28 14:33:02" itemprop="dateCreated datePublished" datetime="2023-01-28T14:33:02+08:00">2023-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前端鉴权"><a href="#前端鉴权" class="headerlink" title="前端鉴权"></a>前端鉴权</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><ul>
<li>认证(Identification) 是指根据声明者所特有的识别信息, 确认声明者的身份</li>
<li>比如我们常见的认证技术: <ul>
<li>身份证、用户名和密码、用户手机: 手机短信、手机⼆维码扫描、手势密码、用户的电子邮箱、用户的生物学特征: 指纹、语音、眼睛虹膜、用户的大数据识别等等</li>
</ul>
</li>
</ul>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><ul>
<li>授权(Authorization) 在信息安全领域是指资源所有者委派执行者, 赋予执行者指定范围的资源操作权限, 以便对资源的相关操作</li>
<li>互联网领域授权的机制: <ul>
<li>web 服务器的 session 机制</li>
<li>web 浏览器的 cookie 机制</li>
<li>颁发授权令牌(token)等</li>
</ul>
</li>
</ul>
<h4 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h4><ul>
<li>鉴权(Authentication) 在信息安全领域是指对于一个声明者所声明的身份权利, 对其所声明的真实性进行鉴别确认的过程。</li>
<li>若从授权出发, 则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系, 先授权, 后鉴权。</li>
<li>在互联网领域: 校验 session/cookie/token 的合法性和有效性</li>
<li>鉴权是一个承上启下的一个环节, 上游它接受授权的输出, 校验其真实性后, 然后获取权限(permission), 这个将会为下一步的权限控制做好准备。</li>
</ul>
<h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><ul>
<li>权限控制(Access/Permission Control) 将可执行的操作定义为权限列表, 然后判断操作是否允许/禁止</li>
<li>对于权限控制, 可以分为两部分进行理解: 一个是权限, 另一个是控制。权限是抽象的逻辑概念, 而控制是具体的实现方式。</li>
<li>在互联网领域: 通过 web 后端服务, 来控制接口访问, 允许或拒绝访问请求</li>
</ul>
<h4 id="彼此关系"><a href="#彼此关系" class="headerlink" title="彼此关系"></a>彼此关系</h4><ul>
<li>认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128144837324.png" alt="image-20230128144837324" style="zoom:80%;" /></p>
<h2 id="2-HTTP-基本鉴权"><a href="#2-HTTP-基本鉴权" class="headerlink" title="2. HTTP 基本鉴权"></a>2. HTTP 基本鉴权</h2><h4 id="HTTP-基本鉴权"><a href="#HTTP-基本鉴权" class="headerlink" title="HTTP 基本鉴权"></a>HTTP 基本鉴权</h4><ul>
<li>在 HTTP 中, 基本认证方案(Basic Access Authentication) 是允许客户端(通常指的就是网页浏览器)在请求时, 通过用户提供用户名和密码的方式, 实现对用户身份的验证。</li>
<li>几乎所有的线上网站都不会走该认证方案</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128145007284.png" alt="image-20230128145007284" style="zoom:80%;" /></p>
<h4 id="优缺点及场景"><a href="#优缺点及场景" class="headerlink" title="优缺点及场景"></a>优缺点及场景</h4><p>优点</p>
<ul>
<li>简单, 基本所有流行的浏览器都支持</li>
</ul>
<p>缺点</p>
<ul>
<li><p>不安全: </p>
<ul>
<li>由于是基于 HTTP 传输, 所以它在网络上几乎是裸奔的, 虽然它使用了 Base64 来编码, 但这个编码很容易就可以解码出来。</li>
<li>即使认证内容无法被解码为原始的用户名和密码也是不安全的, 恶意用户可以再获取了认证内容后使用其不断的向服务器发起请求, 这就是所谓的重放攻击。</li>
</ul>
</li>
<li><p>无法主动注销: </p>
<ul>
<li>由于 HTTP 协议没有提供机制清除浏览器中的 Basic 认证信息, 除非标签页或浏览器关闭、或用户清除历史记录。</li>
</ul>
</li>
</ul>
<p>使用场景</p>
<ul>
<li>内部网络, 或者对安全要求不是很高的网络</li>
</ul>
<h2 id="3-Session-Cookie-鉴权"><a href="#3-Session-Cookie-鉴权" class="headerlink" title="3. Session-Cookie 鉴权"></a>3. Session-Cookie 鉴权</h2><h3 id="3-1-Cookie"><a href="#3-1-Cookie" class="headerlink" title="3.1 Cookie"></a>3.1 Cookie</h3><ul>
<li>众所周知, HTTP 是无状态的协议(对于事务处理没有记忆能力, 每次客户端和服务端会话完成时, 服务端不会保存任何会话信息)</li>
<li>所以为了让服务器区分不同的客户端, 就必须主动的去维护一个状态, 这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态可以通过 Cookie 去实现</li>
</ul>
<h4 id="关于-cookie"><a href="#关于-cookie" class="headerlink" title="关于 cookie"></a>关于 cookie</h4><ul>
<li>cookie 对用户来说不是加密的<ul>
<li>服务器向客户端发送的所有 cookie 都能被客户端查看, 绝没有加密那样的安全性。</li>
</ul>
</li>
<li>用户可以删除或禁用cookie<ul>
<li>用户对 cookie 有绝对的控制权, 并且浏览器支持批量或单个删除 cookie。</li>
<li>用户也可以禁用 cookie, 但这更容易造成问题, 因为只有最简单的 Web 应用程序才不需要依赖 cookie。</li>
</ul>
</li>
<li>Cookie 存储在客户端, 可随意篡改, 不安全<ul>
<li>要确保 cookie 不被篡改, 请使用签名 cookie。</li>
</ul>
</li>
<li>cookie可以用于攻击<ul>
<li>跨站脚本攻击(XSS)攻击中有一种技术就涉及用恶意的 JavaScript 修改 cookie 中的内容。所以不要轻易相信返回到你的服务器的 cookie 内容。</li>
<li>用签名 cookie 会有帮助(不管是用户修改的还是恶意 JavaScript 修改的, 这些篡改都会在签名 cookie 中留下明显的痕迹), 并且还可以设定选项指明 cookie 只能由服务器修改。这些 cookie 的用途会受限, 但它们肯定更安全。</li>
</ul>
</li>
<li>有大小限制, 最大为 4kb</li>
<li>有数量限制, 一般一个浏览器对于一个网站只能存不超过 20 个 Cookie, 浏览器一般只允许存放 300个 Cookie</li>
<li>Android 和 IOS 对 Cookie 支持性不好</li>
<li>Cookie 是不可跨域的, 但是一级域名和⼆级域名是允许共享使用的(利用domain)</li>
</ul>
<h3 id="3-2-Session"><a href="#3-2-Session" class="headerlink" title="3.2 Session"></a>3.2 Session</h3><ul>
<li>Session 的抽象概念是会话, 是无状态协议通信过程中, 为了实现中断/继续操作, 将用户和服务器之间的交互进行的一种抽象</li>
<li>具体来说, 是服务器生成的一种 Session 结构, 可以通过多种方式保存, 如内存、数据库、⽂件等, 大型网站一般有专门的 Session 服务器集群来保存用户会话</li>
<li>原理流程: <ul>
<li>客户端: 用户向服务器首次发送请求</li>
<li>服务器: 接收到数据并自动为该用户创建特定的 Session / Session ID, 来标识用户并跟踪用户当前的会话过程</li>
<li>客户端: 浏览器收到响应获取会话信息, 并且会在下一次请求时带上 Session/Session ID</li>
<li>服务器: 服务器提取后会与本地保存的 Session ID 进行对比找到该特定用户的会话, 进而获取会话状态</li>
<li>⾄此客户端与服务器的通信变成有状态的通信</li>
</ul>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>Session 保存在服务器上</li>
<li>通过服务器自带的加密协议进行</li>
</ul>
<p>与 Cookie 的差异</p>
<ul>
<li>安全性: Cookie 由于保存在客户端, 可随意篡改, Session 则不同, 存储在服务器端, 无法伪造, 所以 Session 的安全性更高</li>
<li>存取值的类型不同: Cookie 只支持字符串数据, Session 可以存任意数据类型</li>
<li>有效期不同: Cookie 可设置为长时间保持, Session 一般失效时间较短</li>
<li>存储大小不同: Cookie 保存的数据不能超过 4K</li>
</ul>
<h4 id="会话的用途"><a href="#会话的用途" class="headerlink" title="会话的用途"></a>会话的用途</h4><ul>
<li>跨页保存用户的偏好</li>
<li>提供用户验证信息<ul>
<li>登录后就会创建一个会话。之后就不用在每次重新加载页面时再登录一次。</li>
<li>即便没有用户账号, 会话也有用。<ul>
<li>网站一般都要记住你喜欢如何排列东西, 或者喜欢哪种日期格式, 这些都不需要登录。</li>
</ul>
</li>
</ul>
</li>
<li>尽管建议优先选择会话而不是 cookie, 但理解 cookie 的⼯作机制也很重要(特别是因为有 cookie 才能用会话)。它对于你在应用中诊断问题、理解安全性及隐私问题都有帮助</li>
</ul>
<h3 id="3-3-Session-Cookie-鉴权"><a href="#3-3-Session-Cookie-鉴权" class="headerlink" title="3.3 Session-Cookie 鉴权"></a>3.3 Session-Cookie 鉴权</h3><ul>
<li>Session-Cookie 认证是利用服务端的 Session(会话)和浏览器(客户端)的 Cookie 来实现的前后端通信认证模式。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128185853425.png" alt="image-20230128185853425" style="zoom:80%;" /></p>
<h4 id="优缺点及使用场景"><a href="#优缺点及使用场景" class="headerlink" title="优缺点及使用场景"></a>优缺点及使用场景</h4><p>Session-Cookie 的优点</p>
<ul>
<li>Cookie 简单易用</li>
<li>Session 数据存储在服务端, 相较于 JWT 方便进行管理, 也就是当用户登录和主动注销, 只需要 添加删除对应的 Session 就可以了, 方便管理</li>
<li>只需要后端操作即可, 前端可以无感等进行操作</li>
</ul>
<p>Session-Cookie 的缺点</p>
<ul>
<li>依赖 Cookie, 一旦用户在浏览器端禁用 Cookie, 那么就无法使用了</li>
<li>非常不安全, Cookie 将数据暴露在浏览器中, 增加了数据被盗的风险(容易被 CSRF 等攻击)</li>
<li>Session 存储在服务端, 增大了服务端的开销, 用户量大的时候会大大降低服务器性能</li>
<li>对移动端的支持性不友好</li>
</ul>
<p>使用场景</p>
<ul>
<li>一般中大型的网站都适用(除了 APP 移动端)</li>
<li>由于一般的 Session 需集中存储在内存服务器上(如 Redis), 这样就会增加服务器的预算, 所 以预算不够请谨慎选择</li>
</ul>
<p>前端常用的 Session 库推荐</p>
<ul>
<li>使用 express: express-session</li>
<li>使用 koa: koa-session</li>
</ul>
<h2 id="4-Token"><a href="#4-Token" class="headerlink" title="4. Token"></a>4. Token</h2><h3 id="4-1-Token-令牌"><a href="#4-1-Token-令牌" class="headerlink" title="4.1 Token(令牌)"></a>4.1 Token(令牌)</h3><ul>
<li>Token 是一个令牌, 客户端访问服务器时, 验证通过后服务端会为其签发一张令牌, 之后, 客户端就可以携带令牌访问服务器, 服务端只需要验证令牌的有效性即可</li>
<li>一句话概括, 访问资源接口(API)时所需要的资源凭证</li>
<li>一般 Token 的组成: <ul>
<li>uid (用户唯一的身份标识) + time (当前时间的时间戳) + sign (签名, Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串)</li>
</ul>
</li>
</ul>
<h4 id="Token-的认证流程图"><a href="#Token-的认证流程图" class="headerlink" title="Token 的认证流程图"></a>Token 的认证流程图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128190802696.png" alt="image-20230128190802696" style="zoom:80%;" /></p>
<h4 id="Token-的优缺点"><a href="#Token-的优缺点" class="headerlink" title="Token 的优缺点"></a>Token 的优缺点</h4><p>Token 的优点: </p>
<ul>
<li>服务端无状态化、可扩展性好:  Token 机制在服务端不需要存储会话(Session)信息, 因为 Token 自身包含了其所标识用户的相关信息, 这有利于在多个服务间共享用户状态</li>
<li>支持 APP 移动端设备</li>
<li>安全性好: 有效避免 CSRF 攻击(因为不需要 Cookie)</li>
<li>支持跨程序调用: 因为 Cookie 是不允许跨域访问的, 而 Token 则不存在这个问题</li>
</ul>
<p>Token 的缺点: </p>
<ul>
<li>配合: 需要前后端配合处理</li>
<li>占带宽: 正常情况下比 sid 更大, 消耗更多流量, 挤占更多宽带</li>
<li>性能问题: 虽说验证 Token 时不用再去访问数据库或远程服务进行权限校验, 但是需要对 Token 加解密等操作, 所以会更耗性能</li>
<li>有效期短: 为了避免 Token 被盗用, 一般 Token 的有效期会设置的较短, 所以就有了 Refresh Token</li>
</ul>
<h3 id="4-2-Refresh-Token-刷新Token"><a href="#4-2-Refresh-Token-刷新Token" class="headerlink" title="4.2 Refresh Token (刷新Token)"></a>4.2 Refresh Token (刷新Token)</h3><ul>
<li>业务接口用来鉴权的 Token, 我们称之为 Access Token</li>
<li>为了安全, Access Token 有效期一般设置较短, 以避免被盗用。但过短的有效期会造成 Access Token 经常过期, 过期后则: <ul>
<li>一种办法是: 刷新 Access Token, 让用户重新登录获取新 Token, 会很麻烦</li>
<li>另外一种办法是: 再来一个 Token, 一个专门生成 Access Token 的 Token, 我们称为 Refresh Token<ul>
<li>Access Token: 用来访问业务接口, 由于有效期⾜够短, 盗用风险小, 也可以使请求方式更宽松灵活</li>
<li>Refresh Token: 用来获取 Access Token, 有效期可以长一些, 通过独立服务和严格的请求方式增加安全性；由于不常验证, 也可以如前面的 Session 一样处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Refresh-Token-的认证流程图"><a href="#Refresh-Token-的认证流程图" class="headerlink" title="Refresh Token 的认证流程图"></a>Refresh Token 的认证流程图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128191512099.png" alt="image-20230128191512099" style="zoom:80%;" /></p>
<h4 id="Token-和-Session-Cookie-的区别"><a href="#Token-和-Session-Cookie-的区别" class="headerlink" title="Token 和 Session-Cookie 的区别"></a>Token 和 Session-Cookie 的区别</h4><p>Session-Cookie 和 Token 有很多类似的地方, 但是 Token 更像是 Session-Cookie 的升级改良版</p>
<ul>
<li>存储地不同: Session 一般是存储在服务端；Token 是无状态的, 一般由前端存储</li>
<li>安全性不同:  Session 和 Token 并不⽭盾, 作为身份认证 Token 安全性比 Session 好, 因为每一个请求都有签名还能防止监听以及重放攻击</li>
<li>支持性不同:  Session-Cookie 认证需要靠浏览器的 Cookie 机制实现, 如果遇到原生 NativeAPP 时这种机制就不起作用了, 或是浏览器的 Cookie 存储功能被禁用, 也是无法使用该认证机制实现鉴权的；而 Token 验证机制丰富了客户端类型</li>
</ul>
<h3 id="4-3-JWT-JSON-Web-Token-鉴权"><a href="#4-3-JWT-JSON-Web-Token-鉴权" class="headerlink" title="4.3 JWT(JSON Web Token)鉴权"></a>4.3 JWT(JSON Web Token)鉴权</h3><ul>
<li>JWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案</li>
<li>就是登录成功后将相关用户信息组成 JSON 对象, 然后对这个对象进行某种方式的加密, 返回给客户端；客户端在下次请求时带上这个 Token；服务端再收到请求时校验 token 合法性, 其实也就是在校验请求的合法性</li>
<li>JWT 由三部分组成: Header 头部、Payload 负载、Signature 签名</li>
<li>它是一个很长的字符串, 中间用点(.)分隔成三个部分。如: <ul>
<li>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fw pMeJf36POk6yJV_adQssw5c</li>
</ul>
</li>
</ul>
<h4 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h4><ul>
<li>客户端收到服务器返回的 JWT, 可以储存在 Cookie 里面, 也可以储存在 localStorage</li>
<li>此后, 客户端每次与服务器通信, 都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送, 但是这样不能跨域, 所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面<ul>
<li>Authorization: Bearer &lt;token&gt;</li>
</ul>
</li>
</ul>
<h4 id="JWT-的认证流程图"><a href="#JWT-的认证流程图" class="headerlink" title="JWT 的认证流程图"></a>JWT 的认证流程图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128192136602.png" alt="image-20230128192136602" style="zoom:80%;" /></p>
<h4 id="JWT-的优缺点"><a href="#JWT-的优缺点" class="headerlink" title="JWT 的优缺点"></a>JWT 的优缺点</h4><p>JWT 的优点</p>
<ul>
<li>不需要在服务端保存会话信息(RESTful API 的原则之一就是无状态), 所以易于应用的扩展, 即信息不保存在服务端, 不会存在 Session 扩展不方便的情况</li>
<li>JWT 中的 Payload 负载可以存储常用信息, 用于信息交换, 有效地使用 JWT, 可以降低服务端查询数据库的次数</li>
</ul>
<p>JWT 的缺点</p>
<ul>
<li>加密问题: JWT 默认是不加密, 但也是可以加密的。生成原始 Token 以后, 可以用密钥再加密一次</li>
<li>到期问题: 由于服务器不保存 Session 状态, 因此无法在使用过程中废止某个 Token, 或者更改 Token 的权限。也就是说, 一旦 JWT 签发了, 在到期之前就会始终有效, 除非服务器部署额外的逻辑</li>
</ul>
<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><h4 id="单点登录-Single-Sign-On"><a href="#单点登录-Single-Sign-On" class="headerlink" title="单点登录(Single Sign On)"></a>单点登录(Single Sign On)</h4><ul>
<li>在同域下的客户端/服务端认证系统中, 通过客户端携带凭证, 可以维持一段时间内的登录状态</li>
<li>但随着企业的发展, 一个大型系统里可能包含 n 多子系统, 用户在操作不同的系统时, 需要多次登录, 很麻烦, 那么单点登录(SSO)就可以很好的解决这个问题的, 在多个应用系统中, 只需要登录一次, 就可以访问其他相互信任的应用系统</li>
</ul>
<h4 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h4><ul>
<li>OAuth 是一个开放标准, 允许用户授权第三方网站 (CSDN、思否等) 访问他们存储在另外的服务提供者上的信息, 而不需要将用户名和密码提供给第三方网站</li>
<li>常见的提供 OAuth 认证服务的厂商: 支付宝、QQ、微信、微博</li>
<li>简单说, OAuth 就是一种授权机制。数据的所有者告诉系统, 同意授权第三方应用进入系统, 获取这些数据。系统从而产生一个短期的进入令牌(Token), 用来代替密码, 供第三方应用使用</li>
<li>令牌(Token)与密码(Password)的作用是一样的, 都可以进入系统, 但是有三点差异<ul>
<li>令牌是短期的, 到期会自动失效: 用户自己无法修改。密码一般长期有效, 用户不修改, 就不会发生变化</li>
<li>令牌可以被数据所有者撤销, 会立即失效</li>
<li>令牌有权限范围(scope): 对于网络服务来说, 只读令牌就比读写令牌更安全。密码一般是完 整权限</li>
</ul>
</li>
</ul>
<h4 id="联合登录和信任登录"><a href="#联合登录和信任登录" class="headerlink" title="联合登录和信任登录"></a>联合登录和信任登录</h4><ul>
<li>联合登录 指同时包含多种凭证校验的登录服务, 同时, 也可以理解为使用第三方凭证进行校验的登录服务</li>
<li>信任登录 是指所有不需要用户主动参与的登录, 例如建立在私有设备与用户之间的绑定关系, 凭证就是私有设备的信息, 此时不需要用户再提供额外的凭证。信任登录又指用第三方比较成熟的用户库来校验凭证, 并登录当前访问的网站</li>
</ul>
<h4 id="唯一登录"><a href="#唯一登录" class="headerlink" title="唯一登录"></a>唯一登录</h4><p>唯一登录, 指的是禁止多人同时登录同一账号, 后者的登录行为, 会导致前者掉线</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128193458058.png" alt="image-20230128193458058" style="zoom:80%;" /></p>
<h4 id="扫码登录"><a href="#扫码登录" class="headerlink" title="扫码登录"></a>扫码登录</h4><ul>
<li>扫码登录通常见于移动端 APP 中, 很多 PC 端的网站都提供了扫码登录的功能, 无需在网页上输入任何账号和密码, 只需要让移动端 APP (如微信、淘宝、QQ等等) 中已登录用户主动扫描⼆维码, 再确认登录, 以使 PC 端的同款应用得以快速登录的方式就是扫码登录</li>
</ul>
<h4 id="一键登录-适用于原生APP"><a href="#一键登录-适用于原生APP" class="headerlink" title="一键登录(适用于原生APP)"></a>一键登录(适用于原生APP)</h4><ul>
<li>短信验证码的作用就是证明当前操作页面的用户与输入手机号的用户为相同的人, 那么实际上只要我们能够获取到当前手机使用的手机卡号, 直接使用这个号码进行登录, 不需要额外的操作, 这就是一键登录。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/01/10/JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/10/JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/" class="post-title-link" itemprop="url">JavaScript 从入门到放弃</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-10 00:49:41" itemprop="dateCreated datePublished" datetime="2023-01-10T00:49:41+08:00">2023-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-13 17:28:10" itemprop="dateModified" datetime="2023-08-13T17:28:10+08:00">2023-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVASCRIPT-编程语言"><a href="#JAVASCRIPT-编程语言" class="headerlink" title="JAVASCRIPT 编程语言"></a>JAVASCRIPT 编程语言</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-Hello-world"><a href="#1-1-Hello-world" class="headerlink" title="1.1 Hello,world!"></a>1.1 Hello,world!</h3><blockquote>
<p>一般来说，只有最简单的脚本才嵌入到 HTML 中。更复杂的脚本存放在单独的文件中。</p>
<p>使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的缓存中。</p>
<p>之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。</p>
<p>这可以节省流量，并使得页面(加载)更快。</p>
</blockquote>
<ul>
<li><p>如果设置了 <code>src</code> 特性，<code>script</code> 标签内容将会被忽略。</p>
<ul>
<li>一个单独的 <code>&lt;script&gt;</code> 标签不能同时有 <code>src</code> 特性和内部包裹的代码。</li>
</ul>
</li>
<li><p><code>type</code> 和 <code>language</code> 特性(attribute)不是必需的。</p>
</li>
<li><p>外部的脚本可以通过 <code>&lt;script src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt;</code> 的方式插入。</p>
</li>
</ul>
<h3 id="1-2-代码结构"><a href="#1-2-代码结构" class="headerlink" title="1.2 代码结构"></a>1.2 代码结构</h3><ul>
<li><p>分号</p>
<ul>
<li><p>当存在换行符(line break)时，在大多数情况下可以省略分号。JavaScript 将换行符理解成“隐式”的分号。这也被称为 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">自动分号插入</a>。</p>
</li>
<li><p>但存在 JavaScript 无法确定是否真的需要自动插入分号的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">forEach</span>(alert);<br><br><span class="hljs-comment">//被视为alert(&quot;Hello&quot;)[1, 2].forEach(alert); 只有第一个 Hello 会被显示出来，并且有一个报错</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>不支持注释嵌套！</strong></p>
</li>
</ul>
<h3 id="1-3-现代模式，”use-strict”"><a href="#1-3-现代模式，”use-strict”" class="headerlink" title="1.3 现代模式，”use strict”"></a>1.3 现代模式，”use strict”</h3><p>ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。需要一个特殊的指令 —— <code>&quot;use strict&quot;</code> 来明确地激活这些特性。</p>
<p>当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br>...<br></code></pre></td></tr></table></figure>
<p><code>&quot;use strict&quot;</code> 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。</p>
<ul>
<li><p><strong>确保 “use strict” 出现在最顶部</strong></p>
<ul>
<li>只有注释可以出现在 <code>&quot;use strict&quot;</code> 的上面。</li>
</ul>
</li>
<li><p><strong>没有办法取消</strong> <code>use strict</code></p>
</li>
<li><p>现代 JavaScript 支持 “class” 和 “module” —— 高级语言结构，它们会自动启用 <code>use strict</code>。因此，如果我们使用它们，则无需添加 <code>&quot;use strict&quot;</code> 指令。</p>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>我们可以使用 <code>var</code>、<code>let</code> 或 <code>const</code> 声明变量来存储数据。</p>
<ul>
<li><code>let</code> — 现代的变量声明方式。</li>
<li><code>var</code> — 老旧的变量声明方式。一般情况下，我们不会再使用它。</li>
<li><code>const</code> — 类似于 <code>let</code>，但是变量的值无法被修改。</li>
</ul>
<p>变量应当以一种容易理解变量内部是什么的方式进行命名。</p>
</li>
<li><p><strong>未采用</strong> <code>use strict</code> <strong>下的赋值</strong></p>
<ul>
<li><p>一般，我们需要在使用一个变量前定义它。但是在早期，我们可以不使用 <code>let</code> 进行变量声明，而可以简单地通过赋值来创建一个变量。现在如果我们不在脚本中使用 <code>use strict</code> 声明启用严格模式，这仍然可以正常工作，这是为了保持对旧脚本的兼容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注意：这个例子中没有 &quot;use strict&quot;</span><br><br>num = <span class="hljs-number">5</span>; <span class="hljs-comment">// 如果变量 &quot;num&quot; 不存在，就会被创建</span><br><br><span class="hljs-title function_">alert</span>(num); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>上面这是个糟糕的做法，严格模式下会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br>num = <span class="hljs-number">5</span>; <span class="hljs-comment">// 错误：num 未定义</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-数据类型"><a href="#1-5-数据类型" class="headerlink" title="1.5 数据类型"></a>1.5 数据类型</h3><p>JavaScript 中有八种基本的数据类型(译注：前七种为基本数据类型，也称为原始类型，而 <code>object</code> 为复杂数据类型)。</p>
<h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h4><ul>
<li><p>用于任何类型的数字：整数或浮点数，在 $\pm (2^{53}-1)$ 范围内的整数。</p>
</li>
<li><p>特殊数值(special numeric values)也属于这种类型：<code>Infinity</code>、<code>-Infinity</code> 和 <code>NaN</code>。</p>
<ul>
<li><p>可以通过除以 0 来得到它, 或者在代码中直接使用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-number">1</span> / <span class="hljs-number">0</span> ); <span class="hljs-comment">// Infinity</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Infinity</span> ); <span class="hljs-comment">// Infinity</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>NaN</code> 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;not a number&quot;</span> / <span class="hljs-number">2</span> ); <span class="hljs-comment">// NaN，这样的除法是错误的</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>NaN</code> 是粘性的。任何对 <code>NaN</code> 的进一步数学运算都会返回 <code>NaN</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">NaN</span> + <span class="hljs-number">1</span> ); <span class="hljs-comment">// NaN</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-number">3</span> * <span class="hljs-title class_">NaN</span> ); <span class="hljs-comment">// NaN</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;not a number&quot;</span> / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> ); <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 只有一个例外：NaN ** 0 (幂) 结果为 1</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="Bigint-类型"><a href="#Bigint-类型" class="headerlink" title="Bigint 类型"></a>Bigint 类型</h4><ul>
<li><p>用于任意长度的整数。</p>
</li>
<li><p>“number” 类型无法表示大于 $(2^{53}-1)$ (即 <code>9007199254740991</code>)，或小于 $-(2^{53}-1)$ 的整数</p>
</li>
<li><p>更准确的说，“number” 类型可以存储更大的整数(最多 1.7976931348623157 * $10^{308}$)，但超出安全整数范围 $±(2^{53}-1)$ 会出现精度问题，因为并非所有数字都适合固定的 64 位存储。因此，可能存储的是“近似值”。</p>
</li>
<li><p>可以通过将 <code>n</code> 附加到整数字段的末尾来创建 <code>BigInt</code> 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 尾部的 &quot;n&quot; 表示这是一个 BigInt 类型</span><br><span class="hljs-keyword">const</span> bigInt = <span class="hljs-number">1234567890123456789012345678901234567890n</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><ul>
<li><p>用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</p>
</li>
<li><p>JavaScript 中的字符串必须被括在引号里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&#x27;Single quotes are ok too&#x27;</span>;<br><span class="hljs-keyword">let</span> phrase = <span class="hljs-string">`can embed another <span class="hljs-subst">$&#123;str&#125;</span>`</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别。</p>
</li>
<li><p>反引号是 <strong>功能扩展</strong> 引号。它们允许我们通过将变量和表达式包装在 <code>$&#123;...&#125;</code> 中，来将它们嵌入到字符串中。</p>
</li>
<li><p><strong>JavaScript 中没有</strong> <em>character</em> <strong>类型。</strong></p>
</li>
</ul>
<h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h4><ul>
<li>用于 <code>true</code> 和 <code>false</code>。</li>
</ul>
<h4 id="null-值"><a href="#null-值" class="headerlink" title="null 值"></a>null 值</h4><ul>
<li>用于未知的值: 只有一个 <code>null</code> 值的独立类型</li>
<li><strong>不是</strong>一个 “对不存在的 <code>object</code> 的引用” 或者 “null 指针”</li>
</ul>
<h4 id="undefined-值"><a href="#undefined-值" class="headerlink" title="undefined 值"></a>undefined 值</h4><ul>
<li><p>用于未定义的值: 只有一个 <code>undefined</code> 值的独立类型。</p>
</li>
<li><p>通常，使用 <code>null</code> 将一个“空”或者“未知”的值写入变量中，而 <code>undefined</code> 则保留作为未进行初始化的事物的默认初始值</p>
</li>
</ul>
<h4 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h4><ul>
<li>用于创建对象的唯一标识符</li>
</ul>
<h4 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h4><ul>
<li>用于储存数据集合和更复杂的实体</li>
</ul>
<h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><ul>
<li><p>通常用作 <code>typeof x</code>，但 <code>typeof(x)</code> 也可行。</p>
</li>
<li><p>以字符串的形式返回类型名称，例如 <code>&quot;string&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>) <span class="hljs-comment">// &quot;symbol&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span> <span class="hljs-comment">// &quot;object&quot;  </span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;object&quot; </span><br><span class="hljs-keyword">typeof</span> alert <span class="hljs-comment">// &quot;function&quot;  </span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>typeof null</code> 会返回 <code>&quot;object&quot;</code> —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 <code>object</code></p>
<p>在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 <code>object</code> 类型。但是 <code>typeof</code> 会对函数区分对待，并返回 function</p>
</blockquote>
<h3 id="1-6-交互：alert、prompt、confirm"><a href="#1-6-交互：alert、prompt、confirm" class="headerlink" title="1.6 交互：alert、prompt、confirm"></a>1.6 交互：alert、prompt、confirm</h3><p><code>alert</code></p>
<ul>
<li>显示信息。对 <code>alert</code> 的调用没有返回值。或者说返回的是 <code>undefined</code>。</li>
</ul>
<p><code>prompt</code></p>
<ul>
<li>显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 Esc 键返回 <code>null</code>。以字符串形式返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">result = <span class="hljs-title function_">prompt</span>(title, [<span class="hljs-keyword">default</span>]);<br></code></pre></td></tr></table></figure>
<p><code>confirm</code></p>
<ul>
<li>显示信息等待用户点击确定或取消。点击确定返回 <code>true</code>，点击取消或按下 Esc 键返回 <code>false</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> isBoss = <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;Are you the boss?&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。</p>
<p>上述所有方法共有两个限制：</p>
<ol>
<li>模态窗口的确切位置由浏览器决定。通常在页面中心。</li>
<li>窗口的确切外观也取决于浏览器。我们不能修改它。</li>
</ol>
<h3 id="1-7-类型转换"><a href="#1-7-类型转换" class="headerlink" title="1.7 类型转换"></a>1.7 类型转换</h3><p>有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。</p>
<p><strong>字符串转换</strong> —— 转换发生在输出内容<code>alert</code>的时候，也可以通过 <code>String(value)</code> 进行显式转换。原始类型值的 string 类型转换通常是很明显的。</p>
<p><strong>数字型转换</strong> —— 转换发生在进行算术操作时，也可以通过 <code>Number(value)</code> 进行显式转换。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">变成</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>undefined</code></td>
<td style="text-align:left"><code>NaN</code></td>
</tr>
<tr>
<td style="text-align:left"><code>null</code></td>
<td style="text-align:left"><code>0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>true / false</code></td>
<td style="text-align:left"><code>1 / 0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">“按原样读取”字符串，两端的空白字符会被忽略。空字符串变成 <code>0</code>。转换出错则输出 <code>NaN</code>。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>布尔型转换</strong> —— 转换发生在进行逻辑操作时，也可以通过 <code>Boolean(value)</code> 进行显式转换。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">变成</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>&quot;&quot;</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left">其他值</td>
<td style="text-align:left"><code>true</code></td>
</tr>
</tbody>
</table>
</div>
<p>上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：</p>
<ul>
<li>对 <code>undefined</code> 进行数字型转换时，输出结果为 <code>NaN</code>，而非 <code>0</code></li>
<li>对 <code>&quot;0&quot;</code> 和只有空格的字符串(比如：<code>&quot; &quot;</code>)进行布尔型转换时，输出结果为 <code>true</code></li>
</ul>
<h3 id="1-8-基础运算符，数学运算"><a href="#1-8-基础运算符，数学运算" class="headerlink" title="1.8 基础运算符，数学运算"></a>1.8 基础运算符，数学运算</h3><p><strong>+, -, *, /, %, **</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-number">2</span> ** <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2² = 4</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-number">8</span> ** (<span class="hljs-number">1</span>/<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 2(1/3 次方与立方根相同)</span><br></code></pre></td></tr></table></figure>
<p><strong>用二元运算符 + 连接字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;my&quot;</span> + <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-title function_">alert</span>(s); <span class="hljs-comment">// mystring</span><br></code></pre></td></tr></table></figure>
<ul>
<li>注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;1&#x27;</span> ); <span class="hljs-comment">// &quot;41&quot;</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-number">2</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">// &quot;122&quot;</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-number">6</span> - <span class="hljs-string">&#x27;2&#x27;</span> ); <span class="hljs-comment">// 4，将 &#x27;2&#x27; 转换为数字</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;6&#x27;</span> / <span class="hljs-string">&#x27;2&#x27;</span> ); <span class="hljs-comment">// 3，将两个运算元都转换为数字</span><br></code></pre></td></tr></table></figure>
<p><strong>数字转化，一元运算符 +</strong></p>
<p>一元运算符加号，或者说，加号 <code>+</code> 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 <code>+</code> 则会将其转化为数字。它的效果和 <code>Number(...)</code> 相同，但是更加简短。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对数字无效</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-title function_">alert</span>( +x ); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 转化非数字</span><br><span class="hljs-title function_">alert</span>( +<span class="hljs-literal">true</span> ); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">alert</span>( +<span class="hljs-string">&quot;&quot;</span> );   <span class="hljs-comment">// 0</span><br><br><span class="hljs-keyword">let</span> apples = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">let</span> oranges = <span class="hljs-string">&quot;3&quot;</span>;<br><span class="hljs-comment">// 在二元运算符加号起作用之前，所有的值都被转化为了数字</span><br><span class="hljs-title function_">alert</span>( +apples + +oranges ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>
<p><strong>逗号运算符</strong></p>
<ul>
<li><p>逗号运算符能让我们处理多个语句，使用 <code>,</code> 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-number">3</span> + <span class="hljs-number">4</span>);<br><br><span class="hljs-title function_">alert</span>(a); <span class="hljs-comment">// 7(3 + 4 的结果)</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-9-值的比较"><a href="#1-9-值的比较" class="headerlink" title="1.9 值的比较"></a>1.9 值的比较</h3><ul>
<li><p>字符串的比较，会按照“词典”顺序逐字符地比较大小。</p>
<ul>
<li><code>&quot;a&quot;</code> 大于 <code>&quot;A&quot;</code></li>
</ul>
</li>
<li><p>当对不同类型的值进行比较时，它们会先被转化为数字(不包括严格相等检查)再进行比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-number">1</span> ); <span class="hljs-comment">// true，字符串 &#x27;2&#x27; 会被转化为数字 2</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;01&#x27;</span> == <span class="hljs-number">1</span> ); <span class="hljs-comment">// true，字符串 &#x27;01&#x27; 会被转化为数字 1</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">true</span> == <span class="hljs-number">1</span> ); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">false</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</strong></p>
</li>
<li><p>在非严格相等 <code>==</code> 下，<code>null</code> 和 <code>undefined</code> 相等且各自不等于任何其他的值。</p>
</li>
<li><p>在使用 <code>&gt; &gt;=</code> 或 <code>&lt; &lt;=</code> 进行比较时，需要注意变量可能为 <code>null/undefined</code> 的情况。比较好的方法是单独检查变量是否等于 <code>null/undefined</code>。</p>
<ul>
<li><code>null/undefined</code> 会被转化为数字：<code>null</code> 被转化为 <code>0</code>，<code>undefined</code> 被转化为 <code>NaN</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>奇怪的结果：null vs 0</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> &gt; <span class="hljs-number">0</span> );  <span class="hljs-comment">// (1) false</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// (2) false</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> &gt;= <span class="hljs-number">0</span> ); <span class="hljs-comment">// (3) true</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这是因为相等性检查 <code>==</code> 和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。</li>
<li><p>进行值的比较时，<code>null</code> 会被转化为数字，因此它被转化为了 <code>0</code>。</p>
<ul>
<li>(3)中 <code>null &gt;= 0</code> 返回值是 true</li>
<li>(1)中 <code>null &gt; 0</code> 返回值是 false</li>
</ul>
</li>
<li><p>另一方面，<code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值</p>
<ul>
<li>(2)中 <code>null == 0</code> 会返回 false。</li>
</ul>
</li>
</ul>
<p><strong>特立独行的 undefined</strong></p>
<p><code>undefined</code> 不应该被与其他值进行比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> &gt; <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (1)</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> &lt; <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (2)</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (3)</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>(1)</code> 和 <code>(2)</code> 都返回 <code>false</code> 是因为 <code>undefined</code> 在比较中被转换为了 <code>NaN</code>，而 <code>NaN</code> 是一个特殊的数值型值，它与任何值进行比较都会返回 <code>false</code>。</li>
<li><code>(3)</code> 返回 <code>false</code> 是因为这是一个相等性检查，而 <code>undefined</code> 只与 <code>null</code> 相等，不会与其他值相等。</li>
</ul>
</blockquote>
<h3 id="1-10-逻辑运算符"><a href="#1-10-逻辑运算符" class="headerlink" title="1.10 逻辑运算符"></a>1.10 逻辑运算符</h3><p><strong>或运算寻找第一个真值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">result = value1 || value2 || value3;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>或运算将返回第一个真值，如果不存在真值，就返回该链的最后一个值</p>
</li>
<li><p>获取变量列表或者表达式中的第一个真值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">let</span> lastName = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">let</span> nickName = <span class="hljs-string">&quot;SuperCoder&quot;</span>;<br><br><span class="hljs-title function_">alert</span>( firstName || lastName || nickName || <span class="hljs-string">&quot;Anonymous&quot;</span>); <span class="hljs-comment">// SuperCoder</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>短路求值(Short-circuit evaluation)</p>
<ul>
<li>有时，人们利用这个特性，只在左侧的条件为假时才执行命令</li>
</ul>
</li>
</ul>
<p><strong>与运算寻找第一个假值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">result = value1 &amp;&amp; value2 &amp;&amp; value3;<br></code></pre></td></tr></table></figure>
<ul>
<li>与运算返回第一个假值，如果没有假值就返回最后一个值</li>
</ul>
<blockquote>
<p>与运算 <code>&amp;&amp;</code> 在或运算 <code>||</code> 之前进行</p>
<ul>
<li>与运算 <code>&amp;&amp;</code> 的优先级比或运算 <code>||</code> 要高</li>
</ul>
<p>不要用 <code>||</code> 或 <code>&amp;&amp;</code> 来取代 <code>if</code></p>
</blockquote>
<p><strong><code>!</code>(非)</strong></p>
<ul>
<li><p><strong>两个非运算 <code>!!</code> 有时候用来将某个值转化为布尔类型：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( !!<span class="hljs-string">&quot;non-empty string&quot;</span> ); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">alert</span>( !!<span class="hljs-literal">null</span> ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>有更多详细的方法可以完成同样的事 —— 一个内建的 <code>Boolean</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&quot;non-empty string&quot;</span>) ); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">null</span>) ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>非运算符 <code>!</code> 的优先级在所有逻辑运算符里面最高，所以它总是在 <code>&amp;&amp;</code> 和 <code>||</code> 之前执行。</p>
</li>
</ul>
<h3 id="1-11-空值合并运算符’-’"><a href="#1-11-空值合并运算符’-’" class="headerlink" title="1.11 空值合并运算符’??’"></a>1.11 空值合并运算符’??’</h3><ul>
<li><p>当一个值既不是 <code>null</code> 也不是 <code>undefined</code> 时，我们将其称为“已定义的(defined)”。</p>
<ul>
<li><p><code>a ?? b</code> 的结果是：</p>
<ul>
<li>如果 <code>a</code> 是已定义的，则结果为 <code>a</code>，</li>
<li>如果 <code>a</code> 不是已定义的，则结果为 <code>b</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>??</code> 的常见使用场景是提供默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> firstName = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> lastName = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> nickName = <span class="hljs-string">&quot;Supercoder&quot;</span>;<br><br><span class="hljs-comment">// 显示第一个已定义的值：</span><br><span class="hljs-title function_">alert</span>(firstName ?? lastName ?? nickName ?? <span class="hljs-string">&quot;匿名&quot;</span>); <span class="hljs-comment">// Supercoder</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>与<code>||</code>比较</strong></p>
<ul>
<li><p>它们之间重要的区别是：</p>
<ul>
<li><code>||</code> 返回第一个 <strong>真</strong> 值。</li>
<li><code>??</code> 返回第一个 <strong>已定义的</strong> 值。</li>
</ul>
</li>
<li><p>换句话说，<code>||</code> 无法区分 <code>false</code>、<code>0</code>、空字符串 <code>&quot;&quot;</code> 和 <code>null/undefined</code>。它们都一样 —— 假值(falsy values)。如果其中任何一个是 <code>||</code> 的第一个参数，那么我们将得到第二个参数作为结果。</p>
</li>
<li><p><code>??</code> 运算符的优先级与 <code>||</code> 相同</p>
<ul>
<li>这意味着，就像 <code>||</code> 一样，空值合并运算符在 <code>=</code> 和 <code>?</code> 运算前计算，但在大多数其他运算(例如 <code>+</code> 和 <code>*</code>)之后计算。</li>
</ul>
</li>
<li><p>出于安全原因，JavaScript 禁止将 <code>??</code> 运算符与 <code>&amp;&amp;</code> 和 <code>||</code> 运算符一起使用，除非使用括号明确指定了优先级。</p>
</li>
</ul>
<h3 id="1-12-循环：while和for"><a href="#1-12-循环：while和for" class="headerlink" title="1.12 循环：while和for"></a>1.12 循环：while和for</h3><ul>
<li><p><strong>禁止</strong> <code>break/continue</code> <strong>在 ‘?’ 的右边</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(i &gt; <span class="hljs-number">5</span>) ? <span class="hljs-title function_">alert</span>(i) : <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 代码会停止运行，并显示有语法错误。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>break/continue 标签</strong></p>
<ul>
<li><p><strong>标签</strong> 是在循环之前带有冒号的标识符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">labelName</span>: <span class="hljs-keyword">for</span> (...) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>break &lt;labelName&gt;</code> 语句跳出循环至标签处：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">outer</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>    <span class="hljs-keyword">let</span> input = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">`Value at coords (<span class="hljs-subst">$&#123;i&#125;</span>,<span class="hljs-subst">$&#123;j&#125;</span>)`</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-comment">// 如果是空字符串或被取消，则中断并跳出这两个循环。</span><br>    <span class="hljs-keyword">if</span> (!input) <span class="hljs-keyword">break</span> outer; <span class="hljs-comment">// (*)</span><br>  &#125;<br>&#125;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Done!&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>我们还可以将标签移至单独一行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">outer</span>:<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123; ... &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>continue</code> 指令也可以与标签一起使用。在这种情况下，执行跳转到标记循环的下一次迭代。</p>
</li>
</ul>
</li>
<li><p><strong>标签并不允许“跳到”所有位置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">break</span> label;  <span class="hljs-comment">// 跳转至下面的 label 处(无效)</span><br><br><span class="hljs-attr">label</span>: <span class="hljs-keyword">for</span> (...)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>break</code> 指令必须在代码块内。从技术上讲，任何被标记的代码块都有效，例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">label</span>: &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">break</span> label; <span class="hljs-comment">// 有效</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>continue</code> 只有在循环内部才可行。</li>
</ul>
</li>
</ul>
<h3 id="1-14-switch语句"><a href="#1-14-switch语句" class="headerlink" title="1.14 switch语句"></a>1.14 switch语句</h3><ul>
<li><p><code>switch/case</code> 有通过 case 进行“分组”的能力，其实是 switch 语句没有 <code>break</code> 时的副作用。</p>
</li>
<li><p>这里的相等是<strong>严格相等</strong>。被比较的值必须是相同的类型才能进行匹配。</p>
</li>
</ul>
<h3 id="1-15-函数"><a href="#1-15-函数" class="headerlink" title="1.15 函数"></a>1.15 函数</h3><ul>
<li>作为参数传递给函数的值，会被复制到函数的局部变量。</li>
<li>如果在函数内部声明了同名变量，那么函数会 <strong>遮蔽</strong> 外部变量。</li>
<li>函数可以返回值。如果没有返回值或为空值，则其返回的结果是 <code>undefined</code>。</li>
</ul>
<blockquote>
<p>参数(parameter)是函数声明中括号内列出的变量(它是函数声明时的术语)</p>
<p>参数(argument)是调用函数时传递给函数的值(它是函数调用时的术语)</p>
</blockquote>
<ul>
<li>如果一个函数被调用，但有参数(argument)未被提供，那么相应的值就会变成 <code>undefined</code>。</li>
<li>我们可以使用 <code>=</code> 为函数声明中的参数指定所谓的“默认”(如果对应参数的值未被传递则使用)值：</li>
</ul>
<p><strong>不要在</strong> <code>return</code> <strong>与返回值之间添加新行</strong></p>
<ul>
<li>JavaScript 默认会在 <code>return</code> 之后加上分号。</li>
</ul>
<h3 id="1-16-函数表达式"><a href="#1-16-函数表达式" class="headerlink" title="1.16 函数表达式"></a>1.16 函数表达式</h3><ul>
<li><p>另一种创建函数的语法称为 <strong>函数表达式</strong>。它允许我们在任何表达式的中间创建一个新函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span> );<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>function</code> 关键字后面没有函数名。函数表达式允许省略函数名。</li>
</ul>
</li>
<li><p><strong>函数是值</strong>。它们可以在代码的任何地方被分配，复制或声明。</p>
<ul>
<li><p>我们还可以用 <code>alert</code> 显示这个变量的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span> );<br>&#125;<br><span class="hljs-keyword">let</span> func = sayHi; <span class="hljs-comment">// 复制</span><br><br><span class="hljs-title function_">alert</span>( sayHi ); <span class="hljs-comment">// 显示函数源代码</span><br><span class="hljs-title function_">func</span>(); <span class="hljs-comment">// 执行</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>回调函数</strong></p>
<ul>
<li><p>函数需要提出 <code>question</code>(问题)，并根据用户的回答，调用 <code>yes()</code> 或 <code>no()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()<br>  <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showOk</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;You agreed.&quot;</span> );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showCancel</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;You canceled the execution.&quot;</span> );<br>&#125;<br><br><span class="hljs-comment">// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask</span><br><span class="hljs-title function_">ask</span>(<span class="hljs-string">&quot;Do you agree?&quot;</span>, showOk, showCancel);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>ask</code> 的两个参数值 <code>showOk</code> 和 <code>showCancel</code> 可以被称为 <strong>回调函数</strong> 或简称 <strong>回调</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>匿名函数</strong></p>
<ul>
<li><p>我们可以使用函数表达式来编写一个等价的、更简洁的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()<br>  <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();<br>&#125;<br><br><span class="hljs-title function_">ask</span>(<br>  <span class="hljs-string">&quot;Do you agree?&quot;</span>,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;You agreed.&quot;</span>); &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;You canceled the execution.&quot;</span>); &#125;<br>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>这里直接在 <code>ask(...)</code> 调用内进行函数声明。这两个函数没有名字，所以叫 <strong>匿名函数</strong>。这样的函数在 <code>ask</code> 外无法访问(因为没有对它们分配变量)</p>
</li>
</ul>
</li>
<li><p>在执行代码块之前，内部算法会<strong>先处理函数声明</strong>。所以函数声明在其被声明的代码块内的任何位置都是可见的。</p>
</li>
<li><p><strong>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。</strong></p>
</li>
<li><p><strong>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</strong></p>
<ul>
<li><p>可以使用函数表达式，并将函数赋值给在 <code>if</code> 外声明的变量，并具有正确的可见性。</p>
</li>
<li><p>或者可以使用问号运算符 <code>?</code> 来进一步对代码进行简化：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;What is your age?&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-keyword">let</span> welcome = (age &lt; <span class="hljs-number">18</span>) ?<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>); &#125; :<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Greetings!&quot;</span>); &#125;;<br><br><span class="hljs-title function_">welcome</span>(); <span class="hljs-comment">// 现在可以了</span><br></code></pre></td></tr></table></figure>
<p>在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。</p>
<h3 id="1-17-箭头函数，基础知识"><a href="#1-17-箭头函数，基础知识" class="headerlink" title="1.17 箭头函数，基础知识"></a>1.17 箭头函数，基础知识</h3><p>创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好。它被称为“箭头函数”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2, ..., argN</span>) =&gt; expression;<br></code></pre></td></tr></table></figure>
<p>这里创建了一个函数 <code>func</code>，它接受参数 <code>arg1..argN</code>，然后使用参数对右侧的 <code>expression</code> 求值并返回其结果。</p>
<ul>
<li><p>如果我们只有一个参数，可以省略掉参数外的圆括号，使代码更短</p>
</li>
<li><p>如果没有参数，括号则是空的(但括号必须保留)</p>
</li>
<li><p>多行的箭头函数</p>
</li>
</ul>
<p>有时我们需要更复杂一点的函数，比如带有多行的表达式或语句。在这种情况下，我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 <code>return</code> 才能返回值(就像常规函数一样)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;  <span class="hljs-comment">// 花括号表示开始一个多行函数</span><br>  <span class="hljs-keyword">let</span> result = a + b;<br>  <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<h2 id="2-Object-对象-：基础知识"><a href="#2-Object-对象-：基础知识" class="headerlink" title="2. Object(对象)：基础知识"></a>2. Object(对象)：基础知识</h2><h3 id="2-1-对象"><a href="#2-1-对象" class="headerlink" title="2.1 对象"></a>2.1 对象</h3><p>可以通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>&#123;…&#125;</code> 来创建对象。一个属性就是一个键值对（“key: value”），其中键（<code>key</code>）是一个字符串（也叫做属性名），值（<code>value</code>）可以是任何值。</p>
<ul>
<li><p>可以用下面两种语法中的任一种来创建一个空的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// “构造函数” 的语法</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;;  <span class="hljs-comment">// “字面量” 的语法</span><br><br><span class="hljs-keyword">let</span> user = &#123;     <span class="hljs-comment">// 一个对象</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,  <span class="hljs-comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>        <span class="hljs-comment">// 键 &quot;age&quot;，值 30</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以使用点符号访问属性值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 读取文件的属性：</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">age</span> ); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>属性的值可以是任意类型，如添加一个布尔类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">user.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以用 <code>delete</code> 操作符移除属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> user.<span class="hljs-property">age</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>也可以用多字词语来作为属性名，但必须给它们加上引号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-string">&quot;likes birds&quot;</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 多词属性名必须加引号</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>对于多词属性，点操作就不能用了，另一种方法，就是使用方括号，可用于任何字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-comment">// 设置</span><br>user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 读取</span><br><span class="hljs-title function_">alert</span>(user[<span class="hljs-string">&quot;likes birds&quot;</span>]); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">delete</span> user[<span class="hljs-string">&quot;likes birds&quot;</span>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>方括号同样提供了一种可以通过任意表达式来获取属性名的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;likes birds&quot;</span>;<br><br><span class="hljs-comment">// 跟 user[&quot;likes birds&quot;] = true; 一样</span><br>user[key] = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
<p>在这里，变量 <code>key</code> 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。</p>
</li>
<li><p>当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 <strong>计算属性</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br><br><span class="hljs-keyword">let</span> bag = &#123;<br>  [fruit]: <span class="hljs-number">5</span>, <span class="hljs-comment">// 属性名是从 fruit 变量中得到的</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( bag.<span class="hljs-property">apple</span> ); <span class="hljs-comment">// 5 如果 fruit=&quot;apple&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>我们可以在方括号中使用更复杂的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;<br>  [fruit + <span class="hljs-string">&#x27;Computers&#x27;</span>]: <span class="hljs-number">5</span> <span class="hljs-comment">// bag.appleComputers = 5</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。</p>
</li>
<li><p>所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。</p>
</li>
</ul>
</li>
<li><p>属性值简写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: name,<br>    <span class="hljs-attr">age</span>: age,<br>    <span class="hljs-comment">// ……其他的属性</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">makeUser</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure>
<p>在上面的例子中，属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 <strong>属性值缩写</strong> 方法，使属性名变得更短。</p>
<p>可以用 <code>name</code> 来代替 <code>name:name</code> 像下面那样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    name, <span class="hljs-comment">// 与 name: name 相同</span><br>    age,  <span class="hljs-comment">// 与 age: age 相同</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以把属性名简写方式和正常方式混用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  name,  <span class="hljs-comment">// 与 name:name 相同</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>属性命名没有限制。属性名可以是任何字符串或者 symbol</p>
<ul>
<li><p>其他类型会被自动地转换为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span><br>&#125;;<br><br><span class="hljs-comment">// 都会输出相同的属性(数字 0 被转为字符串 &quot;0&quot;)</span><br><span class="hljs-title function_">alert</span>( obj[<span class="hljs-string">&quot;0&quot;</span>] ); <span class="hljs-comment">// test</span><br><span class="hljs-title function_">alert</span>( obj[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// test (相同的属性)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>这里有个小陷阱：一个名为 <code>__proto__</code> 的属性。我们不能将它设置为一个非对象的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">__proto__</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 分配一个数字</span><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// [object Object] —— 值为对象，与预期结果不同</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>属性存在性测试，”in”操作符</p>
<ul>
<li><p>相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！</p>
</li>
<li><p>读取不存在的属性只会得到 <code>undefined</code>。所以我们可以很容易地判断一个属性是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">noSuchProperty</span> === <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true: 没有这个属性</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>检查属性是否存在的操作符 <code>&quot;in&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，user.age 存在</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;blabla&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// false，user.blabla 不存在。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>请注意，<code>in</code> 的左边必须是 <strong>属性名</strong>。通常是一个带引号的字符串。</p>
<p>如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;age&quot;</span>;<br><span class="hljs-title function_">alert</span>( key <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，属性 &quot;age&quot; 存在</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>为何会有 <code>in</code> 运算符呢？</p>
<p>属性存在，但存储的值是 <code>undefined</code> 的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-literal">undefined</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-property">test</span> ); <span class="hljs-comment">// 显示 undefined，所以属性不存在？</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-keyword">in</span> obj ); <span class="hljs-comment">// true，属性存在！</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>“for..in” 循环</strong></p>
<ul>
<li><p>为了遍历一个对象的所有键(key)，可以使用一个特殊形式的循环：<code>for..in</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;<br>  <span class="hljs-comment">// keys</span><br>  <span class="hljs-title function_">alert</span>( key );  <span class="hljs-comment">// name, age, isAdmin</span><br>  <span class="hljs-comment">// 属性键的值</span><br>  <span class="hljs-title function_">alert</span>( user[key] ); <span class="hljs-comment">// John, 30, true</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>排序</p>
<ul>
<li><p>对象有顺序吗？如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？</p>
</li>
<li><p>整数属性会被进行排序，其他属性则按照创建的顺序显示。详情如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> codes = &#123;<br>  <span class="hljs-string">&quot;49&quot;</span>: <span class="hljs-string">&quot;Germany&quot;</span>,<br>  <span class="hljs-string">&quot;41&quot;</span>: <span class="hljs-string">&quot;Switzerland&quot;</span>,<br>  <span class="hljs-string">&quot;44&quot;</span>: <span class="hljs-string">&quot;Great Britain&quot;</span>,<br>  <span class="hljs-comment">// ..,</span><br>  <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> code <span class="hljs-keyword">in</span> codes) &#123;<br>  <span class="hljs-title function_">alert</span>(code); <span class="hljs-comment">// 1, 41, 44, 49</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-对象引用和复制"><a href="#2-2-对象引用和复制" class="headerlink" title="2.2 对象引用和复制"></a>2.2 对象引用和复制</h3><ul>
<li><p>对象通过引用被赋值和拷贝。<strong>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。</strong>因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p>
</li>
<li><p>所有通过被拷贝的引用的操作(如添加、删除属性)都作用在同一个对象上。</p>
</li>
<li><p>仅当两个对象为同一对象时，两者才相等。<code>==</code>，<code>===</code></p>
</li>
<li><p>我们可以创建一个新对象，通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = &#123;&#125;; <span class="hljs-comment">// 新的空对象</span><br><br><span class="hljs-comment">// 将 user 中所有的属性拷贝到其中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;<br>  clone[key] = user[key];<br>&#125;<br><br><span class="hljs-comment">// 现在 clone 是带有相同内容的完全独立的对象</span><br>clone.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 改变了其中的数据</span><br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 原来的对象中的 name 属性依然是 John</span><br></code></pre></td></tr></table></figure>
<ul>
<li>我们也可以使用 Object.assign 方法来达成同样的效果。</li>
</ul>
</li>
<li><p>为了创建“真正的拷贝”(一个克隆)，我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”(嵌套对象被通过引用进行拷贝)或者使用“深拷贝”函数，例如 <a target="_blank" rel="noopener" href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
<ul>
<li><p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, [src1, src2, src3...])<br></code></pre></td></tr></table></figure>
<ul>
<li>第一个参数 <code>dest</code> 是指目标对象。</li>
<li>更后面的参数 <code>src1, ..., srcN</code>(可按需传递多个参数)是源对象。</li>
<li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。</li>
<li>调用结果返回 <code>dest</code>。</li>
</ul>
</li>
<li><p>我们可以用它来合并多个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> permissions1 = &#123; <span class="hljs-attr">canView</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-keyword">let</span> permissions2 = &#123; <span class="hljs-attr">canEdit</span>: <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, permissions1, permissions2);<br><br><span class="hljs-comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span> &#125;);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>我们也可以用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>深层克隆</p>
<ul>
<li>属性可以是对其他对象的引用。</li>
<li>为了解决这个问题，我们应该使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。</li>
</ul>
</li>
<li><p><strong>使用 const 声明的对象也是可以被修改的</strong></p>
<p>通过引用对对象进行存储的一个重要的副作用是声明为 <code>const</code> 的对象 <strong>可以</strong> 被修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br>user.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// (*)</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Pete</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>user</code> 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改。</p>
</li>
<li><p>换句话说，只有当我们尝试将 <code>user=...</code> 作为一个整体进行赋值时，<code>const user</code> 才会报错。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-垃圾回收"><a href="#2-3-垃圾回收" class="headerlink" title="2.3 垃圾回收"></a>2.3 垃圾回收</h3><ul>
<li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li>
<li>当对象是可达状态时，它一定是存在于内存中的。</li>
<li>被引用与可访问(从一个根)不同：一组相互连接的对象可能整体都不可达</li>
</ul>
<p>垃圾回收的基本算法被称为 “mark-and-sweep”。定期执行以下“垃圾回收”步骤：</p>
<ol>
<li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li>
<li>然后它遍历并“标记”来自它们的所有引用。</li>
<li>然后它遍历标记的对象并标记 <strong>它们的</strong> 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li>
<li>没有被标记的对象都会被删除。</li>
</ol>
<p>一些优化建议：</p>
<ul>
<li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。</li>
<li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。</li>
<li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li>
</ul>
<p>现代引擎实现了垃圾回收的高级算法。</p>
<h3 id="2-4-对象方法，”this”"><a href="#2-4-对象方法，”this”" class="headerlink" title="2.4 对象方法，”this”"></a>2.4 对象方法，”this”</h3><ul>
<li><p>方法示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br>user.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure>
<ul>
<li>我们也可以使用预先声明的函数作为方法，就像这样：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 首先，声明函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 然后将其作为一个方法添加</span><br>user.<span class="hljs-property">sayHi</span> = sayHi;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>方法简写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这些对象作用一样</span><br>user = &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 方法简写看起来更好，对吧？</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span><br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>“this” 不受限制</strong></p>
<ul>
<li>JavaScript 中的 <code>this</code> 可以用于任何函数，即使它不是对象的方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p>
</li>
<li><p>例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br><br><span class="hljs-comment">// 在两个对象中使用相同的函数</span><br>user.<span class="hljs-property">f</span> = sayHi;<br>admin.<span class="hljs-property">f</span> = sayHi;<br><br><span class="hljs-comment">// 这两个调用有不同的 this 值</span><br><span class="hljs-comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span><br>user.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// John(this == user)</span><br>admin.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// Admin(this == admin)</span><br><br>admin[<span class="hljs-string">&#x27;f&#x27;</span>](); <span class="hljs-comment">// Admin(使用点符号或方括号语法来访问这个方法，都没有关系。)</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这个规则很简单：如果 <code>obj.f()</code> 被调用了，则 <code>this</code> 在 <code>f</code> 函数调用期间是 <code>obj</code>。所以在上面的例子中 this 先是 <code>user</code>，之后是 <code>admin</code>。</li>
</ul>
</li>
<li><p><strong>在没有对象的情况下调用：</strong><code>this == undefined</code></p>
<ul>
<li><p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会报错。</p>
</li>
<li><p>在非严格模式的情况下，<code>this</code> 将会是 <strong>全局对象</strong>（浏览器中的 <code>window</code>）。这是一个历史行为，<code>&quot;use strict&quot;</code> 已经将其修复了。</p>
</li>
</ul>
</li>
<li><p><strong>箭头函数没有自己的”this”</strong></p>
<ul>
<li><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部“正常的”函数。</p>
<p>举个例子，这里的 <code>arrow()</code> 使用的 <code>this</code> 来自于外部的 <code>user.sayHi()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ilya&quot;</span>,<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>);<br>    <span class="hljs-title function_">arrow</span>();<br>  &#125;<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Ilya</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-构造器和操作符-“new”"><a href="#2-5-构造器和操作符-“new”" class="headerlink" title="2.5 构造器和操作符 “new”"></a>2.5 构造器和操作符 “new”</h3><ul>
<li><p>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jack</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 <code>this</code>。</li>
<li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li>
<li>返回 <code>this</code> 的值。</li>
</ol>
</li>
<li><p>构造函数只能使用 <code>new</code> 来调用。这样的调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</p>
</li>
<li><p>从技术上讲，任何函数(除了箭头函数，它没有自己的 <code>this</code>)都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p>
</li>
<li><p><strong>new function() { … }</strong></p>
<p>如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个函数并立即使用 new 调用它</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// ……用于用户创建的其他代码</span><br>  <span class="hljs-comment">// 也许是复杂的逻辑和语句</span><br>  <span class="hljs-comment">// 局部变量等</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p>
</li>
<li><p>构造器的return</p>
<p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p>
<p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p>
<ul>
<li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li>
<li>如果 <code>return</code> 返回的是一个原始类型或空，则忽略。</li>
</ul>
</li>
<li><p><strong>省略括号</strong></p>
<p>如果没有参数，我们可以省略 <code>new</code> 后的括号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>; <span class="hljs-comment">// &lt;-- 没有参数</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>构造器中的方法</p>
<p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;My name is: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><br>john.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// My name is: John</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">john = &#123;</span><br><span class="hljs-comment">   name: &quot;John&quot;,</span><br><span class="hljs-comment">   sayHi: function() &#123; ... &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-6-可选链-“-”"><a href="#2-6-可选链-“-”" class="headerlink" title="2.6 可选链 “?.”"></a>2.6 可选链 “?.”</h3><ul>
<li><p>可选链 <code>?.</code> 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。</p>
</li>
<li><p>如果可选链 <code>?.</code> 前面的值为 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回 <code>undefined</code>。</p>
<p>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined(不报错)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>不要过度使用可选链</strong></p>
<ul>
<li>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</li>
<li>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</li>
<li>那么，如果 <code>user</code> 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</li>
</ul>
</li>
<li><p><code>?.</code> <strong>前的变量必须已声明</strong></p>
</li>
<li><p>如果 <code>?.</code> 左边部分不存在，就会立即停止运算(“短路效应”)。</p>
<p>因此，如果在 <code>?.</code> 的右侧有任何进一步的函数调用或操作，它们均不会执行。</p>
</li>
<li><p>其他变体：?.()，?.[]</p>
<ul>
<li><p>将 <code>?.()</code> 用于调用一个可能不存在的函数。</p>
<p>在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userAdmin = &#123;<br>  <span class="hljs-title function_">admin</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;I am admin&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> userGuest = &#123;&#125;;<br><br>userAdmin.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// I am admin</span><br><br>userGuest.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// 啥都没发生(没有这样的方法)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如果我们想使用方括号 <code>[]</code> 而不是点符号 <code>.</code> 来访问属性，语法 <code>?.[]</code> 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;firstName&quot;</span>;<br><br><span class="hljs-keyword">let</span> user1 = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> user2 = <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">alert</span>( user1?.[key] ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user2?.[key] ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>我们可以使用</strong> <code>?.</code> <strong>来安全地读取或删除，但不能写入</strong></p>
<ul>
<li><p>可选链 <code>?.</code> 不能用在赋值语句的左侧。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><br>user?.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// Error，不起作用</span><br><span class="hljs-comment">// 因为它在计算的是：undefined = &quot;John&quot;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可选链 <code>?.</code> 语法有三种形式：</p>
<ol>
<li><code>obj?.prop</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.prop</code>，否则返回 <code>undefined</code>。</li>
<li><code>obj?.[prop]</code> —— 如果 <code>obj</code> 存在则返回 <code>obj[prop]</code>，否则返回 <code>undefined</code>。</li>
<li><code>obj.method?.()</code> —— 如果 <code>obj.method</code> 存在则调用 <code>obj.method()</code>，否则返回 <code>undefined</code>。</li>
</ol>
</li>
</ul>
<h3 id="2-7-symbol类型"><a href="#2-7-symbol类型" class="headerlink" title="2.7 symbol类型"></a>2.7 symbol类型</h3><ul>
<li><p>根据规范，只有两种原始类型可以用作对象属性键：</p>
<ul>
<li><p>字符串类型</p>
</li>
<li><p>symbol 类型</p>
</li>
</ul>
<p>否则，如果使用另一种类型，例如数字，它会被自动转换为字符串。所以 <code>obj[1]</code> 与 <code>obj[&quot;1&quot;]</code> 相同，而 <code>obj[true]</code> 与 <code>obj[&quot;true&quot;]</code> 相同。</p>
</li>
<li><p><code>symbol</code> 是唯一标识符的基本类型</p>
</li>
<li><p>symbol 是使用带有可选描述(name)的 <code>Symbol()</code> 调用创建的。</p>
<p>创建时，我们可以给 symbol 一个描述(也称为 symbol 名)，这在代码调试时非常有用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// id 是描述为 &quot;id&quot; 的 symbol</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：<code>Symbol.for(key)</code> 返回(如果需要的话则创建)一个以 <code>key</code> 作为名字的全局 symbol。使用 <code>Symbol.for</code> 多次调用 <code>key</code> 相同的 symbol 时，返回的就是同一个 symbol。</p>
</li>
<li><p><strong>symbol 不会被自动转换为字符串</strong></p>
<ul>
<li><p>例如，这个 <code>alert</code> 将会提示出错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id); <span class="hljs-comment">// 类型错误：无法将 symbol 值转换为字符串。</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个。</li>
</ul>
</li>
<li><p>如果我们真的想显示一个 symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Symbol(id)，现在它有效了</span><br></code></pre></td></tr></table></figure>
<p>或者获取 <code>symbol.description</code> 属性，只显示描述(description)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-property">description</span>); <span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>symbol 有两个主要的使用场景：</p>
<ol>
<li><p>“隐藏” 对象属性。</p>
<ul>
<li><p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 <code>for..in</code> 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p>
</li>
<li><p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p>
</li>
<li><p>但如果我们处于同样的目的，使用字符串 <code>&quot;id&quot;</code> 而不是用 symbol，那么 <strong>就会</strong> 出现冲突：</p>
</li>
</ul>
</li>
<li><p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 <code>Symbol.*</code> 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 <code>Symbol.iterator</code> 来进行 <a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable">迭代</a> 操作，使用 <code>Symbol.toPrimitive</code> 来设置 <a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive">对象原始值的转换</a> 等等。</p>
</li>
</ol>
</li>
</ul>
<p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 symbol。还有一个名为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p>
<ul>
<li><p>对象字面量中的symbol</p>
<ul>
<li><p>如果我们要在对象字面量 <code>&#123;...&#125;</code> 中使用 symbol，则需要使用方括号把它括起来。</p>
<p>就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  [id]: <span class="hljs-number">123</span> <span class="hljs-comment">// 而不是 &quot;id&quot;：123</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这是因为我们需要变量 <code>id</code> 的值作为键，而不是字符串 “id”。</p>
</li>
</ul>
</li>
<li><p>全局symbol</p>
<ul>
<li><p>这里有一个 <strong>全局 symbol 注册表</strong>。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。</p>
</li>
<li><p>要从注册表中读取(不存在则创建)symbol，请使用 <code>Symbol.for(key)</code>。</p>
</li>
<li><p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 symbol，则返回该 symbol，否则将创建一个新 symbol(<code>Symbol(key)</code>)，并通过给定的 <code>key</code> 将其存储在注册表中。</p>
</li>
<li><p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 从全局注册表中读取</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 如果该 symbol 不存在，则创建它</span><br><br><span class="hljs-comment">// 再次读取(可能是在代码中的另一个位置)</span><br><span class="hljs-keyword">let</span> idAgain = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-comment">// 相同的 symbol</span><br><span class="hljs-title function_">alert</span>( id === idAgain ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对于全局 symbol，<code>Symbol.for(key)</code> 按名字返回一个 symbol。相反，通过全局 symbol 返回一个名字，我们可以使用 <code>Symbol.keyFor(sym)</code></p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">let</span> localSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSymbol) ); <span class="hljs-comment">// name，全局 symbol</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(localSymbol) ); <span class="hljs-comment">// undefined，非全局</span><br><br><span class="hljs-title function_">alert</span>( localSymbol.<span class="hljs-property">description</span> ); <span class="hljs-comment">// name</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-8-对象-—-原始值转换"><a href="#2-8-对象-—-原始值转换" class="headerlink" title="2.8 对象 — 原始值转换*"></a>2.8 对象 — 原始值转换*</h3><ul>
<li><p>JavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言(Ruby，C++)不同，我们无法实现特殊的对象处理方法来处理加法(或其他运算)。</p>
<p>在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果(也是一个原始值)。</p>
</li>
<li><p>转换规则</p>
<ul>
<li>没有转换为布尔值。所有的对象在布尔上下文(context)中均为 <code>true</code>，就这么简单。只有字符串和数字转换。</li>
<li>数字转换发生在对象相减或应用数学函数时。例如，<code>Date</code> 对象可以相减，<code>date1 - date2</code> 的结果是两个日期之间的差值。</li>
<li>至于字符串转换 —— 通常发生在我们像 <code>alert(obj)</code> 这样输出一个对象和类似的上下文中。</li>
</ul>
</li>
<li><p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p>
<p>这里有三种类型(hint)：</p>
<ul>
<li><code>&quot;string&quot;</code>(对于 <code>alert</code> 和其他需要字符串的操作)</li>
<li><code>&quot;number&quot;</code>(对于数学运算)</li>
<li><code>&quot;default&quot;</code>(少数运算符，通常对象以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换)</li>
</ul>
<p>规范明确描述了哪个运算符使用哪个 hint。</p>
<p>转换算法是：</p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</li>
<li>否则，如果 hint 是<code>&quot;string&quot;</code><ul>
<li>尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li>
</ul>
</li>
<li>否则，如果 hint 是<code>&quot;number&quot;</code>或者<code>&quot;default&quot;</code><ul>
<li>尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li>
</ul>
</li>
</ol>
<p>所有这些方法都必须返回一个原始值才能工作(如果已定义)。</p>
</li>
<li><p>在实际使用中，通常只实现 <code>obj.toString()</code> 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</p>
</li>
</ul>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><h3 id="3-1-原始类型的方法"><a href="#3-1-原始类型的方法" class="headerlink" title="3.1 原始类型的方法"></a>3.1 原始类型的方法</h3><ul>
<li><p>除 <code>null</code> 和 <code>undefined</code> 以外的原始类型都提供了许多有用的方法。我们后面的章节中学习这些内容。</p>
<ul>
<li><p>例如，字符串方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">str.toUpperCase()</a> 返回一个大写化处理的字符串。</p>
<p>用法演示如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">toUpperCase</span>() ); <span class="hljs-comment">// HELLO</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>很简单，对吧？以下是 <code>str.toUpperCase()</code> 中实际发生的情况：</p>
<ol>
<li>字符串 <code>str</code> 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有可用的方法，例如 <code>toUpperCase()</code>。</li>
<li>该方法运行并返回一个新的字符串(由 <code>alert</code> 显示)。</li>
<li>特殊对象被销毁，只留下原始值 <code>str</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p>从形式上讲，这些方法通过临时对象工作，但 JavaScript 引擎可以很好地调整，以在内部对其进行优化，因此调用它们并不需要太高的成本。</p>
</li>
<li><p><strong>构造器</strong> <code>String/Number/Boolean</code> <strong>仅供内部使用</strong></p>
<ul>
<li><p>像 Java 这样的一些语言允许我们使用 <code>new Number(1)</code> 或 <code>new Boolean(false)</code> 等语法，明确地为原始类型创建“对象包装器”。</p>
<p>在 JavaScript 中，由于历史原因，这也是可以的，但极其 <strong>不推荐</strong>。因为这样会出问题。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span> ); <span class="hljs-comment">// &quot;number&quot;</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// &quot;object&quot;!</span><br></code></pre></td></tr></table></figure>
<p>对象在 <code>if</code> 中始终为真，所以此处的 alert 将显示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> zero = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (zero) &#123; <span class="hljs-comment">// zero 为 true，因为它是一个对象</span><br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;zero is truthy?!?&quot;</span> );<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>另一方面，调用不带 <code>new</code>(关键字)的 <code>String/Number/Boolean</code> 函数是可以的且有效的。它们将一个值转换为相应的类型：转成字符串、数字或布尔值(原始类型)。</p>
<p>例如，下面完全是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 将字符串转成数字</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>null/undefined 没有任何方法</strong></p>
</li>
</ul>
<h3 id="3-2-数字类型"><a href="#3-2-数字类型" class="headerlink" title="3.2 数字类型"></a>3.2 数字类型</h3><p>要写有很多零的数字：</p>
<ul>
<li>将 <code>&quot;e&quot;</code> 和 0 的数量附加到数字后。就像：<code>123e6</code> 与 <code>123</code> 后面接 6 个 0 相同。</li>
<li><code>&quot;e&quot;</code> 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 <code>123e-6</code> 表示 <code>0.000123</code>(<code>123</code> 的百万分之一)。</li>
</ul>
<p>对于不同的数字系统：</p>
<ul>
<li>可以直接在十六进制(<code>0x</code>)，八进制(<code>0o</code>)和二进制(<code>0b</code>)系统中写入数字。</li>
<li><code>parseInt(str，base)</code> 将字符串 <code>str</code> 解析为在给定的 <code>base</code> 数字系统中的整数，<code>2 ≤ base ≤ 36</code>。</li>
<li><code>num.toString(base)</code> 将数字转换为在给定的 <code>base</code> 数字系统中的字符串。</li>
<li><strong>使用两个点来调用一个方法</strong><ul>
<li>请注意 <code>123456..toString(36)</code> 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 <code>toString</code>，那么我们需要在它后面放置两个点 <code>..</code>。</li>
<li>如果我们放置一个点：<code>123456.toString(36)</code>，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。</li>
<li>也可以写成 <code>(123456).toString(36)</code>。</li>
</ul>
</li>
</ul>
<p>对于常规数字检测：</p>
<ul>
<li><code>isNaN(value)</code> 将其参数转换为数字，然后检测它是否为 <code>NaN</code></li>
<li><code>isFinite(value)</code> 将其参数转换为数字，如果它是常规数字，则返回 <code>true</code>，而不是 <code>NaN/Infinity/-Infinity</code></li>
</ul>
<p>要将 <code>12pt</code> 和 <code>100px</code> 之类的值转换为数字：</p>
<ul>
<li>使用 <code>parseInt/parseFloat</code> 进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。</li>
</ul>
<p>小数：</p>
<ul>
<li>使用 <code>Math.floor</code>，<code>Math.ceil</code>，<code>Math.trunc</code>，<code>Math.round</code> 或 <code>num.toFixed(precision)</code> 进行舍入。</li>
<li>请确保记住使用小数时会损失精度。</li>
</ul>
<p>更多数学函数：</p>
<ul>
<li>需要时请查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a> 对象。这个库很小，但是可以满足基本的需求。</li>
</ul>
<h3 id="3-3-字符串"><a href="#3-3-字符串" class="headerlink" title="3.3 字符串"></a>3.3 字符串</h3><h3 id="3-4-数组"><a href="#3-4-数组" class="headerlink" title="3.4 数组"></a>3.4 数组</h3><h3 id="3-5-数组方法"><a href="#3-5-数组方法" class="headerlink" title="3.5 数组方法"></a>3.5 数组方法</h3><h3 id="3-6-Iterable-object-可迭代对象"><a href="#3-6-Iterable-object-可迭代对象" class="headerlink" title="3.6 Iterable object(可迭代对象)"></a>3.6 Iterable object(可迭代对象)</h3><h3 id="3-7-Map-and-Set-映射和集合"><a href="#3-7-Map-and-Set-映射和集合" class="headerlink" title="3.7 Map and Set(映射和集合)"></a>3.7 Map and Set(映射和集合)</h3><h3 id="3-8-WeakMap-and-WeakSet-弱映射和弱集合"><a href="#3-8-WeakMap-and-WeakSet-弱映射和弱集合" class="headerlink" title="3.8 WeakMap and WeakSet(弱映射和弱集合)"></a>3.8 WeakMap and WeakSet(弱映射和弱集合)</h3><h3 id="3-9-Object-keys，values，entries"><a href="#3-9-Object-keys，values，entries" class="headerlink" title="3.9 Object.keys，values，entries"></a>3.9 Object.keys，values，entries</h3><h3 id="3-10-解构赋值"><a href="#3-10-解构赋值" class="headerlink" title="3.10 解构赋值"></a>3.10 解构赋值</h3><h3 id="3-11-日期和时间"><a href="#3-11-日期和时间" class="headerlink" title="3.11 日期和时间"></a>3.11 日期和时间</h3><h3 id="3-12-JSON方法，toJSON"><a href="#3-12-JSON方法，toJSON" class="headerlink" title="3.12 JSON方法，toJSON"></a>3.12 JSON方法，toJSON</h3><h2 id="4-函数进阶"><a href="#4-函数进阶" class="headerlink" title="4. 函数进阶"></a>4. 函数进阶</h2><h2 id="5-对象属性配置"><a href="#5-对象属性配置" class="headerlink" title="5. 对象属性配置"></a>5. 对象属性配置</h2><h2 id="6-原型，继承"><a href="#6-原型，继承" class="headerlink" title="6. 原型，继承"></a>6. 原型，继承</h2><h3 id="6-1-原型继承"><a href="#6-1-原型继承" class="headerlink" title="6.1 原型继承"></a>6.1 原型继承</h3><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h4><p>在 JavaScript 中，所有的对象都有一个隐藏的 <code>[[Prototype]]</code> 属性，它要么是另一个对象，要么就是 <code>null</code>, 通过 <code>[[Prototype]]</code> 引用的对象被称为“原型”。</p>
<ul>
<li>我们可以使用 <code>obj.__proto__</code> 访问它(历史遗留下来的 getter/setter)。</li>
<li><strong>只能有一个</strong> <code>[[Prototype]]</code>。一个对象不能从其他两个对象获得继承</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222152010231.png" alt="image-20230222152010231" style="zoom:80%;" /></p>
<p>当我们从 <code>object</code> 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。在编程中，这被称为<strong>“原型继承”</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<br>	<span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-keyword">let</span> rabbit = &#123;<br>	<span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br>rabbit.<span class="hljs-property">__proto__</span> = animal; <span class="hljs-comment">// (*) 将 animal 设置为 rabbit 的原型。</span><br><br><span class="hljs-comment">// 现在这两个属性我们都能在 rabbit 中找到：</span><br><span class="hljs-title function_">alert</span>( rabbit.<span class="hljs-property">eats</span> ); <span class="hljs-comment">// true (**)</span><br><span class="hljs-title function_">alert</span>( rabbit.<span class="hljs-property">jumps</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p><strong>原型链</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<br>    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-title function_">walk</span>(<span class="hljs-params"></span>) &#123;<br>    	<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Animal walk&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> rabbit = &#123;<br>    <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">__proto__</span>: animal<br>&#125;;<br><br><span class="hljs-keyword">let</span> longEar = &#123;<br>    <span class="hljs-attr">earLength</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">__proto__</span>: rabbit<br>&#125;;<br><br><span class="hljs-comment">// walk 是通过原型链获得的</span><br>longEar.<span class="hljs-title function_">walk</span>(); <span class="hljs-comment">// Animal walk</span><br><span class="hljs-title function_">alert</span>(longEar.<span class="hljs-property">jumps</span>); <span class="hljs-comment">// true（从 rabbit）</span><br></code></pre></td></tr></table></figure>
<p>这里只有两个限制：</p>
<ol>
<li>引用不能形成闭环。如果我们试图给 <code>__proto__</code> 赋值但会导致引用形成闭环时，JavaScript 会抛出错误。</li>
<li><code>__proto__</code> 的值可以是对象，也可以是 <code>null</code>。而其他的类型都会被忽略。</li>
</ol>
<blockquote>
<p><strong><code>__proto__</code> 是 <code>[[Prototype]]</code> 的因历史原因而留下来的 getter/setter</strong></p>
<ul>
<li><p><code>__proto__</code> 与内部的 <code>[[Prototype]]</code> <strong>不一样</strong>。<code>__proto__</code> 是 <code>[[Prototype]]</code> 的 getter/setter。</p>
</li>
<li><p><code>__proto__</code> 属性有点过时了。它的存在是出于历史的原因，现代编程语言建议我们应该使用函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code> 来取代 <code>__proto__</code> 去 get/set 原型。</p>
</li>
<li><p>根据规范，<code>__proto__</code> 必须仅受浏览器环境的支持。但实际上，包括服务端在内的所有环境都支持它，因此我们使用它是非常安全的。</p>
</li>
</ul>
</blockquote>
<h4 id="写入不使用原型"><a href="#写入不使用原型" class="headerlink" title="写入不使用原型"></a>写入不使用原型</h4><p>写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222152746444.png" alt="image-20230222152746444" style="zoom:80%;" /></p>
<p><strong>“this”的值</strong></p>
<p><code>this</code> 不受原型的影响。</p>
<ul>
<li><p>无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，<strong><code>this</code> 始终是点符号 <code>.</code> 前面的对象。</strong></p>
</li>
<li><p>如果我们调用 <code>obj.method()</code>，而且 <code>method</code> 是从原型中获取的，<code>this</code> 仍然会引用 <code>obj</code>。因此，方法始终与当前对象一起使用，即使方法是继承的。</p>
</li>
</ul>
<h4 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h4><ul>
<li><code>for..in</code> 循环在其自身和继承的属性上进行迭代。所有其他的键/值获取方法仅对对象本身起作用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<br>  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> rabbit = &#123;<br>  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">__proto__</span>: animal<br>&#125;;<br><br><span class="hljs-comment">// Object.keys 只返回自己的 key</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(rabbit)); <span class="hljs-comment">// jumps</span><br><br><span class="hljs-comment">// for..in 会遍历自己以及继承的键</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> rabbit) <span class="hljs-title function_">alert</span>(prop); <span class="hljs-comment">// jumps，然后是 eats</span><br></code></pre></td></tr></table></figure>
<h3 id="6-2-F-prototype"><a href="#6-2-F-prototype" class="headerlink" title="6.2 F.prototype"></a>6.2 F.prototype</h3><p><code>F.prototype</code> 属性（不要把它与 <code>[[Prototype]]</code> 弄混了）在 <code>new F()</code> 被调用时为新对象的 <code>[[Prototype]]</code> 赋值。</p>
<ul>
<li>这里的 <code>F.prototype</code> 指的是 <code>F</code> 的一个名为 <code>&quot;prototype&quot;</code> 的常规属性</li>
<li><code>F.prototype</code> 的值要么是一个对象，要么就是 <code>null</code>：其他值都不起作用。</li>
<li><code>&quot;prototype&quot;</code> 属性仅当设置在一个构造函数上，并通过 <code>new</code> 调用时，才具有这种特殊的影响。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<br>  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = animal;<br><br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(<span class="hljs-string">&quot;White Rabbit&quot;</span>); <span class="hljs-comment">//  rabbit.__proto__ == animal</span><br><br><span class="hljs-title function_">alert</span>( rabbit.<span class="hljs-property">eats</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222153319547.png" style="zoom:80%;" /></p>
<h4 id="默认的-F-prototype-构造器属性"><a href="#默认的-F-prototype-构造器属性" class="headerlink" title="默认的 F.prototype, 构造器属性"></a>默认的 F.prototype, 构造器属性</h4><p>每个函数都有 <code>&quot;prototype&quot;</code> 属性，即使我们没有提供它。</p>
<p>默认的 <code>&quot;prototype&quot;</code> 是一个只有属性 <code>constructor</code> 的对象，属性 <code>constructor</code> 指向函数自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">// 默认：</span><br><span class="hljs-comment">// Rabbit.prototype = &#123; constructor: Rabbit &#125;</span><br><br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(); <span class="hljs-comment">// 继承自 &#123;constructor: Rabbit&#125;</span><br><span class="hljs-title function_">alert</span>(rabbit.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Rabbit</span>); <span class="hljs-comment">// true (from prototype)</span><br></code></pre></td></tr></table></figure>
<p>所以我们可以通过访问它的 <code>&quot;constructor&quot;</code> 属性来获取一个对象的构造器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。</span><br><span class="hljs-keyword">let</span> rabbit2 = <span class="hljs-keyword">new</span> rabbit.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">&quot;Black Rabbit&quot;</span></span>);<br></code></pre></td></tr></table></figure>
<p>在常规对象上，<code>prototype</code> 没什么特别的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">prototype</span>: <span class="hljs-string">&quot;Bla-bla&quot;</span> <span class="hljs-comment">// 这里只是普通的属性</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="6-3-原生的原型"><a href="#6-3-原生的原型" class="headerlink" title="6.3 原生的原型"></a>6.3 原生的原型</h3><h4 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-title function_">alert</span>( obj ); <span class="hljs-comment">// &quot;[object Object]&quot; ?</span><br></code></pre></td></tr></table></figure>
<p><code>obj = &#123;&#125;</code> 和 <code>obj = new Object()</code> 是一个意思，其中 <code>Object</code> 就是一个内建的对象构造函数，其自身的 <code>prototype</code> 指向一个带有 <code>toString</code> 和其他方法的一个巨大的对象。</p>
<p>当 <code>new Object()</code> 被调用（或一个字面量对象 <code>&#123;...&#125;</code> 被创建），这个对象的 <code>[[Prototype]]</code> 属性被设置为 <code>Object.prototype</code>：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222154740488.png" alt="image-20230222154740488" style="zoom:80%;" /></p>
<p>可以验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">toString</span> === obj.<span class="hljs-property">__proto__</span>.<span class="hljs-property">toString</span>); <span class="hljs-comment">//true</span><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">toString</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>); <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">// 请注意在 Object.prototype 上方的链中没有更多的 [[Prototype]]</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>
<h4 id="其他内建原型"><a href="#其他内建原型" class="headerlink" title="其他内建原型"></a>其他内建原型</h4><p>其他内建对象，像 <code>Array</code>、<code>Date</code>、<code>Function</code> 及其他，都在 prototype 上挂载了方法。</p>
<p>例如，当我们创建一个数组 <code>[1, 2, 3]</code>，在内部会默认使用 <code>new Array()</code> 构造器。因此 <code>Array.prototype</code> 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。</p>
<p>按照规范，所有的内建原型顶端都是 <code>Object.prototype</code>。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222155008991.png" alt="image-20230222155008991" style="zoom:80%;" /></p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>字符串、数字和布尔值并不是对象。但是如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 <code>String</code>、<code>Number</code> 和 <code>Boolean</code> 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。</p>
<p>这些对象对我们来说是无形地创建出来的。大多数引擎都会对其进行优化，但是规范中描述的就是通过这种方式。这些对象的方法也驻留在它们的 prototype 中，可以通过 <code>String.prototype</code>、<code>Number.prototype</code> 和 <code>Boolean.prototype</code> 进行获取。</p>
<blockquote>
<p>特殊值 <code>null</code> 和 <code>undefined</code> 比较特殊。它们没有对象包装器，所以它们没有方法和属性。并且它们也没有相应的原型。</p>
<p>原生的原型是可以被修改的, 但这通常是一个很不好的想法。</p>
<p>原型是全局的，所以很容易造成冲突。如果有两个库都添加了 <code>String.prototype.show</code> 方法，那么其中的一个方法将被另一个覆盖。</p>
<p><strong>在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。</strong></p>
<p>Polyfilling 是一个术语，表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">repeat</span>) &#123; <span class="hljs-comment">// 如果这儿没有这个方法</span><br>  <span class="hljs-comment">// 那就在 prototype 中添加它</span><br><br>  <span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">repeat</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-comment">// 重复传入的字符串 n 次</span><br><br>    <span class="hljs-comment">// 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）</span><br>    <span class="hljs-comment">// 但即使是不够完美的 polyfill 也常常被认为是足够好的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">join</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;La&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// LaLaLa</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="从原型中继承"><a href="#从原型中继承" class="headerlink" title="从原型中继承"></a>从原型中继承</h4><p>一些原生原型的方法通常会被借用。</p>
<p>例如，如果我们要创建类数组对象，则可能需要向其中复制一些 <code>Array</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Hello&quot;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;world!&quot;</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><br>obj.<span class="hljs-property">join</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">join</span>;<br><br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) ); <span class="hljs-comment">// Hello,world!</span><br></code></pre></td></tr></table></figure>
<p>上面这段代码有效，是因为内建的方法 <code>join</code> 的内部算法只关心正确的索引和 <code>length</code> 属性。它不会检查这个对象是否是真正的数组。许多内建方法就是这样。</p>
<p>另一种方式是通过将 <code>obj.__proto__</code> 设置为 <code>Array.prototype</code>，这样 <code>Array</code> 中的所有方法都自动地可以在 <code>obj</code> 中使用了。</p>
<p>但是如果 <code>obj</code> 已经从另一个对象进行了继承，那么这种方法就不可行了（译注：因为这样会覆盖掉已有的继承。此处 <code>obj</code> 其实已经从 <code>Object</code> 进行了继承，但是 <code>Array</code> 也继承自 <code>Object</code>，所以此处的方法借用不会影响 <code>obj</code> 对原有继承的继承，因为 <code>obj</code> 通过原型链依旧继承了 <code>Object</code>）。请记住，我们<strong>一次只能继承一个对象</strong>。</p>
<p>方法借用很灵活，它允许在需要时混合来自不同对象的方法。</p>
<h3 id="6-4-原型方法，没有-proto-的对象"><a href="#6-4-原型方法，没有-proto-的对象" class="headerlink" title="6.4 原型方法，没有 __proto__ 的对象"></a>6.4 原型方法，没有 <code>__proto__</code> 的对象</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/30/Node-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/Node-js/" class="post-title-link" itemprop="url">Node.js</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-30 00:49:41" itemprop="dateCreated datePublished" datetime="2022-12-30T00:49:41+08:00">2022-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Frontend/" itemprop="url" rel="index"><span itemprop="name">Frontend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Frontend/Node-js/" itemprop="url" rel="index"><span itemprop="name">Node.js</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="初识-Node-js-与内置模块"><a href="#初识-Node-js-与内置模块" class="headerlink" title="初识 Node.js 与内置模块"></a>初识 Node.js 与内置模块</h2><h3 id="1-fs-文件系统模块"><a href="#1-fs-文件系统模块" class="headerlink" title="1. fs 文件系统模块"></a>1. fs 文件系统模块</h3><h4 id="1-1-什么是-fs"><a href="#1-1-什么是-fs" class="headerlink" title="1.1 什么是 fs"></a>1.1 什么是 fs</h4><p>fs 模块是 Node.js 官方提供的，用来操作文件的模块。提供了一系列的方法和属性，用来满足用户对文件的操作需求</p>
<ul>
<li><code>fs.readFile()</code>: 用来读取指定文件的内容</li>
<li><code>fs.writeFile()</code>: 用来向指定的文件写入内容</li>
</ul>
<p>如果要在 JS 代码中，使用 fs 模块来操作文件，需要使用如下方式导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="1-2-读取指定文件的内容"><a href="#1-2-读取指定文件的内容" class="headerlink" title="1.2 读取指定文件的内容"></a>1.2 读取指定文件的内容</h4><p><strong><code>fs.readFile()</code>的语法格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(path[, options], callback)<br></code></pre></td></tr></table></figure>
<ul>
<li>参数1: 必选参数，字符串，表示文件的路径</li>
<li>参数2: 可选参数，表示以什么编码格式来读取文件</li>
<li>参数3: 必选参数，文件读取完成后，通过回调函数拿到读取的结果</li>
</ul>
<p><strong><code>fs.readFile()</code>的示例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以 UTF-8 的编码格式, 读取指定文件内容，并打印 err 和 dataStr 的值</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr);<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>读取成功</p>
<ul>
<li>err: null</li>
<li>dataStr: 文件内容</li>
</ul>
</li>
<li><p>读取失败</p>
<ul>
<li>err: 错误对象</li>
<li>dataStr: undefined</li>
</ul>
</li>
</ul>
<p><strong>判断文件是否读取成功</strong></p>
<p>可以判断 err 对象是否为 null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>    <span class="hljs-keyword">if</span>(err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件读取失败: &#x27;</span> + err.<span class="hljs-property">message</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件读取成功, 内容是: &#x27;</span> + dataStr);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="1-3-向指定文件写入内容"><a href="#1-3-向指定文件写入内容" class="headerlink" title="1.3 向指定文件写入内容"></a>1.3 向指定文件写入内容</h4><p><strong><code>fs.writeFile()</code>的语法格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">writeFile</span>(file, data[, options], callback)<br></code></pre></td></tr></table></figure>
<ul>
<li>参数1: 必选参数，需要制定一个文件路径的字符串</li>
<li>参数2: 必选参数，表示要写入的内容</li>
<li>参数3: 可选参数，表示以什么编码格式来写入文件内容, 默认值是 utf8</li>
<li>参数4: 必选参数，文件写入完成后的回调函数</li>
</ul>
<p><strong><code>fs.writeFile()</code>的示例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./11.txt&#x27;</span>, <span class="hljs-string">&#x27;Hello Node.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li>写入成功<ul>
<li>err: null</li>
</ul>
</li>
<li>写入失败<ul>
<li>err: 错误对象</li>
</ul>
</li>
</ul>
<p><strong>判断文件是否写入成功</strong></p>
<p>可以判断 err 对象是否为 null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./11.txt&#x27;</span>, <span class="hljs-string">&#x27;Hello Node.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span>(err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入失败: &#x27;</span> + err.<span class="hljs-property">message</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入成功&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="1-4-处理路径问题"><a href="#1-4-处理路径问题" class="headerlink" title="1.4 处理路径问题"></a>1.4 处理路径问题</h4><p>在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题</p>
<ul>
<li>原因：代码在运行时，会以<strong>执行 node 命令时所处的目录</strong>，动态拼接出被操作文件的完整路径</li>
<li>解决：直接提供完整的路径<ul>
<li><code>__dirname</code> 表示当前文件所处目录</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(__dirname + <span class="hljs-string">&#x27;/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="2-path-路径模块"><a href="#2-path-路径模块" class="headerlink" title="2. path 路径模块"></a>2. path 路径模块</h3><h4 id="2-1-什么是-path-路径模块"><a href="#2-1-什么是-path-路径模块" class="headerlink" title="2.1 什么是 path 路径模块"></a>2.1 什么是 path 路径模块</h4><p>path 模块是 Node.js 官方提供的，用来处理路径的模块。提供了一系列的方法和属性，用来满足用户对路径的处理需求</p>
<ul>
<li><code>path.join()</code>: 用来将多个路径片段拼接成一个完整的路径字符串</li>
<li><code>path.basename()</code>: 用来从路径字符串中，将文件名解析出来</li>
</ul>
<p>使用如下方法导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="2-2-路径拼接"><a href="#2-2-路径拼接" class="headerlink" title="2.2 路径拼接"></a>2.2 路径拼接</h4><p><strong><code>path.join()</code>的语法格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">join</span>([...paths])<br></code></pre></td></tr></table></figure>
<ul>
<li>参数: …paths 字符串类型，路径片段的序列</li>
<li>返回值: 字符串</li>
</ul>
<p><strong><code>path.join()</code>的代码示例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> pathStr = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-string">&#x27;/b/c&#x27;</span>, <span class="hljs-string">&#x27;../&#x27;</span>, <span class="hljs-string">&#x27;./d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathStr); <span class="hljs-comment">// 输出 \a\b\d\e</span><br><br><span class="hljs-keyword">const</span> pathStr2 = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./11.txt&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathStr2);<br></code></pre></td></tr></table></figure>
<ul>
<li>今后涉及到路径的拼接操作，使用 <code>path.join()</code>，不要直接使用 + 进行字符串的拼接</li>
</ul>
<h4 id="2-3-获取路径中的文件名"><a href="#2-3-获取路径中的文件名" class="headerlink" title="2.3 获取路径中的文件名"></a>2.3 获取路径中的文件名</h4><p><strong><code>path.basename()</code>的语法格式</strong></p>
<p>使用 <code>path.basename()</code> 可以获取到路径中的最后一部分，常通过该方法获取路径中的文件名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">basename</span>(path[, ext])<br></code></pre></td></tr></table></figure>
<ul>
<li>path: 必选参数，表示一个路径的字符串</li>
<li>ext: 可选参数，表示文件扩展名的字符串</li>
<li>返回值: 路径中的最后一部分</li>
</ul>
<p><strong><code>path.basename()</code>的代码示例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><span class="hljs-keyword">var</span> fullName = path.<span class="hljs-title function_">basename</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName) <span class="hljs-comment">// index.html</span><br><br><span class="hljs-keyword">var</span> nameWithoutExt = path.<span class="hljs-title function_">basename</span>(fpath, <span class="hljs-string">&#x27;.html&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nameWithoutExt) <span class="hljs-comment">//index</span><br></code></pre></td></tr></table></figure>
<h4 id="2-4-获取路径中的文件扩展名"><a href="#2-4-获取路径中的文件扩展名" class="headerlink" title="2.4 获取路径中的文件扩展名"></a>2.4 获取路径中的文件扩展名</h4><p><strong><code>path.extname()</code>的语法格式</strong></p>
<p>使用 <code>path.extname()</code> 可以获取到路径中的扩展名部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">extname</span>(path)<br></code></pre></td></tr></table></figure>
<ul>
<li>path: 必选参数，表示一个路径的字符串</li>
<li>返回值: 扩展名字符串</li>
</ul>
<p><strong><code>path.extname()</code>的代码示例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><span class="hljs-keyword">const</span> fext = path.<span class="hljs-title function_">extname</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fext) <span class="hljs-comment">// .html</span><br></code></pre></td></tr></table></figure>
<h3 id="3-http-模块"><a href="#3-http-模块" class="headerlink" title="3. http 模块"></a>3. http 模块</h3><h4 id="3-1-什么是-http-模块"><a href="#3-1-什么是-http-模块" class="headerlink" title="3.1 什么是 http 模块"></a>3.1 什么是 http 模块</h4><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 <code>http.createServer()</code> 方法，就能方便地把一台普通的电脑，变成一台 web 服务器，从而对外提供服务</p>
<p>使用如下方法导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="3-2-创建基本-Web-服务器"><a href="#3-2-创建基本-Web-服务器" class="headerlink" title="3.2 创建基本 Web 服务器"></a>3.2 创建基本 Web 服务器</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 创建 web 服务器实例</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br><span class="hljs-comment">// 为服务器实例绑定 request 事件，监听客户端的请求</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-comment">// 只要有请求，就会触发 request 事件，从而调用这个事件处理函数</span><br>    <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>    <span class="hljs-keyword">const</span> method = req.<span class="hljs-property">method</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-string">`Your request url is <span class="hljs-subst">$&#123;url&#125;</span>, and request method is <span class="hljs-subst">$&#123;method&#125;</span>`</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br><br>    <span class="hljs-comment">// 设置 Content-Type 响应头，解决中文乱码的问题</span><br>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>    <span class="hljs-comment">// 向客户端响应内容</span><br>    res.<span class="hljs-title function_">end</span>(str)<br>&#125;)<br><br><span class="hljs-comment">// 调用 .listen() 方法就能启动服务器</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p><strong>req 请求对象</strong></p>
<p>只要服务器接收到了客户端的请求，就会调用通过 <code>server.on()</code> 为服务器绑定的 request 事件处理函数</p>
<p>如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用 req 对象</p>
<p><strong>res 响应对象</strong></p>
<p>在服务器的 request 事件处理函数中，访问与服务器相关的数据或属性，可以使用 req 对象</p>
<h4 id="3-3-根据不同-url-响应不同内容"><a href="#3-3-根据不同-url-响应不同内容" class="headerlink" title="3.3 根据不同 url 响应不同内容"></a>3.3 根据不同 url 响应不同内容</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-comment">// 设置默认的响应内容为 404 Not found</span><br>  <span class="hljs-keyword">let</span> content = <span class="hljs-string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br>  <span class="hljs-comment">// 判断用户请求的是否为 / 或 /index.html 首页</span><br>  <span class="hljs-comment">// 判断用户请求的是否为 /about.html 关于页面</span><br>  <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/&#x27;</span> || url === <span class="hljs-string">&#x27;/index.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/about.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br>  &#125;<br><br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>  res.<span class="hljs-title function_">end</span>(content)<br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="1-模块化的基本概念"><a href="#1-模块化的基本概念" class="headerlink" title="1. 模块化的基本概念"></a>1. 模块化的基本概念</h3><h4 id="1-1-什么是模块化"><a href="#1-1-什么是模块化" class="headerlink" title="1.1 什么是模块化"></a>1.1 什么是模块化</h4><ul>
<li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li>
<li>编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并相互依赖的多个小模块</li>
<li>模块化可提高代码的复用性和可维护性，实现按需加载。</li>
</ul>
<h4 id="1-2-模块化规范"><a href="#1-2-模块化规范" class="headerlink" title="1.2 模块化规范"></a>1.2 模块化规范</h4><ul>
<li>模块化规范是对代码进行模块化拆分和组合时，需要遵守的规则<ul>
<li>如使用何种语法格式引用模块和向外暴露成员</li>
</ul>
</li>
</ul>
<h3 id="2-Node-js-中的模块化"><a href="#2-Node-js-中的模块化" class="headerlink" title="2. Node.js 中的模块化"></a>2. Node.js 中的模块化</h3><h4 id="2-1-Node-js-中模块的分类"><a href="#2-1-Node-js-中模块的分类" class="headerlink" title="2.1 Node.js 中模块的分类"></a>2.1 Node.js 中模块的分类</h4><ul>
<li>内置模块：由 Node.js 官方提供的，例如 fs, path, http 等</li>
<li>自定义模块：用户创建的每个 .js 文件，都是自定义模块</li>
<li>第三方模块：由第三方开发出来的模块，使用前需下载</li>
</ul>
<h4 id="2-2-加载模块"><a href="#2-2-加载模块" class="headerlink" title="2.2 加载模块"></a>2.2 加载模块</h4><ul>
<li><code>require()</code> 方法，可以加载三类模块，只有加载自定义模块需要路径名(可以省略后缀名)<ul>
<li>使用 <code>require()</code> 加载模块时，会执行被加载模块中的代码</li>
</ul>
</li>
</ul>
<h4 id="2-3-模块作用域"><a href="#2-3-模块作用域" class="headerlink" title="2.3 模块作用域"></a>2.3 模块作用域</h4><ul>
<li><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</p>
</li>
<li><p>可以防止全局变量污染</p>
</li>
</ul>
<h4 id="2-4-向外共享模块作用域中的成员"><a href="#2-4-向外共享模块作用域中的成员" class="headerlink" title="2.4 向外共享模块作用域中的成员"></a>2.4 向外共享模块作用域中的成员</h4><p><strong><code>module</code> 对象</strong></p>
<ul>
<li>每个 .js 自定义模块中都有一个 <code>module</code> 对象，它里面存储了和当前模块有关的信息</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">Module <span class="hljs-punctuation">&#123;</span><br>  id<span class="hljs-punctuation">:</span> &#x27;.&#x27;<span class="hljs-punctuation">,</span><br>  path<span class="hljs-punctuation">:</span> &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\VSC\\nodejs&#x27;<span class="hljs-punctuation">,</span><br>  exports<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  filename<span class="hljs-punctuation">:</span> &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\VSC\\nodejs\\a.js&#x27;<span class="hljs-punctuation">,</span><br>  loaded<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  children<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  paths<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\VSC\\nodejs\\node_modules&#x27;<span class="hljs-punctuation">,</span><br>    &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\VSC\\node_modules&#x27;<span class="hljs-punctuation">,</span><br>    &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\node_modules&#x27;<span class="hljs-punctuation">,</span><br>    &#x27;E<span class="hljs-punctuation">:</span>\\node_modules&#x27;<br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p><strong><code>module.exports</code> 对象</strong></p>
<ul>
<li>在自定义模块中，可以使用 <code>module.exports</code> 对象，将模块内的成员共享出去，供外界使用。</li>
<li>外界使用 <code>require()</code> 导入自定义模块时，得到的就是 <code>module.exports</code> 指向的对象。</li>
<li>使用 <code>require()</code> 导入模块时，<strong>导入的结果永远以 <code>module.exports</code> 指向的对象为准</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 向 module.exports 对象上挂载属性和方法</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;zs&#x27;</span>;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong><code>exports</code> 对象</strong></p>
<ul>
<li>默认情况下，<code>exports</code> 和 <code>module.exports</code> 指向同一个对象。<strong>最终共享的结果，以 <code>module.exports</code> 指向的对象为准。</strong></li>
</ul>
<h4 id="2-5-Node-js-中的模块化规范"><a href="#2-5-Node-js-中的模块化规范" class="headerlink" title="2.5 Node.js 中的模块化规范"></a>2.5 Node.js 中的模块化规范</h4><p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何互相依赖</p>
<p><strong>CommonJS 模块化规范</strong></p>
<ul>
<li>每个模块内部，<code>module</code> 变量代表当前模块</li>
<li><code>module</code> 变量是一个对象，<code>module.exports</code> 是对外的接口</li>
<li>加载某个模块即加载该模块的 <code>module.exports</code> 属性，<code>require()</code> 用于加载模块</li>
</ul>
<h3 id="3-npm-与包"><a href="#3-npm-与包" class="headerlink" title="3. npm 与包"></a>3. npm 与包</h3><h4 id="3-1-包"><a href="#3-1-包" class="headerlink" title="3.1 包"></a>3.1 包</h4><ul>
<li>Node.js 中的第三方模块又叫做包，由第三方个人或团队开发出来，免费供所有人使用</li>
<li>包是基于内置模块封装出来的</li>
</ul>
<h4 id="3-2-npm"><a href="#3-2-npm" class="headerlink" title="3.2 npm"></a>3.2 npm</h4><p><strong>初次装包后多了哪些文件</strong></p>
<ul>
<li>node_modules 文件夹<ul>
<li>用来存放所有已安装到项目中的包</li>
</ul>
</li>
<li>package-lock.json 配置文件<ul>
<li>记录 node_modules 目录下的每一个包的下载信息，例如包名、版本号、下载地址</li>
</ul>
</li>
<li>不需要手动修改，npm 会自动维护</li>
</ul>
<p><strong>安装指定版本的包</strong></p>
<ul>
<li>默认安装最新版本的包，可以通过 <code>包名@版本号</code> 指定具体版本</li>
</ul>
<p><strong>包的语义化版本规范</strong></p>
<p>分为三位数字，以”点分十进制”形式进行定义, eg. <code>2.24.0</code></p>
<ul>
<li>第 1 位: 大版本</li>
<li>第 2 位: 功能版本</li>
<li>第 3 位: Bug修复版本</li>
</ul>
<h4 id="3-3-包管理配置文件"><a href="#3-3-包管理配置文件" class="headerlink" title="3.3 包管理配置文件"></a>3.3 包管理配置文件</h4><p>npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置信息，例如</p>
<ul>
<li>项目的名称、版本号、描述等</li>
<li>项目中都用到了哪些包</li>
<li>哪些包只在开发期间会用到</li>
<li>哪些包在开发和部署时都需要用到</li>
</ul>
<p><strong>快速创建 package.json</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm init -y<br></code></pre></td></tr></table></figure>
<p><strong>安装包</strong></p>
<p>使用 <code>npm i(nstall)</code> 可以一次性安装所有的依赖包</p>
<ul>
<li>会先读取 package.json 中的 dependencies 节点</li>
</ul>
<p><strong>卸载包</strong></p>
<p><code>npm uninstall</code></p>
<p><strong>devDependencies 节点</strong></p>
<p>如果某些包只在项目开发阶段用到，项目上线后不会用到，则建议把这些包记录到 devDependencies 节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 记录到 devDependencies 节点</span><br>npm i 包名 -D<br><span class="hljs-comment"># 上面是简写，等价于下方完整写法</span><br>npm install 包名 --save-dev<br></code></pre></td></tr></table></figure>
<p>与之相对，如果某些包在开发和上线都需要用到，则建议把这些包记录到 dependencies 节点</p>
<h4 id="3-4-npm-换源"><a href="#3-4-npm-换源" class="headerlink" title="3.4 npm 换源"></a>3.4 npm 换源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前下载源</span><br>npm config get registry<br><span class="hljs-comment"># 切换为淘宝源</span><br>npm config <span class="hljs-built_in">set</span> registry=http://registry.npmmirror.com<br></code></pre></td></tr></table></figure>
<h3 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="4. 模块的加载机制"></a>4. 模块的加载机制</h3><h4 id="4-1-优先从缓存中加载"><a href="#4-1-优先从缓存中加载" class="headerlink" title="4.1 优先从缓存中加载"></a>4.1 优先从缓存中加载</h4><p><strong>模块第一次加载后会被缓存</strong>，即多次调用 <code>require()</code> 不会导致模块的代码被执行多次，提高模块加载效率</p>
<h4 id="4-2-内置模块的加载机制"><a href="#4-2-内置模块的加载机制" class="headerlink" title="4.2 内置模块的加载机制"></a>4.2 内置模块的加载机制</h4><p>内置模块加载优先级最高。</p>
<h4 id="4-3-自定义模块的加载机制"><a href="#4-3-自定义模块的加载机制" class="headerlink" title="4.3 自定义模块的加载机制"></a>4.3 自定义模块的加载机制</h4><p>加载自定义模块时，路径要以 <code>./</code> 或 <code>../</code> 开头，否则会作为内置模块或第三方模块加载。</p>
<p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p>
<ul>
<li>按确切的文件名加载</li>
<li>补全 <code>.js</code> 扩展名加载</li>
<li>补全 <code>.json</code> 扩展名加载</li>
<li>补全 <code>.node</code> 扩展名加载</li>
<li>报错</li>
</ul>
<h4 id="4-4-第三方模块加载"><a href="#4-4-第三方模块加载" class="headerlink" title="4.4 第三方模块加载"></a>4.4 第三方模块加载</h4><ul>
<li>若导入第三方模块，Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 <code>/node_modules</code> 文件夹中加载第三方模块。</li>
<li>如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。</li>
</ul>
<blockquote>
<p>例如，假设在 <code>C:\Users\bruce\project\foo.js</code> 文件里调用了 <code>require(&#39;tools&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li><code>C:\Users\bruce\project\node_modules\tools</code></li>
<li><code>C:\Users\bruce\node_modules\tools</code></li>
<li><code>C:\Users\node_modules\tools</code></li>
<li><code>C:\node_modules\tools</code></li>
</ul>
</blockquote>
<h4 id="4-5-目录作为模块加载"><a href="#4-5-目录作为模块加载" class="headerlink" title="4.5 目录作为模块加载"></a>4.5 目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p>
<ul>
<li>在被加载的目录下查找 <code>package.json</code> 的文件，并寻找 <code>main</code> 属性，作为 <code>require()</code> 加载的入口</li>
<li>如果没有 <code>package.json</code> 文件，或者 <code>main</code> 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 <code>index.js</code> 文件。</li>
<li>若失败则报错</li>
</ul>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><h3 id="1-初识-Express"><a href="#1-初识-Express" class="headerlink" title="1. 初识 Express"></a>1. 初识 Express</h3><p><a target="_blank" rel="noopener" href="https://www.expressjs.com.cn/">官网传送门</a></p>
<blockquote>
<p>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</p>
</blockquote>
<p>Express 是用于快速创建服务器的第三方模块</p>
<h4 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h4><p>安装 Express：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install express<br></code></pre></td></tr></table></figure>
<p>创建服务器，监听客户端请求，并返回内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 web 服务器</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span> &#125;)<br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 通过 req.query 可以获取到客户端发送过来的查询参数</span><br>  <span class="hljs-comment">// ?name=zs&amp;age=20</span><br>  <span class="hljs-comment">// req.query.name   req.query.age</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">query</span>)<br>&#125;)<br><br><span class="hljs-comment">// 这里的 :id 是一个动态的参数</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id/:username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// req.params 是动态匹配到的 URL 参数，默认是一个空对象</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<h4 id="1-2-托管静态资源"><a href="#1-2-托管静态资源" class="headerlink" title="1.2 托管静态资源"></a>1.2 托管静态资源</h4><ul>
<li>通过 <code>express.static()</code> 方法可创建静态资源服务器，向外开放访问静态资源。</li>
<li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，<strong>存放静态文件的目录名不会出现在 URL 中</strong></li>
<li>访问静态资源时，会根据目录的添加顺序查找文件</li>
<li>可为静态资源访问路径添加前缀</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>))<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/bruce&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;bruce&#x27;</span>))<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">可直接访问 public, files 目录下的静态资源</span><br><span class="hljs-comment">http://localhost:3000/images/bg.jpg</span><br><span class="hljs-comment">http://localhost:3000/css/style.css</span><br><span class="hljs-comment">http://localhost:3000/js/login.js</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">通过带有 /bruce 前缀的地址访问 bruce 目录下的文件</span><br><span class="hljs-comment">http://localhost:8080/bruce/images/logo.png</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="2-Express-路由"><a href="#2-Express-路由" class="headerlink" title="2. Express 路由"></a>2. Express 路由</h3><h4 id="2-1-路由的概念"><a href="#2-1-路由的概念" class="headerlink" title="2.1 路由的概念"></a>2.1 路由的概念</h4><ul>
<li>Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系</li>
<li>Express 中的路由分 3 部分组成，分别是<strong>请求的类型、请求的 URL 地址、处理函数</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">METHOD</span>(<span class="hljs-variable constant_">PATH</span>, <span class="hljs-variable constant_">HANDLER</span>)<br></code></pre></td></tr></table></figure>
<h4 id="2-2-路由的使用"><a href="#2-2-路由的使用" class="headerlink" title="2.2 路由的使用"></a>2.2 路由的使用</h4><ul>
<li><p>简单使用: 把路由直接挂载到 app 上，如上述代码所示</p>
</li>
<li><p>模块化路由: 为了<strong>方便对路由进行模块化的管理</strong>，Express<strong>不建议</strong>将路由直接挂载到 app 上，而是<strong>推荐将路由抽离为单独的模块</strong>。将路由抽离为单独模块的步骤如下：</p>
<ol>
<li>创建路由模块对应的 .js 文件</li>
<li>调用 <code>express.Router()</code> 函数创建路由对象</li>
<li>向路由对象上挂载具体的路由</li>
<li>使用 <code>module.exports</code> 向外共享路由对象</li>
<li>使用 <code>app.use()</code> 函数注册路由模块</li>
</ol>
</li>
<li><p>创建路由模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建路由对象</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<br><br><span class="hljs-comment">// 挂载具体路由</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list.&#x27;</span>)<br>&#125;)<br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 向外导出路由对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br></code></pre></td></tr></table></figure>
</li>
<li><p>注册路由模块，添加访问前缀</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 注册路由模块，添加访问前缀(可选)</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>app.use()</code> 函数的作用，就是来注册全局中间件</p>
</li>
</ul>
<h3 id="3-Express-中间件"><a href="#3-Express-中间件" class="headerlink" title="3. Express 中间件"></a>3. Express 中间件</h3><h4 id="3-1-中间件的概念"><a href="#3-1-中间件的概念" class="headerlink" title="3.1 中间件的概念"></a>3.1 中间件的概念</h4><ul>
<li>中间件(Middleware)，特指业务流程的<strong>中间处理环节</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/26/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-7-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/26/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-7-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">编译原理(7) 中间代码生成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-26 16:14:07" itemprop="dateCreated datePublished" datetime="2022-12-26T16:14:07+08:00">2022-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h1><h2 id="一、表达式的翻译与控制流的翻译"><a href="#一、表达式的翻译与控制流的翻译" class="headerlink" title="一、表达式的翻译与控制流的翻译"></a>一、表达式的翻译与控制流的翻译</h2><h3 id="1-核心"><a href="#1-核心" class="headerlink" title="1. 核心"></a>1. 核心</h3><h4 id="1-1-大局观"><a href="#1-1-大局观" class="headerlink" title="1.1 大局观"></a>1.1 大局观</h4><h4 id="1-2-分工、合作"><a href="#1-2-分工、合作" class="headerlink" title="1.2 分工、合作"></a>1.2 分工、合作</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221226161923069.png" alt="image-20221226161923069" style="zoom:80%;" /></p>
<blockquote>
<p>分工: $B$, $S_1$ 各自负责自己的中间代码生成 </p>
<p>合作: $B$ 为 true 或 false 时, 需要跳转到不同的位置(类似 <code>goto label</code>), 这个位置 $B$ 不知道, 需要父节点(或父父节点..)通过继承属性传递信息</p>
<ul>
<li>当 $B$ 为 true, $S$ 知道应该跳转到哪</li>
<li>当 $B$ 为 false, $P$ 知道应该跳转到哪</li>
</ul>
</blockquote>
<h3 id="2-表达式的翻译"><a href="#2-表达式的翻译" class="headerlink" title="2. 表达式的翻译"></a>2. 表达式的翻译</h3><h4 id="2-1-总览"><a href="#2-1-总览" class="headerlink" title="2.1 总览"></a>2.1 总览</h4><ul>
<li>起始符号为第三段的 $P$</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221226163911815.png" alt="image-20221226163911815" style="zoom:80%;" /></p>
<h4 id="2-2-表达式的中间代码翻译"><a href="#2-2-表达式的中间代码翻译" class="headerlink" title="2.2 表达式的中间代码翻译"></a>2.2 表达式的中间代码翻译</h4><ul>
<li>综合属性 $\textcolor{green}{E.code}$: 中间代码</li>
<li>综合属性 $\textcolor{blue}{E.addr}$: 变量名(包括临时变量)、常量</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221226170705741.png" alt="image-20221226170705741" style="zoom:80%;" /></p>
<ul>
<li>LLVM IR<ul>
<li>因为没有被使用过, 设置优化后会全部删掉</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221226165931772.png" alt="image-20221226165931772" style="zoom:80%;" /></p>
<h4 id="2-3-数组引用的中间代码翻译"><a href="#2-3-数组引用的中间代码翻译" class="headerlink" title="2.3 数组引用的中间代码翻译"></a>2.3 数组引用的中间代码翻译</h4><ul>
<li>声明: $\text{int } a[2][3]$</li>
<li>数组引用: $x = a[1][2];  a[1][2] = x$</li>
<li>需要计算 $a[1][2]$ 相对于<strong>数组基地址</strong> $a$ 的<strong>偏移地址</strong><ul>
<li>$addr(a[1][2]) = \textcolor{blue}{base} + 1 \times 12 + 2 \times 4$</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221226171518951.png" alt="image-20221226171518951" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230104195326682.png" alt="image-20230104195326682" style="zoom:80%;" /></p>
<ul>
<li>综合属性 $\textcolor{green}{L.array(.base)}$: 数组基地址(即，数组名)</li>
<li>综合属性 $\textcolor{red}{L.addr}$: 偏移地址</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230104195549841.png" alt="image-20230104195549841" style="zoom:80%;" /></p>
<ul>
<li><p>eg: $c + a[i][j]$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230108132058170.png" alt="image-20230108132058170" style="zoom:80%;" /></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://llvm.org/docs/GetElementPtr.html">GEP Instruction</a></p>
<blockquote>
<p>为什么要多一个 <code>i64 0</code>:</p>
<ul>
<li>%2 指向的是这一整个数组，如果直接对其偏移就会偏移 n 个数组大小的位置</li>
<li>因此需要 i64 0，先对其解一层([0])</li>
</ul>
</blockquote>
</li>
</ul>
<p>  <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230108132135329.png" alt="image-20230108132135329" style="zoom:80%;" /></p>
<h4 id="2-4-控制流语句与布尔表达式的中间代码翻译"><a href="#2-4-控制流语句与布尔表达式的中间代码翻译" class="headerlink" title="2.4 控制流语句与布尔表达式的中间代码翻译"></a>2.4 控制流语句与布尔表达式的中间代码翻译</h4><p>继承属性 $\textcolor{blue}{B.true, B.f alse, S.next}$ 指明了<strong>控制流跳转目标</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230108132248288.png" alt="image-20230108132248288" style="zoom:80%;" /></p>
<ul>
<li>继承属性 $\textcolor{red}{S.next}$<ul>
<li>$S.next$ 为语句 $S$ 指明了 “跳出” $S$ 的目标</li>
<li>$P$ “知道” $S.next$ 在哪，会在 $S$ 后面添加标签</li>
</ul>
</li>
<li>代表了表达式的翻译, 包括数组引用</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230109214843035.png" alt="image-20230109214843035" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230109215321211.png" alt="image-20230109215321211" style="zoom:80%;" /></p>
<h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230109215437475.png" alt="image-20230109215437475" style="zoom:80%;" /></p>
<ul>
<li><p>举例</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230109220923761.png" alt="image-20230109220923761" style="zoom:80%;" /></p>
</li>
</ul>
<h5 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230109221547115.png" alt="image-20230109221547115" style="zoom:80%;" /></p>
<ul>
<li><p>举例</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230109221603920.png" alt="image-20230109221603920" style="zoom:80%;" /></p>
</li>
</ul>
<h5 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113173701643.png" alt="image-20230113173701643" style="zoom:80%;" /></p>
<ul>
<li>举例</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113173815940.png" alt="image-20230113173815940" style="zoom:80%;" /></p>
<h5 id="并列语句"><a href="#并列语句" class="headerlink" title="并列语句"></a>并列语句</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113180355333.png" alt="image-20230113180355333" style="zoom:80%;" /></p>
<h4 id="2-5-布尔表达式的中间代码翻译"><a href="#2-5-布尔表达式的中间代码翻译" class="headerlink" title="2.5 布尔表达式的中间代码翻译"></a>2.5 布尔表达式的中间代码翻译</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113180528906.png" alt="image-20230113180528906" style="zoom:80%;" /></p>
<ul>
<li><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113180725060.png" alt="image-20230113180725060" style="zoom:80%;" /></p>
</li>
<li><p>!</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113180821400.png" alt="image-20230113180821400" style="zoom: 80%;" /></p>
</li>
<li><p>||</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113180906940.png" alt="image-20230113180906940" style="zoom:80%;" /></p>
</li>
<li><p>&amp;&amp;</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113181038343.png" alt="image-20230113181038343" style="zoom:80%;" /></p>
</li>
<li><p>rel</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113181113631.png" alt="image-20230113181113631" style="zoom:80%;" /></p>
</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113182158071.png" alt="image-20230113182158071" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113182220865.png" alt="image-20230113182220865" style="zoom:80%;" /></p>
<blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113182136913.png" alt="image-20230113182136913" style="zoom:80%;" /></p>
</blockquote>
<h4 id="2-6-布尔表达式的作用"><a href="#2-6-布尔表达式的作用" class="headerlink" title="2.6 布尔表达式的作用"></a>2.6 布尔表达式的作用</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113210020300.png" alt="image-20230113210020300" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230113210031118.png" alt="image-20230113210031118" style="zoom:80%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
