<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="码农预备役">
<meta property="og:type" content="website">
<meta property="og:title" content="Whale&#39;s Blog">
<meta property="og:url" content="https://whale-lyi.github.io/page/8/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="码农预备役">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Whale">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://whale-lyi.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/10/20/6-S081-Lab-2-System-calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/20/6-S081-Lab-2-System-calls/" class="post-title-link" itemprop="url">6.S081 Lab(2) System calls</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-20 19:08:31" itemprop="dateCreated datePublished" datetime="2022-10-20T19:08:31+08:00">2022-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/" itemprop="url" rel="index"><span itemprop="name">MIT</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>课程主页</strong>：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p>
<h2 id="Lab2-System-calls"><a href="#Lab2-System-calls" class="headerlink" title="Lab2 System calls"></a>Lab2 System calls</h2><h3 id="2-1-System-call-tracing-moderate"><a href="#2-1-System-call-tracing-moderate" class="headerlink" title="2.1 System call tracing (moderate)"></a>2.1 System call tracing (moderate)</h3><h3 id="2-2-Sysinfo-moderate"><a href="#2-2-Sysinfo-moderate" class="headerlink" title="2.2 Sysinfo (moderate)"></a>2.2 Sysinfo (moderate)</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/10/20/6-S081-Lab-1-Utilities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/20/6-S081-Lab-1-Utilities/" class="post-title-link" itemprop="url">6.S081 Lab(1) Utilities</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-20 19:08:30" itemprop="dateCreated datePublished" datetime="2022-10-20T19:08:30+08:00">2022-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/" itemprop="url" rel="index"><span itemprop="name">MIT</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>课程主页</strong>：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p>
<h2 id="Lab0-Tools"><a href="#Lab0-Tools" class="headerlink" title="Lab0 Tools"></a>Lab0 Tools</h2><p>虚拟机使用<strong>VMware Workstation 16 Player</strong>，系统采用<strong>ubuntu20.04</strong></p>
<p>安装必要工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu <br></code></pre></td></tr></table></figure>
<p>测试安装</p>
<ul>
<li><p>你应当可以编译并运行xv6（按住Ctrl+a  x退出）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># in the xv6 directory</span><br>$ make qemu<br><span class="hljs-comment"># ... lots of output ...</span><br>init: starting sh<br>$<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1 Xv6 and Unix utilities"></a>Lab1 Xv6 and Unix utilities</h2><h3 id="1-1-Boot-xv6-easy"><a href="#1-1-Boot-xv6-easy" class="headerlink" title="1.1 Boot xv6 (easy)"></a>1.1 Boot xv6 (easy)</h3><p>clone仓库并切换到util分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021<br>$ <span class="hljs-built_in">cd</span> xv6-labs-2021<br>$ git checkout util<br></code></pre></td></tr></table></figure>
<p>提交代码, -a 表示不需要git add 直接提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -a 表示不需要git add 直接提交</span><br>$ git commit -am <span class="hljs-string">&#x27;my solution for util lab exercise 1&#x27;</span><br></code></pre></td></tr></table></figure>
<p>查看代码变动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 展示和上次提交代码不同的地方</span><br>$ git diff<br><span class="hljs-comment"># 展示和初始时不同的地方</span><br>$ git diff origin/util<br></code></pre></td></tr></table></figure>
<p>启动qemu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ make qemu<br></code></pre></td></tr></table></figure>
<p>查看可执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>.              1 1 1024<br>..             1 1 1024<br>README         2 2 2059<br>xargstest.sh   2 3 93<br><span class="hljs-built_in">cat</span>            2 4 24256<br><span class="hljs-built_in">echo</span>           2 5 23080<br>forktest       2 6 13272<br>grep           2 7 27560<br>init           2 8 23816<br><span class="hljs-built_in">kill</span>           2 9 23024<br><span class="hljs-built_in">ln</span>             2 10 22880<br><span class="hljs-built_in">ls</span>             2 11 26448<br><span class="hljs-built_in">mkdir</span>          2 12 23176<br><span class="hljs-built_in">rm</span>             2 13 23160<br>sh             2 14 41976<br>stressfs       2 15 24016<br>usertests      2 16 148456<br>grind          2 17 38144<br><span class="hljs-built_in">wc</span>             2 18 25344<br>zombie         2 19 22408<br>console        3 20 0<br></code></pre></td></tr></table></figure>
<p>xv6没有ps命令，但按Ctrl-p，内核会打印每个进程的信息。如果现在尝试，会看到两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">1 <span class="hljs-built_in">sleep</span>  init<br>2 <span class="hljs-built_in">sleep</span>  sh<br></code></pre></td></tr></table></figure>
<p>退出可按住Ctrl-a，再输入x</p>
<p>通过<code>make grade</code>获取成绩，<code>make handin</code>提交lab</p>
<h3 id="1-2-sleep-easy"><a href="#1-2-sleep-easy" class="headerlink" title="1.2 sleep (easy)"></a>1.2 sleep (easy)</h3><p>user中创建sleep.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Please enter a number!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>添加到Makefile中</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">UPROGS=\<br>        $U/_cat\<br>        $U/_echo\<br>        $U/_forktest\<br>        $U/_grep\<br>        $U/_init\<br>        $U/_kill\<br>        $U/_ln\<br>        $U/_ls\<br>        $U/_mkdir\<br>        $U/_rm\<br>        $U/_sh\<br>        $U/_stressfs\<br>        $U/_usertests\<br>        $U/_grind\<br>        $U/_wc\<br>        $U/_zombie\<br>        $U/_sleep\<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ ./grade-lab-util <span class="hljs-built_in">sleep</span><br>make: “kernel/kernel”已是最新。<br>== Test <span class="hljs-built_in">sleep</span>, no arguments == <span class="hljs-built_in">sleep</span>, no arguments: OK (2.1s) <br>== Test <span class="hljs-built_in">sleep</span>, returns == <span class="hljs-built_in">sleep</span>, returns: OK (0.6s) <br>== Test <span class="hljs-built_in">sleep</span>, makes syscall == <span class="hljs-built_in">sleep</span>, makes syscall: OK (0.9s) <br></code></pre></td></tr></table></figure>
<h3 id="1-3-pingpong-easy"><a href="#1-3-pingpong-easy" class="headerlink" title="1.3 pingpong (easy)"></a>1.3 pingpong (easy)</h3><p>添加到Makefile</p>
<p>user中添加pingpong.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READEND 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITEEND 1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>	<span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>	<span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>	<span class="hljs-type">int</span> pid;<br>	<span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br><br>	pipe(p1);<br>	pipe(p2);<br><br>	pid = fork();<br><br>	<span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>		close(p1[WRITEEND]);<br>		close(p2[READEND]);<br>		read(p1[READEND], buf, <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br>		write(p2[WRITEEND], buf, <span class="hljs-number">1</span>);<br>		close(p1[READEND]);<br>		close(p2[WRITEEND]);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		close(p1[READEND]);<br>		close(p2[WRITEEND]);<br>		write(p1[WRITEEND], <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>		read(p2[READEND], buf, <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br>		close(p1[WRITEEND]);<br>		close(p2[READEND]);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用两个管道进行双向的数据传输，子进程要先等待父进程写才能读，之后父进程要等子进程写才能读</p>
<h3 id="1-4-primes-moderate-hard"><a href="#1-4-primes-moderate-hard" class="headerlink" title="1.4 primes (moderate)/(hard)"></a>1.4 primes (moderate)/(hard)</h3><p>素数筛法：将一组数feed到一个进程里，先print出最小的一个数，这是一个素数，然后用其他剩下的数依次尝试整除这个素数，如果可以整除，则将其drop，不能整除则将其feed到下一个进程中，直到最后打印出所有的素数。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220815203942525.png" alt="image-20220815203942525"></p>
<p>解决思路：采用递归，每次先尝试从左pipe中读取一个数，如果读不到说明已经到达终点，exit，否则再创建一个右pipe并fork一个子进程，将筛选后的数feed进这个右pipe。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READEND 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITEEND 1</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br><br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>        child(p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[READEND]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;<br>            write(p[WRITEEND], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        &#125;   <br>        close(p[WRITEEND]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> &#123;<br>    <span class="hljs-type">int</span> pr[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> n;<br><br>    close(p[WRITEEND]);<br>    <span class="hljs-keyword">if</span>(read(p[READEND], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <br>    <br>    pipe(pr);<br><br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>        child(pr);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(pr[READEND]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, n);<br>        <span class="hljs-type">int</span> prime = n;<br>        <span class="hljs-keyword">while</span>(read(p[READEND], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) &#123;<br>            <span class="hljs-keyword">if</span>(n % prime != <span class="hljs-number">0</span>) &#123;<br>                write(pr[WRITEEND], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>            &#125;<br>        &#125;<br>        close(pr[WRITEEND]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1-5-find-moderate"><a href="#1-5-find-moderate" class="headerlink" title="1.5 find (moderate)"></a>1.5 find (moderate)</h4><p>模仿 ls.c 即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span>* file)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: You need pass in only 2 argument&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> *target_path = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">char</span> *target_file = argv[<span class="hljs-number">2</span>];<br>    find(target_path, target_file);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span>* file)</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span>(st.type)&#123;<br>        <span class="hljs-keyword">case</span> T_FILE:<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-built_in">strlen</span>(path) - <span class="hljs-built_in">strlen</span>(file), file) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> T_DIR:<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">strcpy</span>(buf, path);  <br>            p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>            *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>            <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>                <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 获取完整路径名</span><br>                memmove(p, de.name, DIRSIZ);<br>                p[DIRSIZ] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 递归时不要进入.和..</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span>)) &#123;<br>                    find(buf, file);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-6-xargs-mederate"><a href="#1-6-xargs-mederate" class="headerlink" title="1.6 xargs (mederate)"></a>1.6 xargs (mederate)</h3><p>实现将标准输入作为参数一起输入到<code>xargs</code>后面跟的命令中，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> hello too | xargs <span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span><br><span class="hljs-built_in">bye</span> hello too<br></code></pre></td></tr></table></figure>
<p>如果标准输入有多行，那么也要执行多次命令</p>
<p>使用<code>fork</code>起一个子进程，在子进程中用<code>exec</code>执行相应的命令。父进程<code>wait</code>。对标准输入每次读一个char，若读到<code>\n</code>需要执行命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LEN 100</span><br>   <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>	<span class="hljs-type">char</span> *command = argv[<span class="hljs-number">1</span>];<br>	<span class="hljs-type">char</span> bf;<br>	<span class="hljs-type">char</span> paramv[MAXARG][MAX_LEN]; <span class="hljs-comment">// arguments</span><br>	<span class="hljs-type">char</span> *m[MAXARG];<br>   <br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-type">int</span> count = argc - <span class="hljs-number">1</span>;  <span class="hljs-comment">// # of current arguments</span><br>		<span class="hljs-built_in">memset</span>(paramv, <span class="hljs-number">0</span>, MAXARG * MAX_LEN);<br>		<span class="hljs-comment">// copy the parameter of command</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123;<br>			<span class="hljs-built_in">strcpy</span>(paramv[i - <span class="hljs-number">1</span>], argv[i]);<br>		&#125;<br>   <br>		<span class="hljs-type">int</span> cursor = <span class="hljs-number">0</span>; <span class="hljs-comment">// cursor pointing the char position in single_arg</span><br>		<span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>; <span class="hljs-comment">// flag indicating whether thers is argument preceding space</span><br>		<span class="hljs-type">int</span> read_result;<br>   <br>		<span class="hljs-keyword">while</span> (((read_result = read(<span class="hljs-number">0</span>, &amp;bf, <span class="hljs-number">1</span>))) &gt; <span class="hljs-number">0</span> &amp;&amp; bf != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>			<span class="hljs-keyword">if</span> (bf == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; flag == <span class="hljs-number">1</span>) &#123;<br>				count++;<br>				<span class="hljs-comment">// reset flag and p</span><br>				cursor = <span class="hljs-number">0</span>;<br>				flag = <span class="hljs-number">0</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>				paramv[count][cursor++] = bf;<br>				flag = <span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>		<br>		<span class="hljs-keyword">if</span> (read_result &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// encounters EOF of input</span><br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXARG - <span class="hljs-number">1</span>; i++) &#123;<br>			m[i] = paramv[i];<br>		&#125;<br>		m[MAXARG - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 参数最后0结尾</span><br>		<span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>			exec(command, m);<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>到这里lab1就全部完成了！</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221020170416506.png" alt="image-20221020170416506"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/10/17/Ubuntu20-04%E4%B8%ADVSCode%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/Ubuntu20-04%E4%B8%ADVSCode%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">Ubuntu中配置VSCode的C/C++环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-17 23:50:41" itemprop="dateCreated datePublished" datetime="2022-10-17T23:50:41+08:00">2022-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Ubuntu/" itemprop="url" rel="index"><span itemprop="name">Ubuntu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Ubuntu 20.04中配置VSCode的C/C++环境</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/10/17/Ubuntu20-04%E4%B8%ADVSCode%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/10/13/weka%E5%AE%9E%E7%8E%B0%E9%99%8D%E7%BB%B4-%E5%88%86%E7%B1%BB-%E8%81%9A%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/13/weka%E5%AE%9E%E7%8E%B0%E9%99%8D%E7%BB%B4-%E5%88%86%E7%B1%BB-%E8%81%9A%E7%B1%BB/" class="post-title-link" itemprop="url">weka实现降维,分类,聚类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-13 00:11:52" itemprop="dateCreated datePublished" datetime="2022-10-13T00:11:52+08:00">2022-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index"><span itemprop="name">Big Data</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/weka/" itemprop="url" rel="index"><span itemprop="name">weka</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实验使用java weka api，首先导入weka依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/nz.ac.waikato.cms.weka/weka-stable --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>nz.ac.waikato.cms.weka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>weka-stable<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="1-降维"><a href="#1-降维" class="headerlink" title="1.降维"></a>1.降维</h2><h3 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h3><p>数据降维采用PCA(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。</p>
<p>PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n条这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面k条坐标轴中，后面的坐标轴所含的方差几乎为0。于是，我们可以忽略余下的坐标轴，只保留前面k条含有绝大部分方差的坐标轴。事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为0的特征维度，实现对数据特征的降维处理。</p>
<h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-type">Instances</span> <span class="hljs-variable">dataset</span> <span class="hljs-operator">=</span> DataSource.read(<span class="hljs-string">&quot;src/main/resources/diabetes.arff&quot;</span>);<br>    dataset.setClassIndex(dataset.numAttributes() - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">PrincipalComponents</span> <span class="hljs-variable">pca</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrincipalComponents</span>();<br>    pca.setCenterData(<span class="hljs-literal">true</span>);<br>    pca.buildEvaluator(dataset);<br>    System.out.println(pca);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先通过DataSource读取数据集，设置最后一列为标签(setClassIndex),然后创建PrincipalComponents对象，设置对数据进行中心化处理，随后导入数据，初始化主成分并执行分析，最后打印结果即可</p>
<h3 id="1-3-实验结果"><a href="#1-3-实验结果" class="headerlink" title="1.3 实验结果"></a>1.3 实验结果</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013003759127.png" alt="image-20221013003759127"></p>
<p>计算出的协方差矩阵如图所示，可以看到原本为八维的数据被降为二维，效果显著</p>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><h3 id="2-1-方法介绍"><a href="#2-1-方法介绍" class="headerlink" title="2.1 方法介绍"></a>2.1 方法介绍</h3><p>分类采用J48实现，J48是基于从上到下的策略，递归的分治策略，选择某个属性放置在根节点，为每个可能的属性值产生一个分支，将实例分成多个子集，每个子集对应一个根节点的分支，然后在每个分支上递归地重复这个过程。当所有实例有相同的分类时停止。</p>
<h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-type">Instances</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> DataSource.read(<span class="hljs-string">&quot;src/main/resources/spambase.train.arff&quot;</span>);<br>    <span class="hljs-type">Instances</span> <span class="hljs-variable">test_data</span> <span class="hljs-operator">=</span> DataSource.read(<span class="hljs-string">&quot;src/main/resources/spambase.test.arff&quot;</span>);<br>    data.setClassIndex(data.numAttributes() - <span class="hljs-number">1</span>);<br>    test_data.setClassIndex(test_data.numAttributes() - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Instance</span> <span class="hljs-variable">test_instance</span> <span class="hljs-operator">=</span> test_data.firstInstance();<br>    <span class="hljs-type">J48</span> <span class="hljs-variable">j48</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">J48</span>();<br>    j48.buildClassifier(data);<br>	System.out.println(j48);<br>    System.out.println(j48.classifyInstance(test_instance));<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>首先通过DataSource读取训练数据集以及测试数据集，设置最后一列为标签(setClassIndex),再获取测试数据集中的测试数据，然后创建J48对象，随后导入数据，生成分类器，最后打印分类器信息以及对测试数据进行分类的结果</p>
<h3 id="2-3-实验结果"><a href="#2-3-实验结果" class="headerlink" title="2.3 实验结果"></a>2.3 实验结果</h3><p>可以看到J48生成的决策树，以及树的大小和叶子数，以及测试数据分类后的结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013004059857.png" alt="image-20221013004059857"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013004106306.png" alt="image-20221013004106306"></p>
<h2 id="3-聚类"><a href="#3-聚类" class="headerlink" title="3.聚类"></a>3.聚类</h2><h3 id="3-1-方法介绍"><a href="#3-1-方法介绍" class="headerlink" title="3.1 方法介绍"></a>3.1 方法介绍</h3><p>聚类采用K-means实现，K-Means算法是一种聚类分析的算法。首先从样本中随机选择k个点作为初始质心，随后计算每个样本到各个质心的距离，将样本划分到距离最近的质心所对应的簇中，计算每个簇中所有样本的均值，并使用该均值更新簇的质心，重复以上步骤，直到质心的位置变化小于制定的阈值或者达到最大迭代次数。</p>
<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-type">Instances</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> DataSource.read(<span class="hljs-string">&quot;src/main/resources/bank_data.arff&quot;</span>);<br>    <span class="hljs-type">SimpleKMeans</span> <span class="hljs-variable">kMeans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleKMeans</span>();<br>    kMeans.setNumClusters(<span class="hljs-number">6</span>);<br>    kMeans.buildClusterer(data);<br>    System.out.println(kMeans);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先通过DataSource读取数据集，创建SimpleKMeans对象，设置群数为6，随后导入数据，生成聚类器，最后打印聚类器信息</p>
<h3 id="3-3-实验结果"><a href="#3-3-实验结果" class="headerlink" title="3.3 实验结果"></a>3.3 实验结果</h3><p>设置群数为6，从分群结果可以分析出不同人群的特点。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013004241168.png" alt="image-20221013004241168"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/27/XV6-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/27/XV6-3/" class="post-title-link" itemprop="url">XV6(3) Page tables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-27 15:25:19" itemprop="dateCreated datePublished" datetime="2022-09-27T15:25:19+08:00">2022-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/" itemprop="url" rel="index"><span itemprop="name">MIT</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3 Page tables"></a>Chapter 3 Page tables</h2><p>页表让每个进程都拥有自己独立的虚拟内存地址，并决定每个进程可以访问物理内存的哪些部分。</p>
<p>页表隔离了不同进程的地址空间，实现了内存隔离，并将它们映射到同一个物理内存</p>
<p>xv6通过页表实现了一些有趣的功能：在多个地址空间中映射相同的内存(a <em>trampoline</em> page 蹦床页面)，并使用未映射的页面保护内核和用户堆栈。</p>
<h3 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h3><p>RISC-V指令操纵虚拟地址，而机器RAM或物理内存使用物理地址，RISC-V页表硬件通过将每个虚拟地址映射到物理地址来连接这两种地址</p>
<p>xv6运行于Sv39 RISC-V，即在 64 位地址中只有最下面的 39 位被使用作为虚拟地址，其中底 12 位是页内偏移，高 27 位是页表索引，即 4096 字节( $2^{12}$ )作为一个page，一个进程的虚拟内存可以有 $2^{27}$ 个page，对应到页表中就是 $2^{27}$ 个<em>page table entry</em>(PTE)。</p>
<p>每个PTE有一个 44 位的physical page number (PPN) 用来映射到物理地址上和 10 位flag，总共需要 54 位，用 8 个字节存储(下面解释)。每个物理地址的高 44 位是页表中存储的PPN，低 12 位是页内偏移，一个物理地址总共由 56 位构成。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221113234723564.png" alt="image-20221113234723564" style="zoom: 50%;" /></p>
<p>在Sv39 RISC-V，PTE格式中存在着可以使物理地址再增加 10 位的空间。</p>
<p>在实际中，页表并不是作为一个包含了 $2^{27}$ 个PTE的大列表存储在物理内存中的，而是采用了三级树状的形式进行存储，这样可以让页表分散存储。每个页表就是一页。第一级页表是一个 4096 字节的页，包含了 512 个PTE(因为每个PTE需要 8 字节)，每个PTE存储了下级页表的页物理地址。第二级列表由512个页构成，第三级列表由512*512个页构成。</p>
<blockquote>
<p>与单层设计相比，三层结构可以以一种内存高效的方式记录PTE</p>
<p>通常情况下执行一个进程，大部分的虚拟地址是不会被映射的，三层结构可以省略整个页面目录</p>
<p>例如，如果一个应用程序只使用从地址 0 开始的几个页面，那么一级页面目录的条目 1 到 511 是无效的，因此内核不必为 1-511 的二级页面目录分配页面。此外，内核还不必为这些二级页面目录对应的的三层页面目录分配页面。因此，在本例中，三层结构为二级页面目录节省了511页，为底层页面目录节省511×512页。</p>
</blockquote>
<p>因为每个进程虚拟地址的高 27 位用来确定PTE，对应到3级页表就是最高的 9 位确定一级页表PTE的位置，中间 9 位确定二级页表PTE的位置，最低 9 位确定三级页表PTE的位置。如下图所示。第一级根页表的物理页地址存储在<code>satp</code>寄存器中，每个CPU拥有自己独立的<code>satp</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221113234808913.png" alt="image-20221113234808913" style="zoom:80%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/27/XV6-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/27/XV6-2/" class="post-title-link" itemprop="url">XV6(2) Operating system organization</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-27 15:25:18" itemprop="dateCreated datePublished" datetime="2022-09-27T15:25:18+08:00">2022-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/" itemprop="url" rel="index"><span itemprop="name">MIT</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2 Operating system organization"></a>Chapter 2 Operating system organization</h2><p>操作系统应当能够保证同时支持多个活动，不同进程可以共享计算机的资源</p>
<p>操作系统还应保证进程间的隔离性(<em>isolation</em>)，也就是说，如果一个进程出现错误和故障，不应影响不依赖于这个错误进程的进程。</p>
<p>但是，不应做到完全隔离，因为不同进程间也会进行交互，例如管道。</p>
<p>因此，操作系统必须满足三个要求</p>
<ul>
<li><strong>多进程支持(<em>multiplexing</em>)</strong></li>
<li><strong>进程间隔离(<em>isolation</em>)</strong></li>
<li><strong>受控制的进程间交互(<em>interaction</em>)</strong></li>
</ul>
<h3 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h3><p><strong>方案一</strong></p>
<p><strong>可以将系统调用实现为一个库，应用程序与之链接</strong>。在这个方案中，每个应用程序都有专属于自己的库来满足其需求，可以直接与硬件资源交互，并且可以以最优方式使用(例如，实现高性能或达到可预测的性能)。一些嵌入式设备或实时系统的操作系统就是以这种方式组织的。</p>
<p>如果有多个应用程序在同时运行，则每个应用程序必须表现良好。例如，每个应用程序必须定期放弃CPU，以便其他应用程序可以运行。如果所有应用程序彼此信任并且没有出现错误，则这种协作分时方案是可行的。但对于应用程序来说，更典型的情况是彼此不信任，并且可能存在bug。因此通常需要比该方案更强的隔离性。</p>
<p><strong>方案二</strong></p>
<p>为了实现强隔离，可以<strong>禁止应用程序直接访问敏感硬件资源，将资源抽象为服务。</strong></p>
<blockquote>
<p>例如，Unix应用程序仅通过文件系统的<code>open</code>、<code>read</code>、<code>write</code>和<code>close</code>系统调用与存储交互，而不是直接读取和写入磁盘。</p>
</blockquote>
<p>这为应用程序提供了路径名的便利，并允许操作系统(作为接口的实现者)来管理磁盘。</p>
<p>该方案中，即使对隔离的要求不高，有意交互的程序(或只是希望避免相互干扰)也会发现使用文件系统抽象也比直接使用磁盘更加方便</p>
<blockquote>
<p>例1. Unix可以在进程间透明地切换CPU，根据需要保存和恢复寄存器状态，因此应用程序不必知道’分时’如何实现，这种透明性允许操作系统共享CPU，即使某些应用程序处于死循环</p>
<p>例2. Unix进程使用<code>exec</code>构建其内存映像，而不是直接和物理内存交互。这允许操作系统决定进程在内存中如何存放，如果内存紧张，操作系统甚至会将进程的部分数据存放在磁盘。<code>exec</code>还为用户提供了存储可执行程序图像的文件系统的便利</p>
<p>例3. Unix进程之间的许多交互形式都是通过文件描述符进行的。文件描述符不仅抽象了许多细节(例如管道或文件中的数据存储位置)，而且还以简化交互的方式定义。例如，如果管道中的一个应用程序出错了，内核将为管道中的下一个进程生成EOF信号。</p>
</blockquote>
<h3 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode, and system calls"></a>2.2 User mode, supervisor mode, and system calls</h3><p>为了实现强隔离，操作系统必须保证应用程序不能修改(甚至读取)操作系统的数据结构和指令，并且应用程序不能访问其他进程的内存</p>
<p>CPU为强隔离提供硬件支持。例如，RISC-V有三种CPU可以执行指令的模式</p>
<ul>
<li><em>machine mode</em>: 权限最高，主要目的是为了配置电脑，<strong>CPU以machine mode启动，之后立即切换到supervisor mode。</strong></li>
<li><em>supervisor mode</em>: 允许CPU执行<em>privileged instructions</em>，比如中断管理、对存储页表地址的寄存器进行读写操作、执行system call(从user mode切换到supervisor mode)。运行在supervisor mode也称为在<em>kernel space</em>中运行。</li>
<li><em>user mode</em>: 应用程序只能执行user mode指令，比如改变变量、执行util function。运行在user mode也称为在<em>user space</em>中运行。要想让CPU从user mode切换到supervisor mode，RISC-V提供了一个特殊的<code>ecall</code>指令。一旦CPU切换到supervisor mode，内核会验证系统调用的参数(例如检查地址是否是该程序内存的一部分)，决定是否执行。</li>
</ul>
<p>由<strong>内核</strong>而不是应用程序<strong>控制切换到supervisor mode的入口点(地址)非常重要</strong>，可以避免恶意程序跳过参数验证</p>
<h3 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h3><p><em>monolithic kernel(宏内核)</em>: 整个操作系统都在kernel中，所有system call都在supervisor mode下运行，拥有全部硬件权限，不同部分便于合作。但是一旦出现错误常常会导致内核崩溃，导致所有程序出错，不得不重启。xv6就是monolithic kernel</p>
<p><em>micro kernel(微内核)</em>: 将需要运行在supervisor mode下的操作系统代码压到最小，保证kernel内系统的安全性，将大部分的操作系统代码执行在user mode下。会有在user/kernel mode反复跳转带来的性能损耗。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915012051093.png" alt="image-20220915012051093"></p>
<p>如2.1所示，文件系统是一个user-level的进程，为其他进程提供服务，因此也叫做server</p>
<p>作为<strong>进程</strong>运行的<strong>操作系统服务</strong>称为server。</p>
<p>为了允许应用程序与文件服务交互，内核提供了一种进程间通信机制，将消息从一个用户模式进程发送到另一个进程。(例如，如果像shell这样的应用程序想要读取或写入文件，它会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统并等待响应)</p>
<p>xv6 kernel source file如下所示</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915010746816.png" alt="image-20220915010746816"></p>
<h3 id="2-4-Process-overview"><a href="#2-4-Process-overview" class="headerlink" title="2.4 Process overview"></a>2.4 Process overview</h3><p><strong>隔离的单元叫做进程</strong>，进程的抽象使得一个进程不能破坏或者监听另外一个进程的内存、CPU、文件描述符等，也不能破坏kernel本身，即进程无法破坏内核的隔离机制</p>
<p>内核用于实现进程的机制包括<em>user/supervisor mode</em>标志，地址空间，线程的时间切片</p>
<p>为了实现进程隔离，<strong>xv6提供了一种机制让每个程序都认为自己拥有一个独立的机器</strong>。</p>
<p>一个进程为一个程序<strong>提供了一个私有的内存系统，或<em>address space</em>，其他的进程不能够读/写这个内存</strong></p>
<p>xv6使用<strong><em>page table</em>(页表)</strong>来给每个进程分配自己的<em>address space</em>，页表再将这些<em>address space</em>，也就是<strong>虚拟地址</strong>(virtual address)(RISC-V指令操作的地址) <strong>映射为物理地址</strong>(physical address)(CPU芯片发送到主存的地址)。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220922154824955.png" alt="image-20220922154824955"></p>
<p>虚拟地址从0开始，往上依次是指令、全局变量、栈、堆。</p>
<p>有许多因素限制了进程地址空间的最大大小：RISC-V上的指针是64位的，硬件在页表寻找虚拟地址时只使用低39位，而xv6只使用39位中的低38位，因此最大的地址是$2^{38}-1$=0x3fffffffff=MAXVA</p>
<p>在地址空间的顶部，xv6为<em>trampoline</em>保留了一页，并为映射进程<em>trapframe</em>预留了一页。xv6使用这两页切换到内核并返回：<em>trampoline</em>页包含了该功能的代码，而映射<em>trapframe</em>是保存/恢复用户进程状态所必需的</p>
<p>xv6内核保存了每个进程的许多状态，并集中在<code>struct pr</code>中。进程最重要的内核状态有：</p>
<ol>
<li>页表 <code>p-&gt;pagetable</code>，分页硬件会在用户空间执行进程时使用，并且页表还会<strong>记录分配给用于储存进程的内存的物理页地址</strong></li>
<li>内核堆栈<code>p-&gt;kstack</code> </li>
<li>运行状态<code>p-&gt;state</code>，显示进程是否已经被分配、准备运行/正在运行/等待I/O或退出</li>
</ol>
<p><strong>每个进程中都有线程(<em>thread</em>)，是执行进程命令的最小单元，可以被暂停和继续。</strong>为了透明地切换进程，内核会挂起正在运行的线程，并恢复其他进程的线程。<strong>线程的大部分状态(局部变量、函数返回地址等)都被存储在线程的堆栈中。</strong></p>
<p>每个进程有两个堆栈：<strong>用户堆栈(<em>user stack</em>)和内核堆栈(<em>kernel stack</em>)</strong>。</p>
<ul>
<li>当进程在user space中执行用户指令时只使用用户堆栈，内核堆栈为空</li>
<li>当进程进入了内核(比如进行了system call或中断)使用内核堆栈，此时用户堆栈仍然包含保存的数据</li>
</ul>
<p>一个进程的线程交替使用其用户堆栈和内核堆栈。内核堆栈是独立的(并受用户代码保护的)，因此即使进程破坏了其用户堆栈，内核也可以正常执行</p>
<p>进程可以通过执行RISC-V <code>ecall</code>指令进行系统调用。该指令会<strong>提高硬件的特权级别</strong>，并<strong>将程序计数器更改为内核定义的入口点</strong>。入口点的代码会切换到内核堆栈并执行实现系统调用的内核指令。当系统调用完成，内核切换回用户堆栈，通过调用<code>sret</code>指令返回用户空间，同时降低硬件特权级别并恢复执行用户指令。</p>
<blockquote>
<p><code>ecall</code>会接收一个数字参数，代表应用程序想要调用的System Call，<code>ecall</code>会跳转到内核中一个特定，由内核控制的位置。之后控制权到了<code>syscall</code>函数</p>
<p>在内核空间，有一个位于syscall.c的函数<code>syscall</code>，每一个从应用程序发起的系统调用都会调用到这个<code>syscall</code>函数，<code>syscall</code>函数会检查<code>ecall</code>的参数，通过这个参数内核可以知道需要调用的是哪个system call</p>
</blockquote>
<p>一个进程的线程可以在内核中”阻塞”以等待I/O，并在I/O完成后恢复到中断的位置</p>
<p>进程捆绑了两种设计思想：地址空间(进程认为拥有属于自己的内存)、线程(进程认为拥有属于自己的CPU)。xv6中，一个进程包括一个<em>address space</em>和一个<em>thread</em>。而真实操作系统一个进程往往有多个线程来充分利用多核CPU</p>
<h3 id="2-5-Code-starting-xv6-the-first-process-and-system-call"><a href="#2-5-Code-starting-xv6-the-first-process-and-system-call" class="headerlink" title="2.5 Code: starting xv6, the first process and system call"></a>2.5 Code: starting xv6, the first process and system call</h3><p>RISC-V计算机启动时，先运行一个存储于 ROM 中的 bootloader 程序 <code>kernel.ld</code> 来加载xv6 kernel到内存中，然后在machine模式下从<code>_entry</code>开始运行xv6。此时分页硬件没有工作，虚拟地址直接映射到物理地址。bootloader将xv6 kernel加载到<code>0x80000000</code>的物理地址中，因为前面的地址中包含I/O设备</p>
<p>指令在<code>_entry</code>中设置了一个初始stack来执行C代码，xv6执行<code>kernel/start.c</code>并在其中声明一个初始化堆栈<code>stack0</code>。<code>_entry</code>处的代码加载堆栈的指针寄存器<code>sp</code>到栈顶<code>stack0+4096</code>，因为RISC-V的堆栈是向下生长的</p>
<p><code>start</code>函数先在machine模式下做一些配置，还对时钟芯片进行编程，以生成定时器中断，然后通过RISC-V提供的<code>mret</code>指令切换到supervisor mode。使program counter(pc)也切换到<code>kernel/main.c</code></p>
<blockquote>
<p><code>mret</code>指令常用于上一条指令为从supervisor mode切换到machine mode，但显然<code>start</code>并不是这样的，而是假装是这样的：它将寄存器<code>mstatus</code>中以前的特权模式设置为supervisor</p>
<p>它通过把<code>main</code>的地址写入到寄存器<code>mepc</code>中使得返回地址被设置为<code>main</code></p>
<p>通过将 0 写入页表寄存器<code>satp</code>中禁用superviser模式下的虚拟地址转换</p>
<p>将所有中断和异常委派给supervisor mode</p>
</blockquote>
<p><code>main</code>先对一些设备和子系统进行初始化，然后调用<code>kernel/proc.c</code>中定义的<code>userinit</code>来创建第一个用户进程。这个进程执行了一个<code>initcode.S</code>的汇编程序，这个汇编程序调用了<code>exec</code>这个system call来执行<code>/init</code>，重新进入kernel。<code>exec</code>将当前进程的内存和寄存器替换为一个新的程序(<code>/init</code>)，当kernel执行完毕<code>exec</code>指定的程序后，回到<code>/init</code>进程。<code>/init</code>(<code>user/init.c</code>)创建了一个新的console device以文件描述符0,1,2打开，然后在console device中开启了一个shell进程，至此整个系统启动了</p>
<h3 id="2-6-Security-Model"><a href="#2-6-Security-Model" class="headerlink" title="2.6 Security Model"></a>2.6 Security Model</h3><p>操作系统必须假设进程的用户代码会尽力破坏内核或其他进程。包括引用超出其允许地址空间的指针、执行RISC-V特权指令、读取和写入任意RISC-V控制寄存器等。而内核的目标就是要限制每个用户进程，只能读/写/执行自己的用户内存、使用通用寄存器、使用允许的系统调用。</p>
<p>而内核代码不同，内核代码应当没有bug，不含任何恶意代码。这个假设会影响我们分析内核代码的方式，我们往往相信内核代码都是正确编写的，并且遵循内核自身函数和数据结构的使用规则</p>
<p>在硬件级别，我们也假设CPU、RAM、磁盘等都按照文档正确运行，没有硬件错误</p>
<p>而现实中，我们不可能编写无缺陷代码或者设计无缺陷硬件，因此我们有必要为内核设计保护措施：断言、类型检查、堆栈保护页等</p>
<p>有时用户代码和内核代码之间的界限会变得模糊：一些特权用户级进程会提供基本服务，并有效地成为操作系统的一部分，在某些操作系统，特权用户代码甚至可以将新代码插入内核(与Linux的可加载内核模块一样)</p>
<h3 id="2-7-Real-World"><a href="#2-7-Real-World" class="headerlink" title="2.7 Real World"></a>2.7 Real World</h3><p>大多数操作系统都采用了进程概念，并且大多数进程也与xv6类似。然而，现代操作系统支持一个进程中的多个线程，从而允许单个进程利用多核CPU。而在一个进程中支持多个线程需要很多xv6没有的机制，包括潜在的接口更改(e.g. Linux的<code>clone</code>，就是<code>fork</code>的变体)，以控制线程共享哪些方面。</p>
<h3 id="2-8-Something-Else"><a href="#2-8-Something-Else" class="headerlink" title="2.8 Something Else"></a>2.8 Something Else</h3><p>当应用程序恶意破坏或者就是在一个死循环中，内核是如何夺回控制权限的？</p>
<ul>
<li>内核会通过硬件设置一个定时器，定时器到期之后会将控制权限从用户空间转移到内核空间，之后内核就有了控制能力并可以重新调度CPU到另一个进程中。</li>
</ul>
<p>内核编译过程</p>
<ul>
<li>首先，Makefile(XV6目录下的文件)会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V汇编语言文件；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式</li>
<li>Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o。</li>
<li>之后，系统加载器(Loader)会收集所有的.o文件，将它们链接在一起，并生成内核文件</li>
<li>这里生成的内核文件就是将会在QEMU中运行的文件。同时，Makefile还会创建kernel.asm，这里包含了内核的完整汇编语言，可以通过查看它来定位究竟是哪个指令导致了Bug。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/27/XV6-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/27/XV6-1/" class="post-title-link" itemprop="url">XV6(1) Introduction and Examples</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-27 15:25:17" itemprop="dateCreated datePublished" datetime="2022-09-27T15:25:17+08:00">2022-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/" itemprop="url" rel="index"><span itemprop="name">MIT</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT/6-S081/" itemprop="url" rel="index"><span itemprop="name">6.S081</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-1-Introduction-and-Examples"><a href="#Chapter-1-Introduction-and-Examples" class="headerlink" title="Chapter 1 Introduction and Examples"></a>Chapter 1 Introduction and Examples</h2><p><strong>操作系统应该提供的功能</strong></p>
<ul>
<li><p>抽象硬件    Abstract Hardware</p>
<ul>
<li>硬件是底层级的资源，一些应用程序实现了高层级的接口和抽象，例如进程、文件系统。这些高层级的接口和抽象（Abstraction）方便了应用的开发，也提供了更好的移植性。</li>
</ul>
</li>
<li><p>多进程支持    Multiplex</p>
</li>
<li>进程间隔离    Isolation</li>
<li>数据的共享    Sharing</li>
<li>权限系统    Security</li>
<li>帮助应用程序获得高性能    Performance</li>
<li>支持大量不同应用程序</li>
</ul>
<p><strong>操作系统结构</strong></p>
<ul>
<li><strong>user application</strong>: VI、CC、Shell等，这里程序都运行在同一个空间中，这个空间通常会被称为用户空间（User space）。</li>
<li><strong>kernel</strong>: 为运行的程序提供服务的一种特殊程序。只能有一个<ul>
<li>文件系统</li>
<li>进程管理系统：每个运行着的程序叫做进程，它们有自己的内存(存储指令、数据和堆栈)和共享的CPU时间。Kernel会管理内存的分配。</li>
<li>Access Control (security)</li>
</ul>
</li>
<li><strong>h/w</strong>: CPU, RAM, disk, net, &amp;c</li>
</ul>
<p><strong>什么是 application / kernel interface?</strong></p>
<p>每当进程需要调用内核服务时，它会触发一个<em>system call</em>(系统调用)，system call进入内核执行相应的服务然后返回。因此，进程在<em>user space</em>和<em>kernel space</em>中交替执行</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220812120814236.png" alt="image-20220812120814236"></p>
<ul>
<li><em>shell</em>: 一个普通的程序，其功能是读取用户输入的命令并执行它们，shell<strong>不是</strong>内核的一部分</li>
</ul>
<h3 id="1-1-Processes-and-memory"><a href="#1-1-Processes-and-memory" class="headerlink" title="1.1 Processes and memory"></a>1.1 Processes and memory</h3><p>每个进程拥有自己的用户空间内存以及内核空间状态，当进程不再执行时xv6将存储和这些进程相关的CPU寄存器直到下一次运行这些进程。kernel将每一个进程用一个PID(process identifier)指代。</p>
<p><strong>常用syscall</strong></p>
<ul>
<li><p><code>fork</code>: 形式: <code>int fork()</code>。</p>
<ul>
<li>其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程。在父进程中，<code>fork</code>的返回值是这个子进程的PID，在子进程中，返回值是0</li>
</ul>
</li>
<li><p><code>exit</code>: 形式: <code>int exit(int status)</code>。</p>
<ul>
<li>让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出</li>
</ul>
</li>
<li><p><code>wait</code>: 形式: <code>int wait(int *status)</code>。</p>
<ul>
<li><p>返回当前进程的已退出（或已终止）子进程的PID，子进程的退出状态存储到<code>status</code>这个地址中。如果没有已退出的子进程则等待。如果调用者没有子进程，<code>wait</code>立即返回-1。如果不关心子进程的退出状态，可以传递0地址</p>
</li>
<li><p>如果有任何子进程退出，wait就会直接返回。因此如果有多个子进程，需要调用多个<code>wait</code></p>
</li>
</ul>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();<br><span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>    pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  前两行输出可能是</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">parent: child=1234<br>child: exiting<br></code></pre></td></tr></table></figure>
<p>  也可能是</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">child: exiting<br>parent: child=1234<br></code></pre></td></tr></table></figure>
<p>  这是因为在<code>fork</code>了之后，父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。输出取决于哪个进程先调用了<code>printf</code></p>
<p>  子进程在判断完<code>pid == 0</code>之后将<code>exit</code>，父进程发现子进程<code>exit</code>之后，<code>wait</code>执行完毕，打印输出</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">parent: child 1234 is done<br></code></pre></td></tr></table></figure>
<p>  尽管<code>fork</code>了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程。</p>
<ul>
<li><p><code>exec</code>: 形式: <code>int exec(char *file, char *argv[])</code>。</p>
<ul>
<li>加载一个文件，获取执行它的参数，执行。将调用进程的内存替换为从文件加载的内存映像。如果执行错误返回-1，执行成功则不会返回(内存已经被替换，没有地方返回)，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。</li>
<li>如果直接调用<code>exec</code>，这里会用<code>echo</code>指令来替代Shell进程，当<code>echo</code>退出了，一切就结束了。因此常见方法是先执行<code>fork</code>，子进程再执行<code>exec</code></li>
<li><strong>参数</strong><ul>
<li>第一个参数是包含可执行文件的文件名</li>
<li>第二个参数是字符串参数数组</li>
</ul>
</li>
</ul>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *argv[<span class="hljs-number">3</span>];<br><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;echo&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>argv[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记数组的结尾</span><br>exec(<span class="hljs-string">&quot;/bin/echo&quot;</span>, argv);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec error\n&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>  大多数程序忽略参数数组的第一个元素，通常是该程序的名称</p>
<p><strong>执行流程</strong></p>
<p>xv6 shell使用以上四个system call来为用户执行程序。在shell进程的<code>main</code>中主循环先通过<code>getcmd</code>来从用户获取命令，然后调用<code>fork</code>来运行一个和当前shell进程完全相同的子进程。父进程调用<code>wait</code>等待子进程<code>exec</code>执行完（在<code>runcmd</code>中调用<code>exec</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sh.c */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">int</span> fd;<br><br>  <span class="hljs-comment">// Ensure that three file descriptors are open.</span><br>  <span class="hljs-keyword">while</span>((fd = open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">3</span>)&#123;<br>      close(fd);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Read and run input commands.</span><br>  <span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>      <span class="hljs-comment">// Chdir must be called by the parent, not the child.</span><br>      buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// chop \n</span><br>      <span class="hljs-keyword">if</span>(chdir(buf+<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="hljs-number">3</span>);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)<br>      runcmd(parsecmd(buf));<br>    wait(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Xv6隐式分配大部分用户空间内存：<code>fork</code>分配父内存的子副本所需的内存，<code>exec</code>分配足够的内存来保存可执行文件。在运行时需要更多内存的进程（可能是<code>malloc</code>）可以调用<code>sbrk(n)</code>将其数据内存增加 n 个字节；<code>sbrk</code>返回新内存的位置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>System call</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>int fork()</td>
<td>创建进程，返回子进程PID</td>
</tr>
<tr>
<td>int exit(int status)</td>
<td>终止当前进程；status报告给wait()，没有返回值</td>
</tr>
<tr>
<td>int wait(int *status)</td>
<td>等待子进程结束；结束状态存放在status，返回子进程PID</td>
</tr>
<tr>
<td>int kill(int pid)</td>
<td>终止进程号为pid的进程，返回0，出现错误返回-1</td>
</tr>
<tr>
<td>int getpid()</td>
<td>获取当前进程PID</td>
</tr>
<tr>
<td>int sleep(int n)</td>
<td>暂停n个时钟滴答</td>
</tr>
<tr>
<td>int exec(char <em>file, char </em>argv[])</td>
<td>加载文件并按参数执行，只在出现错误才返回</td>
</tr>
<tr>
<td>char *sbrk(int n)</td>
<td>进程内存增长n字节，返回新内存的起始位置</td>
</tr>
<tr>
<td>int open(char *file, int flags)</td>
<td>打开文件，flags指示读/写；返回fd</td>
</tr>
<tr>
<td>int write(int fd, char *buf, int n)</td>
<td>从buf写n个字节到fd，返回n</td>
</tr>
<tr>
<td>int read(int fd, char *buf, int n)</td>
<td>从fd读n个字节到buf，返回读到的数量，文件结尾返回0</td>
</tr>
<tr>
<td>int close(int fd)</td>
<td>关闭打开的fd</td>
</tr>
<tr>
<td>int dup(int fd)</td>
<td>返回一个新的fd，和参数fd引用相同对象</td>
</tr>
<tr>
<td>int pipe(int p[])</td>
<td>创建管道，把读、写fd放到p[0],p[1]</td>
</tr>
<tr>
<td>int chdir(char *dir)</td>
<td>改变当前目录</td>
</tr>
<tr>
<td>int mkdir(char *dir)</td>
<td>创建新目录</td>
</tr>
<tr>
<td>int mknod(char *file, int, int)</td>
<td>创建设备文件</td>
</tr>
<tr>
<td>int fstat(int fd, struct stat *st)</td>
<td>将打开文件的信息存放到st</td>
</tr>
<tr>
<td>int stat(char *file, struct stat *st)</td>
<td>根据文件名将文件信息存放到st</td>
</tr>
<tr>
<td>int link(char *file1, char *file2)</td>
<td>给 f1 创建一个新名字(f2)</td>
</tr>
<tr>
<td>int unlink(char *file)</td>
<td>删除文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-2-I-O-and-File-descriptors"><a href="#1-2-I-O-and-File-descriptors" class="headerlink" title="1.2 I/O and File descriptors"></a>1.2 I/O and File descriptors</h3><ul>
<li><p><strong>copy.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> n = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        write(<span class="hljs-number">1</span>, buf, n);<br>    &#125;<br>    <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><em>file descriptor</em>：文件描述符，用来表示一个被内核管理的、可以被进程读/写的对象的一个整数，通常将对象称之为文件。表现形式类似于字节流，通过打开文件、目录、设备、创建管道等方式获得。一个文件被打开得越早，文件描述符就越小。</p>
<p>每个进程都拥有自己独立的文件描述符列表，其中0是标准输入，1是标准输出，2是标准错误。shell将保证总是有3个文件描述符是可用的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>((fd = open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">3</span>)&#123;<br>        close(fd);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>read</code>和<code>write</code>：形式：<code>int read(int fd, char *buf, int n)</code>和<code>int write(int fd, char *buf, int n)</code></p>
<ul>
<li><code>read</code>从文件描述符 <code>fd</code> 读 n 字节的内容写入<code>buf</code>，返回值是成功读取的字节数。</li>
<li><code>write</code>向文件描述符 <code>fd</code> 写 n 字节<code>buf</code>的内容，返回值是成功写入的字节数。</li>
<li>每个文件描述符有一个offset，<code>read</code>会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个<code>read</code>将从新的offset开始读取字节。<code>write</code>也有类似的offset</li>
<li><strong>参数</strong><ul>
<li>第一个参数是文件描述符</li>
<li>第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据</li>
<li>第三个参数是代码想读取/写入的最大长度</li>
</ul>
</li>
<li><code>read</code>如果到达了文件的结尾没有更多的内容了，<code>read</code>会返回0。如果出现了一些错误，比如文件描述符不存在，<code>read</code>会返回-1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* essence of cat program */</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-type">int</span> n;<br>  <br><span class="hljs-keyword">for</span> (;;) &#123;<br>    n = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span> buf);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read errot\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (write(<span class="hljs-number">1</span>, buf, n) != n)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>cat</code>不知道它是从文件、控制台还是管道中读取。类似地，<code>cat</code>也不知道它是否正在打印到控制台、文件或其他任何东西。通过使用 输入文件描述符0 以及 输出文件描述符1 可以简单地实现<code>cat</code>。</p>
</blockquote>
</li>
<li><p><code>close</code>。形式：<code>int close(int fd)</code>。</p>
</li>
</ul>
<ul>
<li><p>将打开的文件<code>fd</code>释放，使该文件描述符可以被后面的<code>open</code>、<code>pipe</code>、<code>dup</code>等system call使用。新分配的文件描述符始终是当前进程中编号最低的未使用描述符</p>
</li>
<li><p>使用<code>close</code>来修改file descriptor table能够实现I/O重定向</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* implementation of I/O redirection,</span><br><span class="hljs-comment"> * more specifically, cat &lt; input.txt</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cat&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// in the child process</span><br>    close(<span class="hljs-number">0</span>);  <span class="hljs-comment">// this step is to release the stdin file descriptor</span><br>    open(<span class="hljs-string">&quot;input.txt&quot;</span>, O_RDONLY); <span class="hljs-comment">// the newly allocated fd for input.txt is 0, since the previous fd 0 is released</span><br>    exec(<span class="hljs-string">&quot;cat&quot;</span>, argv); <span class="hljs-comment">// execute the cat program, by default takes in the fd 0 as input, which is input.txt</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>父进程的fd table将不会被子进程fd table的变化影响，但是文件中的offset将被共享。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    wait(<span class="hljs-number">0</span>);<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br>&#125;<br><span class="hljs-comment">/* hello world */</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>open</code>: 形式: <code>int open(char *file, int flags)</code>。</li>
</ul>
<ul>
<li><p>返回fd(当前进程中编号最低的未使用描述符)</p>
</li>
<li><p><strong>参数</strong></p>
<ul>
<li>第一个参数是要打开的文件名</li>
<li>第二个参数由一组标志组成，用位表示，控制<code>open</code>的功能，可能的值有<code>O_RDONLY, O_WRONLY, O_RDWR, O_CREATE, O_TRUNC</code>。指示<code>open</code>打开文件进行读取；写入；读写；如果文件不存在，则创建文件；将文件截断为零长度。</li>
</ul>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// open.c: create a file, write to it.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREATE);<br>  write(fd, <span class="hljs-string">&quot;ooo\n&quot;</span>, <span class="hljs-number">4</span>);<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>dup</code>: 形式：<code>int dup(int fd)</code>。</li>
</ul>
<ul>
<li><p>复制现有的<code>fd</code>，返回一个引用相同底层I/O对象的新<code>fd</code>。两个<code>fd</code>共享一个offset</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">fd = dup(<span class="hljs-number">1</span>);<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br>write(fd, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-comment">// outputs hello world</span><br></code></pre></td></tr></table></figure>
<p>除了<code>dup</code>和<code>fork</code>之外，其他方式<strong>不能</strong>使两个I/O对象共享同一个offset，比如同时<code>open</code>相同的文件</p>
<p>xv6本身是不支持标准错误文件描述符重定向的，我们可以通过<code>dup</code>来实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> existing-file non-existing-file &gt; tmp1 2&gt;&amp;1<br></code></pre></td></tr></table></figure>
<p><code>2&gt;&amp;1</code>告诉shell <code>fd2</code> 是 <code>fd1</code> 的复制，这样<em>存在文件的文件名和不存在文件的错误信息</em>都会出现在文件<code>tmp1</code>中。</p>
</li>
</ul>
<h3 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3 Pipes"></a>1.3 Pipes</h3><ul>
<li><p><em>pipe</em>: 管道是一个小的内核缓冲区，它以<strong>文件描述符对</strong>的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。</p>
</li>
<li><p><code>pipe</code>: 形式为<code>int pipe(int p[])</code>，<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 示例代码运行了程序 wc，它的标准输入绑定到了一个管道的读端口。 */</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>  <br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <br>pipe(p); <span class="hljs-comment">// read fd put into p[0], write fd put into p[1]</span><br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    close(<span class="hljs-number">0</span>);<br>    dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 子进程将管道的读端口拷贝在描述符0(标准输入)上</span><br>    close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// original read end of pipe is closed</span><br>    close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">// fd p[1] is closed in child process, but not closed in the parent process. 注意这里关闭p[1]非常重要，因为如果不关闭p[1]，管道的读取端会一直等待读取，wc就永远也无法等到EOF</span><br>    exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv); <span class="hljs-comment">// by default wc will take fd 0 as the input, which is the read end of pipe in this case</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// close the read end of pipe in parent process will not affect child process</span><br>    write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>); <br>    close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">// write end of pipe closed, the pipe shuts down</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>如果数据没有准备好，那么对管道执行的<code>read</code>会一直等待，直到有数据了或者其他绑定在这个管道写端口的描述符都已经关闭了。在后一种情况中，<code>read</code> 会返回 0，就像是一份文件读到了最后。</p>
</li>
<li><p>xv6中的实现和上述的类似</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> PIPE:<br>pcmd = (<span class="hljs-keyword">struct</span> pipecmd*)cmd;<br><span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;pipe&quot;</span>);<br><span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// in child process</span><br>    close(<span class="hljs-number">1</span>); <span class="hljs-comment">// close stdout</span><br>    dup(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">// make the fd 1 as the write end of pipe</span><br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    runcmd(pcmd-&gt;left); <span class="hljs-comment">// run command in the left side of pipe |, output redirected to the write end of pipe</span><br>&#125;<br><span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// in child process</span><br>    close(<span class="hljs-number">0</span>); <span class="hljs-comment">// close stdin</span><br>    dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// make the fd 0 as the read end of pipe</span><br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    runcmd(pcmd-&gt;right); <span class="hljs-comment">//  run command in the right side of pipe |, input redirected to the read end of pipe</span><br>&#125;<br>close(p[<span class="hljs-number">0</span>]);<br>close(p[<span class="hljs-number">1</span>]);<br>wait(<span class="hljs-number">0</span>); <span class="hljs-comment">// wait for child process to finish</span><br>wait(<span class="hljs-number">0</span>); <span class="hljs-comment">// wait for child process to finish</span><br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>管道看上去也可以用临时文件来替代，但有四个不同点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> hello world | <span class="hljs-built_in">wc</span><br><span class="hljs-built_in">echo</span> hello world &gt; /tmp/xyz; <span class="hljs-built_in">wc</span> &lt; /tmp/xyz<br></code></pre></td></tr></table></figure>
<ul>
<li>管道会进行自我清扫，如果是 shell 重定向的话，我们必须要在任务完成后删除 <code>/tmp/xyz</code></li>
<li>管道可以传输任意长度的数据</li>
<li>管道允许同步：两个进程可以使用一对管道来进行二者之间的信息传递，每一个读操作都阻塞调用进程，直到另一个进程用 <code>write</code> 完成数据的发送。</li>
<li>实现进程间通信，管道效率更高</li>
</ul>
</li>
</ul>
<h3 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4 File system"></a>1.4 File system</h3><p>xv6文件系统包含了<em>文件</em>(byte arrays)和<em>目录</em>(对其他文件和目录的引用)。目录生成了一个树，树从根目录<code>/</code>开始。对于不以<code>/</code>开头的路径，认为是是相对路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">mkdir(<span class="hljs-string">&quot;/dir&quot;</span>);<br>fd = open(<span class="hljs-string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONGLY);<br>close(fd);<br>mknod(<span class="hljs-string">&quot;/console&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>mknod</code>：形式：<code>int mknod(char *file, int, int)</code></p>
<ul>
<li>创建设备文件，一个设备文件有一个major device和一个minor device，用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将<code>read</code>和<code>write</code>的system call重新定向到设备上。</li>
</ul>
</li>
<li><p>一个文件的名称和文件本身是不一样的，文件本身，也叫<em>inode</em>。可以有多个名字，也叫<em>link</em>，每个link包括了一个文件名和一个对inode的引用。一个inode存储了文件的元数据，包括该文件的类型(file, directory or device)、大小、文件在硬盘中的存储位置以及指向这个inode的link的个数</p>
</li>
<li><p><code>fstat</code>。形式：<code>int fstat(int fd, struct stat *st)</code></p>
<ul>
<li>将inode中的相关信息存储到<code>st</code>中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DIR 1 <span class="hljs-comment">// Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE 2 <span class="hljs-comment">// File</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE 3 <span class="hljs-comment">// Device</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>    <span class="hljs-type">int</span> dev; <span class="hljs-comment">// File system’s disk device</span><br>    uint ino; <span class="hljs-comment">// Inode number</span><br>    <span class="hljs-type">short</span> type; <span class="hljs-comment">// Type of file</span><br>    <span class="hljs-type">short</span> nlink; <span class="hljs-comment">// Number of links to file</span><br>    uint64 size; <span class="hljs-comment">// Size of file in bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>link</code>。形式：<code>int link(char *file1, char *file2)</code></p>
<ul>
<li>创建一个指向同一个inode的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">open(<span class="hljs-string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);<br>link(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br><br>unlink(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>读写 <code>a</code> 就相当于读写 <code>b</code>。每一个 inode 都由一个唯一的 <code>inode 号</code> 直接确定。在上面这段代码中，我们可以通过 <code>fstat</code> 知道 <code>a</code> 和 <code>b</code> 都指向同样的内容：<code>a</code> 和 <code>b</code> 都会返回同样的 inode 号（<code>ino</code>），并且 <code>nlink</code> 数会设置为2。</li>
</ul>
</li>
</ul>
<p>注意：Unix提供了许多在<strong>用户层面</strong>的程序来执行文件系统相关的操作，比如<code>mkdir</code>、<code>ln</code>、<code>rm</code>等，而不是将其放在shell或kernel内，这样可以使用户比较方便地在这些程序上进行扩展。</p>
<p>但是<code>cd</code>是一个例外，它是在shell程序内构建的，因为它必须要改变这个calling shell本身指向的路径位置，如果是一个和shell平行的程序，那么它必须要调用一个子进程，在子进程里起一个新 shell 再进行<code>cd</code>，<code>cd</code>只会改变<em>子进程</em>的当前工作目录。父进程的工作目录保持原样。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/25/Scala-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/Scala-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Scala(4) 面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-25 00:16:50" itemprop="dateCreated datePublished" datetime="2022-09-25T00:16:50+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index"><span itemprop="name">Big Data</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Scala面向对象</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/25/Scala-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/25/Scala-3-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/Scala-3-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Scala(3) 函数式编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-25 00:16:49" itemprop="dateCreated datePublished" datetime="2022-09-25T00:16:49+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index"><span itemprop="name">Big Data</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Scala函数式编程</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/25/Scala-3-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/25/Scala-2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/Scala-2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">Scala(2) 基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-25 00:16:48" itemprop="dateCreated datePublished" datetime="2022-09-25T00:16:48+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index"><span itemprop="name">Big Data</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Scala基础语法</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/25/Scala-2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/25/Scala-1-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/Scala-1-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">Scala(1) 概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-25 00:16:47" itemprop="dateCreated datePublished" datetime="2022-09-25T00:16:47+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index"><span itemprop="name">Big Data</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Scala概述、安装、Hello World</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/25/Scala-1-%E6%A6%82%E8%BF%B0/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/14/Git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/14/Git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Git基础操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-14 21:22:06" itemprop="dateCreated datePublished" datetime="2022-09-14T21:22:06+08:00">2022-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Git基础操作</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/14/Git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/09/13/Ubuntu-20-04-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/13/Ubuntu-20-04-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Ubuntu 20.04 环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-13 21:22:40" itemprop="dateCreated datePublished" datetime="2022-09-13T21:22:40+08:00">2022-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Ubuntu/" itemprop="url" rel="index"><span itemprop="name">Ubuntu</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ubuntu 20.04 各项配置</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/13/Ubuntu-20-04-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/08/30/Redis-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/Redis-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Redis(1) 数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-30 18:25:07" itemprop="dateCreated datePublished" datetime="2022-08-30T18:25:07+08:00">2022-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-17 14:44:37" itemprop="dateModified" datetime="2024-02-17T14:44:37+08:00">2024-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Redis介绍相关知识"><a href="#1-Redis介绍相关知识" class="headerlink" title="1. Redis介绍相关知识"></a>1. Redis介绍相关知识</h2><p>Redis是单线程+多路IO复用技术</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>
<p>端口号<code>6379</code></p>
<p>默认16个数据库，类似数组下标从0开始，初始默认使用0号库</p>
<p>统一密码管理，所有库同样密码</p>
<h2 id="2-常用五大数据类型"><a href="#2-常用五大数据类型" class="headerlink" title="2. 常用五大数据类型"></a>2. 常用五大数据类型</h2><h3 id="2-1-Redis键-key"><a href="#2-1-Redis键-key" class="headerlink" title="2.1 Redis键(key)"></a>2.1 Redis键(key)</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>keys *</code></td>
<td>查看当前库所有key  (匹配：keys *1)</td>
</tr>
<tr>
<td><code>exists key</code></td>
<td>判断某个key是否存在</td>
</tr>
<tr>
<td><code>type key</code></td>
<td>查看你的key是什么类型</td>
</tr>
<tr>
<td><code>del key</code></td>
<td>删除指定的key数据</td>
</tr>
<tr>
<td><code>unlink key</code></td>
<td>非阻塞删除，只是将键与键空间<strong>断开连接</strong>。真正的删除会在后续异步操作</td>
</tr>
<tr>
<td><code>expire key 10</code></td>
<td>为给定的key设置过期时间10秒钟</td>
</tr>
<tr>
<td><code>ttl key</code></td>
<td>查看还有多少秒过期，-1表示永不过期，-2表示已过期</td>
</tr>
<tr>
<td><code>select &lt;dbid&gt;</code></td>
<td>切换数据库</td>
</tr>
<tr>
<td><code>dbsize</code></td>
<td>查看当前数据库的key的数量</td>
</tr>
<tr>
<td><code>flushdb</code></td>
<td>清空当前库</td>
</tr>
<tr>
<td><code>flushall</code></td>
<td>清空全部库</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-2-Redis字符串-String"><a href="#2-2-Redis字符串-String" class="headerlink" title="2.2 Redis字符串(String)"></a>2.2 Redis字符串(String)</h3><h4 id="2-2-1-简介"><a href="#2-2-1-简介" class="headerlink" title="2.2.1 简介"></a>2.2.1 简介</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是<code>二进制安全的</code>。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<h4 id="2-2-2-常用命令"><a href="#2-2-2-常用命令" class="headerlink" title="2.2.2 常用命令"></a>2.2.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set &lt;key&gt; &lt;value&gt;</code></td>
<td>添加键值对</td>
</tr>
<tr>
<td><code>get &lt;key&gt;</code></td>
<td>查询对应键值</td>
</tr>
<tr>
<td><code>append &lt;key&gt; &lt;value&gt;</code></td>
<td>将给定的<code>&lt;value&gt;</code>追加到原值的末尾</td>
</tr>
<tr>
<td><code>strlen &lt;key&gt;</code></td>
<td>获得值的长度</td>
</tr>
<tr>
<td><code>setnx &lt;key&gt; &lt;value&gt;</code></td>
<td>只有在 key 不存在时  设置 key 的值</td>
</tr>
<tr>
<td><code>incr &lt;key&gt;</code></td>
<td>将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1</td>
</tr>
<tr>
<td><code>decr &lt;key&gt;</code></td>
<td>将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1</td>
</tr>
<tr>
<td><code>incrby/decrby &lt;key&gt; &lt;步长&gt;</code></td>
<td>将 key 中储存的数字值增减。自定义步长</td>
</tr>
<tr>
<td><code>mset &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;</code></td>
<td>同时设置一个或多个 key-value对</td>
</tr>
<tr>
<td><code>mget &lt;key1&gt; &lt;key2&gt; &lt;key3&gt;</code></td>
<td>同时获取一个或多个 value</td>
</tr>
<tr>
<td><code>msetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;</code></td>
<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key <code>都</code>不存在。<strong>原子性，有一个失败则都失败</strong></td>
</tr>
<tr>
<td><code>getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</code></td>
<td>获得值的范围，类似java中的substring，<strong>前包，后包</strong></td>
</tr>
<tr>
<td><code>setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</code></td>
<td>用<code>&lt;value&gt;</code>覆写<code>&lt;key&gt;</code>所储存的字符串值，从<code>&lt;起始位置&gt;</code>开始(<strong>索引从0开始</strong>)。</td>
</tr>
<tr>
<td><code>setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;</code></td>
<td>设置键值的同时，设置过期时间，单位秒</td>
</tr>
<tr>
<td><code>getset &lt;key&gt; &lt;value&gt;</code></td>
<td>以新换旧，设置了新值同时获得旧值</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220831005752139.png" alt="image-20220831005752139"></p>
<blockquote>
<p>*NX: 当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX: 当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX: key的超时秒数</p>
<p>*PX: key的超时毫秒数，与EX互斥</p>
<p>==原子性==</p>
<p>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<p>（1）在单线程中，能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</p>
<p>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p>
<p>Redis单命令的原子性主要得益于Redis的单线程。</p>
</blockquote>
<h4 id="2-2-3-数据结构"><a href="#2-2-3-数据结构" class="headerlink" title="2.2.3 数据结构"></a>2.2.3 数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220831010522193.png" alt="image-20220831010522193"></p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h3 id="2-3-Redis列表-List"><a href="#2-3-Redis列表-List" class="headerlink" title="2.3 Redis列表(List)"></a>2.3 Redis列表(List)</h3><h4 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901100702152.png" alt="image-20220901100702152"></p>
<h4 id="2-3-2-常用命令"><a href="#2-3-2-常用命令" class="headerlink" title="2.3.2 常用命令"></a>2.3.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt; &lt;value3&gt; ....</code></td>
<td>从左边/右边插入一个或多个值</td>
</tr>
<tr>
<td><code>lpop/rpop &lt;key&gt;</code></td>
<td>从左边/右边吐出一个值。值在键在，值光键亡</td>
</tr>
<tr>
<td><code>rpoplpush &lt;key1&gt; &lt;key2&gt;</code></td>
<td>从<code>&lt;key1&gt;</code>列表右边吐出一个值，插到<code>&lt;key2&gt;</code>列表左边</td>
</tr>
<tr>
<td><code>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code></td>
<td>按照索引下标获得元素(从左到右)，0左边第一个，-1右边第一个，(0 -1表示获取所有)</td>
</tr>
<tr>
<td><code>lindex &lt;key&gt; &lt;index&gt;</code></td>
<td>按照索引下标获得元素(从左到右)</td>
</tr>
<tr>
<td><code>llen &lt;key&gt;</code></td>
<td>获得列表长度</td>
</tr>
<tr>
<td>`linsert <key> before</td>
<td>after <value> <newvalue>`</td>
<td>在<code>&lt;value&gt;</code>的前/后面插入<code>&lt;newvalue&gt;</code></td>
</tr>
<tr>
<td><code>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</code></td>
<td>从左边删除 n 个 value (从左到右)。当n&lt;0时，从右向左</td>
</tr>
<tr>
<td><code>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</code></td>
<td>将列表key下标为index的值替换成value</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-3-3-数据结构"><a href="#2-3-3-数据结构" class="headerlink" title="2.3.3 数据结构"></a>2.3.3 数据结构</h4><p>List的数据结构为快速链表quickList。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是zipList，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901101645368.png" alt="image-20220901101645368"></p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h3 id="2-4-Redis集合-Set"><a href="#2-4-Redis集合-Set" class="headerlink" title="2.4 Redis集合(Set)"></a>2.4 Redis集合(Set)</h3><h4 id="2-4-1-简介"><a href="#2-4-1-简介" class="headerlink" title="2.4.1 简介"></a>2.4.1 简介</h4><p>Redis set对外提供的功能与list类似，是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的<strong>无序集合</strong>。<strong>底层是一个value为null的hash表</strong>，所以添加，删除，查找的<strong>复杂度都是O(1)</strong>。</p>
<h4 id="2-4-2-常用命令"><a href="#2-4-2-常用命令" class="headerlink" title="2.4.2 常用命令"></a>2.4.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; .....</code></td>
<td>将一个或多个元素加入到集合 key 中，已经存在的元素将被忽略</td>
</tr>
<tr>
<td><code>smembers &lt;key&gt;</code></td>
<td>取出该集合的所有值</td>
</tr>
<tr>
<td><code>sismember &lt;key&gt; &lt;value&gt;</code></td>
<td>判断集合<code>&lt;key&gt;</code>是否为含有该<code>&lt;value&gt;</code>值，有1，没有0</td>
</tr>
<tr>
<td><code>scard &lt;key&gt;</code></td>
<td>返回该集合的元素个数</td>
</tr>
<tr>
<td><code>srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ....</code></td>
<td>删除集合中的某个元素</td>
</tr>
<tr>
<td><code>spop &lt;key&gt;</code></td>
<td><strong>随机从该集合中吐出一个值</strong></td>
</tr>
<tr>
<td><code>srandmember &lt;key&gt; &lt;n&gt;</code></td>
<td>随机从该集合中取出n个值。不会从集合中删除</td>
</tr>
<tr>
<td><code>smove &lt;source&gt; &lt;destination&gt; &lt;value&gt;</code></td>
<td>把集合中一个值从一个集合移动到另一个集合</td>
</tr>
<tr>
<td><code>sinter &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的交集元素</td>
</tr>
<tr>
<td><code>sunion &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的并集元素</td>
</tr>
<tr>
<td><code>sdiff &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-4-3-数据结构"><a href="#2-4-3-数据结构" class="headerlink" title="2.4.3 数据结构"></a>2.4.3 数据结构</h4><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h3 id="2-5-Redis哈希-Hash"><a href="#2-5-Redis哈希-Hash" class="headerlink" title="2.5 Redis哈希(Hash)"></a>2.5 Redis哈希(Hash)</h3><h4 id="2-5-1-简介"><a href="#2-5-1-简介" class="headerlink" title="2.5.1 简介"></a>2.5.1 简介</h4><p>Redis hash是一个键值对集合。是一个string类型的field和value的映射表，特别适合用于存储对象。</p>
<p>类似Java里面的Map<String,Object></p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901104741224.png" alt="image-20220901104741224"></p>
<p>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901104754643.png" alt="image-20220901104754643"></p>
<p>用户ID数据冗余</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901104806546.png" alt="image-20220901104806546"></p>
<p>通过 <code>key(用户ID) + field(属性标签)</code> 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p>
<h4 id="2-5-2-常用命令"><a href="#2-5-2-常用命令" class="headerlink" title="2.5.2 常用命令"></a>2.5.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></td>
<td>给<code>&lt;key&gt;</code>集合中的<code>&lt;field&gt;</code>键赋值<code>&lt;value&gt;</code></td>
</tr>
<tr>
<td><code>hget &lt;key&gt; &lt;field&gt;</code></td>
<td>从<code>&lt;key&gt;</code>集合<code>&lt;field&gt;</code>取出value</td>
</tr>
<tr>
<td><code>hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt; ...</code></td>
<td>批量设置hash的值</td>
</tr>
<tr>
<td><code>hexists &lt;key&gt; &lt;field&gt;</code></td>
<td>查看哈希表 key 中，给定域 field 是否存在</td>
</tr>
<tr>
<td><code>hkeys &lt;key&gt;</code></td>
<td>列出该hash集合的所有field</td>
</tr>
<tr>
<td><code>hvals &lt;key&gt;</code></td>
<td>列出该hash集合的所有value</td>
</tr>
<tr>
<td><code>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</code></td>
<td>为哈希表 key 中的域 field 的值加上增量</td>
</tr>
<tr>
<td><code>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></td>
<td>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-5-3-数据结构"><a href="#2-5-3-数据结构" class="headerlink" title="2.5.3 数据结构"></a>2.5.3 数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h3 id="2-6-Redis有序集合-Zset"><a href="#2-6-Redis有序集合-Zset" class="headerlink" title="2.6 Redis有序集合(Zset)"></a>2.6 Redis有序集合(Zset)</h3><h4 id="2-6-1-简介"><a href="#2-6-1-简介" class="headerlink" title="2.6.1 简介"></a>2.6.1 简介</h4><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个<strong>评分(score)</strong>，集合中的成员按照最低分到最高分的方式排序。集合的成员是唯一的，但是评分可以是重复的。</p>
<p>因为元素是有序的, 所以可以根据评分(score)或者次序(position)来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的，因此可以使用zset作为一个没有重复成员的智能列表。</p>
<h4 id="2-6-2-常用命令"><a href="#2-6-2-常用命令" class="headerlink" title="2.6.2 常用命令"></a>2.6.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;</code></td>
<td>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</td>
</tr>
<tr>
<td><code>zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [WITHSCORES]</code></td>
<td>返回有序集 key 中，下标在\<start>\<stop>之间的元素。带 WITHSCORES，可以让分数一起和值返回到结果集。</td>
</tr>
<tr>
<td><code>zrangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt; [WITHSCORES] [limit offset count]</code></td>
<td>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于min或max)的成员。有序集成员按 score 值递增(从小到大)次序排列。</td>
</tr>
<tr>
<td><code>zrevrangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt; [withscores] [limit offset count]</code></td>
<td>同上，改为从大到小排列。</td>
</tr>
<tr>
<td><code>zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</code></td>
<td>为元素的score加上增量</td>
</tr>
<tr>
<td><code>zrem &lt;key&gt; &lt;value&gt;</code></td>
<td>删除该集合下，指定值的元素</td>
</tr>
<tr>
<td><code>zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</code></td>
<td>统计该集合，分数区间内的元素个数</td>
</tr>
<tr>
<td><code>zrank &lt;key&gt; &lt;value&gt;</code></td>
<td>返回该值在集合中的排名，从0开始</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-6-3-数据结构"><a href="#2-6-3-数据结构" class="headerlink" title="2.6.3 数据结构"></a>2.6.3 数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map<String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<ul>
<li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li>
</ul>
<h4 id="2-6-4-跳跃表-跳表"><a href="#2-6-4-跳跃表-跳表" class="headerlink" title="2.6.4 跳跃表(跳表)"></a>2.6.4 跳跃表(跳表)</h4><ol>
<li><p>简介</p>
<p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p>跳跃表是一种随机化的数据结构，就是一种可以进行二分查找的有序链表，<strong>为每个节点随机出一个层数(level)</strong></p>
</li>
<li><p>对比有序链表和跳跃表，从链表中查询出51</p>
</li>
</ol>
<ul>
<li><p>有序链表</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914154523960.png" alt="image-20220914154523960"></p>
<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
</li>
<li><p>跳跃表</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914154608149.png" alt="image-20220914154608149"></p>
<p>从第2层开始，1节点比51节点小，向后比较。21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层。</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
</li>
</ul>
<h2 id="3-Redis配置文件介绍"><a href="#3-Redis配置文件介绍" class="headerlink" title="3. Redis配置文件介绍"></a>3. Redis配置文件介绍</h2><p>文件 /etc/redis/redis.conf</p>
<h3 id="3-1-NETWORK"><a href="#3-1-NETWORK" class="headerlink" title="3.1 NETWORK"></a>3.1 NETWORK</h3><p><strong>bind</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914193301605.png" alt="image-20220914193301605"></p>
<p>默认情况bind=127.0.0.1只能接受本机的访问请求</p>
<p>不写的情况下，接受任何ip地址的访问</p>
<p><strong>protected-mode</strong></p>
<p>设置本机访问保护模式</p>
<p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</p>
<p><strong>port</strong></p>
<p>端口号，默认6379</p>
<p><strong>tcp-backlog</strong></p>
<p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p>
<p><strong>timeout</strong></p>
<p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即<code>永不关闭</code>。</p>
<p><strong>tcp-keepalive</strong></p>
<p>对访问客户端的一种<code>心跳检测</code>，每n秒检测一次。</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</p>
<h3 id="3-2-GENERAL"><a href="#3-2-GENERAL" class="headerlink" title="3.2 GENERAL"></a>3.2 GENERAL</h3><p><strong>daemonize</strong></p>
<p>是否为后台进程，设置为yes</p>
<p><strong>profile</strong></p>
<p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<p><strong>loglevel</strong></p>
<p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<code>notice</code></p>
<p>四个级别根据使用阶段来选择，生产环境选择notice或者warning</p>
<p><strong>logfile</strong></p>
<p>日志文件名称</p>
<p><strong>databases</strong></p>
<p>设定库的数量，默认16个，默认数据库为0，可以使用SELECT \<dbid>命令在连接上指定数据库id</p>
<h3 id="3-3-SECURITY"><a href="#3-3-SECURITY" class="headerlink" title="3.3 SECURITY"></a>3.3 SECURITY</h3><p><strong>requirepass</strong></p>
<p>设置密码，进入redis时通过<code>auth &lt;pass&gt;</code>来使用</p>
<p>在命令中设置密码，只是临时的，永久设置需要在配置文件中进行设置</p>
<h3 id="3-4-CLIENTS"><a href="#3-4-CLIENTS" class="headerlink" title="3.4 CLIENTS"></a>3.4 CLIENTS</h3><p><strong>maxclients</strong></p>
<p>设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。</p>
<p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<h3 id="3-5-MEMORY-MANAGEMENT"><a href="#3-5-MEMORY-MANAGEMENT" class="headerlink" title="3.5 MEMORY MANAGEMENT"></a>3.5 MEMORY MANAGEMENT</h3><p><strong>maxmemory</strong></p>
<p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</p>
<p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<p><strong>maxmemory-policy</strong></p>
<ul>
<li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</li>
<li>allkeys-lru：在所有集合key中，使用LRU算法移除key</li>
<li>volatile-lfu：使用LFU算法移除key，只对设置了过期时间的键；（最近最不常使用）</li>
<li>allkeys-lfu：在所有集合key中，使用LFU算法移除key</li>
<li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li>
<li>allkeys-random：在所有集合key中，移除随机的key</li>
<li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li>
<li>noeviction：不进行移除。针对写操作，只是返回错误信息</li>
</ul>
<p><strong>maxmemory-samples</strong></p>
<p>设置样本数量，LRU,LFU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个</p>
<p>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小</p>
<h2 id="4-Redis的发布和订阅"><a href="#4-Redis的发布和订阅" class="headerlink" title="4. Redis的发布和订阅"></a>4. Redis的发布和订阅</h2><h3 id="4-1-什么是发布和订阅"><a href="#4-1-什么是发布和订阅" class="headerlink" title="4.1 什么是发布和订阅"></a>4.1 什么是发布和订阅</h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h3 id="4-2-Redis的发布和订阅"><a href="#4-2-Redis的发布和订阅" class="headerlink" title="4.2 Redis的发布和订阅"></a>4.2 Redis的发布和订阅</h3><p>客户端可以订阅频道如下图</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200344453.png" alt="image-20220914200344453"></p>
<p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200349203.png" alt="image-20220914200349203"></p>
<h3 id="4-3-发布订阅命令行实现"><a href="#4-3-发布订阅命令行实现" class="headerlink" title="4.3 发布订阅命令行实现"></a>4.3 发布订阅命令行实现</h3><ol>
<li>打开一个客户端订阅channel1</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200539836.png" alt="image-20220914200539836"></p>
<ol>
<li>打开另一个客户端，给channel1发布消息hello</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200723253.png" alt="image-20220914200723253"></p>
<ol>
<li>第一个客户端接收到消息</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200738291.png" alt="image-20220914200738291"></p>
<h2 id="5-Redis新数据类型"><a href="#5-Redis新数据类型" class="headerlink" title="5. Redis新数据类型"></a>5. Redis新数据类型</h2><h3 id="5-1-Bitmaps"><a href="#5-1-Bitmaps" class="headerlink" title="5.1 Bitmaps"></a>5.1 Bitmaps</h3><h4 id="5-1-1-简介"><a href="#5-1-1-简介" class="headerlink" title="5.1.1 简介"></a>5.1.1 简介</h4><p>Redis提供了Bitmaps以实现对位的操作</p>
<ul>
<li><p>Bitmaps本身不是一种数据类型，实际上它就是字符串（key-value），但是它可以对字符串的位进行操作。</p>
</li>
<li><p>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914203611578.png" alt="image-20220914203611578"></p>
<h4 id="5-1-2-命令"><a href="#5-1-2-命令" class="headerlink" title="5.1.2 命令"></a>5.1.2 命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</code></td>
<td>设置Bitmaps中某个偏移量的值(0或1)</td>
</tr>
<tr>
<td><code>getbit &lt;key&gt; &lt;offset&gt;</code></td>
<td>获取Bitmaps中某个偏移量的值</td>
</tr>
<tr>
<td><code>bitcount &lt;key&gt; [start end]</code></td>
<td>统计字符串从start字节到end字节比特值为1的数量，可以使用负数值：比如 -1 表示最后一个字节，而 -2 表示倒数第二个字节</td>
</tr>
<tr>
<td><code>bitop and(or/not/xor) &lt;destkey&gt; [key…]</code></td>
<td>bitop是一个复合操作，它可以做多个Bitmaps的and(交集)、or(并集)、not(非)、xor(异或)操作并将结果保存在destkey中。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-2-HyperLogLog"><a href="#5-2-HyperLogLog" class="headerlink" title="5.2 HyperLogLog"></a>5.2 HyperLogLog</h3><h4 id="5-2-1-简介"><a href="#5-2-1-简介" class="headerlink" title="5.2.1 简介"></a>5.2.1 简介</h4><p>求集合中不重复元素个数的问题称为基数问题。</p>
<p>Redis HyperLogLog就是用来做基数统计的算法，HyperLogLog的优点是在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<h4 id="5-2-2-命令"><a href="#5-2-2-命令" class="headerlink" title="5.2.2 命令"></a>5.2.2 命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pfadd &lt;key&gt; &lt;element&gt; [element ...]</code></td>
<td>添加指定元素到 HyperLogLog 中</td>
</tr>
<tr>
<td><code>pfcount &lt;key&gt; [key ...]</code></td>
<td>计算HLL的近似基数，可以计算多个HLL</td>
</tr>
<tr>
<td><code>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey ...]</code></td>
<td>将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-3-Geospatial"><a href="#5-3-Geospatial" class="headerlink" title="5.3 Geospatial"></a>5.3 Geospatial</h3><h4 id="5-3-1-简介"><a href="#5-3-1-简介" class="headerlink" title="5.3.1 简介"></a>5.3.1 简介</h4><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h4 id="5-3-2-命令"><a href="#5-3-2-命令" class="headerlink" title="5.3.2 命令"></a>5.3.2 命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt; [longitude latitude member...]</code></td>
<td>添加地理位置(经度，纬度，名称)</td>
</tr>
<tr>
<td><code>geopos &lt;key&gt; &lt;member&gt; [member...]</code></td>
<td>获得指定地区的坐标值</td>
</tr>
<tr>
<td>`geodist <key> <member1> <member2> [m</td>
<td>km</td>
<td>ft</td>
<td>mi]`</td>
<td>获取两个位置之间的直线距离,mi-英里,ft-英尺。默认使用m</td>
</tr>
<tr>
<td>`georadius <key> <longitude> <latitude> radius [m</td>
<td>km</td>
<td>ft</td>
<td>mi]`</td>
<td>以给定的经纬度为中心，找出某一半径内的元素</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6. Jedis"></a>6. Jedis</h2><ul>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>注意事项</p>
<p>禁用Linux的防火墙，redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</p>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.231.131&quot;</span>,<span class="hljs-number">6379</span>);<br>        jedis.auth(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pong</span> <span class="hljs-operator">=</span> jedis.ping();<br>        System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span>+pong);<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>简单使用</p>
<ul>
<li><p>key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>System.out.println(keys.size());<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));                <br>System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br></code></pre></td></tr></table></figure></li>
<li><p>string</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br>jedis.incr(<span class="hljs-string">&quot;str1&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>list</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order01&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order03&quot;</span>);<br>Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;orders&quot;</span>);<br>jedis.srem(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>hash</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,String&gt;();<br>map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>map.put(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;abc@163.com&quot;</span>);<br>jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>zset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">90d</span>, <span class="hljs-string">&quot;l4&quot;</span>);<br> <br>Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="7-SpringBoot整合Redis"><a href="#7-SpringBoot整合Redis" class="headerlink" title="7. SpringBoot整合Redis"></a>7. SpringBoot整合Redis</h2><ul>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.231</span><span class="hljs-number">.131</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">password</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">18000000</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-comment"># 连接池最大连接数(负值表示没有限制)</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 最大阻塞等待时间(负数表示没有限制)</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 连接池中的最大空闲连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-comment"># 连接池中的最小空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        <span class="hljs-comment">// 1.创建 redisTemplate 模版</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 2.关联 redisConnectionFactory</span><br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">// 3.创建 序列化类</span><br>        <span class="hljs-type">GenericToStringSerializer</span> <span class="hljs-variable">genericToStringSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericToStringSerializer</span>(Object.class);<br>        <span class="hljs-comment">// 6.序列化类，对象映射设置</span><br>        <span class="hljs-comment">// 7.设置 value 的转化格式和 key 的转化格式</span><br>        template.setValueSerializer(genericToStringSerializer);<br>        template.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        template.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/redisTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTestController</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置值到redis</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>        <span class="hljs-comment">//从redis获取值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String)redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/08/11/SpringCloud-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/SpringCloud-1/" class="post-title-link" itemprop="url">SpringCloud(1) 服务注册中心</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-11 14:49:33" itemprop="dateCreated datePublished" datetime="2022-08-11T14:49:33+08:00">2022-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h1><h2 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1 Eureka"></a>1 Eureka</h2><h3 id="1-1-Eureka基础知识"><a href="#1-1-Eureka基础知识" class="headerlink" title="1.1 Eureka基础知识"></a>1.1 Eureka基础知识</h3><ul>
<li>什么是服务治理<ul>
<li>Spring Cloud封装了Netflix公司开发的Eureka模块来实现服务治理</li>
<li>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</li>
</ul>
</li>
<li>什么是服务注册与发现<ul>
<li>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到Eureka Sever并维持心跳连接。这样系统的维护人员就可以通过Euleka Server来监控系统中各个微服务是否正常运行。</li>
<li>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者|服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))</li>
</ul>
</li>
<li>包含两个组件<ul>
<li>Eureka Server提供服务注册服务<ul>
<li>各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</li>
</ul>
</li>
<li>Eureka Client通过注册中心进行访问<ul>
<li>是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳, Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-Eureka-Server端配置"><a href="#1-2-Eureka-Server端配置" class="headerlink" title="1.2 Eureka Server端配置"></a>1.2 Eureka Server端配置</h3><ol>
<li><p>创建工程 cloud-eureka-server7001</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span>  <span class="hljs-comment"># eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment"># false表示不向注册中心注册自己</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaMain7001</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaMain7001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试运行<code>EurekaMain7001</code>，浏览器输入<code>http://localhost:7001/</code>回车，会查看到Spring Eureka服务主页。</p>
</li>
</ol>
<h3 id="1-3-Eureka-Client端配置"><a href="#1-3-Eureka-Client端配置" class="headerlink" title="1.3 Eureka Client端配置"></a>1.3 Eureka Client端配置</h3><ol>
<li><p>修改工程 cloud-provider-payment8001</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br>  <br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span><br>    <br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment"># 表示是否将自己注册进EurekaServer 默认为true</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 是否从EurekaServer抓取已有的注册信息, 默认为true。单点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentMain8001</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(PaymentMain8001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<ul>
<li><p>启动cloud-provider-payment8001和cloud-eureka-server7001工程。</p>
</li>
<li><p>浏览器输入 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001/</a> 主页内的<strong>Instances currently registered with Eureka</strong>会显示cloud-provider-payment8001的配置文件application.yml设置的应用名<strong>cloud-payment-service</strong></p>
</li>
</ul>
</li>
<li><p>自我保护机制</p>
<blockquote>
<p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.</p>
<p>紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。</p>
</blockquote>
</li>
</ol>
<h3 id="1-4-Eureka集群原理说明"><a href="#1-4-Eureka集群原理说明" class="headerlink" title="1.4 Eureka集群原理说明"></a>1.4 Eureka集群原理说明</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220727165105034.png" alt="image-20220727165105034"></p>
<ul>
<li>问题：微服务RPC远程服务调用最核心的是什么<ul>
<li>高可用，试想你的注册中心只有一个，万一它出故障了，会导致整个微服务环境不可用。</li>
</ul>
</li>
<li>解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错。<ul>
<li><strong>互相注册，相互守望</strong>。</li>
</ul>
</li>
</ul>
<h3 id="1-5-Eureka集群环境构建"><a href="#1-5-Eureka集群环境构建" class="headerlink" title="1.5 Eureka集群环境构建"></a>1.5 Eureka集群环境构建</h3><ul>
<li><p>创建cloud-eureka-server7002工程，参考<strong>1.1.2</strong></p>
</li>
<li><p>找到C:\Windows\System32\drivers\etc路径下的hosts文件，修改映射配置添加进hosts文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">127.0.0.1 eureka7001.com<br>127.0.0.1 eureka7002.com<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改cloud-eureka-server7001配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span> <span class="hljs-comment">#eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment">#false表示不向注册中心注册自己。</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br>    <span class="hljs-attr">service-url:</span><br>    <span class="hljs-comment">#集群指向其它eureka</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/</span><br>    <span class="hljs-comment">#单机就是7001自己</span><br>      <span class="hljs-comment">#defaultZone: http://eureka7001.com:7001/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>修改cloud-eureka-server7002配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7002</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7002.com</span>  <span class="hljs-comment"># eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment"># false表示不向注册中心注册自己</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>启动服务，访问eureka7001.com:7001与eureka7002.com:7002</p>
</li>
</ul>
<h3 id="1-6-将微服务注册进Eureka集群"><a href="#1-6-将微服务注册进Eureka集群" class="headerlink" title="1.6 将微服务注册进Eureka集群"></a>1.6 将微服务注册进Eureka集群</h3><ul>
<li><p>修改微服务application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment">#表示是否将自己注册进Eurekaserver默认为true。</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br>    <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka,</span> <span class="hljs-string">http://eureka7002.com:7002/eureka</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-7-支付微服务集群配置"><a href="#1-7-支付微服务集群配置" class="headerlink" title="1.7 支付微服务集群配置"></a>1.7 支付微服务集群配置</h3><ul>
<li><p>构建cloud-provider-payment8002工程，参考cloud-provider-payment8001 (<strong>1.1.3</strong>)</p>
</li>
<li><p>修改8001/8002的Controller，添加serverPort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentController</span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String serverPort;<span class="hljs-comment">//添加serverPort</span><br><br>    <span class="hljs-meta">@PostMapping(value = &quot;/payment/create&quot;)</span><br>    <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Payment payment)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> paymentService.create(payment);<br>        log.info(<span class="hljs-string">&quot;*****插入结果：&quot;</span> + result);<br><br>        <span class="hljs-keyword">if</span>(result &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;插入数据库成功,serverPort: &quot;</span> + serverPort, result);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;插入数据库失败&quot;</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>负载均衡</strong></p>
<ul>
<li><p>cloud-consumer-order80订单服务访问地址不能写死</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-comment">//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PAYMENT_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>; <span class="hljs-comment">//Eureka注册的服务名</span><br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContextConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">getRestTemplate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>测试</p>
<ul>
<li><p>先要启动EurekaServer，7001/7002服务</p>
</li>
<li><p>再要启动服务提供者provider，8001/8002服务</p>
</li>
<li><p>浏览器输入 - <a target="_blank" rel="noopener" href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a></p>
</li>
<li><p><strong>结果：负载均衡效果达到，8001/8002端口交替出现</strong></p>
<p>Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能。</p>
</li>
<li><p><strong>相互注册，相互守望</strong></p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220727165120848.png" alt="image-20220727165120848"></p>
</li>
</ul>
<h3 id="1-8-actuator微服务信息完善"><a href="#1-8-actuator微服务信息完善" class="headerlink" title="1.8 actuator微服务信息完善"></a>1.8 actuator微服务信息完善</h3><ul>
<li><p>主机名称：服务名称修改(也就是将IP地址，换成可读性高的名字)</p>
<ul>
<li><p>修改cloud-provider-payment8001，cloud-provider-payment8002的YML - eureka.instance.instance-id</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span> <span class="hljs-comment">#添加此处</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8002</span> <span class="hljs-comment">#添加此处</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>修改之后eureka主页将显示payment8001，payment8002代替原来显示的IP地址。</p>
</li>
</ul>
</li>
<li><p>访问信息有IP信息提示，(就是将鼠标指针移至payment8001，payment8002名下，会有IP地址提示)</p>
<ul>
<li><p>修改部分 - YML - eureka.instance.prefer-ip-address</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span> <br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#添加此处</span><br>    <br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8002</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#添加此处</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1-9-服务发现Discovery"><a href="#1-9-服务发现Discovery" class="headerlink" title="1.9 服务发现Discovery"></a>1.9 服务发现Discovery</h3><p>对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息</p>
<ul>
<li><p>修改cloud-provider-payment8001的Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentController</span>&#123;<br>	...<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><br>    ...<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">discovery</span><span class="hljs-params">()</span><br>    &#123;<br>        List&lt;String&gt; services = discoveryClient.getServices();<br>        <span class="hljs-keyword">for</span> (String element : services) &#123;<br>            log.info(<span class="hljs-string">&quot;*****element: &quot;</span>+element);<br>        &#125;<br><br>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);<br>        <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;<br>            log.info(instance.getServiceId()+<span class="hljs-string">&quot;\t&quot;</span>+instance.getHost()+<span class="hljs-string">&quot;\t&quot;</span>+instance.getPort()+<span class="hljs-string">&quot;\t&quot;</span>+instance.getUri());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.discoveryClient;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>8001主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-comment">//添加该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentMain001</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(PaymentMain001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>自测</p>
<ul>
<li>浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8001/payment/discovery">http://localhost:8001/payment/discovery</a></li>
</ul>
</li>
</ul>
<h3 id="1-10-Eureka自我保护"><a href="#1-10-Eureka自我保护" class="headerlink" title="1.10 Eureka自我保护"></a>1.10 Eureka自我保护</h3><ul>
<li><p><strong>概述</strong></p>
<ul>
<li><p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</p>
</li>
<li><p>如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式:</p>
<blockquote>
<p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THANTHRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUSTTO BE SAFE</p>
</blockquote>
</li>
<li><p>一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。</p>
</li>
<li><p>属于CAP里面的AP分支。</p>
</li>
</ul>
</li>
<li><p><strong>为什么会产生Eureka自我保护机制?</strong></p>
<ul>
<li>为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除</li>
</ul>
</li>
<li><strong>什么是自我保护模式?</strong><ul>
<li>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。</li>
<li><strong>在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例</strong>。</li>
<li>它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：<strong>好死不如赖活着</strong>。</li>
<li>综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务(健康的微服务和不健康的微服务都会保留)也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</li>
</ul>
</li>
</ul>
<h3 id="1-11-禁止Eureka自我保护"><a href="#1-11-禁止Eureka自我保护" class="headerlink" title="1.11 禁止Eureka自我保护"></a>1.11 禁止Eureka自我保护</h3><ul>
<li><p>在eurekaServer端7001处设置关闭自我保护机制</p>
</li>
<li><p>默认自我保护机制是开启的，使用<code>eureka.server.enable-self-preservation = false</code>可以禁用自我保护模式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-comment">#关闭自我保护机制，保证不可用服务被及时踢除</span><br>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>关闭效果：</p>
<ul>
<li><p>spring-eureka主页会显示出一句：</p>
<blockquote>
<p>THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>生产者客户端eureakeClient端8001</p>
<ul>
<li><p>默认</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">eureka.instance.lease-renewal-interval-in-seconds=30</span><br><span class="hljs-string">eureka.instance.lease-expiration-duration-in-seconds=90</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>修改为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#心跳检测与续约时间</span><br>    <span class="hljs-comment">#开发时没置小些，保证服务关闭后注册中心能即使剔除服务</span><br>    <span class="hljs-comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span><br>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment">#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务</span><br>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>测试</p>
<ul>
<li>7001和8001都配置完成</li>
<li>先启动7001再启动8001</li>
<li>先关闭8001，马上就被删除了</li>
</ul>
</li>
</ul>
<h2 id="2-Zookeeper"><a href="#2-Zookeeper" class="headerlink" title="2 Zookeeper"></a>2 Zookeeper</h2><h2 id="3-Consul"><a href="#3-Consul" class="headerlink" title="3 Consul"></a>3 Consul</h2><h2 id="4-Nacos"><a href="#4-Nacos" class="headerlink" title="4 Nacos"></a>4 Nacos</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
