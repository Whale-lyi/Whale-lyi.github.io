<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 8 | Whale&#39;s Blog | Stay hungry, Stay foolish</title>

  
  <meta name="author" content="Whale">
  

  
  <meta name="description" content="码农预备役">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Whale&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whale&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Whale&#39;s Blog</a>
    </h1>
    <p class="site-description">Stay hungry, Stay foolish</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/20/6-S081-Lab-2-System-calls/"><span>6.S081 Lab(2) System calls</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/20/6-S081-Lab-2-System-calls/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-20T11:08:31.000Z">
          2022-10-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>课程主页</strong>：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p>
<h2 id="Lab2-System-calls"><a href="#Lab2-System-calls" class="headerlink" title="Lab2 System calls"></a>Lab2 System calls</h2><h3 id="2-1-System-call-tracing-moderate"><a href="#2-1-System-call-tracing-moderate" class="headerlink" title="2.1 System call tracing (moderate)"></a>2.1 System call tracing (moderate)</h3><h3 id="2-2-Sysinfo-moderate"><a href="#2-2-Sysinfo-moderate" class="headerlink" title="2.2 Sysinfo (moderate)"></a>2.2 Sysinfo (moderate)</h3>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/MIT/">MIT</a>, <a href="/categories/MIT/6-S081/">6.S081</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/20/6-S081-Lab-1-Utilities/"><span>6.S081 Lab(1) Utilities</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/20/6-S081-Lab-1-Utilities/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-20T11:08:30.000Z">
          2022-10-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>课程主页</strong>：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p>
<h2 id="Lab0-Tools"><a href="#Lab0-Tools" class="headerlink" title="Lab0 Tools"></a>Lab0 Tools</h2><p>虚拟机使用<strong>VMware Workstation 16 Player</strong>，系统采用<strong>ubuntu20.04</strong></p>
<p>安装必要工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu <br></code></pre></td></tr></table></figure>
<p>测试安装</p>
<ul>
<li><p>你应当可以编译并运行xv6（按住Ctrl+a  x退出）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># in the xv6 directory</span><br>$ make qemu<br><span class="hljs-comment"># ... lots of output ...</span><br>init: starting sh<br>$<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1 Xv6 and Unix utilities"></a>Lab1 Xv6 and Unix utilities</h2><h3 id="1-1-Boot-xv6-easy"><a href="#1-1-Boot-xv6-easy" class="headerlink" title="1.1 Boot xv6 (easy)"></a>1.1 Boot xv6 (easy)</h3><p>clone仓库并切换到util分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021<br>$ <span class="hljs-built_in">cd</span> xv6-labs-2021<br>$ git checkout util<br></code></pre></td></tr></table></figure>
<p>提交代码, -a 表示不需要git add 直接提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -a 表示不需要git add 直接提交</span><br>$ git commit -am <span class="hljs-string">&#x27;my solution for util lab exercise 1&#x27;</span><br></code></pre></td></tr></table></figure>
<p>查看代码变动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 展示和上次提交代码不同的地方</span><br>$ git diff<br><span class="hljs-comment"># 展示和初始时不同的地方</span><br>$ git diff origin/util<br></code></pre></td></tr></table></figure>
<p>启动qemu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ make qemu<br></code></pre></td></tr></table></figure>
<p>查看可执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span><br>.              1 1 1024<br>..             1 1 1024<br>README         2 2 2059<br>xargstest.sh   2 3 93<br><span class="hljs-built_in">cat</span>            2 4 24256<br><span class="hljs-built_in">echo</span>           2 5 23080<br>forktest       2 6 13272<br>grep           2 7 27560<br>init           2 8 23816<br><span class="hljs-built_in">kill</span>           2 9 23024<br><span class="hljs-built_in">ln</span>             2 10 22880<br><span class="hljs-built_in">ls</span>             2 11 26448<br><span class="hljs-built_in">mkdir</span>          2 12 23176<br><span class="hljs-built_in">rm</span>             2 13 23160<br>sh             2 14 41976<br>stressfs       2 15 24016<br>usertests      2 16 148456<br>grind          2 17 38144<br><span class="hljs-built_in">wc</span>             2 18 25344<br>zombie         2 19 22408<br>console        3 20 0<br></code></pre></td></tr></table></figure>
<p>xv6没有ps命令，但按Ctrl-p，内核会打印每个进程的信息。如果现在尝试，会看到两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">1 <span class="hljs-built_in">sleep</span>  init<br>2 <span class="hljs-built_in">sleep</span>  sh<br></code></pre></td></tr></table></figure>
<p>退出可按住Ctrl-a，再输入x</p>
<p>通过<code>make grade</code>获取成绩，<code>make handin</code>提交lab</p>
<h3 id="1-2-sleep-easy"><a href="#1-2-sleep-easy" class="headerlink" title="1.2 sleep (easy)"></a>1.2 sleep (easy)</h3><p>user中创建sleep.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Please enter a number!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>添加到Makefile中</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">UPROGS=\<br>        $U/_cat\<br>        $U/_echo\<br>        $U/_forktest\<br>        $U/_grep\<br>        $U/_init\<br>        $U/_kill\<br>        $U/_ln\<br>        $U/_ls\<br>        $U/_mkdir\<br>        $U/_rm\<br>        $U/_sh\<br>        $U/_stressfs\<br>        $U/_usertests\<br>        $U/_grind\<br>        $U/_wc\<br>        $U/_zombie\<br>        $U/_sleep\<br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ ./grade-lab-util <span class="hljs-built_in">sleep</span><br>make: “kernel/kernel”已是最新。<br>== Test <span class="hljs-built_in">sleep</span>, no arguments == <span class="hljs-built_in">sleep</span>, no arguments: OK (2.1s) <br>== Test <span class="hljs-built_in">sleep</span>, returns == <span class="hljs-built_in">sleep</span>, returns: OK (0.6s) <br>== Test <span class="hljs-built_in">sleep</span>, makes syscall == <span class="hljs-built_in">sleep</span>, makes syscall: OK (0.9s) <br></code></pre></td></tr></table></figure>
<h3 id="1-3-pingpong-easy"><a href="#1-3-pingpong-easy" class="headerlink" title="1.3 pingpong (easy)"></a>1.3 pingpong (easy)</h3><p>添加到Makefile</p>
<p>user中添加pingpong.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READEND 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITEEND 1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>	<span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>	<span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>	<span class="hljs-type">int</span> pid;<br>	<span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br><br>	pipe(p1);<br>	pipe(p2);<br><br>	pid = fork();<br><br>	<span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>		close(p1[WRITEEND]);<br>		close(p2[READEND]);<br>		read(p1[READEND], buf, <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br>		write(p2[WRITEEND], buf, <span class="hljs-number">1</span>);<br>		close(p1[READEND]);<br>		close(p2[WRITEEND]);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		close(p1[READEND]);<br>		close(p2[WRITEEND]);<br>		write(p1[WRITEEND], <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>		read(p2[READEND], buf, <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br>		close(p1[WRITEEND]);<br>		close(p2[READEND]);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用两个管道进行双向的数据传输，子进程要先等待父进程写才能读，之后父进程要等子进程写才能读</p>
<h3 id="1-4-primes-moderate-hard"><a href="#1-4-primes-moderate-hard" class="headerlink" title="1.4 primes (moderate)/(hard)"></a>1.4 primes (moderate)/(hard)</h3><p>素数筛法：将一组数feed到一个进程里，先print出最小的一个数，这是一个素数，然后用其他剩下的数依次尝试整除这个素数，如果可以整除，则将其drop，不能整除则将其feed到下一个进程中，直到最后打印出所有的素数。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220815203942525.png" alt="image-20220815203942525"></p>
<p>解决思路：采用递归，每次先尝试从左pipe中读取一个数，如果读不到说明已经到达终点，exit，否则再创建一个右pipe并fork一个子进程，将筛选后的数feed进这个右pipe。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READEND 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITEEND 1</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br><br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>        child(p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[READEND]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;<br>            write(p[WRITEEND], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        &#125;   <br>        close(p[WRITEEND]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> &#123;<br>    <span class="hljs-type">int</span> pr[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> n;<br><br>    close(p[WRITEEND]);<br>    <span class="hljs-keyword">if</span>(read(p[READEND], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <br>    <br>    pipe(pr);<br><br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>        child(pr);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(pr[READEND]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, n);<br>        <span class="hljs-type">int</span> prime = n;<br>        <span class="hljs-keyword">while</span>(read(p[READEND], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) &#123;<br>            <span class="hljs-keyword">if</span>(n % prime != <span class="hljs-number">0</span>) &#123;<br>                write(pr[WRITEEND], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>            &#125;<br>        &#125;<br>        close(pr[WRITEEND]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1-5-find-moderate"><a href="#1-5-find-moderate" class="headerlink" title="1.5 find (moderate)"></a>1.5 find (moderate)</h4><p>模仿 ls.c 即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span>* file)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: You need pass in only 2 argument&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> *target_path = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">char</span> *target_file = argv[<span class="hljs-number">2</span>];<br>    find(target_path, target_file);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span>* file)</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span>(st.type)&#123;<br>        <span class="hljs-keyword">case</span> T_FILE:<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-built_in">strlen</span>(path) - <span class="hljs-built_in">strlen</span>(file), file) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> T_DIR:<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">strcpy</span>(buf, path);  <br>            p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>            *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>            <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>                <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 获取完整路径名</span><br>                memmove(p, de.name, DIRSIZ);<br>                p[DIRSIZ] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 递归时不要进入.和..</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span>)) &#123;<br>                    find(buf, file);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-6-xargs-mederate"><a href="#1-6-xargs-mederate" class="headerlink" title="1.6 xargs (mederate)"></a>1.6 xargs (mederate)</h3><p>实现将标准输入作为参数一起输入到<code>xargs</code>后面跟的命令中，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> hello too | xargs <span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span><br><span class="hljs-built_in">bye</span> hello too<br></code></pre></td></tr></table></figure>
<p>如果标准输入有多行，那么也要执行多次命令</p>
<p>使用<code>fork</code>起一个子进程，在子进程中用<code>exec</code>执行相应的命令。父进程<code>wait</code>。对标准输入每次读一个char，若读到<code>\n</code>需要执行命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LEN 100</span><br>   <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>	<span class="hljs-type">char</span> *command = argv[<span class="hljs-number">1</span>];<br>	<span class="hljs-type">char</span> bf;<br>	<span class="hljs-type">char</span> paramv[MAXARG][MAX_LEN]; <span class="hljs-comment">// arguments</span><br>	<span class="hljs-type">char</span> *m[MAXARG];<br>   <br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-type">int</span> count = argc - <span class="hljs-number">1</span>;  <span class="hljs-comment">// # of current arguments</span><br>		<span class="hljs-built_in">memset</span>(paramv, <span class="hljs-number">0</span>, MAXARG * MAX_LEN);<br>		<span class="hljs-comment">// copy the parameter of command</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123;<br>			<span class="hljs-built_in">strcpy</span>(paramv[i - <span class="hljs-number">1</span>], argv[i]);<br>		&#125;<br>   <br>		<span class="hljs-type">int</span> cursor = <span class="hljs-number">0</span>; <span class="hljs-comment">// cursor pointing the char position in single_arg</span><br>		<span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>; <span class="hljs-comment">// flag indicating whether thers is argument preceding space</span><br>		<span class="hljs-type">int</span> read_result;<br>   <br>		<span class="hljs-keyword">while</span> (((read_result = read(<span class="hljs-number">0</span>, &amp;bf, <span class="hljs-number">1</span>))) &gt; <span class="hljs-number">0</span> &amp;&amp; bf != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>			<span class="hljs-keyword">if</span> (bf == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; flag == <span class="hljs-number">1</span>) &#123;<br>				count++;<br>				<span class="hljs-comment">// reset flag and p</span><br>				cursor = <span class="hljs-number">0</span>;<br>				flag = <span class="hljs-number">0</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bf != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>				paramv[count][cursor++] = bf;<br>				flag = <span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>		<br>		<span class="hljs-keyword">if</span> (read_result &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// encounters EOF of input</span><br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXARG - <span class="hljs-number">1</span>; i++) &#123;<br>			m[i] = paramv[i];<br>		&#125;<br>		m[MAXARG - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 参数最后0结尾</span><br>		<span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>			exec(command, m);<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>到这里lab1就全部完成了！</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221020170416506.png" alt="image-20221020170416506"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/MIT/">MIT</a>, <a href="/categories/MIT/6-S081/">6.S081</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/17/Ubuntu20-04中VSCode配置C-C-环境/"><span>Ubuntu中配置VSCode的C/C++环境</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/17/Ubuntu20-04中VSCode配置C-C-环境/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-17T15:50:41.000Z">
          2022-10-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="1-安装gcc、gdb"><a href="#1-安装gcc、gdb" class="headerlink" title="1. 安装gcc、gdb"></a>1. 安装gcc、gdb</h3><p>打开终端依次输入以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt update<br>$ sudo apt install build-essential<br>$ sudo apt install gdb<br><br><span class="hljs-comment"># 输入以下内容检查是否安装成功</span><br>$ gcc -v<br>$ g++ -v<br>$ gdb -v<br></code></pre></td></tr></table></figure>
<h3 id="2-安装VSCode插件"><a href="#2-安装VSCode插件" class="headerlink" title="2. 安装VSCode插件"></a>2. 安装VSCode插件</h3><p>只需要安装最基本的<strong>C/C++</strong>与<strong>Code Runner</strong>即可</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221017235454131.png" alt="image-20221017235454131"></p>
<h3 id="3-创建文件夹并编写Hello-World"><a href="#3-创建文件夹并编写Hello-World" class="headerlink" title="3. 创建文件夹并编写Hello World"></a>3. 创建文件夹并编写Hello World</h3><p>在用户主目录(~)创建一个VSCode专用的文件夹vscode，用vscode打开并在其中创建一个c++文件夹用来存放C/C++代码</p>
<p>创建hello.cpp，点击右上角Run Code运行，可以看到控制台输出Hello World</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018000410325.png" alt="image-20221018000410325"></p>
<h3 id="4-调试程序"><a href="#4-调试程序" class="headerlink" title="4. 调试程序"></a>4. 调试程序</h3><p>在vscode文件夹中的<code>.vscode</code>文件夹中创建两个文件<code>launch.json</code>,<code>tasks.json</code>，并写入以下内容</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018000915388.png" alt="image-20221018000915388"></p>
<p><strong>launch.json</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;compile&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p><strong>tasks.json</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;compile&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;g++&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;-g&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-o&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;owner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cpp&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;fileLocation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;relative&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;&quot;</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;pattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;regexp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;line&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;column&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>进入VSCode左侧的调试，打好断点后，点击运行和调试即可正常调试了</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221018001210659.png" alt="image-20221018001210659"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux/">Linux</a>, <a href="/categories/Linux/Ubuntu/">Ubuntu</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Linux/">Linux</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/10/13/weka实现降维-分类-聚类/"><span>weka实现降维,分类,聚类</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/10/13/weka实现降维-分类-聚类/" rel="bookmark">
        <time class="entry-date published" datetime="2022-10-12T16:11:52.000Z">
          2022-10-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>实验使用java weka api，首先导入weka依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/nz.ac.waikato.cms.weka/weka-stable --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>nz.ac.waikato.cms.weka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>weka-stable<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="1-降维"><a href="#1-降维" class="headerlink" title="1.降维"></a>1.降维</h2><h3 id="1-1-方法介绍"><a href="#1-1-方法介绍" class="headerlink" title="1.1 方法介绍"></a>1.1 方法介绍</h3><p>数据降维采用PCA(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。</p>
<p>PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n条这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面k条坐标轴中，后面的坐标轴所含的方差几乎为0。于是，我们可以忽略余下的坐标轴，只保留前面k条含有绝大部分方差的坐标轴。事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为0的特征维度，实现对数据特征的降维处理。</p>
<h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-type">Instances</span> <span class="hljs-variable">dataset</span> <span class="hljs-operator">=</span> DataSource.read(<span class="hljs-string">&quot;src/main/resources/diabetes.arff&quot;</span>);<br>    dataset.setClassIndex(dataset.numAttributes() - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">PrincipalComponents</span> <span class="hljs-variable">pca</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrincipalComponents</span>();<br>    pca.setCenterData(<span class="hljs-literal">true</span>);<br>    pca.buildEvaluator(dataset);<br>    System.out.println(pca);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先通过DataSource读取数据集，设置最后一列为标签(setClassIndex),然后创建PrincipalComponents对象，设置对数据进行中心化处理，随后导入数据，初始化主成分并执行分析，最后打印结果即可</p>
<h3 id="1-3-实验结果"><a href="#1-3-实验结果" class="headerlink" title="1.3 实验结果"></a>1.3 实验结果</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013003759127.png" alt="image-20221013003759127"></p>
<p>计算出的协方差矩阵如图所示，可以看到原本为八维的数据被降为二维，效果显著</p>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><h3 id="2-1-方法介绍"><a href="#2-1-方法介绍" class="headerlink" title="2.1 方法介绍"></a>2.1 方法介绍</h3><p>分类采用J48实现，J48是基于从上到下的策略，递归的分治策略，选择某个属性放置在根节点，为每个可能的属性值产生一个分支，将实例分成多个子集，每个子集对应一个根节点的分支，然后在每个分支上递归地重复这个过程。当所有实例有相同的分类时停止。</p>
<h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-type">Instances</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> DataSource.read(<span class="hljs-string">&quot;src/main/resources/spambase.train.arff&quot;</span>);<br>    <span class="hljs-type">Instances</span> <span class="hljs-variable">test_data</span> <span class="hljs-operator">=</span> DataSource.read(<span class="hljs-string">&quot;src/main/resources/spambase.test.arff&quot;</span>);<br>    data.setClassIndex(data.numAttributes() - <span class="hljs-number">1</span>);<br>    test_data.setClassIndex(test_data.numAttributes() - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Instance</span> <span class="hljs-variable">test_instance</span> <span class="hljs-operator">=</span> test_data.firstInstance();<br>    <span class="hljs-type">J48</span> <span class="hljs-variable">j48</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">J48</span>();<br>    j48.buildClassifier(data);<br>	System.out.println(j48);<br>    System.out.println(j48.classifyInstance(test_instance));<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>首先通过DataSource读取训练数据集以及测试数据集，设置最后一列为标签(setClassIndex),再获取测试数据集中的测试数据，然后创建J48对象，随后导入数据，生成分类器，最后打印分类器信息以及对测试数据进行分类的结果</p>
<h3 id="2-3-实验结果"><a href="#2-3-实验结果" class="headerlink" title="2.3 实验结果"></a>2.3 实验结果</h3><p>可以看到J48生成的决策树，以及树的大小和叶子数，以及测试数据分类后的结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013004059857.png" alt="image-20221013004059857"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013004106306.png" alt="image-20221013004106306"></p>
<h2 id="3-聚类"><a href="#3-聚类" class="headerlink" title="3.聚类"></a>3.聚类</h2><h3 id="3-1-方法介绍"><a href="#3-1-方法介绍" class="headerlink" title="3.1 方法介绍"></a>3.1 方法介绍</h3><p>聚类采用K-means实现，K-Means算法是一种聚类分析的算法。首先从样本中随机选择k个点作为初始质心，随后计算每个样本到各个质心的距离，将样本划分到距离最近的质心所对应的簇中，计算每个簇中所有样本的均值，并使用该均值更新簇的质心，重复以上步骤，直到质心的位置变化小于制定的阈值或者达到最大迭代次数。</p>
<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-type">Instances</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> DataSource.read(<span class="hljs-string">&quot;src/main/resources/bank_data.arff&quot;</span>);<br>    <span class="hljs-type">SimpleKMeans</span> <span class="hljs-variable">kMeans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleKMeans</span>();<br>    kMeans.setNumClusters(<span class="hljs-number">6</span>);<br>    kMeans.buildClusterer(data);<br>    System.out.println(kMeans);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先通过DataSource读取数据集，创建SimpleKMeans对象，设置群数为6，随后导入数据，生成聚类器，最后打印聚类器信息</p>
<h3 id="3-3-实验结果"><a href="#3-3-实验结果" class="headerlink" title="3.3 实验结果"></a>3.3 实验结果</h3><p>设置群数为6，从分群结果可以分析出不同人群的特点。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221013004241168.png" alt="image-20221013004241168"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Big-Data/">Big Data</a>, <a href="/categories/Big-Data/weka/">weka</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/weka/">weka</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/27/XV6-3/"><span>XV6(3) Page tables</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/27/XV6-3/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-27T07:25:19.000Z">
          2022-09-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3 Page tables"></a>Chapter 3 Page tables</h2><p>页表让每个进程都拥有自己独立的虚拟内存地址，并决定每个进程可以访问物理内存的哪些部分。</p>
<p>页表隔离了不同进程的地址空间，实现了内存隔离，并将它们映射到同一个物理内存</p>
<p>xv6通过页表实现了一些有趣的功能：在多个地址空间中映射相同的内存(a <em>trampoline</em> page 蹦床页面)，并使用未映射的页面保护内核和用户堆栈。</p>
<h3 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h3><p>RISC-V指令操纵虚拟地址，而机器RAM或物理内存使用物理地址，RISC-V页表硬件通过将每个虚拟地址映射到物理地址来连接这两种地址</p>
<p>xv6运行于Sv39 RISC-V，即在 64 位地址中只有最下面的 39 位被使用作为虚拟地址，其中底 12 位是页内偏移，高 27 位是页表索引，即 4096 字节( $2^{12}$ )作为一个page，一个进程的虚拟内存可以有 $2^{27}$ 个page，对应到页表中就是 $2^{27}$ 个<em>page table entry</em>(PTE)。</p>
<p>每个PTE有一个 44 位的physical page number (PPN) 用来映射到物理地址上和 10 位flag，总共需要 54 位，用 8 个字节存储(下面解释)。每个物理地址的高 44 位是页表中存储的PPN，低 12 位是页内偏移，一个物理地址总共由 56 位构成。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221113234723564.png" alt="image-20221113234723564" style="zoom: 50%;" /></p>
<p>在Sv39 RISC-V，PTE格式中存在着可以使物理地址再增加 10 位的空间。</p>
<p>在实际中，页表并不是作为一个包含了 $2^{27}$ 个PTE的大列表存储在物理内存中的，而是采用了三级树状的形式进行存储，这样可以让页表分散存储。每个页表就是一页。第一级页表是一个 4096 字节的页，包含了 512 个PTE(因为每个PTE需要 8 字节)，每个PTE存储了下级页表的页物理地址。第二级列表由512个页构成，第三级列表由512*512个页构成。</p>
<blockquote>
<p>与单层设计相比，三层结构可以以一种内存高效的方式记录PTE</p>
<p>通常情况下执行一个进程，大部分的虚拟地址是不会被映射的，三层结构可以省略整个页面目录</p>
<p>例如，如果一个应用程序只使用从地址 0 开始的几个页面，那么一级页面目录的条目 1 到 511 是无效的，因此内核不必为 1-511 的二级页面目录分配页面。此外，内核还不必为这些二级页面目录对应的的三层页面目录分配页面。因此，在本例中，三层结构为二级页面目录节省了511页，为底层页面目录节省511×512页。</p>
</blockquote>
<p>因为每个进程虚拟地址的高 27 位用来确定PTE，对应到3级页表就是最高的 9 位确定一级页表PTE的位置，中间 9 位确定二级页表PTE的位置，最低 9 位确定三级页表PTE的位置。如下图所示。第一级根页表的物理页地址存储在<code>satp</code>寄存器中，每个CPU拥有自己独立的<code>satp</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221113234808913.png" alt="image-20221113234808913" style="zoom:80%;" /></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/MIT/">MIT</a>, <a href="/categories/MIT/6-S081/">6.S081</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/27/XV6-2/"><span>XV6(2) Operating system organization</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/27/XV6-2/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-27T07:25:18.000Z">
          2022-09-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2 Operating system organization"></a>Chapter 2 Operating system organization</h2><p>操作系统应当能够保证同时支持多个活动，不同进程可以共享计算机的资源</p>
<p>操作系统还应保证进程间的隔离性(<em>isolation</em>)，也就是说，如果一个进程出现错误和故障，不应影响不依赖于这个错误进程的进程。</p>
<p>但是，不应做到完全隔离，因为不同进程间也会进行交互，例如管道。</p>
<p>因此，操作系统必须满足三个要求</p>
<ul>
<li><strong>多进程支持(<em>multiplexing</em>)</strong></li>
<li><strong>进程间隔离(<em>isolation</em>)</strong></li>
<li><strong>受控制的进程间交互(<em>interaction</em>)</strong></li>
</ul>
<h3 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h3><p><strong>方案一</strong></p>
<p><strong>可以将系统调用实现为一个库，应用程序与之链接</strong>。在这个方案中，每个应用程序都有专属于自己的库来满足其需求，可以直接与硬件资源交互，并且可以以最优方式使用(例如，实现高性能或达到可预测的性能)。一些嵌入式设备或实时系统的操作系统就是以这种方式组织的。</p>
<p>如果有多个应用程序在同时运行，则每个应用程序必须表现良好。例如，每个应用程序必须定期放弃CPU，以便其他应用程序可以运行。如果所有应用程序彼此信任并且没有出现错误，则这种协作分时方案是可行的。但对于应用程序来说，更典型的情况是彼此不信任，并且可能存在bug。因此通常需要比该方案更强的隔离性。</p>
<p><strong>方案二</strong></p>
<p>为了实现强隔离，可以<strong>禁止应用程序直接访问敏感硬件资源，将资源抽象为服务。</strong></p>
<blockquote>
<p>例如，Unix应用程序仅通过文件系统的<code>open</code>、<code>read</code>、<code>write</code>和<code>close</code>系统调用与存储交互，而不是直接读取和写入磁盘。</p>
</blockquote>
<p>这为应用程序提供了路径名的便利，并允许操作系统(作为接口的实现者)来管理磁盘。</p>
<p>该方案中，即使对隔离的要求不高，有意交互的程序(或只是希望避免相互干扰)也会发现使用文件系统抽象也比直接使用磁盘更加方便</p>
<blockquote>
<p>例1. Unix可以在进程间透明地切换CPU，根据需要保存和恢复寄存器状态，因此应用程序不必知道’分时’如何实现，这种透明性允许操作系统共享CPU，即使某些应用程序处于死循环</p>
<p>例2. Unix进程使用<code>exec</code>构建其内存映像，而不是直接和物理内存交互。这允许操作系统决定进程在内存中如何存放，如果内存紧张，操作系统甚至会将进程的部分数据存放在磁盘。<code>exec</code>还为用户提供了存储可执行程序图像的文件系统的便利</p>
<p>例3. Unix进程之间的许多交互形式都是通过文件描述符进行的。文件描述符不仅抽象了许多细节(例如管道或文件中的数据存储位置)，而且还以简化交互的方式定义。例如，如果管道中的一个应用程序出错了，内核将为管道中的下一个进程生成EOF信号。</p>
</blockquote>
<h3 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode, and system calls"></a>2.2 User mode, supervisor mode, and system calls</h3><p>为了实现强隔离，操作系统必须保证应用程序不能修改(甚至读取)操作系统的数据结构和指令，并且应用程序不能访问其他进程的内存</p>
<p>CPU为强隔离提供硬件支持。例如，RISC-V有三种CPU可以执行指令的模式</p>
<ul>
<li><em>machine mode</em>: 权限最高，主要目的是为了配置电脑，<strong>CPU以machine mode启动，之后立即切换到supervisor mode。</strong></li>
<li><em>supervisor mode</em>: 允许CPU执行<em>privileged instructions</em>，比如中断管理、对存储页表地址的寄存器进行读写操作、执行system call(从user mode切换到supervisor mode)。运行在supervisor mode也称为在<em>kernel space</em>中运行。</li>
<li><em>user mode</em>: 应用程序只能执行user mode指令，比如改变变量、执行util function。运行在user mode也称为在<em>user space</em>中运行。要想让CPU从user mode切换到supervisor mode，RISC-V提供了一个特殊的<code>ecall</code>指令。一旦CPU切换到supervisor mode，内核会验证系统调用的参数(例如检查地址是否是该程序内存的一部分)，决定是否执行。</li>
</ul>
<p>由<strong>内核</strong>而不是应用程序<strong>控制切换到supervisor mode的入口点(地址)非常重要</strong>，可以避免恶意程序跳过参数验证</p>
<h3 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h3><p><em>monolithic kernel(宏内核)</em>: 整个操作系统都在kernel中，所有system call都在supervisor mode下运行，拥有全部硬件权限，不同部分便于合作。但是一旦出现错误常常会导致内核崩溃，导致所有程序出错，不得不重启。xv6就是monolithic kernel</p>
<p><em>micro kernel(微内核)</em>: 将需要运行在supervisor mode下的操作系统代码压到最小，保证kernel内系统的安全性，将大部分的操作系统代码执行在user mode下。会有在user/kernel mode反复跳转带来的性能损耗。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915012051093.png" alt="image-20220915012051093"></p>
<p>如2.1所示，文件系统是一个user-level的进程，为其他进程提供服务，因此也叫做server</p>
<p>作为<strong>进程</strong>运行的<strong>操作系统服务</strong>称为server。</p>
<p>为了允许应用程序与文件服务交互，内核提供了一种进程间通信机制，将消息从一个用户模式进程发送到另一个进程。(例如，如果像shell这样的应用程序想要读取或写入文件，它会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统并等待响应)</p>
<p>xv6 kernel source file如下所示</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220915010746816.png" alt="image-20220915010746816"></p>
<h3 id="2-4-Process-overview"><a href="#2-4-Process-overview" class="headerlink" title="2.4 Process overview"></a>2.4 Process overview</h3><p><strong>隔离的单元叫做进程</strong>，进程的抽象使得一个进程不能破坏或者监听另外一个进程的内存、CPU、文件描述符等，也不能破坏kernel本身，即进程无法破坏内核的隔离机制</p>
<p>内核用于实现进程的机制包括<em>user/supervisor mode</em>标志，地址空间，线程的时间切片</p>
<p>为了实现进程隔离，<strong>xv6提供了一种机制让每个程序都认为自己拥有一个独立的机器</strong>。</p>
<p>一个进程为一个程序<strong>提供了一个私有的内存系统，或<em>address space</em>，其他的进程不能够读/写这个内存</strong></p>
<p>xv6使用<strong><em>page table</em>(页表)</strong>来给每个进程分配自己的<em>address space</em>，页表再将这些<em>address space</em>，也就是<strong>虚拟地址</strong>(virtual address)(RISC-V指令操作的地址) <strong>映射为物理地址</strong>(physical address)(CPU芯片发送到主存的地址)。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220922154824955.png" alt="image-20220922154824955"></p>
<p>虚拟地址从0开始，往上依次是指令、全局变量、栈、堆。</p>
<p>有许多因素限制了进程地址空间的最大大小：RISC-V上的指针是64位的，硬件在页表寻找虚拟地址时只使用低39位，而xv6只使用39位中的低38位，因此最大的地址是$2^{38}-1$=0x3fffffffff=MAXVA</p>
<p>在地址空间的顶部，xv6为<em>trampoline</em>保留了一页，并为映射进程<em>trapframe</em>预留了一页。xv6使用这两页切换到内核并返回：<em>trampoline</em>页包含了该功能的代码，而映射<em>trapframe</em>是保存/恢复用户进程状态所必需的</p>
<p>xv6内核保存了每个进程的许多状态，并集中在<code>struct pr</code>中。进程最重要的内核状态有：</p>
<ol>
<li>页表 <code>p-&gt;pagetable</code>，分页硬件会在用户空间执行进程时使用，并且页表还会<strong>记录分配给用于储存进程的内存的物理页地址</strong></li>
<li>内核堆栈<code>p-&gt;kstack</code> </li>
<li>运行状态<code>p-&gt;state</code>，显示进程是否已经被分配、准备运行/正在运行/等待I/O或退出</li>
</ol>
<p><strong>每个进程中都有线程(<em>thread</em>)，是执行进程命令的最小单元，可以被暂停和继续。</strong>为了透明地切换进程，内核会挂起正在运行的线程，并恢复其他进程的线程。<strong>线程的大部分状态(局部变量、函数返回地址等)都被存储在线程的堆栈中。</strong></p>
<p>每个进程有两个堆栈：<strong>用户堆栈(<em>user stack</em>)和内核堆栈(<em>kernel stack</em>)</strong>。</p>
<ul>
<li>当进程在user space中执行用户指令时只使用用户堆栈，内核堆栈为空</li>
<li>当进程进入了内核(比如进行了system call或中断)使用内核堆栈，此时用户堆栈仍然包含保存的数据</li>
</ul>
<p>一个进程的线程交替使用其用户堆栈和内核堆栈。内核堆栈是独立的(并受用户代码保护的)，因此即使进程破坏了其用户堆栈，内核也可以正常执行</p>
<p>进程可以通过执行RISC-V <code>ecall</code>指令进行系统调用。该指令会<strong>提高硬件的特权级别</strong>，并<strong>将程序计数器更改为内核定义的入口点</strong>。入口点的代码会切换到内核堆栈并执行实现系统调用的内核指令。当系统调用完成，内核切换回用户堆栈，通过调用<code>sret</code>指令返回用户空间，同时降低硬件特权级别并恢复执行用户指令。</p>
<blockquote>
<p><code>ecall</code>会接收一个数字参数，代表应用程序想要调用的System Call，<code>ecall</code>会跳转到内核中一个特定，由内核控制的位置。之后控制权到了<code>syscall</code>函数</p>
<p>在内核空间，有一个位于syscall.c的函数<code>syscall</code>，每一个从应用程序发起的系统调用都会调用到这个<code>syscall</code>函数，<code>syscall</code>函数会检查<code>ecall</code>的参数，通过这个参数内核可以知道需要调用的是哪个system call</p>
</blockquote>
<p>一个进程的线程可以在内核中”阻塞”以等待I/O，并在I/O完成后恢复到中断的位置</p>
<p>进程捆绑了两种设计思想：地址空间(进程认为拥有属于自己的内存)、线程(进程认为拥有属于自己的CPU)。xv6中，一个进程包括一个<em>address space</em>和一个<em>thread</em>。而真实操作系统一个进程往往有多个线程来充分利用多核CPU</p>
<h3 id="2-5-Code-starting-xv6-the-first-process-and-system-call"><a href="#2-5-Code-starting-xv6-the-first-process-and-system-call" class="headerlink" title="2.5 Code: starting xv6, the first process and system call"></a>2.5 Code: starting xv6, the first process and system call</h3><p>RISC-V计算机启动时，先运行一个存储于 ROM 中的 bootloader 程序 <code>kernel.ld</code> 来加载xv6 kernel到内存中，然后在machine模式下从<code>_entry</code>开始运行xv6。此时分页硬件没有工作，虚拟地址直接映射到物理地址。bootloader将xv6 kernel加载到<code>0x80000000</code>的物理地址中，因为前面的地址中包含I/O设备</p>
<p>指令在<code>_entry</code>中设置了一个初始stack来执行C代码，xv6执行<code>kernel/start.c</code>并在其中声明一个初始化堆栈<code>stack0</code>。<code>_entry</code>处的代码加载堆栈的指针寄存器<code>sp</code>到栈顶<code>stack0+4096</code>，因为RISC-V的堆栈是向下生长的</p>
<p><code>start</code>函数先在machine模式下做一些配置，还对时钟芯片进行编程，以生成定时器中断，然后通过RISC-V提供的<code>mret</code>指令切换到supervisor mode。使program counter(pc)也切换到<code>kernel/main.c</code></p>
<blockquote>
<p><code>mret</code>指令常用于上一条指令为从supervisor mode切换到machine mode，但显然<code>start</code>并不是这样的，而是假装是这样的：它将寄存器<code>mstatus</code>中以前的特权模式设置为supervisor</p>
<p>它通过把<code>main</code>的地址写入到寄存器<code>mepc</code>中使得返回地址被设置为<code>main</code></p>
<p>通过将 0 写入页表寄存器<code>satp</code>中禁用superviser模式下的虚拟地址转换</p>
<p>将所有中断和异常委派给supervisor mode</p>
</blockquote>
<p><code>main</code>先对一些设备和子系统进行初始化，然后调用<code>kernel/proc.c</code>中定义的<code>userinit</code>来创建第一个用户进程。这个进程执行了一个<code>initcode.S</code>的汇编程序，这个汇编程序调用了<code>exec</code>这个system call来执行<code>/init</code>，重新进入kernel。<code>exec</code>将当前进程的内存和寄存器替换为一个新的程序(<code>/init</code>)，当kernel执行完毕<code>exec</code>指定的程序后，回到<code>/init</code>进程。<code>/init</code>(<code>user/init.c</code>)创建了一个新的console device以文件描述符0,1,2打开，然后在console device中开启了一个shell进程，至此整个系统启动了</p>
<h3 id="2-6-Security-Model"><a href="#2-6-Security-Model" class="headerlink" title="2.6 Security Model"></a>2.6 Security Model</h3><p>操作系统必须假设进程的用户代码会尽力破坏内核或其他进程。包括引用超出其允许地址空间的指针、执行RISC-V特权指令、读取和写入任意RISC-V控制寄存器等。而内核的目标就是要限制每个用户进程，只能读/写/执行自己的用户内存、使用通用寄存器、使用允许的系统调用。</p>
<p>而内核代码不同，内核代码应当没有bug，不含任何恶意代码。这个假设会影响我们分析内核代码的方式，我们往往相信内核代码都是正确编写的，并且遵循内核自身函数和数据结构的使用规则</p>
<p>在硬件级别，我们也假设CPU、RAM、磁盘等都按照文档正确运行，没有硬件错误</p>
<p>而现实中，我们不可能编写无缺陷代码或者设计无缺陷硬件，因此我们有必要为内核设计保护措施：断言、类型检查、堆栈保护页等</p>
<p>有时用户代码和内核代码之间的界限会变得模糊：一些特权用户级进程会提供基本服务，并有效地成为操作系统的一部分，在某些操作系统，特权用户代码甚至可以将新代码插入内核(与Linux的可加载内核模块一样)</p>
<h3 id="2-7-Real-World"><a href="#2-7-Real-World" class="headerlink" title="2.7 Real World"></a>2.7 Real World</h3><p>大多数操作系统都采用了进程概念，并且大多数进程也与xv6类似。然而，现代操作系统支持一个进程中的多个线程，从而允许单个进程利用多核CPU。而在一个进程中支持多个线程需要很多xv6没有的机制，包括潜在的接口更改(e.g. Linux的<code>clone</code>，就是<code>fork</code>的变体)，以控制线程共享哪些方面。</p>
<h3 id="2-8-Something-Else"><a href="#2-8-Something-Else" class="headerlink" title="2.8 Something Else"></a>2.8 Something Else</h3><p>当应用程序恶意破坏或者就是在一个死循环中，内核是如何夺回控制权限的？</p>
<ul>
<li>内核会通过硬件设置一个定时器，定时器到期之后会将控制权限从用户空间转移到内核空间，之后内核就有了控制能力并可以重新调度CPU到另一个进程中。</li>
</ul>
<p>内核编译过程</p>
<ul>
<li>首先，Makefile(XV6目录下的文件)会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V汇编语言文件；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式</li>
<li>Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o。</li>
<li>之后，系统加载器(Loader)会收集所有的.o文件，将它们链接在一起，并生成内核文件</li>
<li>这里生成的内核文件就是将会在QEMU中运行的文件。同时，Makefile还会创建kernel.asm，这里包含了内核的完整汇编语言，可以通过查看它来定位究竟是哪个指令导致了Bug。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/MIT/">MIT</a>, <a href="/categories/MIT/6-S081/">6.S081</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/27/XV6-1/"><span>XV6(1) Introduction and Examples</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/27/XV6-1/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-27T07:25:17.000Z">
          2022-09-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Chapter-1-Introduction-and-Examples"><a href="#Chapter-1-Introduction-and-Examples" class="headerlink" title="Chapter 1 Introduction and Examples"></a>Chapter 1 Introduction and Examples</h2><p><strong>操作系统应该提供的功能</strong></p>
<ul>
<li><p>抽象硬件    Abstract Hardware</p>
<ul>
<li>硬件是底层级的资源，一些应用程序实现了高层级的接口和抽象，例如进程、文件系统。这些高层级的接口和抽象（Abstraction）方便了应用的开发，也提供了更好的移植性。</li>
</ul>
</li>
<li><p>多进程支持    Multiplex</p>
</li>
<li>进程间隔离    Isolation</li>
<li>数据的共享    Sharing</li>
<li>权限系统    Security</li>
<li>帮助应用程序获得高性能    Performance</li>
<li>支持大量不同应用程序</li>
</ul>
<p><strong>操作系统结构</strong></p>
<ul>
<li><strong>user application</strong>: VI、CC、Shell等，这里程序都运行在同一个空间中，这个空间通常会被称为用户空间（User space）。</li>
<li><strong>kernel</strong>: 为运行的程序提供服务的一种特殊程序。只能有一个<ul>
<li>文件系统</li>
<li>进程管理系统：每个运行着的程序叫做进程，它们有自己的内存(存储指令、数据和堆栈)和共享的CPU时间。Kernel会管理内存的分配。</li>
<li>Access Control (security)</li>
</ul>
</li>
<li><strong>h/w</strong>: CPU, RAM, disk, net, &amp;c</li>
</ul>
<p><strong>什么是 application / kernel interface?</strong></p>
<p>每当进程需要调用内核服务时，它会触发一个<em>system call</em>(系统调用)，system call进入内核执行相应的服务然后返回。因此，进程在<em>user space</em>和<em>kernel space</em>中交替执行</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220812120814236.png" alt="image-20220812120814236"></p>
<ul>
<li><em>shell</em>: 一个普通的程序，其功能是读取用户输入的命令并执行它们，shell<strong>不是</strong>内核的一部分</li>
</ul>
<h3 id="1-1-Processes-and-memory"><a href="#1-1-Processes-and-memory" class="headerlink" title="1.1 Processes and memory"></a>1.1 Processes and memory</h3><p>每个进程拥有自己的用户空间内存以及内核空间状态，当进程不再执行时xv6将存储和这些进程相关的CPU寄存器直到下一次运行这些进程。kernel将每一个进程用一个PID(process identifier)指代。</p>
<p><strong>常用syscall</strong></p>
<ul>
<li><p><code>fork</code>: 形式: <code>int fork()</code>。</p>
<ul>
<li>其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程。在父进程中，<code>fork</code>的返回值是这个子进程的PID，在子进程中，返回值是0</li>
</ul>
</li>
<li><p><code>exit</code>: 形式: <code>int exit(int status)</code>。</p>
<ul>
<li>让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出</li>
</ul>
</li>
<li><p><code>wait</code>: 形式: <code>int wait(int *status)</code>。</p>
<ul>
<li><p>返回当前进程的已退出（或已终止）子进程的PID，子进程的退出状态存储到<code>status</code>这个地址中。如果没有已退出的子进程则等待。如果调用者没有子进程，<code>wait</code>立即返回-1。如果不关心子进程的退出状态，可以传递0地址</p>
</li>
<li><p>如果有任何子进程退出，wait就会直接返回。因此如果有多个子进程，需要调用多个<code>wait</code></p>
</li>
</ul>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();<br><span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>    pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  前两行输出可能是</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">parent: child=1234<br>child: exiting<br></code></pre></td></tr></table></figure>
<p>  也可能是</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">child: exiting<br>parent: child=1234<br></code></pre></td></tr></table></figure>
<p>  这是因为在<code>fork</code>了之后，父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。输出取决于哪个进程先调用了<code>printf</code></p>
<p>  子进程在判断完<code>pid == 0</code>之后将<code>exit</code>，父进程发现子进程<code>exit</code>之后，<code>wait</code>执行完毕，打印输出</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">parent: child 1234 is done<br></code></pre></td></tr></table></figure>
<p>  尽管<code>fork</code>了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程。</p>
<ul>
<li><p><code>exec</code>: 形式: <code>int exec(char *file, char *argv[])</code>。</p>
<ul>
<li>加载一个文件，获取执行它的参数，执行。将调用进程的内存替换为从文件加载的内存映像。如果执行错误返回-1，执行成功则不会返回(内存已经被替换，没有地方返回)，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。</li>
<li>如果直接调用<code>exec</code>，这里会用<code>echo</code>指令来替代Shell进程，当<code>echo</code>退出了，一切就结束了。因此常见方法是先执行<code>fork</code>，子进程再执行<code>exec</code></li>
<li><strong>参数</strong><ul>
<li>第一个参数是包含可执行文件的文件名</li>
<li>第二个参数是字符串参数数组</li>
</ul>
</li>
</ul>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *argv[<span class="hljs-number">3</span>];<br><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;echo&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>argv[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记数组的结尾</span><br>exec(<span class="hljs-string">&quot;/bin/echo&quot;</span>, argv);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec error\n&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>  大多数程序忽略参数数组的第一个元素，通常是该程序的名称</p>
<p><strong>执行流程</strong></p>
<p>xv6 shell使用以上四个system call来为用户执行程序。在shell进程的<code>main</code>中主循环先通过<code>getcmd</code>来从用户获取命令，然后调用<code>fork</code>来运行一个和当前shell进程完全相同的子进程。父进程调用<code>wait</code>等待子进程<code>exec</code>执行完（在<code>runcmd</code>中调用<code>exec</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sh.c */</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">int</span> fd;<br><br>  <span class="hljs-comment">// Ensure that three file descriptors are open.</span><br>  <span class="hljs-keyword">while</span>((fd = open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">3</span>)&#123;<br>      close(fd);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Read and run input commands.</span><br>  <span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>      <span class="hljs-comment">// Chdir must be called by the parent, not the child.</span><br>      buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// chop \n</span><br>      <span class="hljs-keyword">if</span>(chdir(buf+<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="hljs-number">3</span>);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)<br>      runcmd(parsecmd(buf));<br>    wait(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Xv6隐式分配大部分用户空间内存：<code>fork</code>分配父内存的子副本所需的内存，<code>exec</code>分配足够的内存来保存可执行文件。在运行时需要更多内存的进程（可能是<code>malloc</code>）可以调用<code>sbrk(n)</code>将其数据内存增加 n 个字节；<code>sbrk</code>返回新内存的位置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>System call</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>int fork()</td>
<td>创建进程，返回子进程PID</td>
</tr>
<tr>
<td>int exit(int status)</td>
<td>终止当前进程；status报告给wait()，没有返回值</td>
</tr>
<tr>
<td>int wait(int *status)</td>
<td>等待子进程结束；结束状态存放在status，返回子进程PID</td>
</tr>
<tr>
<td>int kill(int pid)</td>
<td>终止进程号为pid的进程，返回0，出现错误返回-1</td>
</tr>
<tr>
<td>int getpid()</td>
<td>获取当前进程PID</td>
</tr>
<tr>
<td>int sleep(int n)</td>
<td>暂停n个时钟滴答</td>
</tr>
<tr>
<td>int exec(char <em>file, char </em>argv[])</td>
<td>加载文件并按参数执行，只在出现错误才返回</td>
</tr>
<tr>
<td>char *sbrk(int n)</td>
<td>进程内存增长n字节，返回新内存的起始位置</td>
</tr>
<tr>
<td>int open(char *file, int flags)</td>
<td>打开文件，flags指示读/写；返回fd</td>
</tr>
<tr>
<td>int write(int fd, char *buf, int n)</td>
<td>从buf写n个字节到fd，返回n</td>
</tr>
<tr>
<td>int read(int fd, char *buf, int n)</td>
<td>从fd读n个字节到buf，返回读到的数量，文件结尾返回0</td>
</tr>
<tr>
<td>int close(int fd)</td>
<td>关闭打开的fd</td>
</tr>
<tr>
<td>int dup(int fd)</td>
<td>返回一个新的fd，和参数fd引用相同对象</td>
</tr>
<tr>
<td>int pipe(int p[])</td>
<td>创建管道，把读、写fd放到p[0],p[1]</td>
</tr>
<tr>
<td>int chdir(char *dir)</td>
<td>改变当前目录</td>
</tr>
<tr>
<td>int mkdir(char *dir)</td>
<td>创建新目录</td>
</tr>
<tr>
<td>int mknod(char *file, int, int)</td>
<td>创建设备文件</td>
</tr>
<tr>
<td>int fstat(int fd, struct stat *st)</td>
<td>将打开文件的信息存放到st</td>
</tr>
<tr>
<td>int stat(char *file, struct stat *st)</td>
<td>根据文件名将文件信息存放到st</td>
</tr>
<tr>
<td>int link(char *file1, char *file2)</td>
<td>给 f1 创建一个新名字(f2)</td>
</tr>
<tr>
<td>int unlink(char *file)</td>
<td>删除文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-2-I-O-and-File-descriptors"><a href="#1-2-I-O-and-File-descriptors" class="headerlink" title="1.2 I/O and File descriptors"></a>1.2 I/O and File descriptors</h3><ul>
<li><p><strong>copy.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> n = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        write(<span class="hljs-number">1</span>, buf, n);<br>    &#125;<br>    <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><em>file descriptor</em>：文件描述符，用来表示一个被内核管理的、可以被进程读/写的对象的一个整数，通常将对象称之为文件。表现形式类似于字节流，通过打开文件、目录、设备、创建管道等方式获得。一个文件被打开得越早，文件描述符就越小。</p>
<p>每个进程都拥有自己独立的文件描述符列表，其中0是标准输入，1是标准输出，2是标准错误。shell将保证总是有3个文件描述符是可用的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>((fd = open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">3</span>)&#123;<br>        close(fd);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>read</code>和<code>write</code>：形式：<code>int read(int fd, char *buf, int n)</code>和<code>int write(int fd, char *buf, int n)</code></p>
<ul>
<li><code>read</code>从文件描述符 <code>fd</code> 读 n 字节的内容写入<code>buf</code>，返回值是成功读取的字节数。</li>
<li><code>write</code>向文件描述符 <code>fd</code> 写 n 字节<code>buf</code>的内容，返回值是成功写入的字节数。</li>
<li>每个文件描述符有一个offset，<code>read</code>会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个<code>read</code>将从新的offset开始读取字节。<code>write</code>也有类似的offset</li>
<li><strong>参数</strong><ul>
<li>第一个参数是文件描述符</li>
<li>第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据</li>
<li>第三个参数是代码想读取/写入的最大长度</li>
</ul>
</li>
<li><code>read</code>如果到达了文件的结尾没有更多的内容了，<code>read</code>会返回0。如果出现了一些错误，比如文件描述符不存在，<code>read</code>会返回-1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* essence of cat program */</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-type">int</span> n;<br>  <br><span class="hljs-keyword">for</span> (;;) &#123;<br>    n = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span> buf);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read errot\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (write(<span class="hljs-number">1</span>, buf, n) != n)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>cat</code>不知道它是从文件、控制台还是管道中读取。类似地，<code>cat</code>也不知道它是否正在打印到控制台、文件或其他任何东西。通过使用 输入文件描述符0 以及 输出文件描述符1 可以简单地实现<code>cat</code>。</p>
</blockquote>
</li>
<li><p><code>close</code>。形式：<code>int close(int fd)</code>。</p>
</li>
</ul>
<ul>
<li><p>将打开的文件<code>fd</code>释放，使该文件描述符可以被后面的<code>open</code>、<code>pipe</code>、<code>dup</code>等system call使用。新分配的文件描述符始终是当前进程中编号最低的未使用描述符</p>
</li>
<li><p>使用<code>close</code>来修改file descriptor table能够实现I/O重定向</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* implementation of I/O redirection,</span><br><span class="hljs-comment"> * more specifically, cat &lt; input.txt</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cat&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// in the child process</span><br>    close(<span class="hljs-number">0</span>);  <span class="hljs-comment">// this step is to release the stdin file descriptor</span><br>    open(<span class="hljs-string">&quot;input.txt&quot;</span>, O_RDONLY); <span class="hljs-comment">// the newly allocated fd for input.txt is 0, since the previous fd 0 is released</span><br>    exec(<span class="hljs-string">&quot;cat&quot;</span>, argv); <span class="hljs-comment">// execute the cat program, by default takes in the fd 0 as input, which is input.txt</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>父进程的fd table将不会被子进程fd table的变化影响，但是文件中的offset将被共享。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    wait(<span class="hljs-number">0</span>);<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br>&#125;<br><span class="hljs-comment">/* hello world */</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>open</code>: 形式: <code>int open(char *file, int flags)</code>。</li>
</ul>
<ul>
<li><p>返回fd(当前进程中编号最低的未使用描述符)</p>
</li>
<li><p><strong>参数</strong></p>
<ul>
<li>第一个参数是要打开的文件名</li>
<li>第二个参数由一组标志组成，用位表示，控制<code>open</code>的功能，可能的值有<code>O_RDONLY, O_WRONLY, O_RDWR, O_CREATE, O_TRUNC</code>。指示<code>open</code>打开文件进行读取；写入；读写；如果文件不存在，则创建文件；将文件截断为零长度。</li>
</ul>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// open.c: create a file, write to it.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREATE);<br>  write(fd, <span class="hljs-string">&quot;ooo\n&quot;</span>, <span class="hljs-number">4</span>);<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>dup</code>: 形式：<code>int dup(int fd)</code>。</li>
</ul>
<ul>
<li><p>复制现有的<code>fd</code>，返回一个引用相同底层I/O对象的新<code>fd</code>。两个<code>fd</code>共享一个offset</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">fd = dup(<span class="hljs-number">1</span>);<br>write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-number">6</span>);<br>write(fd, <span class="hljs-string">&quot;world\n&quot;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-comment">// outputs hello world</span><br></code></pre></td></tr></table></figure>
<p>除了<code>dup</code>和<code>fork</code>之外，其他方式<strong>不能</strong>使两个I/O对象共享同一个offset，比如同时<code>open</code>相同的文件</p>
<p>xv6本身是不支持标准错误文件描述符重定向的，我们可以通过<code>dup</code>来实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> existing-file non-existing-file &gt; tmp1 2&gt;&amp;1<br></code></pre></td></tr></table></figure>
<p><code>2&gt;&amp;1</code>告诉shell <code>fd2</code> 是 <code>fd1</code> 的复制，这样<em>存在文件的文件名和不存在文件的错误信息</em>都会出现在文件<code>tmp1</code>中。</p>
</li>
</ul>
<h3 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3 Pipes"></a>1.3 Pipes</h3><ul>
<li><p><em>pipe</em>: 管道是一个小的内核缓冲区，它以<strong>文件描述符对</strong>的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。</p>
</li>
<li><p><code>pipe</code>: 形式为<code>int pipe(int p[])</code>，<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 示例代码运行了程序 wc，它的标准输入绑定到了一个管道的读端口。 */</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>  <br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <br>pipe(p); <span class="hljs-comment">// read fd put into p[0], write fd put into p[1]</span><br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    close(<span class="hljs-number">0</span>);<br>    dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 子进程将管道的读端口拷贝在描述符0(标准输入)上</span><br>    close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// original read end of pipe is closed</span><br>    close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">// fd p[1] is closed in child process, but not closed in the parent process. 注意这里关闭p[1]非常重要，因为如果不关闭p[1]，管道的读取端会一直等待读取，wc就永远也无法等到EOF</span><br>    exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv); <span class="hljs-comment">// by default wc will take fd 0 as the input, which is the read end of pipe in this case</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// close the read end of pipe in parent process will not affect child process</span><br>    write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>); <br>    close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">// write end of pipe closed, the pipe shuts down</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>如果数据没有准备好，那么对管道执行的<code>read</code>会一直等待，直到有数据了或者其他绑定在这个管道写端口的描述符都已经关闭了。在后一种情况中，<code>read</code> 会返回 0，就像是一份文件读到了最后。</p>
</li>
<li><p>xv6中的实现和上述的类似</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> PIPE:<br>pcmd = (<span class="hljs-keyword">struct</span> pipecmd*)cmd;<br><span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;pipe&quot;</span>);<br><span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// in child process</span><br>    close(<span class="hljs-number">1</span>); <span class="hljs-comment">// close stdout</span><br>    dup(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">// make the fd 1 as the write end of pipe</span><br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    runcmd(pcmd-&gt;left); <span class="hljs-comment">// run command in the left side of pipe |, output redirected to the write end of pipe</span><br>&#125;<br><span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// in child process</span><br>    close(<span class="hljs-number">0</span>); <span class="hljs-comment">// close stdin</span><br>    dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// make the fd 0 as the read end of pipe</span><br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    runcmd(pcmd-&gt;right); <span class="hljs-comment">//  run command in the right side of pipe |, input redirected to the read end of pipe</span><br>&#125;<br>close(p[<span class="hljs-number">0</span>]);<br>close(p[<span class="hljs-number">1</span>]);<br>wait(<span class="hljs-number">0</span>); <span class="hljs-comment">// wait for child process to finish</span><br>wait(<span class="hljs-number">0</span>); <span class="hljs-comment">// wait for child process to finish</span><br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>管道看上去也可以用临时文件来替代，但有四个不同点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> hello world | <span class="hljs-built_in">wc</span><br><span class="hljs-built_in">echo</span> hello world &gt; /tmp/xyz; <span class="hljs-built_in">wc</span> &lt; /tmp/xyz<br></code></pre></td></tr></table></figure>
<ul>
<li>管道会进行自我清扫，如果是 shell 重定向的话，我们必须要在任务完成后删除 <code>/tmp/xyz</code></li>
<li>管道可以传输任意长度的数据</li>
<li>管道允许同步：两个进程可以使用一对管道来进行二者之间的信息传递，每一个读操作都阻塞调用进程，直到另一个进程用 <code>write</code> 完成数据的发送。</li>
<li>实现进程间通信，管道效率更高</li>
</ul>
</li>
</ul>
<h3 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4 File system"></a>1.4 File system</h3><p>xv6文件系统包含了<em>文件</em>(byte arrays)和<em>目录</em>(对其他文件和目录的引用)。目录生成了一个树，树从根目录<code>/</code>开始。对于不以<code>/</code>开头的路径，认为是是相对路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">mkdir(<span class="hljs-string">&quot;/dir&quot;</span>);<br>fd = open(<span class="hljs-string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONGLY);<br>close(fd);<br>mknod(<span class="hljs-string">&quot;/console&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>mknod</code>：形式：<code>int mknod(char *file, int, int)</code></p>
<ul>
<li>创建设备文件，一个设备文件有一个major device和一个minor device，用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将<code>read</code>和<code>write</code>的system call重新定向到设备上。</li>
</ul>
</li>
<li><p>一个文件的名称和文件本身是不一样的，文件本身，也叫<em>inode</em>。可以有多个名字，也叫<em>link</em>，每个link包括了一个文件名和一个对inode的引用。一个inode存储了文件的元数据，包括该文件的类型(file, directory or device)、大小、文件在硬盘中的存储位置以及指向这个inode的link的个数</p>
</li>
<li><p><code>fstat</code>。形式：<code>int fstat(int fd, struct stat *st)</code></p>
<ul>
<li>将inode中的相关信息存储到<code>st</code>中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DIR 1 <span class="hljs-comment">// Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE 2 <span class="hljs-comment">// File</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE 3 <span class="hljs-comment">// Device</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>    <span class="hljs-type">int</span> dev; <span class="hljs-comment">// File system’s disk device</span><br>    uint ino; <span class="hljs-comment">// Inode number</span><br>    <span class="hljs-type">short</span> type; <span class="hljs-comment">// Type of file</span><br>    <span class="hljs-type">short</span> nlink; <span class="hljs-comment">// Number of links to file</span><br>    uint64 size; <span class="hljs-comment">// Size of file in bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>link</code>。形式：<code>int link(char *file1, char *file2)</code></p>
<ul>
<li>创建一个指向同一个inode的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">open(<span class="hljs-string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);<br>link(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br><br>unlink(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>读写 <code>a</code> 就相当于读写 <code>b</code>。每一个 inode 都由一个唯一的 <code>inode 号</code> 直接确定。在上面这段代码中，我们可以通过 <code>fstat</code> 知道 <code>a</code> 和 <code>b</code> 都指向同样的内容：<code>a</code> 和 <code>b</code> 都会返回同样的 inode 号（<code>ino</code>），并且 <code>nlink</code> 数会设置为2。</li>
</ul>
</li>
</ul>
<p>注意：Unix提供了许多在<strong>用户层面</strong>的程序来执行文件系统相关的操作，比如<code>mkdir</code>、<code>ln</code>、<code>rm</code>等，而不是将其放在shell或kernel内，这样可以使用户比较方便地在这些程序上进行扩展。</p>
<p>但是<code>cd</code>是一个例外，它是在shell程序内构建的，因为它必须要改变这个calling shell本身指向的路径位置，如果是一个和shell平行的程序，那么它必须要调用一个子进程，在子进程里起一个新 shell 再进行<code>cd</code>，<code>cd</code>只会改变<em>子进程</em>的当前工作目录。父进程的工作目录保持原样。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/MIT/">MIT</a>, <a href="/categories/MIT/6-S081/">6.S081</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/25/Scala-4-面向对象/"><span>Scala(4) 面向对象</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/25/Scala-4-面向对象/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-24T16:16:50.000Z">
          2022-09-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6. 面向对象"></a>6. 面向对象</h2><h3 id="6-1-Scala包"><a href="#6-1-Scala包" class="headerlink" title="6.1 Scala包"></a>6.1 Scala包</h3><h4 id="6-1-1-包的命名"><a href="#6-1-1-包的命名" class="headerlink" title="6.1.1 包的命名"></a>6.1.1 包的命名</h4><p><strong>命名规则</strong></p>
<p>只能包含数字、字母、下划线、小圆点，但不能用数字开头，也不要使用关键字。</p>
<p><strong>命名规范</strong></p>
<p>com.公司.项目.模块</p>
<h4 id="6-1-2-包说明-包语句"><a href="#6-1-2-包说明-包语句" class="headerlink" title="6.1.2 包说明(包语句)"></a>6.1.2 包说明(包语句)</h4><p><strong>基础说明</strong></p>
<p>Scala有两种包的管理风格，一种和Java的包管理风格相同，每个源文件一个包(<strong>包名和源文件所在路径不要求必须一致</strong>)，用”.”进行分割表示包的层级关系</p>
<p>另一种风格，通过嵌套的风格表示层级关系</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com &#123;<br>    <span class="hljs-keyword">package</span> whale &#123;<br>        <span class="hljs-keyword">package</span> scala &#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有以下特点：</p>
<ul>
<li>一个源文件中可以声明多个package</li>
<li>子包中的类可以直接访问父包中的内容，而无需导包</li>
</ul>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com &#123;<br>    <span class="hljs-comment">// 父包访问子包需要导包</span><br>    <span class="hljs-keyword">import</span> com.whale.<span class="hljs-type">Inner</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Outer</span> </span>&#123;<br>        <span class="hljs-keyword">val</span> out: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;out&quot;</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>            println(<span class="hljs-type">Inner</span>.in)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">package</span> whale &#123;<br><br>        <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Inner</span> </span>&#123;<br>            <span class="hljs-keyword">val</span> in: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;in&quot;</span><br><br>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>                println(<span class="hljs-type">Outer</span>.out) <span class="hljs-comment">// 子包访问父包无需导包</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> other &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="6-1-3-包对象"><a href="#6-1-3-包对象" class="headerlink" title="6.1.3 包对象"></a>6.1.3 包对象</h4><p>在Scala中可以为每个包定义一个<strong>同名</strong>的包对象，定义在包对象中的成员，作为其<strong>对应包</strong>下所有class和object的共享变量，可以被直接访问。</p>
<p><strong>定义</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">com</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> shareValue = <span class="hljs-string">&quot;share&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shareMethod</span></span>() = &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<ol>
<li><p>若使用Java的包管理风格，则包对象一般定义在其对应包下的packageName.scala文件中，包对象名与包名保持一致</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220925121142605.png" alt="image-20220925121142605"></p>
</li>
<li><p>如采用嵌套方式管理包，则包对象可与包定义在同一文件，但是要保证包对象与包声明在同一作用域</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com &#123;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Outer</span> </span>&#123;<br>        <span class="hljs-keyword">val</span> out: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;out&quot;</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>            println(name)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">com</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;com&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="6-1-4-导包说明"><a href="#6-1-4-导包说明" class="headerlink" title="6.1.4 导包说明"></a>6.1.4 导包说明</h4><ul>
<li>可以在顶部使用import导入，在这个文件中的所有类都可以使用</li>
<li><p>局部导入：什么时候使用，什么时候导入。在作用范围内都可以使用</p>
</li>
<li><p>通配符导入：import java.util._</p>
</li>
<li>给类起名：import java.util.{ArrayList =&gt; JL}</li>
<li>导入相同包的多个类：import java.util.{HashSet, ArrayList}</li>
<li>屏蔽类：import java.util.{ArrayList =&gt; _, _}</li>
<li>导入包的绝对路径：new _root_.java.util.HashMap</li>
</ul>
<p><strong>注意</strong></p>
<p>Scala中的三个默认导入</p>
<ul>
<li>import java.lang._</li>
<li>import scala._</li>
<li>import scala.Predef._</li>
</ul>
<h4 id="6-1-5-访问权限"><a href="#6-1-5-访问权限" class="headerlink" title="6.1.5 访问权限"></a>6.1.5 访问权限</h4><ul>
<li>Scala中属性和方法的默认访问权限为public，但Scala中无public关键字</li>
<li>private为私有权限，只有在类的内部和伴生对象中可用</li>
<li><code>protected</code>为受保护权限，比Java中更严格，<strong>同类、子类可以访问，同包无法访问</strong></li>
<li>private [包名]增加包访问权限，包名下的其他类也可以使用</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.whale.scalademo.chapter6<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;tony&quot;</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = <span class="hljs-number">18</span><br>    <span class="hljs-keyword">private</span> [chapter6] <span class="hljs-keyword">var</span> sex: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;男&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(name)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> person = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span><br>        person.say()<br>        println(person.name)<br>        println(person.age)<br>        println(person.sex)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">this</span>.age<br>        <span class="hljs-keyword">this</span>.sex<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>().sex<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-2-类和对象"><a href="#6-2-类和对象" class="headerlink" title="6.2 类和对象"></a>6.2 类和对象</h3><h4 id="6-2-1-定义类"><a href="#6-2-1-定义类" class="headerlink" title="6.2.1 定义类"></a>6.2.1 定义类</h4><p><strong>回顾</strong></p>
<p>Java中，public类的类名与文件名一致，且一个.java文件只有一个public类</p>
<p>Scala中没有public关键字，一个.scala文件可以写多个类</p>
<p><strong>基本语法</strong></p>
<p>[修饰符] class 类名 {</p>
<p>​    类体</p>
<p>}</p>
<ul>
<li>Scala语法中，类并不声明为public，所有这些类都具有公有可见性(即默认为public)</li>
<li>一个Scala源文件可以包含多个类</li>
</ul>
<h4 id="6-2-2-属性"><a href="#6-2-2-属性" class="headerlink" title="6.2.2 属性"></a>6.2.2 属性</h4><p><strong>基本语法</strong></p>
<p>[修饰符] val|var 属性名 [: 类型] = 属性值</p>
<p>注：<code>Bean属性(@BeanProperty)可以自动生成规范的set/get方法</code></p>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;tony&quot;</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = _  <span class="hljs-comment">// _ 表示给属性一个默认值</span><br><br>    <span class="hljs-comment">// Bean属性</span><br>    <span class="hljs-meta">@BeanProperty</span> <span class="hljs-keyword">var</span> sex: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;男&quot;</span><br>    <span class="hljs-comment">// val 修饰的属性不能赋默认值，必须显式指定</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span><br>        println(person.name)<br>        person.setSex(<span class="hljs-string">&quot;女&quot;</span>)<br>        println(person.getSex)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="6-2-3-方法"><a href="#6-2-3-方法" class="headerlink" title="6.2.3 方法"></a>6.2.3 方法</h4><p><strong>基本语法</strong></p>
<p>def 方法名(参数列表)[: 返回值类型] = {</p>
<p>​    方法体</p>
<p>}</p>
<h4 id="6-2-4-创建对象"><a href="#6-2-4-创建对象" class="headerlink" title="6.2.4 创建对象"></a>6.2.4 创建对象</h4><p><strong>基本语法</strong></p>
<p>val|var 对象名 [: 类型] = new 类型()</p>
<p><strong>注意事项</strong></p>
<ul>
<li>val修饰对象，不能改变对象的引用(即内存地址)，可以改变对象属性的值</li>
<li>var修饰对象，可以修改引用和属性值</li>
<li>自动推导变量类型不能堕胎，所以多态需要显式声明</li>
</ul>
<h4 id="6-2-5-构造器"><a href="#6-2-5-构造器" class="headerlink" title="6.2.5 构造器"></a>6.2.5 构造器</h4><p>Scala类的构造器包括：<strong>主构造器和辅助构造器</strong></p>
<p><strong>基本语法</strong></p>
<p>class 类名(形参列表) { <strong>// 主构造器</strong></p>
<p>​    def <code>this</code>(形参列表){} // 辅助构造器</p>
<p>​    def <code>this</code>(形参列表){} // 辅助构造器可以有多个</p>
<p>}</p>
<ul>
<li>辅助构造器，函数名this，可以有多个，编译器通过参数的个数及类型来区分</li>
<li>辅助构造方法不能直接构建对象，<strong>必须直接或者简介调用主构造方法</strong></li>
<li><code>构造器调用其他的构造器，要求被调用构造器必须提前声明</code></li>
<li>如果主构造器无参数，小括号可以省略，构建对象时调用的构造方法的小括号也可以省略</li>
</ul>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// class Person() &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> = _<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = _<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(age: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">this</span>()<br>        <span class="hljs-keyword">this</span>.age = age<br>        println(<span class="hljs-string">&quot;辅助构造器&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(age: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">this</span>(age)<br>        <span class="hljs-keyword">this</span>.name = name<br>    &#125;<br>    <br>    println(<span class="hljs-string">&quot;主构造器&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="6-2-6-构造器参数"><a href="#6-2-6-构造器参数" class="headerlink" title="6.2.6 构造器参数"></a>6.2.6 构造器参数</h4><p><strong>说明</strong></p>
<p>Scala类的主构造器函数的形参包括三种类型：未用任何修饰、var修饰、val修饰</p>
<ul>
<li>未用任何修饰符修饰，这个参数就是一个局部变量</li>
<li>var修饰参数，作为类的成员属性使用，可以修改</li>
<li>val修饰参数，作为类只读属性使用，不能修改</li>
</ul>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, var age: <span class="hljs-type">Int</span>, val sex: <span class="hljs-type">String</span></span>) </span>&#123;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>)<br>        <span class="hljs-comment">// 未用任何修饰符修饰，这个参数就是一个局部变量</span><br>        <span class="hljs-comment">// println(person.name)</span><br><br>        <span class="hljs-comment">// var修饰参数，作为类的成员属性使用，可以修改</span><br>        person.age = <span class="hljs-number">19</span><br>        println(person.age)<br>        <span class="hljs-comment">// val修饰参数，作为类只读属性使用，不能修改</span><br>        <span class="hljs-comment">// person.sex = &quot;女&quot;</span><br>        println(person.sex)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-3-封装"><a href="#6-3-封装" class="headerlink" title="6.3 封装"></a>6.3 封装</h3><p>Scala中的<code>public</code>属性，底层实际为<code>private</code>，并通过get方法(<code>obj.field()</code>)和set方法(<code>obj.field_=(value)</code>)对其进行操作。所以Scala并不推荐将属性设为private，再设置public的get和set方法。</p>
<p>但由于很多Java框架都利用反射调用setXXX和getXXX方法，有时为了兼容，也会为Scala的属性设置get和set方法(通过@BeanProperty)</p>
<h3 id="6-4-继承和多态"><a href="#6-4-继承和多态" class="headerlink" title="6.4 继承和多态"></a>6.4 继承和多态</h3><p><strong>基本语法</strong></p>
<ul>
<li><code>entends</code></li>
<li>子类继承父类的属性和方法</li>
<li>单继承</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Big-Data/">Big Data</a>, <a href="/categories/Big-Data/Scala/">Scala</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Scala/">Scala</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/25/Scala-3-函数式编程/"><span>Scala(3) 函数式编程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/25/Scala-3-函数式编程/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-24T16:16:49.000Z">
          2022-09-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h2><ol>
<li><p>面向对象编程：</p>
<p>解决问题，分解对象，行为，属性，然后通过对象的关系以及行为的调用来解决问题</p>
<p><strong>Scala是一个完全面向对象编程语言。万物皆对象</strong></p>
<p><strong>对象的本质：对数据和行为的一个封装</strong></p>
</li>
<li><p>函数式编程</p>
<p>解决问题时，将问题分解成一个一个的步骤，将每个步骤进行封装(函数)，通过调用这些封装好的步骤，解决问题</p>
<p><strong>Scala是一个完全函数式编程语言。万物皆函数</strong></p>
<p><strong>函数的本质：函数可以当作一个值进行传递</strong></p>
</li>
<li><p>Scala中函数式编程和面向对象编程完美融合在一起</p>
</li>
</ol>
<h3 id="5-1-函数基础"><a href="#5-1-函数基础" class="headerlink" title="5.1 函数基础"></a>5.1 函数基础</h3><h4 id="5-1-1-函数基本语法"><a href="#5-1-1-函数基本语法" class="headerlink" title="5.1.1 函数基本语法"></a>5.1.1 函数基本语法</h4><p><strong>基本语法</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220920151844943.png" alt="image-20220920151844943"></p>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 函数定义</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(arg: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;<br>        println(arg)<br>    &#125;<br>    <span class="hljs-comment">// 函数调用</span><br>    f(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-1-2-函数和方法的区别"><a href="#5-1-2-函数和方法的区别" class="headerlink" title="5.1.2 函数和方法的区别"></a>5.1.2 函数和方法的区别</h4><p><strong>核心概念</strong></p>
<ul>
<li>为完成某一功能的程序语句的集合，称为函数</li>
<li><strong>类中的函数称为方法</strong></li>
</ul>
<p><strong>案例实操</strong></p>
<ul>
<li>Scala可以在任何的语法结构中<strong>声明任何的语法</strong></li>
<li>函数没有重载和重写的概念，<strong>方法可以进行重载和重写</strong></li>
<li>Scala中函数可以<strong>嵌套定义</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TestFunction</span> </span>&#123;<br>    <span class="hljs-comment">// 2. 方法可以进行重载和重写, 程序可以运行</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(): <span class="hljs-type">Unit</span> = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// 1. Scala可以在任何的语法结构中声明任何的语法</span><br>        <span class="hljs-keyword">import</span> java.util.<span class="hljs-type">Date</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Date</span>()<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        2. 函数没有重载和重写的概念, 程序报错</span><br><span class="hljs-comment">        def test(): Unit = &#123;</span><br><span class="hljs-comment">            println(&quot;无参, 无返回值&quot;)</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        test()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        def test(name: String): Unit = &#123;</span><br><span class="hljs-comment">            println()</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">// 3. Scala函数可以嵌套定义</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;<br>                println(name)<br>            &#125;<br>            test3(<span class="hljs-string">&quot;函数可以嵌套定义&quot;</span>)<br>        &#125;<br>        test2()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-1-3-函数定义"><a href="#5-1-3-函数定义" class="headerlink" title="5.1.3 函数定义"></a>5.1.3 函数定义</h4><p><strong>基础语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 函数1: 无参, 无返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;无参, 无返回值&quot;</span>)<br>    &#125;<br>    test1()<br>    <span class="hljs-comment">// 函数2: 无参, 有返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span></span>(): <span class="hljs-type">String</span> = &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;无参, 有返回值&quot;</span><br>    &#125;<br>    println(test2())<br>    <span class="hljs-comment">// 函数3: 有参, 无返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;<br>        println(s)<br>    &#125;<br>    test3(<span class="hljs-string">&quot;有参, 无返回值&quot;</span>)<br>    <span class="hljs-comment">// 函数4: 有参, 有返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">String</span> = &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br>    println(test4(<span class="hljs-string">&quot;有参, 有返回值&quot;</span>))<br>    <span class="hljs-comment">// 函数5: 多参, 无返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test5</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;name&#125;</span>, <span class="hljs-subst">$&#123;age&#125;</span>&quot;</span>)<br>    &#125;<br>    test5(<span class="hljs-string">&quot;tony&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-comment">// 函数6: 多参, 有返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test6</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> = &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;name&#125;</span>, <span class="hljs-subst">$&#123;age&#125;</span>&quot;</span><br>    &#125;<br>    println(test6(<span class="hljs-string">&quot;tony&quot;</span>, <span class="hljs-number">18</span>))<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-1-4-函数参数"><a href="#5-1-4-函数参数" class="headerlink" title="5.1.4 函数参数"></a>5.1.4 函数参数</h4><p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 1.可变参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(s: <span class="hljs-type">String</span>*): <span class="hljs-type">Unit</span> = &#123;<br>        println(s)<br>    &#125;<br>    <span class="hljs-comment">// 有输入参数: 输出 WrappedArray(Hello, Scala)</span><br>    test(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Scala&quot;</span>)<br>    <span class="hljs-comment">// 无输入参数: 输出 List()</span><br>    test()<br><br>    <span class="hljs-comment">// 2.如果参数列表中存在多个参数, 那么可变参数一般放置在最后</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span></span>(name: <span class="hljs-type">String</span>, s: <span class="hljs-type">String</span>*): <span class="hljs-type">Unit</span> = &#123;<br>        println(name + <span class="hljs-string">&quot;,&quot;</span> + s)<br>    &#125;<br>    <span class="hljs-comment">// 输出 jimbo,WrappedArray(nju)</span><br>    test2(<span class="hljs-string">&quot;jimbo&quot;</span>, <span class="hljs-string">&quot;nju&quot;</span>)<br><br>    <span class="hljs-comment">// 3.参数默认值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span> = <span class="hljs-number">30</span>): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;<span class="hljs-subst">$name</span>, <span class="hljs-subst">$age</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 如果参数传递了值，那么会覆盖默认值</span><br>    test3(<span class="hljs-string">&quot;jimbo&quot;</span>, <span class="hljs-number">20</span>)<br>    <span class="hljs-comment">// 如果参数有默认值，在调用的时候，可以省略这个参数</span><br>    test3(<span class="hljs-string">&quot;jimbo&quot;</span>)<br><br>    <span class="hljs-comment">// 一般情况下， 将有默认值的参数放置在参数列表的后面</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span></span>(sex: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;男&quot;</span>, name: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">s&quot;<span class="hljs-subst">$name</span>, <span class="hljs-subst">$sex</span>&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// Scala 函数中参数传递是，从左到右</span><br>    <span class="hljs-comment">// test4(&quot;jimbo&quot;)</span><br><br>    <span class="hljs-comment">// 4.带名参数</span><br>    test4(name = <span class="hljs-string">&quot;jimbo&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-1-5-函数至简原则"><a href="#5-1-5-函数至简原则" class="headerlink" title="5.1.5 函数至简原则"></a>5.1.5 函数至简原则</h4><p>原则：能省就省</p>
<p><strong>内容</strong></p>
<ul>
<li>return可以省略，Scala会使用函数体的最后一行代码作为返回值</li>
<li>如果函数体只有一行代码，可以省略花括号</li>
<li>返回值类型如果能够推断出来，那么可以省略(:和返回值类型一起省略)</li>
<li>如果有return，则不能省略返回值类型，必须指定</li>
<li>如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用</li>
<li>Scala如果期望是无返回值类型，可以省略等号</li>
<li>如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</li>
<li>如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</li>
<li>如果不关心名称，只关心逻辑处理，那么函数名(def)可以省略</li>
</ul>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 0.函数标准写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">String</span> = &#123;<br>        <span class="hljs-keyword">return</span> s + <span class="hljs-string">&quot;nju&quot;</span><br>    &#125;<br>    println(f(<span class="hljs-string">&quot;hello&quot;</span>))<br><br>    <span class="hljs-comment">// 1. return可以省略，Scala会使用函数体的最后一行代码作为返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">String</span> = &#123;<br>        s + <span class="hljs-string">&quot;nju&quot;</span><br>    &#125;<br>    println(f1(<span class="hljs-string">&quot;hello1&quot;</span>))<br><br>    <span class="hljs-comment">// 2. 如果函数体只有一行代码，可以省略花括号</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">String</span> = s + <span class="hljs-string">&quot;nju&quot;</span><br>    println(f2(<span class="hljs-string">&quot;hello2&quot;</span>))<br><br>    <span class="hljs-comment">// 3. 返回值类型如果能够推断出来，那么可以省略(:和返回值类型一起省略)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f3</span></span>(s: <span class="hljs-type">String</span>) = s + <span class="hljs-string">&quot;nju&quot;</span><br>    println(f3(<span class="hljs-string">&quot;hello3&quot;</span>))<br><br>    <span class="hljs-comment">// 4. 如果有return，则不能省略返回值类型，必须指定</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f4</span></span>(): <span class="hljs-type">String</span> = &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello4 nju&quot;</span><br>    &#125;<br>    println(f4())<br><br>    <span class="hljs-comment">// 5. 如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f5</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello5 nju&quot;</span><br>    &#125;<br>    println(f5())<br><br>    <span class="hljs-comment">// 6. Scala如果期望是无返回值类型，可以省略等号</span><br>    <span class="hljs-comment">// 将无返回值的函数称之为过程</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f6</span></span>() &#123;<br>        <span class="hljs-string">&quot;hello6 nju&quot;</span><br>    &#125;<br>    println(f6())<br><br>    <span class="hljs-comment">// 7. 如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f7</span></span>() = <span class="hljs-string">&quot;hello7 nju&quot;</span><br>    println(f7())<br>    println(f7)<br><br>    <span class="hljs-comment">// 8. 如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f8</span> </span>= <span class="hljs-string">&quot;hello8 nju&quot;</span><br>    <span class="hljs-comment">// println(f8())</span><br>    println(f8)<br><br>    <span class="hljs-comment">// 9. 如果不关心名称，只关心逻辑处理，那么函数名(def)可以省略</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f9</span> </span>= (x: <span class="hljs-type">String</span>) =&gt; &#123;<br>        println(<span class="hljs-string">&quot;hello9 nju&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f10</span></span>(f: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Unit</span>) = &#123;<br>        f(<span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br>    f10(f9)<br>    println(f10((x: <span class="hljs-type">String</span>) =&gt; &#123;<br>        println(<span class="hljs-string">&quot;hello10 nju&quot;</span>)<br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220920231245784.png" alt="image-20220920231245784"></p>
<h3 id="5-2-函数高级"><a href="#5-2-函数高级" class="headerlink" title="5.2 函数高级"></a>5.2 函数高级</h3><h4 id="5-2-1-高阶函数"><a href="#5-2-1-高阶函数" class="headerlink" title="5.2.1 高阶函数"></a>5.2.1 高阶函数</h4><p>对于一个函数，我们可以：定义函数、调用函数</p>
<p>但函数还有更高级的用法</p>
<ul>
<li><p><strong>函数可以作为值进行传递</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 1.调用foo函数,把返回值给变量f</span><br>    <span class="hljs-keyword">val</span> f = foo()<br>    println(f)<br><br>    <span class="hljs-comment">// 2.在被调用函数foo后面加上 _ ,相当于把函数foo作为一个整体,传递给变量f1</span><br>    <span class="hljs-keyword">val</span> f1 = foo _<br>    foo<br>    f1() <span class="hljs-comment">// 不能省略()</span><br><br>    <span class="hljs-comment">// 3.如果明确变量类型, 那么不使用下划线也可以将函数作为整体传递给变量</span><br>    <span class="hljs-keyword">var</span> f2: () =&gt; <span class="hljs-type">Int</span> = foo<br>    f2()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>(): <span class="hljs-type">Int</span> = &#123;<br>    println(<span class="hljs-string">&quot;foo...&quot;</span>)<br>    <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>​    <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220920232316768.png" alt="image-20220920232316768"></p>
<ul>
<li><p><strong>函数可以作为参数进行传递</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 1.定义一个函数,函数参数还是一个函数签名</span><br>    <span class="hljs-comment">// f表示函数名称, (Int, Int)表示输入两个Int参数, Int表示函数返回值</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>(f: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>        f(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 2.定义一个函数,参数和返回值类型和f1的输入参数一致</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = a + b<br><br>    <span class="hljs-comment">// 3.将add函数作为参数传递给f1, 如果能够推断出来不是调用, _ 可以省略</span><br>    println(f1(add))<br>    println(f1(add _))<br>    <span class="hljs-comment">// 可以传递匿名函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>函数可以作为函数返回值返回</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>() = &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span></span>() = &#123;<br>            println(<span class="hljs-string">&quot;f2&quot;</span>)<br>        &#125;<br>        f2 _<br>    &#125;<br>    <br>    <span class="hljs-keyword">val</span> f = f1()<br>    <span class="hljs-comment">// 因为f1函数的返回值依然为函数,所以变量f可以作为函数继续调用</span><br>    f()<br>    <span class="hljs-comment">// 上面代码可以简化为</span><br>    f1()()<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-2-匿名函数"><a href="#5-2-2-匿名函数" class="headerlink" title="5.2.2 匿名函数"></a>5.2.2 匿名函数</h4><p><strong>说明</strong></p>
<p>没有名字的函数就是匿名函数</p>
<p><code>(x: Int) =&gt; &#123;函数体&#125;</code></p>
<p>传递匿名函数至简原则</p>
<ul>
<li>参数的类型可以省略，会根据形参自动推导</li>
<li>类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况: 没有参数和参数超过1的永远不能省略圆括号</li>
<li>匿名函数如果只有一行，则大括号也可以省略</li>
<li>如果参数只出现一次，则参数省略且后面参数可以用_代替</li>
</ul>
<p><strong>案例实操</strong></p>
<p>单个参数版</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 1. 定义一个函数, 参数包括数据和逻辑函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">operation</span></span>(arr: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = &#123;<br>        <span class="hljs-keyword">for</span> (elem &lt;- arr) <span class="hljs-keyword">yield</span> op(elem)<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 定义逻辑函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">op</span></span>(ele: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>        ele + <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 3. 标准函数调用</span><br>    <span class="hljs-keyword">val</span> arr = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), op)<br>    println(arr.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-comment">// 4. 采用匿名函数</span><br>    <span class="hljs-keyword">val</span> arr1 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (ele: <span class="hljs-type">Int</span>) =&gt; &#123;ele + <span class="hljs-number">1</span>&#125;)<br>    println(arr1.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-comment">// 4.1 参数的类型可以省略，会根据形参自动推导</span><br>    <span class="hljs-keyword">val</span> arr2 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (ele) =&gt; &#123;ele + <span class="hljs-number">1</span>&#125;)<br>    println(arr2.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-comment">// 4.2 类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况: 没有参数和参数超过1的永远不能省略圆括号</span><br>    <span class="hljs-keyword">val</span> arr3 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), ele =&gt; &#123;ele + <span class="hljs-number">1</span>&#125;)<br>    println(arr3.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-comment">// 4.3 匿名函数如果只有一行，则大括号也可以省略</span><br>    <span class="hljs-keyword">val</span> arr4 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), ele =&gt; ele + <span class="hljs-number">1</span>)<br>    println(arr4.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-comment">// 4.4 如果参数只出现一次，则参数省略且后面参数可以用_代替</span><br>    <span class="hljs-keyword">val</span> arr5 = operation(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), _ + <span class="hljs-number">1</span>)<br>    println(arr5.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>多个参数版</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">operation</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>, op: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>) = &#123;<br>        op(a, b)<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 标准版</span><br>    println(operation(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) =&gt; &#123;x + y&#125;))<br><br>    <span class="hljs-comment">// 2. 匿名函数如果只有一行，则大括号也可以省略</span><br>    println(operation(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, (x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) =&gt; x + y))<br><br>    <span class="hljs-comment">// 3 参数的类型可以省略，会根据形参自动推导</span><br>    println(operation(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, (x, y) =&gt; x + y))<br><br>    <span class="hljs-comment">// 4 如果参数只出现一次，则参数省略且后面参数可以用_代替</span><br>    println(operation(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, _ + _))<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-2-3-高阶函数案例"><a href="#5-2-3-高阶函数案例" class="headerlink" title="5.2.3 高阶函数案例"></a>5.2.3 高阶函数案例</h4><p>模拟Map映射、Filter过滤、Reduce聚合</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 1. map映射</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>(arr: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = &#123;<br>        <span class="hljs-keyword">for</span> (elem &lt;- arr) <span class="hljs-keyword">yield</span> op(elem)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> arr = map(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), x =&gt; x * x)<br>    println(arr.mkString(<span class="hljs-string">&quot;,&quot;</span>))<br><br>    <span class="hljs-comment">// 2. filter过滤. 有参数, 且参数在后面只使用一次, 则参数省略且后面参数用_表示</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span></span>(arr: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Boolean</span>) = &#123;<br>        <span class="hljs-keyword">var</span> arr1: <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Int</span>]()<br>        <span class="hljs-keyword">for</span> (elem &lt;- arr <span class="hljs-keyword">if</span> op(elem)) &#123;<br>            arr1.append(elem)<br>        &#125;<br>        arr1.toArray<br>    &#125;<br>    <span class="hljs-keyword">var</span> arr1 = filter(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), _ % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>    println(arr1.mkString((<span class="hljs-string">&quot;,&quot;</span>)))<br><br>    <span class="hljs-comment">// 3. reduce聚合. 有多个参数, 且每个参数再后面只使用一次, 则参数省略且后面参数用_表示，第n个_代表第n个参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(arr: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], op: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>) = &#123;<br>        <span class="hljs-keyword">var</span> init: <span class="hljs-type">Int</span> = arr(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> (elem &lt;- <span class="hljs-number">1</span> until arr.length) &#123;<br>            init = op(init, elem)<br>        &#125;<br>        init<br>    &#125;<br>    <span class="hljs-keyword">val</span> arr2 = reduce(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), _ * _)<br>    println(arr2)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-2-4-函数柯里化-amp-闭包"><a href="#5-2-4-函数柯里化-amp-闭包" class="headerlink" title="5.2.4 函数柯里化 &amp; 闭包"></a>5.2.4 函数柯里化 &amp; 闭包</h4><p><strong>说明</strong></p>
<p><code>闭包</code>: 如果一个函数，访问到了它的外部(局部)变量的值，那么这个函数和他所处的环境，称为闭包</p>
<p><code>函数柯里化</code>: 把一个参数列表的多个参数，变成多个参数列表</p>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 闭包</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span></span>() = &#123;<br>        <span class="hljs-keyword">val</span> a: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span></span>(b: <span class="hljs-type">Int</span>) = a + b<br>        f2 _<br>    &#125;<br>    <span class="hljs-comment">// 在调用时, f1函数执行完毕后, 局部变量a应该随着栈空间释放掉</span><br>    <span class="hljs-keyword">val</span> f = f1()<br>    <span class="hljs-comment">// 但是在此处, 变量a并没有释放, 而是包含在f2函数的内部, 形成了闭合的效果</span><br>    println(f(<span class="hljs-number">3</span>))<br>    println(f1()(<span class="hljs-number">3</span>))<br><br>    <span class="hljs-comment">// 函数柯里化, 其实就是将复杂的参数逻辑简单化, 函数柯里化一定存在闭包</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-type">Int</span>) (b: <span class="hljs-type">Int</span>) = &#123;<br>        a + b<br>    &#125;<br>    println(add(<span class="hljs-number">10</span>)(<span class="hljs-number">3</span>))<br>    <span class="hljs-comment">// 实际上最先演变成def add(a: Int) = (b: Int) =&gt; a + b</span><br>    <span class="hljs-comment">// val result = add(10)</span><br>    <span class="hljs-comment">// val sum = result(3)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-2-5-递归"><a href="#5-2-5-递归" class="headerlink" title="5.2.5 递归"></a>5.2.5 递归</h4><p><strong>Scala中的递归必须声明函数返回值类型</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    println(test(<span class="hljs-number">5</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(i: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        i * test(i - <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-2-6-控制抽象"><a href="#5-2-6-控制抽象" class="headerlink" title="5.2.6 控制抽象"></a>5.2.6 控制抽象</h4><ul>
<li><p>值调用：把计算后的值传递进去</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> </span>= () =&gt; &#123;<br>        println(<span class="hljs-string">&quot;f...&quot;</span>)<br>        <span class="hljs-number">10</span><br>    &#125;<br>    foo(f())<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>(a: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>    println(a)<br>    println(a)<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// f...</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>名调用：把<strong>代码块</strong>传递过去</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> </span>= () =&gt; &#123;<br>        println(<span class="hljs-string">&quot;f...&quot;</span>)<br>        <span class="hljs-number">10</span><br>    &#125;<br>    foo(f())<br>    foo(&#123;<br>        println(<span class="hljs-string">&quot;这是一个代码块&quot;</span>)<br>        <span class="hljs-number">19</span><br>    &#125;)<br>    <span class="hljs-comment">// 小括号可以省略</span><br>    foo&#123;<br>        println(<span class="hljs-string">&quot;这是一个代码块&quot;</span>)<br>        <span class="hljs-number">29</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// def foo(a: Int): Unit = &#123;</span><br><span class="hljs-comment">// =&gt; Int: 传递代码块, 且返回值为Int</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>(a: =&gt; <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>    println(a)<br>    println(a)<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// f...</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// f...</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 这是一个代码块</span><br><span class="hljs-comment">// 19</span><br><span class="hljs-comment">// 这是一个代码块</span><br><span class="hljs-comment">// 19</span><br><span class="hljs-comment">// 这是一个代码块</span><br><span class="hljs-comment">// 29</span><br><span class="hljs-comment">// 这是一个代码块</span><br><span class="hljs-comment">// 29</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>案例实操</strong></p>
<p>自定义while循环</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">var</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span><br>    myWhile(i &lt;= <span class="hljs-number">5</span>) &#123;<br>        println(i)<br>        i += <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myWhile</span></span>(condition: =&gt; <span class="hljs-type">Boolean</span>) (op: =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        op<br>        myWhile(condition)(op)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-2-7-惰性加载"><a href="#5-2-7-惰性加载" class="headerlink" title="5.2.7 惰性加载"></a>5.2.7 惰性加载</h4><p><strong>说明</strong></p>
<p>当<strong>函数返回值被声明为lazy</strong>时，函数的<strong>执行将被推迟</strong>，直到我们<strong>首次对此取值，该函数才会执行</strong>。这种函数我们称之为惰性函数</p>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> res = sum(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)<br>    println(<span class="hljs-string">&quot;---------&quot;</span>)<br>    println(<span class="hljs-string">&quot;res = &quot;</span>  + res)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(n1: <span class="hljs-type">Int</span>, n2: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;<br>    println(<span class="hljs-string">&quot;sum被执行...&quot;</span>)<br>    n1 + n2<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// ---------</span><br><span class="hljs-comment">// sum被执行...</span><br><span class="hljs-comment">// res = 40</span><br></code></pre></td></tr></table></figure>
<p><code>注意：lazy不能修饰var类型的变量</code></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Big-Data/">Big Data</a>, <a href="/categories/Big-Data/Scala/">Scala</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Scala/">Scala</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/25/Scala-2-基础语法/"><span>Scala(2) 基础语法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/25/Scala-2-基础语法/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-24T16:16:48.000Z">
          2022-09-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="2-变量和数据类型"><a href="#2-变量和数据类型" class="headerlink" title="2. 变量和数据类型"></a>2. 变量和数据类型</h2><h3 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h3><p><strong>基本语法</strong></p>
<ul>
<li><p>单行注释：<code>//</code></p>
</li>
<li><p>多行注释：<code>/* */</code></p>
</li>
<li><p>文档注释：<code>/**</code></p>
<p>​         <code>*</code></p>
<p>​         <code>*/</code></p>
</li>
</ul>
<p><strong>注意事项</strong></p>
<p>Scala注释使用和Java完全一样</p>
<h3 id="2-2-变量和常量"><a href="#2-2-变量和常量" class="headerlink" title="2.2 变量和常量"></a>2.2 变量和常量</h3><p><strong>基本语法</strong></p>
<ul>
<li><code>var 变量名 [: 变量类型] = 初始值</code></li>
<li><p><code>val 常量名 [: 常量类型] = 初始值</code></p>
</li>
<li><p>能用常量的地方不用变量</p>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>声明变量时，<strong>类型可以省略</strong>，编译器自动推导，即类型推导</li>
<li>类型确定后不可修改</li>
<li>变量声明时，<strong>必须要有初始值</strong></li>
<li><p>在声明/定义变量时，可以使用var或者val来修饰，<strong>var修饰的变量可变，val修饰的变量不可变</strong></p>
</li>
<li><p>var修饰的对象引用可以改变，val修饰的对象则不可改变，但对象的状态(字段)是可以改变的</p>
<ul>
<li>类构造方法中的属性加上var/val才能被访问到，能否改变也取决于此</li>
<li>类属性也可以写在字段中，构造方法形如<code>def this(..) &#123;&#125;</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, var age: <span class="hljs-type">Int</span></span>) </span>&#123; &#125;<br><br><span class="hljs-keyword">var</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-number">20</span>)<br>alice = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">21</span>)<br>alice = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">val</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">23</span>)<br>bob.age = <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-3-标识符的命名规范"><a href="#2-3-标识符的命名规范" class="headerlink" title="2.3 标识符的命名规范"></a>2.3 标识符的命名规范</h3><p><strong>命名规则</strong></p>
<p>Scala中的标识符声明，基本和Java一致，但是细节上会有所变化，有以下三点</p>
<ul>
<li>以字母或者下划线开头，后接字母、数字、下划线</li>
<li>以操作符开头，且只包含操作符(+-*/#!等)</li>
<li>用反引号``包括的任意字符串，即使是Scala关键字也可以</li>
</ul>
<h3 id="2-4-字符串输出"><a href="#2-4-字符串输出" class="headerlink" title="2.4 字符串输出"></a>2.4 字符串输出</h3><p><strong>基本语法</strong></p>
<ul>
<li>字符串间用 + 号连接，* 表示复制</li>
<li>printf用法：通过 % 传值</li>
<li>字符串模板(插值字符串)：通过 $ 获取变量值</li>
</ul>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;tony&quot;</span><br><span class="hljs-keyword">val</span> age: <span class="hljs-type">Int</span> = <span class="hljs-number">18</span><br><br><span class="hljs-comment">// 字符串用 + 连接, *可用来复制</span><br>println(name * <span class="hljs-number">3</span> + <span class="hljs-string">&quot; &quot;</span> + age)<br><br><span class="hljs-comment">// printf</span><br>printf(<span class="hljs-string">&quot;name = %s age = %d\n&quot;</span>, name, age)<br><br><span class="hljs-comment">// 字符串, 通过$引用</span><br>println(<span class="hljs-string">s&quot;name = <span class="hljs-subst">$&#123;name&#125;</span> age = <span class="hljs-subst">$&#123;age + 2&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">/* 使用多行字符串时, 用三个双引号包围即可</span><br><span class="hljs-comment">   输入的内容如果因为带有空格、\t导致每一行的开始位置不能对齐</span><br><span class="hljs-comment">   可以应用scala的stripMargin方法, 在scala中的stripMargin默认使用&quot;|&quot;作为连接符</span><br><span class="hljs-comment">   在多行换行的行头前加一个&quot;|&quot;即可</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">val</span> str =<br>    <span class="hljs-string">&quot;&quot;&quot;hello</span><br><span class="hljs-string">      |    world</span><br><span class="hljs-string">      |&quot;&quot;&quot;</span>.stripMargin<br>println(str)<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220918171337002.png" alt="image-20220918171337002"></p>
<h3 id="2-5-控制台输入"><a href="#2-5-控制台输入" class="headerlink" title="2.5 控制台输入"></a>2.5 控制台输入</h3><p><strong>基本语法</strong></p>
<ul>
<li><code>StdIn.readLine()</code></li>
<li><code>StdIn.readInt()</code></li>
<li><code>StdIn.readDouble()</code></li>
<li>…</li>
</ul>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">println(<span class="hljs-string">&quot;input name:&quot;</span>)<br><span class="hljs-keyword">val</span> name = <span class="hljs-type">StdIn</span>.readLine()<br>println(<span class="hljs-string">&quot;input age:&quot;</span>)<br><span class="hljs-keyword">val</span> age = <span class="hljs-type">StdIn</span>.readInt()<br>println(<span class="hljs-string">&quot;input sal:&quot;</span>)<br><span class="hljs-keyword">val</span> sal = <span class="hljs-type">StdIn</span>.readDouble()<br><br>println(<br>    <span class="hljs-string">s&quot;&quot;</span><span class="hljs-string">&quot;name = $&#123;name&#125;</span><br><span class="hljs-string">       |age = $&#123;age&#125;</span><br><span class="hljs-string">       |sal = $&#123;sal&#125;</span><br><span class="hljs-string">       |&quot;</span><span class="hljs-string">&quot;&quot;</span>.stripMargin)<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220918172711571.png" alt="image-20220918172711571"></p>
<h3 id="2-6-读写文件"><a href="#2-6-读写文件" class="headerlink" title="2.6 读写文件"></a>2.6 读写文件</h3><p><strong>基本语法</strong></p>
<ul>
<li><code>Source.fromFile(&quot;...&quot;)</code></li>
<li><code>new PrintWriter(new File(&quot;...&quot;))</code></li>
</ul>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 从文件读取</span><br><span class="hljs-keyword">val</span> source = <span class="hljs-type">Source</span>.fromFile(<span class="hljs-string">&quot;src/main/resources/test.txt&quot;</span>)<br>source.foreach(print)<br>source.close()<br><br><span class="hljs-comment">// 将数据写入文件</span><br><span class="hljs-keyword">val</span> writer = <span class="hljs-keyword">new</span> <span class="hljs-type">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">File</span>(<span class="hljs-string">&quot;src/main/resources/output.txt&quot;</span>))<br>writer.write(<span class="hljs-string">&quot;hello scala from java writer&quot;</span>)<br>writer.close()<br></code></pre></td></tr></table></figure>
<h3 id="2-7-数据类型"><a href="#2-7-数据类型" class="headerlink" title="2.7 数据类型"></a>2.7 数据类型</h3><ul>
<li>Scala 中一切数据都是对象，<strong>都是 Any 的子类</strong></li>
<li>Scala 中数据类型分为两大类：数值类型(AnyVal)，引用类型(AnyRef)，<strong>不管是值类型还是引用类型都是对象</strong></li>
<li>Scala 数据类型仍然遵守，<strong>低精度的值类型向高精度的值类型，自动转换(隐式转换)</strong>，图中虚线</li>
<li>Scala 中的 StringOps 是对 Java 的 String 的增强</li>
<li>Unit：对应 Java 中的 void，用于方法返回值的位置，表示方法没有返回值。<strong>Unit 是一个数据类型</strong>，只有一个对象就是<strong>()</strong>。Void 不是数据类型，只是一个关键词</li>
<li><strong>Null 是一个类型</strong>，只有一个对象就是 null。<strong>它是所有引用类型(AnyRef)的子类</strong></li>
<li><strong>Nothing，是所有数据类型的子类</strong>，主要用在一个函数没有明确返回值时使用，因为这样我们可以把抛出的返回值，返回给任何的变量或者函数</li>
<li>Long 需要在数字后加 <strong>L</strong>，同理，Float 类型需要加 <strong>F</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/20191220112456704.png" alt="20191220112456704"></p>
<h3 id="2-8-Unit、Null、Nothing"><a href="#2-8-Unit、Null、Nothing" class="headerlink" title="2.8 Unit、Null、Nothing"></a>2.8 Unit、Null、Nothing</h3><p><strong>基本说明</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unit</td>
<td>表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。</td>
</tr>
<tr>
<td>Null</td>
<td>null, Null类型只有一个实例值null</td>
</tr>
<tr>
<td>Nothing</td>
<td>Nothing类型在Scala的类层级最低端；它是任何其他类型的子类型。当一个函数，我们确定没有正常的返回值，可以用Nothing来指定返回类型，这样有一个好处，就是我们可以把返回的值(异常)赋给其它的函数或者变量(兼容性)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>案例实操</strong></p>
<ol>
<li><p>Unit 类型用来标识过程，也就是没有明确返回值的函数。</p>
<p>Unit 类似于 Java 里的 void。Unit只有一个实例————()，这个实例也没有实质意义</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayOk</span> </span>: <span class="hljs-type">Unit</span> = &#123;&#125;<br>    println(sayOk)<br>&#125;<br><br><span class="hljs-comment">//输出()</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>Null 类只有一个实例对象，Null 类似于 Java 中的 null 引用。Null 可以赋值给任意引用类型(AnyRef)，但是不能赋值给值类型(AnyVal)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-type">Cat</span>()<br>cat = <span class="hljs-literal">null</span> <span class="hljs-comment">// 正确</span><br><br><span class="hljs-keyword">var</span> n1: <span class="hljs-type">Int</span> = <span class="hljs-literal">null</span> <span class="hljs-comment">// 错误</span><br>println(<span class="hljs-string">&quot;n1: &quot;</span> + n1)<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220918201415881.png" alt="image-20220918201415881"></p>
</li>
<li><p>Nothing，可以作为没有正常返回值的方法的返回类型，非常直观的告诉你这个方法不会正常返回，而且由于 Nothing 是其他任意类型的子类，他还能跟要求返回值的方法兼容。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(): <span class="hljs-type">Nothing</span> = &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>()<br>    &#125;<br>    test()<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-9-类型转换"><a href="#2-9-类型转换" class="headerlink" title="2.9 类型转换"></a>2.9 类型转换</h3><h4 id="2-9-1-数值类型自动转换"><a href="#2-9-1-数值类型自动转换" class="headerlink" title="2.9.1 数值类型自动转换"></a>2.9.1 数值类型自动转换</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220918202357330.png" alt="image-20220918202357330"></p>
<p><strong>基本说明</strong></p>
<ul>
<li><p>自动提升原则：有多种类型的数据混合运算时，系统首先<strong>自动将所有数据转换成精度大的那种数据类型</strong>，然后再进行计算</p>
</li>
<li><p><strong>把精度大的数值类型赋值给精度小的数值类型时，就会报错</strong>，反之就会进行自动类型转换。</p>
</li>
<li><p>Byte，Short和Char不会相互自动转化</p>
</li>
<li><p>Byte，Short和Char三者可以计算，<strong>计算时首先转换为Int类型</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220918202902035.png" alt="image-20220918202902035"></p>
<p><strong>扩展</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 00000000 00000000 00000000 10000010</span><br>    <span class="hljs-keyword">var</span> n: <span class="hljs-type">Int</span> = <span class="hljs-number">130</span> <br>    <span class="hljs-comment">// 10000010</span><br>    <span class="hljs-keyword">var</span> b: <span class="hljs-type">Byte</span> = n.toByte<br>    println(b) <span class="hljs-comment">// -126</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-9-2-强制类型转换"><a href="#2-9-2-强制类型转换" class="headerlink" title="2.9.2 强制类型转换"></a>2.9.2 强制类型转换</h4><p><strong>基本说明</strong></p>
<p>自动类型转换的逆过程，将精度大的数值类型转换为精度小的数值类型。使用时要加上强制转函数，但可能造成精度降低或溢出，格外要注意。</p>
<p><code>var num : Int = 2.7.toInt</code></p>
<p><strong>注意事项</strong></p>
<ul>
<li>将数据由<strong>高精度</strong>转换为<strong>低精度</strong>，就需要使用到强制转换</li>
<li>强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</li>
</ul>
<h4 id="2-9-3-数值类型和String类型间转换"><a href="#2-9-3-数值类型和String类型间转换" class="headerlink" title="2.9.3 数值类型和String类型间转换"></a>2.9.3 数值类型和String类型间转换</h4><p><strong>基本语法</strong></p>
<ul>
<li>基本类型转String类型: 将基本类型的值<code>+&quot;&quot;</code>即可</li>
<li>String类型转基本数值类型: <code>s.toInt, s.toFloat, s.toDouble</code>…</li>
</ul>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><p><strong>大部分与Java相同，仅列举不同之处</strong></p>
<h3 id="3-1-关系-比较-运算符"><a href="#3-1-关系-比较-运算符" class="headerlink" title="3.1 关系(比较)运算符"></a>3.1 关系(比较)运算符</h3><ul>
<li>在 Scala 中，== 是类中定义的方法，其底层调用时，调用的是此类的 equals 方法</li>
<li><p>String 的 equals 方法比较的是两个对象的具体的值。</p>
</li>
<li><p>eq 方法比较的是两个对象的地址，其底层调用的是 Java 中的 == 比较运算符。</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> s1 = <span class="hljs-string">&quot;abc&quot;</span><br>    <span class="hljs-keyword">val</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">&quot;abc&quot;</span>)<br><br>    println(s1 == s2) <span class="hljs-comment">// true</span><br>    println(s1.equals(s2)) <span class="hljs-comment">// true</span><br>    println(s1.eq(s2)) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p>Scala 中没有 ++, — 操作符，可以通过 +=, -= 实现</p>
<h3 id="3-3-三元运算符"><a href="#3-3-三元运算符" class="headerlink" title="3.3 三元运算符"></a>3.3 三元运算符</h3><p>Scala 中没有三元运算符 ?:，可以用if-else实现 <code>val res = if (...) x else y</code></p>
<h3 id="3-4-Scala运算符本质"><a href="#3-4-Scala运算符本质" class="headerlink" title="3.4 Scala运算符本质"></a>3.4 Scala运算符本质</h3><p>Scala中其实是没有运算符的，<strong>所有的运算符都是方法</strong>，任何具有单个参数的方法都可以用作<em>中缀运算符</em>。</p>
<ul>
<li>当调用对象的方法时，<strong>点.</strong>可以省略</li>
<li>如果函数参数只有一个，或者没有参数，<strong>()</strong>可以省略</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 标准的加法运算</span><br>    <span class="hljs-keyword">val</span> i: <span class="hljs-type">Int</span> = <span class="hljs-number">1.</span>+(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 当调用对象的方法时, 点.可以省略</span><br>    <span class="hljs-keyword">val</span> j: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span> + (<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 如果函数参数只有一个, 或者没有参数, ()可以省略</span><br>    <span class="hljs-keyword">val</span> k: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span> + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4. 流程控制"></a>4. 流程控制</h2><h3 id="4-1-if-else"><a href="#4-1-if-else" class="headerlink" title="4.1 if-else"></a>4.1 if-else</h3><p>大部分与Java相同</p>
<p><strong>不同点</strong></p>
<p>Scala中<strong>if-else表达式其实是有返回值的</strong>，具体返回值取决于满足条件的<strong>代码体的最后一行</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    println(<span class="hljs-string">&quot;input age:&quot;</span>)<br>    <span class="hljs-keyword">val</span> age = <span class="hljs-type">StdIn</span>.readInt()<br>	<span class="hljs-comment">// 如果返回值类型不一致，取他们共同的祖先类型</span><br>    <span class="hljs-keyword">val</span> res: <span class="hljs-type">Any</span> = <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) &#123;<br>        <span class="hljs-string">&quot;童年&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span> &amp;&amp; age &lt; <span class="hljs-number">30</span>) &#123;<br>        <span class="hljs-string">&quot;中年&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-number">100</span><br>    &#125;<br>    println(res)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h3><p>Scala中没有Switch，而是使用<strong>模式匹配</strong>处理</p>
<h3 id="4-3-for"><a href="#4-3-for" class="headerlink" title="4.3 for"></a>4.3 for</h3><h4 id="4-3-1-范围数据循环-to"><a href="#4-3-1-范围数据循环-to" class="headerlink" title="4.3.1 范围数据循环(to)"></a>4.3.1 范围数据循环(to)</h4><p><strong>基本语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span>) &#123;<br>    println(i)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>i 表示循环的变量，&lt;- 表示为 i 赋值</li>
<li>i 从 1-3 循环，<strong>前后闭合</strong></li>
</ul>
<h4 id="4-3-2-范围数据循环-until"><a href="#4-3-2-范围数据循环-until" class="headerlink" title="4.3.2 范围数据循环(until)"></a>4.3.2 范围数据循环(until)</h4><p><strong>基本语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> until <span class="hljs-number">3</span>) &#123;<br>    println(i)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>i 从 1-2 循环，<strong>前闭后开</strong></li>
</ul>
<h4 id="4-3-3-循环守卫"><a href="#4-3-3-循环守卫" class="headerlink" title="4.3.3 循环守卫"></a>4.3.3 循环守卫</h4><p><strong>基本语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span> <span class="hljs-keyword">if</span> i != <span class="hljs-number">2</span>) &#123;<br>     println(i)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>循环守卫，即循环保护式(条件判断式、守卫)。<strong>保护式为true才会进入循环体内部</strong></li>
</ul>
<h4 id="4-3-4-循环步长-by"><a href="#4-3-4-循环步长-by" class="headerlink" title="4.3.4 循环步长(by)"></a>4.3.4 循环步长(by)</h4><p><strong>基本语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span> by <span class="hljs-number">3</span>) &#123;<br>    println(i)<br>&#125;<br><span class="hljs-comment">// 1 4 7 10</span><br></code></pre></td></tr></table></figure>
<h4 id="4-3-5-嵌套循环"><a href="#4-3-5-嵌套循环" class="headerlink" title="4.3.5 嵌套循环"></a>4.3.5 嵌套循环</h4><p><strong>基本语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span>; j &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span>) &#123;<br>    println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot; j = &quot;</span> + j)<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">for</span> (j &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span>) &#123;<br>    	println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot; j = &quot;</span> + j)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-3-6-引入变量"><a href="#4-3-6-引入变量" class="headerlink" title="4.3.6 引入变量"></a>4.3.6 引入变量</h4><p><strong>基本语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span>; j = <span class="hljs-number">4</span> - i) &#123;<br>    println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot; j = &quot;</span> + j)<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">var</span> j = <span class="hljs-number">4</span> - i<br>	println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot; j = &quot;</span> + j)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>for推导式一行中由多个表达式时，要加 <code>;</code> 隔断逻辑</p>
</li>
<li><p>for推导式有一个约定，当仅包含单一表达式时使用圆括号，否则一行一个表达式，并用花括号替代</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> &#123;<br>    i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">3</span><br>    j = <span class="hljs-number">4</span> - i<br>&#125; &#123;<br>    println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot; j = &quot;</span> + j)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-3-7-循环返回值"><a href="#4-3-7-循环返回值" class="headerlink" title="4.3.7 循环返回值"></a>4.3.7 循环返回值</h4><p><strong>基本语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> res = <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) <span class="hljs-keyword">yield</span> i<br>println(res)<br><br><span class="hljs-comment">// 打印</span><br><span class="hljs-comment">// Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>将遍历过程中处理的结果返回到一个新的Vector集合，使用yield关键字</strong></li>
<li>开发中很少使用</li>
</ul>
<p><strong>案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> res = <span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) <span class="hljs-keyword">yield</span> &#123;<br>    i * <span class="hljs-number">2</span><br>&#125;<br>println(res)<br><br><span class="hljs-comment">// Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)</span><br></code></pre></td></tr></table></figure>
<h4 id="4-3-8-倒叙打印"><a href="#4-3-8-倒叙打印" class="headerlink" title="4.3.8 倒叙打印"></a>4.3.8 倒叙打印</h4><p><strong>基本语法</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span> reverse) &#123;<br>    println(i)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-4-while、do-while"><a href="#4-4-while、do-while" class="headerlink" title="4.4 while、do..while"></a>4.4 while、do..while</h3><p>和Java相同</p>
<ul>
<li>与for不同，<strong>while没有返回值</strong>，即while语句的结果是<strong>Unit类型()</strong></li>
</ul>
<h3 id="4-5-循环中断"><a href="#4-5-循环中断" class="headerlink" title="4.5 循环中断"></a>4.5 循环中断</h3><p><strong>基本说明</strong></p>
<p>Scala内置控制结构<strong>去掉了break和continue</strong>，是为了更好地适应<code>函数式编程</code>，推荐使用函数式风格解决break和continue的问题。</p>
<p>Scala中使用<strong>breakable</strong>控制结构来实现break和continue功能</p>
<p><strong>案例实操</strong></p>
<ul>
<li><p>异常方式退出循环</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (elem &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) &#123;<br>        println(elem)<br>        <span class="hljs-keyword">if</span> (elem == <span class="hljs-number">5</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span><br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> e: <span class="hljs-type">RuntimeException</span> =&gt; e.printStackTrace()<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>采用Scala自带函数退出循环</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-type">Breaks</span>.breakable &#123;<br>    <span class="hljs-keyword">for</span> (elem &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) &#123;<br>        println(elem)<br>        <span class="hljs-keyword">if</span> (elem == <span class="hljs-number">5</span>) <span class="hljs-type">Breaks</span>.<span class="hljs-keyword">break</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>对break进行省略</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">breakable &#123;<br>    <span class="hljs-keyword">for</span> (elem &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) &#123;<br>        println(elem)<br>        <span class="hljs-keyword">if</span> (elem == <span class="hljs-number">5</span>) <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Big-Data/">Big Data</a>, <a href="/categories/Big-Data/Scala/">Scala</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Scala/">Scala</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/25/Scala-1-概述/"><span>Scala(1) 概述</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/25/Scala-1-概述/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-24T16:16:47.000Z">
          2022-09-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-Scala-概述"><a href="#1-Scala-概述" class="headerlink" title="1. Scala 概述"></a>1. Scala 概述</h2><h3 id="1-1-Scala简介"><a href="#1-1-Scala简介" class="headerlink" title="1.1 Scala简介"></a>1.1 Scala简介</h3><ul>
<li>Scala —— Java++<ul>
<li>Scala基于JVM，和Java完全兼容，同样具有跨平台、可移植性好、方便的垃圾回收等特性</li>
<li>Scala比Java更加面向对象</li>
<li>Scala是一门函数式编程语言</li>
</ul>
</li>
<li><p>Scala更适合大数据的处理</p>
<ul>
<li>Scala对集合类型数据处理有非常好的支持</li>
<li>Spark底层用Scala编写</li>
</ul>
</li>
<li><p>Scala和Java的关系</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917012108881.png" alt="image-20220917012108881"></p>
<h3 id="1-2-Scala环境搭建"><a href="#1-2-Scala环境搭建" class="headerlink" title="1.2 Scala环境搭建"></a>1.2 Scala环境搭建</h3><p><strong>安装步骤</strong></p>
<ol>
<li><p>已安装jdk1.8</p>
</li>
<li><p>下载Scala安装文件scala-2.12.16.zip，<a target="_blank" rel="noopener" href="https://scala-lang.org/download/2.12.16.html">https://scala-lang.org/download/2.12.16.html</a></p>
</li>
<li><p>解压到D:\scala-2.12.16</p>
</li>
<li><p>配置环境变量</p>
<ul>
<li><p>添加SCALA_HOME</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917013802834.png" alt="image-20220917013802834"></p>
</li>
<li><p>Path添加</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917013709138.png" alt="image-20220917013709138"></p>
</li>
</ul>
</li>
</ol>
<p><strong>测试</strong></p>
<p>cmd中使用Scala计算两数之和</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917014028760.png" alt="image-20220917014028760"></p>
<h3 id="1-3-IDEA安装Scala插件"><a href="#1-3-IDEA安装Scala插件" class="headerlink" title="1.3 IDEA安装Scala插件"></a>1.3 IDEA安装Scala插件</h3><p>在插件市场搜索Scala安装</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917014710623.png" alt="image-20220917014710623"></p>
<h3 id="1-4-Hello-World"><a href="#1-4-Hello-World" class="headerlink" title="1.4 Hello World"></a>1.4 Hello World</h3><h4 id="1-4-1-创建项目"><a href="#1-4-1-创建项目" class="headerlink" title="1.4.1 创建项目"></a>1.4.1 创建项目</h4><p><strong>创建Scala项目</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917015254262.png" alt="image-20220917015254262"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917015404188.png" alt="image-20220917015404188"></p>
<p><strong>创建Maven项目</strong></p>
<ol>
<li><p>先正常创建Maven项目即可</p>
</li>
<li><p>默认下，Maven不支持Scala开发，需要引入Scala框架，在项目上点击右键-&gt;Add Framework Support-&gt;选择Scala-&gt;点击OK</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917015942718.png" alt="image-20220917015942718"></p>
</li>
<li><p>创建项目的源文件目录并标记为Sources root</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917020202555.png" alt="image-20220917020202555"></p>
</li>
</ol>
<h4 id="1-4-2-创建包和类"><a href="#1-4-2-创建包和类" class="headerlink" title="1.4.2 创建包和类"></a>1.4.2 创建包和类</h4><p>在scala包下创建包和类</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220917020450212.png" alt="image-20220917020450212"></p>
<h4 id="1-4-3-编写代码"><a href="#1-4-3-编写代码" class="headerlink" title="1.4.3 编写代码"></a>1.4.3 编写代码</h4><p>输入main快速生成main方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出两行hello world</span><br></code></pre></td></tr></table></figure>
<p><code>Java中部分代码也可以在Scala中运行</code></p>
<h3 id="1-5-语法说明"><a href="#1-5-语法说明" class="headerlink" title="1.5 语法说明"></a>1.5 语法说明</h3><h4 id="1-5-1-Hello-World语法说明"><a href="#1-5-1-Hello-World语法说明" class="headerlink" title="1.5.1 Hello World语法说明"></a>1.5.1 Hello World语法说明</h4><p><strong>object</strong>：关键字，声明一个单例对象(伴生对象)</p>
<p><strong>main方法</strong>：从外部可以直接调用执行的方法，定义在object中</p>
<p><strong>定义方法</strong>：<code>def 方法名称(参数名称: 参数类型): 返回值类型 = &#123; 方法体 &#125;</code></p>
<p><strong>[]</strong>：表示泛型(与Java要区分)</p>
<p><strong>Unit</strong>：表示没有返回值(类似Java中的void)</p>
<p>scala中没有public关键字，如果不声明访问权限，那么就是公共的</p>
<h4 id="1-5-2-clss和object说明"><a href="#1-5-2-clss和object说明" class="headerlink" title="1.5.2 clss和object说明"></a>1.5.2 clss和object说明</h4><p>Scala是一个完全面向对象的语言，没有静态语法，为了能模仿静态语法，采用<strong>伴生对象单例</strong>的方式调用方法</p>
<p>Scala无static关键字，由<strong>object实现类似静态方法的功能</strong></p>
<p>class关键字和Java中相同，用来定义一个类</p>
<p>伴生对象与类必须同名且在一个文件中，类可以访问伴生对象所有私有属性</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printInfo</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        println(name + <span class="hljs-string">&quot; &quot;</span> + age + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-type">Student</span>.school)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 引入伴生对象</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> school: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;NJU&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-keyword">val</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-number">20</span>)<br>        <span class="hljs-keyword">val</span> bob = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">23</span>)<br><br>        alice.printInfo()<br>        bob.printInfo()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// alice 20 NJU</span><br><span class="hljs-comment">// bob 23 NJU</span><br></code></pre></td></tr></table></figure>
<h4 id="1-5-3-Scala程序反编译"><a href="#1-5-3-Scala程序反编译" class="headerlink" title="1.5.3 Scala程序反编译"></a>1.5.3 Scala程序反编译</h4><p><strong>Student.class</strong></p>
<p>入口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.whale.scalademo;<br><br><span class="hljs-keyword">import</span> scala.Predef$;<br><span class="hljs-keyword">import</span> scala.reflect.ScalaSignature;<br><br><span class="hljs-meta">@ScalaSignature(bytes = &quot;\006\001\r3Aa\003\007\001&#x27;!A!\004\001B\001B\003%1\004\003\005&#x27;\001\t\005\t\025!\003(\021\025Q\003\001\&quot;\001,\021\025\001\004\001\&quot;\0012\017\025)D\002#\0017\r\025YA\002#\0018\021\025Qc\001\&quot;\0019\021\035IdA1A\005\002iBaa\017\004!\002\023Y\002\&quot;\002\037\007\t\003i$aB*uk\022,g\016\036\006\003\0339\t\021b]2bY\006$W-\\8\013\005=\001\022!B&lt;iC2,&#x27;\&quot;A\t\002\007\r|Wn\001\001\024\005\001!\002CA\013\031\033\0051\&quot;\&quot;A\f\002\013M\034\027\r\\1\n\005e1\&quot;AB!osJ+g-\001\003oC6,\007C\001\017$\035\ti\022\005\005\002\037-5\tqD\003\002!%\0051AH]8pizJ!A\t\f\002\rA\023X\rZ3g\023\t!SE\001\004TiJLgn\032\006\003EY\t1!Y4f!\t)</span>\<span class="hljs-number">002</span>&amp;\<span class="hljs-number">003</span>\<span class="hljs-number">002</span>*-\t\<span class="hljs-number">031</span>\021J\<span class="hljs-number">034</span>;\<span class="hljs-number">002</span>\rqJg.\<span class="hljs-number">033</span>;?)\racf\f\t\<span class="hljs-number">003</span>[\001i\<span class="hljs-number">021</span>\<span class="hljs-number">001</span>\<span class="hljs-number">004</span>\<span class="hljs-number">005</span>\<span class="hljs-number">0065</span>\r\<span class="hljs-number">001</span>\ra\<span class="hljs-number">007</span>\<span class="hljs-number">005</span>\006M\r\<span class="hljs-number">001</span>\raJ\<span class="hljs-number">001</span>\naJLg\<span class="hljs-number">016</span>^%oM&gt;$\022A\r\t\<span class="hljs-number">003</span>+MJ!\<span class="hljs-number">001</span>\<span class="hljs-number">016</span>\f\<span class="hljs-number">003</span>\tUs\<span class="hljs-number">027</span>\<span class="hljs-number">016</span>^\<span class="hljs-number">001</span>\b<span class="hljs-string">&#x27;R,H-\0328u!\tica\005\002\007)Q\ta&#x27;</span>\<span class="hljs-number">001</span>\004tG\<span class="hljs-string">&quot;|w\016\\\013\0027\00591o\0315p_2\004\023\001B7bS:$\&quot;A\r \t\013&#125;R\001\031\001!\002\t\005\024xm\035\t\004+\005[\022B\001\&quot;\027\005\025\t%O]1z\001&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;&#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;<br>    Predef$.MODULE$.println((<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">2</span>))<br>                            .append(<span class="hljs-built_in">this</span>.name)<br>                            .append(<span class="hljs-string">&quot; &quot;</span>)<br>                            .append(<span class="hljs-built_in">this</span>.age)<br>                            .append(<span class="hljs-string">&quot; &quot;</span>)<br>                            .append(Student$.MODULE$.school()).toString());<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">school</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Student$.MODULE$.school();<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] paramArrayOfString)</span> &#123;<br>    Student$.MODULE$.main(paramArrayOfString);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>Student$.class</strong></p>
<p>伴生对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.whale.scalademo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student$</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student$ MODULE$;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String school;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">school</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.school;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">alice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">bob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">23</span>);<br>    alice.printInfo();<br>    bob.printInfo();<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> Student$() &#123;<br>    MODULE$ = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-built_in">this</span>.school = <span class="hljs-string">&quot;NJU&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-6-关联源码"><a href="#1-6-关联源码" class="headerlink" title="1.6 关联源码"></a>1.6 关联源码</h3><ol>
<li><p>官网下载源代码文件scala-2.12.16.tar.gz</p>
</li>
<li><p>拷贝到scala-2.12.16\lib下，并解压为文件夹</p>
</li>
<li>IDEA中选择Attach Sources，选择该文件夹</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220918161000094.png" alt="image-20220918161000094"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Big-Data/">Big Data</a>, <a href="/categories/Big-Data/Scala/">Scala</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Scala/">Scala</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/14/Git基础操作/"><span>Git基础操作</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/14/Git基础操作/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-14T13:22:06.000Z">
          2022-09-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-Git常用命令"><a href="#1-Git常用命令" class="headerlink" title="1. Git常用命令"></a>1. Git常用命令</h2><ul>
<li><p><strong>Git中文件的三种状态</strong></p>
<ul>
<li><p><strong>Modified 已修改</strong></p>
<ul>
<li>修改了文件，但还没保存到数据库中</li>
</ul>
</li>
<li><p><strong>Staged 已暂存</strong></p>
<ul>
<li>对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li>
</ul>
</li>
<li><p><strong>Committed 已提交</strong></p>
<ul>
<li>数据已安全的保存在本地数据库中</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git config —global user.name 用户名</td>
<td>设置用户签名</td>
</tr>
<tr>
<td>git config —global user.email 邮箱</td>
<td>设置用户签名</td>
</tr>
<tr>
<td>git config —list</td>
<td>查看配置</td>
</tr>
<tr>
<td>git init</td>
<td>初始化本地库</td>
</tr>
<tr>
<td>git status</td>
<td>查看本地库状态</td>
</tr>
<tr>
<td>git add 文件名</td>
<td>添加到暂存区</td>
</tr>
<tr>
<td>git commint -m “日志信息” 文件名</td>
<td>提交到本地库</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看版本信息</td>
</tr>
<tr>
<td>git log</td>
<td>查看版本详细信息</td>
</tr>
<tr>
<td>git reset —hard 版本号</td>
<td>版本穿梭</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-Git分支操作"><a href="#2-Git分支操作" class="headerlink" title="2. Git分支操作"></a>2. Git分支操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git branch -d 分支名</td>
<td>删除分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr>
<td>git checkout -b 分支名</td>
<td>创建新分支并立即切换到该分支下</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>把指定的分支合并到当前分支上</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>产生合并冲突<ul>
<li>表现：后面状态为MERGING</li>
<li>原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪个。必须人为决定新代码内容</li>
</ul>
</li>
<li>解决冲突<ul>
<li>编辑有冲突的文件，删除特殊符号，决定要使用的内容</li>
<li>添加到暂存区</li>
<li>执行提交（此处的git commit 不能带文件名）</li>
</ul>
</li>
</ul>
<h2 id="3-GitHub操作"><a href="#3-GitHub操作" class="headerlink" title="3. GitHub操作"></a>3. GitHub操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推送本地分支上的内容到远程仓库</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td>将远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git pull 远程库地址别名 远程分支名</td>
<td>将远程仓库的分支最新内容拉下来后与当前本地分支直接合并</td>
</tr>
<tr>
<td>ssh-keygen -t rsa -C 邮箱</td>
<td>生成SSH-key</td>
</tr>
<tr>
<td>cat id_rsa.pub</td>
<td>查看公钥</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tools/">Tools</a>, <a href="/categories/Tools/Git/">Git</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Git/">Git</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/09/13/Ubuntu-20-04-环境配置/"><span>Ubuntu 20.04 环境配置</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/09/13/Ubuntu-20-04-环境配置/" rel="bookmark">
        <time class="entry-date published" datetime="2022-09-13T13:22:40.000Z">
          2022-09-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>记录一下安装Linux后都要安装哪些软件，方便以后查看</p>
<h2 id="1-安装Ubuntu"><a href="#1-安装Ubuntu" class="headerlink" title="1. 安装Ubuntu"></a>1. 安装Ubuntu</h2><p>虚拟机使用VMware Workstation 16 Player</p>
<p>前往Ubuntu官网下载Ubuntu 20.04的iso文件</p>
<p>根据说明一步步安装即可</p>
<h2 id="2-安装常用软件"><a href="#2-安装常用软件" class="headerlink" title="2. 安装常用软件"></a>2. 安装常用软件</h2><p><strong>vim</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt install vim<br></code></pre></td></tr></table></figure>
<p><strong>jdk</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure>
<p><strong>浏览器无法播放视频</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt install ffmpeg<br></code></pre></td></tr></table></figure>
<p><strong>ide+文本编辑器</strong></p>
<p>使用软件商店安装</p>
<p><strong>maven</strong></p>
<p>从官网下载.tar.gz文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /opt/maven<br>sudo tar zxvf apache-maven-3.8.6-bin.tar.gz -C /opt/maven<br><span class="hljs-built_in">cd</span> /opt/maven<br>sudo <span class="hljs-built_in">mkdir</span> repository<br>sudo <span class="hljs-built_in">chmod</span> 777 repository<br>sudo vim ./apache-maven-3.8.6/conf/settings.xml<br><span class="hljs-comment"># 修改本地仓库地址 + 添加阿里云镜像</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>/opt/maven/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo vim /etc/profile.d/mavenenv.sh<br><span class="hljs-comment"># 添加以下内容</span><br><span class="hljs-built_in">export</span> M2_HOME=/opt/maven/apache-maven-3.8.6<br><span class="hljs-built_in">export</span> MAVEN_HOME=/opt/maven/apache-maven-3.8.6<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$&#123;M2_HOME&#125;</span>/bin:<span class="hljs-variable">$&#123;PATH&#125;</span><br><span class="hljs-comment"># 添加执行权限</span><br>sudo <span class="hljs-built_in">chmod</span> +x /etc/profile.d/mavenenv.sh<br><span class="hljs-comment"># 在bashrc添加加载命令</span><br>sudo vim ~/.bashrc<br><span class="hljs-comment"># 添加以下内容</span><br><span class="hljs-built_in">source</span> /etc/profile.d/mavenenv.sh<br></code></pre></td></tr></table></figure>
<p><strong>redis</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt install redis-server<br>sudo vim /etc/redis/redis.conf<br><span class="hljs-comment"># 设置requirepass, 即密码</span><br>service redis restart<br></code></pre></td></tr></table></figure>
<p><strong>MySQL</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt install mysql-server<br>sudo mysql<br>&gt; ALTER USER <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password by <span class="hljs-string">&#x27;password&#x27;</span><br>&gt; <span class="hljs-built_in">exit</span><br>sudo mysql_secure_installation<br></code></pre></td></tr></table></figure>
<p><strong>gcc</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install build-essential<br></code></pre></td></tr></table></figure>
<p><strong>git</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt install git<br>git config --global user.name <span class="hljs-string">&quot;name&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;email&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><p><strong>mit 6.S081 lab</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu <br><br>git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021<br><span class="hljs-comment"># 应当可以编译并运行xv6（按住Ctrl+a x退出）</span><br><span class="hljs-comment"># in the xv6 directory</span><br>make qemu<br><span class="hljs-comment"># ... lots of output ...</span><br>init: starting sh<br>$<br></code></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux/">Linux</a>, <a href="/categories/Linux/Ubuntu/">Ubuntu</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Linux/">Linux</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/30/Redis-1-数据类型/"><span>Redis(1) 数据类型</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/30/Redis-1-数据类型/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-30T10:25:07.000Z">
          2022-08-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-Redis介绍相关知识"><a href="#1-Redis介绍相关知识" class="headerlink" title="1. Redis介绍相关知识"></a>1. Redis介绍相关知识</h2><p>Redis是单线程+多路IO复用技术</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>
<p>端口号<code>6379</code></p>
<p>默认16个数据库，类似数组下标从0开始，初始默认使用0号库</p>
<p>统一密码管理，所有库同样密码</p>
<h2 id="2-常用五大数据类型"><a href="#2-常用五大数据类型" class="headerlink" title="2. 常用五大数据类型"></a>2. 常用五大数据类型</h2><h3 id="2-1-Redis键-key"><a href="#2-1-Redis键-key" class="headerlink" title="2.1 Redis键(key)"></a>2.1 Redis键(key)</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>keys *</code></td>
<td>查看当前库所有key  (匹配：keys *1)</td>
</tr>
<tr>
<td><code>exists key</code></td>
<td>判断某个key是否存在</td>
</tr>
<tr>
<td><code>type key</code></td>
<td>查看你的key是什么类型</td>
</tr>
<tr>
<td><code>del key</code></td>
<td>删除指定的key数据</td>
</tr>
<tr>
<td><code>unlink key</code></td>
<td>非阻塞删除，只是将键与键空间<strong>断开连接</strong>。真正的删除会在后续异步操作</td>
</tr>
<tr>
<td><code>expire key 10</code></td>
<td>为给定的key设置过期时间10秒钟</td>
</tr>
<tr>
<td><code>ttl key</code></td>
<td>查看还有多少秒过期，-1表示永不过期，-2表示已过期</td>
</tr>
<tr>
<td><code>select &lt;dbid&gt;</code></td>
<td>切换数据库</td>
</tr>
<tr>
<td><code>dbsize</code></td>
<td>查看当前数据库的key的数量</td>
</tr>
<tr>
<td><code>flushdb</code></td>
<td>清空当前库</td>
</tr>
<tr>
<td><code>flushall</code></td>
<td>清空全部库</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-2-Redis字符串-String"><a href="#2-2-Redis字符串-String" class="headerlink" title="2.2 Redis字符串(String)"></a>2.2 Redis字符串(String)</h3><h4 id="2-2-1-简介"><a href="#2-2-1-简介" class="headerlink" title="2.2.1 简介"></a>2.2.1 简介</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是<code>二进制安全的</code>。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<h4 id="2-2-2-常用命令"><a href="#2-2-2-常用命令" class="headerlink" title="2.2.2 常用命令"></a>2.2.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set &lt;key&gt; &lt;value&gt;</code></td>
<td>添加键值对</td>
</tr>
<tr>
<td><code>get &lt;key&gt;</code></td>
<td>查询对应键值</td>
</tr>
<tr>
<td><code>append &lt;key&gt; &lt;value&gt;</code></td>
<td>将给定的<code>&lt;value&gt;</code>追加到原值的末尾</td>
</tr>
<tr>
<td><code>strlen &lt;key&gt;</code></td>
<td>获得值的长度</td>
</tr>
<tr>
<td><code>setnx &lt;key&gt; &lt;value&gt;</code></td>
<td>只有在 key 不存在时  设置 key 的值</td>
</tr>
<tr>
<td><code>incr &lt;key&gt;</code></td>
<td>将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1</td>
</tr>
<tr>
<td><code>decr &lt;key&gt;</code></td>
<td>将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1</td>
</tr>
<tr>
<td><code>incrby/decrby &lt;key&gt; &lt;步长&gt;</code></td>
<td>将 key 中储存的数字值增减。自定义步长</td>
</tr>
<tr>
<td><code>mset &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;</code></td>
<td>同时设置一个或多个 key-value对</td>
</tr>
<tr>
<td><code>mget &lt;key1&gt; &lt;key2&gt; &lt;key3&gt;</code></td>
<td>同时获取一个或多个 value</td>
</tr>
<tr>
<td><code>msetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;</code></td>
<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key <code>都</code>不存在。<strong>原子性，有一个失败则都失败</strong></td>
</tr>
<tr>
<td><code>getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</code></td>
<td>获得值的范围，类似java中的substring，<strong>前包，后包</strong></td>
</tr>
<tr>
<td><code>setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</code></td>
<td>用<code>&lt;value&gt;</code>覆写<code>&lt;key&gt;</code>所储存的字符串值，从<code>&lt;起始位置&gt;</code>开始(<strong>索引从0开始</strong>)。</td>
</tr>
<tr>
<td><code>setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;</code></td>
<td>设置键值的同时，设置过期时间，单位秒</td>
</tr>
<tr>
<td><code>getset &lt;key&gt; &lt;value&gt;</code></td>
<td>以新换旧，设置了新值同时获得旧值</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220831005752139.png" alt="image-20220831005752139"></p>
<blockquote>
<p>*NX: 当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX: 当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX: key的超时秒数</p>
<p>*PX: key的超时毫秒数，与EX互斥</p>
<p>==原子性==</p>
<p>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<p>（1）在单线程中，能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</p>
<p>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p>
<p>Redis单命令的原子性主要得益于Redis的单线程。</p>
</blockquote>
<h4 id="2-2-3-数据结构"><a href="#2-2-3-数据结构" class="headerlink" title="2.2.3 数据结构"></a>2.2.3 数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220831010522193.png" alt="image-20220831010522193"></p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h3 id="2-3-Redis列表-List"><a href="#2-3-Redis列表-List" class="headerlink" title="2.3 Redis列表(List)"></a>2.3 Redis列表(List)</h3><h4 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901100702152.png" alt="image-20220901100702152"></p>
<h4 id="2-3-2-常用命令"><a href="#2-3-2-常用命令" class="headerlink" title="2.3.2 常用命令"></a>2.3.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt; &lt;value3&gt; ....</code></td>
<td>从左边/右边插入一个或多个值</td>
</tr>
<tr>
<td><code>lpop/rpop &lt;key&gt;</code></td>
<td>从左边/右边吐出一个值。值在键在，值光键亡</td>
</tr>
<tr>
<td><code>rpoplpush &lt;key1&gt; &lt;key2&gt;</code></td>
<td>从<code>&lt;key1&gt;</code>列表右边吐出一个值，插到<code>&lt;key2&gt;</code>列表左边</td>
</tr>
<tr>
<td><code>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code></td>
<td>按照索引下标获得元素(从左到右)，0左边第一个，-1右边第一个，(0 -1表示获取所有)</td>
</tr>
<tr>
<td><code>lindex &lt;key&gt; &lt;index&gt;</code></td>
<td>按照索引下标获得元素(从左到右)</td>
</tr>
<tr>
<td><code>llen &lt;key&gt;</code></td>
<td>获得列表长度</td>
</tr>
<tr>
<td>`linsert <key> before</td>
<td>after <value> <newvalue>`</td>
<td>在<code>&lt;value&gt;</code>的前/后面插入<code>&lt;newvalue&gt;</code></td>
</tr>
<tr>
<td><code>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</code></td>
<td>从左边删除 n 个 value (从左到右)。当n&lt;0时，从右向左</td>
</tr>
<tr>
<td><code>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</code></td>
<td>将列表key下标为index的值替换成value</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-3-3-数据结构"><a href="#2-3-3-数据结构" class="headerlink" title="2.3.3 数据结构"></a>2.3.3 数据结构</h4><p>List的数据结构为快速链表quickList。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是zipList，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901101645368.png" alt="image-20220901101645368"></p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h3 id="2-4-Redis集合-Set"><a href="#2-4-Redis集合-Set" class="headerlink" title="2.4 Redis集合(Set)"></a>2.4 Redis集合(Set)</h3><h4 id="2-4-1-简介"><a href="#2-4-1-简介" class="headerlink" title="2.4.1 简介"></a>2.4.1 简介</h4><p>Redis set对外提供的功能与list类似，是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的<strong>无序集合</strong>。<strong>底层是一个value为null的hash表</strong>，所以添加，删除，查找的<strong>复杂度都是O(1)</strong>。</p>
<h4 id="2-4-2-常用命令"><a href="#2-4-2-常用命令" class="headerlink" title="2.4.2 常用命令"></a>2.4.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; .....</code></td>
<td>将一个或多个元素加入到集合 key 中，已经存在的元素将被忽略</td>
</tr>
<tr>
<td><code>smembers &lt;key&gt;</code></td>
<td>取出该集合的所有值</td>
</tr>
<tr>
<td><code>sismember &lt;key&gt; &lt;value&gt;</code></td>
<td>判断集合<code>&lt;key&gt;</code>是否为含有该<code>&lt;value&gt;</code>值，有1，没有0</td>
</tr>
<tr>
<td><code>scard &lt;key&gt;</code></td>
<td>返回该集合的元素个数</td>
</tr>
<tr>
<td><code>srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ....</code></td>
<td>删除集合中的某个元素</td>
</tr>
<tr>
<td><code>spop &lt;key&gt;</code></td>
<td><strong>随机从该集合中吐出一个值</strong></td>
</tr>
<tr>
<td><code>srandmember &lt;key&gt; &lt;n&gt;</code></td>
<td>随机从该集合中取出n个值。不会从集合中删除</td>
</tr>
<tr>
<td><code>smove &lt;source&gt; &lt;destination&gt; &lt;value&gt;</code></td>
<td>把集合中一个值从一个集合移动到另一个集合</td>
</tr>
<tr>
<td><code>sinter &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的交集元素</td>
</tr>
<tr>
<td><code>sunion &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的并集元素</td>
</tr>
<tr>
<td><code>sdiff &lt;key1&gt; &lt;key2&gt;</code></td>
<td>返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-4-3-数据结构"><a href="#2-4-3-数据结构" class="headerlink" title="2.4.3 数据结构"></a>2.4.3 数据结构</h4><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h3 id="2-5-Redis哈希-Hash"><a href="#2-5-Redis哈希-Hash" class="headerlink" title="2.5 Redis哈希(Hash)"></a>2.5 Redis哈希(Hash)</h3><h4 id="2-5-1-简介"><a href="#2-5-1-简介" class="headerlink" title="2.5.1 简介"></a>2.5.1 简介</h4><p>Redis hash是一个键值对集合。是一个string类型的field和value的映射表，特别适合用于存储对象。</p>
<p>类似Java里面的Map<String,Object></p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901104741224.png" alt="image-20220901104741224"></p>
<p>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901104754643.png" alt="image-20220901104754643"></p>
<p>用户ID数据冗余</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220901104806546.png" alt="image-20220901104806546"></p>
<p>通过 <code>key(用户ID) + field(属性标签)</code> 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p>
<h4 id="2-5-2-常用命令"><a href="#2-5-2-常用命令" class="headerlink" title="2.5.2 常用命令"></a>2.5.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></td>
<td>给<code>&lt;key&gt;</code>集合中的<code>&lt;field&gt;</code>键赋值<code>&lt;value&gt;</code></td>
</tr>
<tr>
<td><code>hget &lt;key&gt; &lt;field&gt;</code></td>
<td>从<code>&lt;key&gt;</code>集合<code>&lt;field&gt;</code>取出value</td>
</tr>
<tr>
<td><code>hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt; ...</code></td>
<td>批量设置hash的值</td>
</tr>
<tr>
<td><code>hexists &lt;key&gt; &lt;field&gt;</code></td>
<td>查看哈希表 key 中，给定域 field 是否存在</td>
</tr>
<tr>
<td><code>hkeys &lt;key&gt;</code></td>
<td>列出该hash集合的所有field</td>
</tr>
<tr>
<td><code>hvals &lt;key&gt;</code></td>
<td>列出该hash集合的所有value</td>
</tr>
<tr>
<td><code>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</code></td>
<td>为哈希表 key 中的域 field 的值加上增量</td>
</tr>
<tr>
<td><code>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></td>
<td>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-5-3-数据结构"><a href="#2-5-3-数据结构" class="headerlink" title="2.5.3 数据结构"></a>2.5.3 数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h3 id="2-6-Redis有序集合-Zset"><a href="#2-6-Redis有序集合-Zset" class="headerlink" title="2.6 Redis有序集合(Zset)"></a>2.6 Redis有序集合(Zset)</h3><h4 id="2-6-1-简介"><a href="#2-6-1-简介" class="headerlink" title="2.6.1 简介"></a>2.6.1 简介</h4><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个<strong>评分(score)</strong>，集合中的成员按照最低分到最高分的方式排序。集合的成员是唯一的，但是评分可以是重复的。</p>
<p>因为元素是有序的, 所以可以根据评分(score)或者次序(position)来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的，因此可以使用zset作为一个没有重复成员的智能列表。</p>
<h4 id="2-6-2-常用命令"><a href="#2-6-2-常用命令" class="headerlink" title="2.6.2 常用命令"></a>2.6.2 常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;</code></td>
<td>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</td>
</tr>
<tr>
<td><code>zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [WITHSCORES]</code></td>
<td>返回有序集 key 中，下标在\<start>\<stop>之间的元素。带 WITHSCORES，可以让分数一起和值返回到结果集。</td>
</tr>
<tr>
<td><code>zrangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt; [WITHSCORES] [limit offset count]</code></td>
<td>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于min或max)的成员。有序集成员按 score 值递增(从小到大)次序排列。</td>
</tr>
<tr>
<td><code>zrevrangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt; [withscores] [limit offset count]</code></td>
<td>同上，改为从大到小排列。</td>
</tr>
<tr>
<td><code>zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</code></td>
<td>为元素的score加上增量</td>
</tr>
<tr>
<td><code>zrem &lt;key&gt; &lt;value&gt;</code></td>
<td>删除该集合下，指定值的元素</td>
</tr>
<tr>
<td><code>zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</code></td>
<td>统计该集合，分数区间内的元素个数</td>
</tr>
<tr>
<td><code>zrank &lt;key&gt; &lt;value&gt;</code></td>
<td>返回该值在集合中的排名，从0开始</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-6-3-数据结构"><a href="#2-6-3-数据结构" class="headerlink" title="2.6.3 数据结构"></a>2.6.3 数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map<String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<ul>
<li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li>
</ul>
<h4 id="2-6-4-跳跃表-跳表"><a href="#2-6-4-跳跃表-跳表" class="headerlink" title="2.6.4 跳跃表(跳表)"></a>2.6.4 跳跃表(跳表)</h4><ol>
<li><p>简介</p>
<p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p>跳跃表是一种随机化的数据结构，就是一种可以进行二分查找的有序链表，<strong>为每个节点随机出一个层数(level)</strong></p>
</li>
<li><p>对比有序链表和跳跃表，从链表中查询出51</p>
</li>
</ol>
<ul>
<li><p>有序链表</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914154523960.png" alt="image-20220914154523960"></p>
<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
</li>
<li><p>跳跃表</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914154608149.png" alt="image-20220914154608149"></p>
<p>从第2层开始，1节点比51节点小，向后比较。21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层。</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
</li>
</ul>
<h2 id="3-Redis配置文件介绍"><a href="#3-Redis配置文件介绍" class="headerlink" title="3. Redis配置文件介绍"></a>3. Redis配置文件介绍</h2><p>文件 /etc/redis/redis.conf</p>
<h3 id="3-1-NETWORK"><a href="#3-1-NETWORK" class="headerlink" title="3.1 NETWORK"></a>3.1 NETWORK</h3><p><strong>bind</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914193301605.png" alt="image-20220914193301605"></p>
<p>默认情况bind=127.0.0.1只能接受本机的访问请求</p>
<p>不写的情况下，接受任何ip地址的访问</p>
<p><strong>protected-mode</strong></p>
<p>设置本机访问保护模式</p>
<p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</p>
<p><strong>port</strong></p>
<p>端口号，默认6379</p>
<p><strong>tcp-backlog</strong></p>
<p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p>
<p><strong>timeout</strong></p>
<p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即<code>永不关闭</code>。</p>
<p><strong>tcp-keepalive</strong></p>
<p>对访问客户端的一种<code>心跳检测</code>，每n秒检测一次。</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</p>
<h3 id="3-2-GENERAL"><a href="#3-2-GENERAL" class="headerlink" title="3.2 GENERAL"></a>3.2 GENERAL</h3><p><strong>daemonize</strong></p>
<p>是否为后台进程，设置为yes</p>
<p><strong>profile</strong></p>
<p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<p><strong>loglevel</strong></p>
<p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<code>notice</code></p>
<p>四个级别根据使用阶段来选择，生产环境选择notice或者warning</p>
<p><strong>logfile</strong></p>
<p>日志文件名称</p>
<p><strong>databases</strong></p>
<p>设定库的数量，默认16个，默认数据库为0，可以使用SELECT \<dbid>命令在连接上指定数据库id</p>
<h3 id="3-3-SECURITY"><a href="#3-3-SECURITY" class="headerlink" title="3.3 SECURITY"></a>3.3 SECURITY</h3><p><strong>requirepass</strong></p>
<p>设置密码，进入redis时通过<code>auth &lt;pass&gt;</code>来使用</p>
<p>在命令中设置密码，只是临时的，永久设置需要在配置文件中进行设置</p>
<h3 id="3-4-CLIENTS"><a href="#3-4-CLIENTS" class="headerlink" title="3.4 CLIENTS"></a>3.4 CLIENTS</h3><p><strong>maxclients</strong></p>
<p>设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。</p>
<p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<h3 id="3-5-MEMORY-MANAGEMENT"><a href="#3-5-MEMORY-MANAGEMENT" class="headerlink" title="3.5 MEMORY MANAGEMENT"></a>3.5 MEMORY MANAGEMENT</h3><p><strong>maxmemory</strong></p>
<p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</p>
<p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<p><strong>maxmemory-policy</strong></p>
<ul>
<li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</li>
<li>allkeys-lru：在所有集合key中，使用LRU算法移除key</li>
<li>volatile-lfu：使用LFU算法移除key，只对设置了过期时间的键；（最近最不常使用）</li>
<li>allkeys-lfu：在所有集合key中，使用LFU算法移除key</li>
<li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li>
<li>allkeys-random：在所有集合key中，移除随机的key</li>
<li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li>
<li>noeviction：不进行移除。针对写操作，只是返回错误信息</li>
</ul>
<p><strong>maxmemory-samples</strong></p>
<p>设置样本数量，LRU,LFU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个</p>
<p>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小</p>
<h2 id="4-Redis的发布和订阅"><a href="#4-Redis的发布和订阅" class="headerlink" title="4. Redis的发布和订阅"></a>4. Redis的发布和订阅</h2><h3 id="4-1-什么是发布和订阅"><a href="#4-1-什么是发布和订阅" class="headerlink" title="4.1 什么是发布和订阅"></a>4.1 什么是发布和订阅</h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h3 id="4-2-Redis的发布和订阅"><a href="#4-2-Redis的发布和订阅" class="headerlink" title="4.2 Redis的发布和订阅"></a>4.2 Redis的发布和订阅</h3><p>客户端可以订阅频道如下图</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200344453.png" alt="image-20220914200344453"></p>
<p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200349203.png" alt="image-20220914200349203"></p>
<h3 id="4-3-发布订阅命令行实现"><a href="#4-3-发布订阅命令行实现" class="headerlink" title="4.3 发布订阅命令行实现"></a>4.3 发布订阅命令行实现</h3><ol>
<li>打开一个客户端订阅channel1</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200539836.png" alt="image-20220914200539836"></p>
<ol>
<li>打开另一个客户端，给channel1发布消息hello</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200723253.png" alt="image-20220914200723253"></p>
<ol>
<li>第一个客户端接收到消息</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914200738291.png" alt="image-20220914200738291"></p>
<h2 id="5-Redis新数据类型"><a href="#5-Redis新数据类型" class="headerlink" title="5. Redis新数据类型"></a>5. Redis新数据类型</h2><h3 id="5-1-Bitmaps"><a href="#5-1-Bitmaps" class="headerlink" title="5.1 Bitmaps"></a>5.1 Bitmaps</h3><h4 id="5-1-1-简介"><a href="#5-1-1-简介" class="headerlink" title="5.1.1 简介"></a>5.1.1 简介</h4><p>Redis提供了Bitmaps以实现对位的操作</p>
<ul>
<li><p>Bitmaps本身不是一种数据类型，实际上它就是字符串（key-value），但是它可以对字符串的位进行操作。</p>
</li>
<li><p>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914203611578.png" alt="image-20220914203611578"></p>
<h4 id="5-1-2-命令"><a href="#5-1-2-命令" class="headerlink" title="5.1.2 命令"></a>5.1.2 命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</code></td>
<td>设置Bitmaps中某个偏移量的值(0或1)</td>
</tr>
<tr>
<td><code>getbit &lt;key&gt; &lt;offset&gt;</code></td>
<td>获取Bitmaps中某个偏移量的值</td>
</tr>
<tr>
<td><code>bitcount &lt;key&gt; [start end]</code></td>
<td>统计字符串从start字节到end字节比特值为1的数量，可以使用负数值：比如 -1 表示最后一个字节，而 -2 表示倒数第二个字节</td>
</tr>
<tr>
<td><code>bitop and(or/not/xor) &lt;destkey&gt; [key…]</code></td>
<td>bitop是一个复合操作，它可以做多个Bitmaps的and(交集)、or(并集)、not(非)、xor(异或)操作并将结果保存在destkey中。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-2-HyperLogLog"><a href="#5-2-HyperLogLog" class="headerlink" title="5.2 HyperLogLog"></a>5.2 HyperLogLog</h3><h4 id="5-2-1-简介"><a href="#5-2-1-简介" class="headerlink" title="5.2.1 简介"></a>5.2.1 简介</h4><p>求集合中不重复元素个数的问题称为基数问题。</p>
<p>Redis HyperLogLog就是用来做基数统计的算法，HyperLogLog的优点是在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<h4 id="5-2-2-命令"><a href="#5-2-2-命令" class="headerlink" title="5.2.2 命令"></a>5.2.2 命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pfadd &lt;key&gt; &lt;element&gt; [element ...]</code></td>
<td>添加指定元素到 HyperLogLog 中</td>
</tr>
<tr>
<td><code>pfcount &lt;key&gt; [key ...]</code></td>
<td>计算HLL的近似基数，可以计算多个HLL</td>
</tr>
<tr>
<td><code>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey ...]</code></td>
<td>将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-3-Geospatial"><a href="#5-3-Geospatial" class="headerlink" title="5.3 Geospatial"></a>5.3 Geospatial</h3><h4 id="5-3-1-简介"><a href="#5-3-1-简介" class="headerlink" title="5.3.1 简介"></a>5.3.1 简介</h4><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h4 id="5-3-2-命令"><a href="#5-3-2-命令" class="headerlink" title="5.3.2 命令"></a>5.3.2 命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt; [longitude latitude member...]</code></td>
<td>添加地理位置(经度，纬度，名称)</td>
</tr>
<tr>
<td><code>geopos &lt;key&gt; &lt;member&gt; [member...]</code></td>
<td>获得指定地区的坐标值</td>
</tr>
<tr>
<td>`geodist <key> <member1> <member2> [m</td>
<td>km</td>
<td>ft</td>
<td>mi]`</td>
<td>获取两个位置之间的直线距离,mi-英里,ft-英尺。默认使用m</td>
</tr>
<tr>
<td>`georadius <key> <longitude> <latitude> radius [m</td>
<td>km</td>
<td>ft</td>
<td>mi]`</td>
<td>以给定的经纬度为中心，找出某一半径内的元素</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6. Jedis"></a>6. Jedis</h2><ul>
<li>引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>注意事项</p>
<p>禁用Linux的防火墙，redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</p>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.231.131&quot;</span>,<span class="hljs-number">6379</span>);<br>        jedis.auth(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pong</span> <span class="hljs-operator">=</span> jedis.ping();<br>        System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span>+pong);<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>简单使用</p>
<ul>
<li><p>key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>System.out.println(keys.size());<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));                <br>System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br></code></pre></td></tr></table></figure></li>
<li><p>string</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br>jedis.incr(<span class="hljs-string">&quot;str1&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>list</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order01&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order03&quot;</span>);<br>Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;orders&quot;</span>);<br>jedis.srem(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>hash</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,String&gt;();<br>map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>map.put(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;abc@163.com&quot;</span>);<br>jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>zset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">90d</span>, <span class="hljs-string">&quot;l4&quot;</span>);<br> <br>Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="7-SpringBoot整合Redis"><a href="#7-SpringBoot整合Redis" class="headerlink" title="7. SpringBoot整合Redis"></a>7. SpringBoot整合Redis</h2><ul>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.231</span><span class="hljs-number">.131</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">password</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">18000000</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-comment"># 连接池最大连接数(负值表示没有限制)</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 最大阻塞等待时间(负数表示没有限制)</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-comment"># 连接池中的最大空闲连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-comment"># 连接池中的最小空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        <span class="hljs-comment">// 1.创建 redisTemplate 模版</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 2.关联 redisConnectionFactory</span><br>        template.setConnectionFactory(factory);<br>        <span class="hljs-comment">// 3.创建 序列化类</span><br>        <span class="hljs-type">GenericToStringSerializer</span> <span class="hljs-variable">genericToStringSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericToStringSerializer</span>(Object.class);<br>        <span class="hljs-comment">// 6.序列化类，对象映射设置</span><br>        <span class="hljs-comment">// 7.设置 value 的转化格式和 key 的转化格式</span><br>        template.setValueSerializer(genericToStringSerializer);<br>        template.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        template.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/redisTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTestController</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置值到redis</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>        <span class="hljs-comment">//从redis获取值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String)redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Backend/">Backend</a>, <a href="/categories/Backend/Redis/">Redis</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Redis/">Redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/11/SpringCloud-1/"><span>SpringCloud(1) 服务注册中心</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/11/SpringCloud-1/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-11T06:49:33.000Z">
          2022-08-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h1><h2 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1 Eureka"></a>1 Eureka</h2><h3 id="1-1-Eureka基础知识"><a href="#1-1-Eureka基础知识" class="headerlink" title="1.1 Eureka基础知识"></a>1.1 Eureka基础知识</h3><ul>
<li>什么是服务治理<ul>
<li>Spring Cloud封装了Netflix公司开发的Eureka模块来实现服务治理</li>
<li>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</li>
</ul>
</li>
<li>什么是服务注册与发现<ul>
<li>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到Eureka Sever并维持心跳连接。这样系统的维护人员就可以通过Euleka Server来监控系统中各个微服务是否正常运行。</li>
<li>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者|服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))</li>
</ul>
</li>
<li>包含两个组件<ul>
<li>Eureka Server提供服务注册服务<ul>
<li>各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</li>
</ul>
</li>
<li>Eureka Client通过注册中心进行访问<ul>
<li>是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳, Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-Eureka-Server端配置"><a href="#1-2-Eureka-Server端配置" class="headerlink" title="1.2 Eureka Server端配置"></a>1.2 Eureka Server端配置</h3><ol>
<li><p>创建工程 cloud-eureka-server7001</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span>  <span class="hljs-comment"># eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment"># false表示不向注册中心注册自己</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaMain7001</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaMain7001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试运行<code>EurekaMain7001</code>，浏览器输入<code>http://localhost:7001/</code>回车，会查看到Spring Eureka服务主页。</p>
</li>
</ol>
<h3 id="1-3-Eureka-Client端配置"><a href="#1-3-Eureka-Client端配置" class="headerlink" title="1.3 Eureka Client端配置"></a>1.3 Eureka Client端配置</h3><ol>
<li><p>修改工程 cloud-provider-payment8001</p>
</li>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br>  <br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span><br>    <br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment"># 表示是否将自己注册进EurekaServer 默认为true</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 是否从EurekaServer抓取已有的注册信息, 默认为true。单点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentMain8001</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(PaymentMain8001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<ul>
<li><p>启动cloud-provider-payment8001和cloud-eureka-server7001工程。</p>
</li>
<li><p>浏览器输入 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001/</a> 主页内的<strong>Instances currently registered with Eureka</strong>会显示cloud-provider-payment8001的配置文件application.yml设置的应用名<strong>cloud-payment-service</strong></p>
</li>
</ul>
</li>
<li><p>自我保护机制</p>
<blockquote>
<p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.</p>
<p>紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。</p>
</blockquote>
</li>
</ol>
<h3 id="1-4-Eureka集群原理说明"><a href="#1-4-Eureka集群原理说明" class="headerlink" title="1.4 Eureka集群原理说明"></a>1.4 Eureka集群原理说明</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220727165105034.png" alt="image-20220727165105034"></p>
<ul>
<li>问题：微服务RPC远程服务调用最核心的是什么<ul>
<li>高可用，试想你的注册中心只有一个，万一它出故障了，会导致整个微服务环境不可用。</li>
</ul>
</li>
<li>解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错。<ul>
<li><strong>互相注册，相互守望</strong>。</li>
</ul>
</li>
</ul>
<h3 id="1-5-Eureka集群环境构建"><a href="#1-5-Eureka集群环境构建" class="headerlink" title="1.5 Eureka集群环境构建"></a>1.5 Eureka集群环境构建</h3><ul>
<li><p>创建cloud-eureka-server7002工程，参考<strong>1.1.2</strong></p>
</li>
<li><p>找到C:\Windows\System32\drivers\etc路径下的hosts文件，修改映射配置添加进hosts文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">127.0.0.1 eureka7001.com<br>127.0.0.1 eureka7002.com<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改cloud-eureka-server7001配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span> <span class="hljs-comment">#eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment">#false表示不向注册中心注册自己。</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>     <span class="hljs-comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br>    <span class="hljs-attr">service-url:</span><br>    <span class="hljs-comment">#集群指向其它eureka</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/</span><br>    <span class="hljs-comment">#单机就是7001自己</span><br>      <span class="hljs-comment">#defaultZone: http://eureka7001.com:7001/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>修改cloud-eureka-server7002配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7002</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7002.com</span>  <span class="hljs-comment"># eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment"># false表示不向注册中心注册自己</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>启动服务，访问eureka7001.com:7001与eureka7002.com:7002</p>
</li>
</ul>
<h3 id="1-6-将微服务注册进Eureka集群"><a href="#1-6-将微服务注册进Eureka集群" class="headerlink" title="1.6 将微服务注册进Eureka集群"></a>1.6 将微服务注册进Eureka集群</h3><ul>
<li><p>修改微服务application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment">#表示是否将自己注册进Eurekaserver默认为true。</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span><br>    <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka,</span> <span class="hljs-string">http://eureka7002.com:7002/eureka</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-7-支付微服务集群配置"><a href="#1-7-支付微服务集群配置" class="headerlink" title="1.7 支付微服务集群配置"></a>1.7 支付微服务集群配置</h3><ul>
<li><p>构建cloud-provider-payment8002工程，参考cloud-provider-payment8001 (<strong>1.1.3</strong>)</p>
</li>
<li><p>修改8001/8002的Controller，添加serverPort</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentController</span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String serverPort;<span class="hljs-comment">//添加serverPort</span><br><br>    <span class="hljs-meta">@PostMapping(value = &quot;/payment/create&quot;)</span><br>    <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Payment payment)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> paymentService.create(payment);<br>        log.info(<span class="hljs-string">&quot;*****插入结果：&quot;</span> + result);<br><br>        <span class="hljs-keyword">if</span>(result &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;插入数据库成功,serverPort: &quot;</span> + serverPort, result);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-number">444</span>, <span class="hljs-string">&quot;插入数据库失败&quot;</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>负载均衡</strong></p>
<ul>
<li><p>cloud-consumer-order80订单服务访问地址不能写死</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-comment">//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PAYMENT_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>; <span class="hljs-comment">//Eureka注册的服务名</span><br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContextConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">getRestTemplate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>测试</p>
<ul>
<li><p>先要启动EurekaServer，7001/7002服务</p>
</li>
<li><p>再要启动服务提供者provider，8001/8002服务</p>
</li>
<li><p>浏览器输入 - <a target="_blank" rel="noopener" href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a></p>
</li>
<li><p><strong>结果：负载均衡效果达到，8001/8002端口交替出现</strong></p>
<p>Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能。</p>
</li>
<li><p><strong>相互注册，相互守望</strong></p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220727165120848.png" alt="image-20220727165120848"></p>
</li>
</ul>
<h3 id="1-8-actuator微服务信息完善"><a href="#1-8-actuator微服务信息完善" class="headerlink" title="1.8 actuator微服务信息完善"></a>1.8 actuator微服务信息完善</h3><ul>
<li><p>主机名称：服务名称修改(也就是将IP地址，换成可读性高的名字)</p>
<ul>
<li><p>修改cloud-provider-payment8001，cloud-provider-payment8002的YML - eureka.instance.instance-id</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span> <span class="hljs-comment">#添加此处</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8002</span> <span class="hljs-comment">#添加此处</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>修改之后eureka主页将显示payment8001，payment8002代替原来显示的IP地址。</p>
</li>
</ul>
</li>
<li><p>访问信息有IP信息提示，(就是将鼠标指针移至payment8001，payment8002名下，会有IP地址提示)</p>
<ul>
<li><p>修改部分 - YML - eureka.instance.prefer-ip-address</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span> <br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#添加此处</span><br>    <br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8002</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#添加此处</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1-9-服务发现Discovery"><a href="#1-9-服务发现Discovery" class="headerlink" title="1.9 服务发现Discovery"></a>1.9 服务发现Discovery</h3><p>对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息</p>
<ul>
<li><p>修改cloud-provider-payment8001的Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentController</span>&#123;<br>	...<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><br>    ...<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">discovery</span><span class="hljs-params">()</span><br>    &#123;<br>        List&lt;String&gt; services = discoveryClient.getServices();<br>        <span class="hljs-keyword">for</span> (String element : services) &#123;<br>            log.info(<span class="hljs-string">&quot;*****element: &quot;</span>+element);<br>        &#125;<br><br>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);<br>        <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;<br>            log.info(instance.getServiceId()+<span class="hljs-string">&quot;\t&quot;</span>+instance.getHost()+<span class="hljs-string">&quot;\t&quot;</span>+instance.getPort()+<span class="hljs-string">&quot;\t&quot;</span>+instance.getUri());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.discoveryClient;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>8001主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-comment">//添加该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentMain001</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(PaymentMain001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>自测</p>
<ul>
<li>浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8001/payment/discovery">http://localhost:8001/payment/discovery</a></li>
</ul>
</li>
</ul>
<h3 id="1-10-Eureka自我保护"><a href="#1-10-Eureka自我保护" class="headerlink" title="1.10 Eureka自我保护"></a>1.10 Eureka自我保护</h3><ul>
<li><p><strong>概述</strong></p>
<ul>
<li><p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</p>
</li>
<li><p>如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式:</p>
<blockquote>
<p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THANTHRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUSTTO BE SAFE</p>
</blockquote>
</li>
<li><p>一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。</p>
</li>
<li><p>属于CAP里面的AP分支。</p>
</li>
</ul>
</li>
<li><p><strong>为什么会产生Eureka自我保护机制?</strong></p>
<ul>
<li>为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除</li>
</ul>
</li>
<li><strong>什么是自我保护模式?</strong><ul>
<li>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。</li>
<li><strong>在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例</strong>。</li>
<li>它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：<strong>好死不如赖活着</strong>。</li>
<li>综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务(健康的微服务和不健康的微服务都会保留)也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</li>
</ul>
</li>
</ul>
<h3 id="1-11-禁止Eureka自我保护"><a href="#1-11-禁止Eureka自我保护" class="headerlink" title="1.11 禁止Eureka自我保护"></a>1.11 禁止Eureka自我保护</h3><ul>
<li><p>在eurekaServer端7001处设置关闭自我保护机制</p>
</li>
<li><p>默认自我保护机制是开启的，使用<code>eureka.server.enable-self-preservation = false</code>可以禁用自我保护模式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-comment">#关闭自我保护机制，保证不可用服务被及时踢除</span><br>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>关闭效果：</p>
<ul>
<li><p>spring-eureka主页会显示出一句：</p>
<blockquote>
<p>THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>生产者客户端eureakeClient端8001</p>
<ul>
<li><p>默认</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">eureka.instance.lease-renewal-interval-in-seconds=30</span><br><span class="hljs-string">eureka.instance.lease-expiration-duration-in-seconds=90</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>修改为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#心跳检测与续约时间</span><br>    <span class="hljs-comment">#开发时没置小些，保证服务关闭后注册中心能即使剔除服务</span><br>    <span class="hljs-comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span><br>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment">#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务</span><br>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>测试</p>
<ul>
<li>7001和8001都配置完成</li>
<li>先启动7001再启动8001</li>
<li>先关闭8001，马上就被删除了</li>
</ul>
</li>
</ul>
<h2 id="2-Zookeeper"><a href="#2-Zookeeper" class="headerlink" title="2 Zookeeper"></a>2 Zookeeper</h2><h2 id="3-Consul"><a href="#3-Consul" class="headerlink" title="3 Consul"></a>3 Consul</h2><h2 id="4-Nacos"><a href="#4-Nacos" class="headerlink" title="4 Nacos"></a>4 Nacos</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Backend/">Backend</a>, <a href="/categories/Backend/SpringCloud/">SpringCloud</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SpringCloud/">SpringCloud</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/7/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/9/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Whale
    
  </p>
</footer>
    
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>