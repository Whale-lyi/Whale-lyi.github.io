<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="码农预备役">
<meta property="og:type" content="website">
<meta property="og:title" content="Whale&#39;s Blog">
<meta property="og:url" content="https://whale-lyi.github.io/page/2/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="码农预备役">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Whale">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://whale-lyi.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/29/JUC-5-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/29/JUC-5-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">JUC(5) 阻塞队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-29 13:48:08 / Modified: 14:34:24" itemprop="dateCreated datePublished" datetime="2023-12-29T13:48:08+08:00">2023-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-阻塞队列"><a href="#1-阻塞队列" class="headerlink" title="1. 阻塞队列"></a>1. 阻塞队列</h2><p>阻塞队列是共享队列（多线程操作），一端输入，一端输出，不能无限放队列，满了之后就会进入阻塞，取出也同理</p>
<ul>
<li>当队列是空的，从队列中获取元素的操作将会被阻塞</li>
<li>当队列是满的，从队列中添加元素的操作将会被阻塞</li>
<li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li>
<li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</li>
</ul>
<h3 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h3><p><code>BlockingQueue</code> 是一个接口</p>
<ul>
<li><p>父接口有：<code>Collection</code>，<code>Iterable</code>，<code>Queue</code></p>
</li>
<li><p>子接口有：<code>BlockingDeque</code>，<code>TransferQueue</code></p>
</li>
<li><p>实现类有：<code>ArrayBlockingQueue</code>，<code>DelayQueue</code>，<code>LinkedBlockingDeque</code>，<code>LinkedBlockingQueue</code>，<code>LinkedTransferQueue</code>，<code>PriorityBlockingQueue</code>，<code>SynchronousQueue</code></p>
</li>
</ul>
<h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><p><code>ArrayBlockingQueue</code> (常用)</p>
<ul>
<li>基于数组的阻塞队列实现, 除了一个定长数组外，<code>ArrayBlockingQueue</code> 内部还保存着两个整形变量，分别标识着队列的 头部和尾部在数组中的位置。</li>
<li><code>ArrayBlockingQueue</code> 在生产者放入数据和消费者获取数据，共用同一个锁对象，两者无法真正并行运行</li>
<li><strong>由数组结构组成的有界阻塞队列</strong></li>
</ul>
<p><code>LinkedBlockingQueue</code> (常用)</p>
<ul>
<li>基于链表的阻塞队列，同 <code>ArrayListBlockingQueue</code> 类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成）</li>
<li>对于生产者端和消费者端分别采用了独立的锁来控制数据同步</li>
<li><strong>由链表结构组成的有界(大小默认值为<code>Integer.MAX_VALUE</code>)阻塞队列</strong></li>
</ul>
<p><code>DelayQueue</code></p>
<ul>
<li><code>DelayQueue</code> 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素</li>
<li><p><code>DelayQueue</code> 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
</li>
<li><p><strong>使用优先级队列实现的延迟无界阻塞队列</strong></p>
</li>
</ul>
<p><code>PriorityBlockingQueue</code></p>
<ul>
<li>基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Comparator 对象来决定）</li>
<li><strong>不会阻塞数据生产者，只会在没有可消费的数据时，阻塞数据的消费者</strong></li>
<li>注意：<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度</strong>，否则时间一长，会最终耗尽所有的可用堆内存空间</li>
<li>内部控制线程同步的锁采用的是<strong>公平锁</strong></li>
<li><strong>支持优先级排序的无界阻塞队列</strong></li>
</ul>
<p><code>SynchronousQueue</code></p>
<ul>
<li>一种无缓冲的等待队列</li>
<li>相对于有缓冲的 <code>BlockingQueue</code> 来说，少了一个中间经销商的环节（缓冲区）</li>
<li><strong>不存储元素的阻塞队列，也即单个元素的队列</strong></li>
<li>声明一个 <code>SynchronousQueue</code> 有两种不同的方式<ul>
<li>公平模式：<code>SynchronousQueue</code> 会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略</li>
<li>非公平模式(默认)：<code>SynchronousQueue</code> 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者<ul>
<li>如果生产者和消费者的处理速度有差距，很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>LinkedTransferQueue</code></p>
<ul>
<li><strong>由链表结构组成的无界阻塞 <code>TransferQueue</code> 队列</strong></li>
<li>相对于其他阻塞队列，<code>LinkedTransferQueue</code> 多了 <code>tryTransfer</code> 和 <code>transfer</code> 方法</li>
<li>采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素 为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时 发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到 该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</li>
</ul>
<p><code>LinkedBlockingDeque</code></p>
<ul>
<li><strong>由链表结构组成的双向阻塞队列</strong></li>
<li>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再将该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异常</li>
<li>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</li>
</ul>
<h2 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2. 核心方法"></a>2. 核心方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(e)</td>
<td>offer()</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291426781.png" alt="image-20231229142616707"></p>
<p><strong>第一种方式：抛出异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueueTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建阻塞队列</span><br>        BlockingQueue&lt;Object&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 当队列中加元素</span><br>        System.out.println(blockingQueue.add(<span class="hljs-string">&quot;a&quot;</span>));<br>        System.out.println(blockingQueue.add(<span class="hljs-string">&quot;b&quot;</span>));<br>        System.out.println(blockingQueue.add(<span class="hljs-string">&quot;c&quot;</span>));<br>        <span class="hljs-comment">// 检查</span><br>        System.out.println(blockingQueue.element());<br>        <span class="hljs-comment">/** 此时输出的结果为</span><br><span class="hljs-comment">         * true</span><br><span class="hljs-comment">         * true</span><br><span class="hljs-comment">         * true</span><br><span class="hljs-comment">         * a</span><br><span class="hljs-comment">         * */</span><br>        System.out.println(blockingQueue.add(<span class="hljs-string">&quot;d&quot;</span>));<br>        <span class="hljs-comment">// 此时再添加元素，会抛出异常:IllegalStateException: Queue full</span><br>        <span class="hljs-comment">// 取出元素</span><br>        System.out.println(blockingQueue.remove());<br>        <span class="hljs-comment">// 检查</span><br>        System.out.println(blockingQueue.element());<br>        <span class="hljs-comment">/** 此时输出的结果为</span><br><span class="hljs-comment">         * true</span><br><span class="hljs-comment">         * true</span><br><span class="hljs-comment">         * true</span><br><span class="hljs-comment">         * a</span><br><span class="hljs-comment">         * a (取出数据)</span><br><span class="hljs-comment">         * b (队首数据)</span><br><span class="hljs-comment">         * */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>第二种方式：布尔值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>));<br><span class="hljs-comment">// 检查元素</span><br>System.out.println(blockingQueue.peek());<br><span class="hljs-comment">// 取出元素,先进先出</span><br>System.out.println(blockingQueue.poll());<br></code></pre></td></tr></table></figure>
<p><strong>第三种方式：阻塞</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.println(blockingQueue.put(<span class="hljs-string">&quot;a&quot;</span>));<br><span class="hljs-comment">// 检查元素</span><br>System.out.println(blockingQueue.element());<br><span class="hljs-comment">// 取出元素,先进先出</span><br>System.out.println(blockingQueue.take());<br></code></pre></td></tr></table></figure>
<p>该方法加入元素或者取出元素，如果满了或者空了，还进行下一步加入或者取出操作，会出现阻塞的状态</p>
<p><strong>第四种方式：超时</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-number">3L</span>, TimeUnit.SECONDS));<br></code></pre></td></tr></table></figure>
<p>该方法满了或者空了在进行会有阻塞，但可以加入参数，超时退出，返回false</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/28/JUC-4-%E8%BE%85%E5%8A%A9%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/28/JUC-4-%E8%BE%85%E5%8A%A9%E7%B1%BB/" class="post-title-link" itemprop="url">JUC(4) 辅助类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-28 22:22:57" itemprop="dateCreated datePublished" datetime="2023-12-28T22:22:57+08:00">2023-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-29 00:26:16" itemprop="dateModified" datetime="2023-12-29T00:26:16+08:00">2023-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-减少计数-CountDownLatch"><a href="#1-减少计数-CountDownLatch" class="headerlink" title="1. 减少计数 CountDownLatch"></a>1. 减少计数 CountDownLatch</h2><p>CountDownLatch 类可以设置一个计数器，然后通过 <code>countDown</code> 方法来进行减 1 的操作，使用 <code>await</code> 方法等待计数器不大于 0，然后继续执行 <code>await</code> 方法之后的语句。</p>
<ul>
<li><code>CountDownLatch</code> 主要有两个方法，当一个或多个线程调用 <code>await</code> 方法时，这些线程会阻塞</li>
<li>其它线程调用 <code>countDown</code> 方法会将计数器减 1 (调用 countDown 方法的线程不会阻塞)</li>
<li>当计数器的值变为 0 时，因 <code>await</code> 方法阻塞的线程会被唤醒，继续执行</li>
</ul>
<blockquote>
<p>案例</p>
<p>6个同学陆续离开教室之后，班长才能锁门。如果不加 CountDownLatch类，会出现线程混乱执行，同学还未离开教室班长就已经锁门了</p>
</blockquote>
<p>不使用CountDownLatch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 创建六个线程，模拟六个学生</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;离开教室&quot;</span>),String.valueOf(i)).start();<br>    &#125;<br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;锁门&quot;</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1离开教室</span><br><span class="hljs-comment">4离开教室</span><br><span class="hljs-comment">2离开教室</span><br><span class="hljs-comment">6离开教室</span><br><span class="hljs-comment">3离开教室</span><br><span class="hljs-comment">main锁门</span><br><span class="hljs-comment">5离开教室</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>使用CountDownLatch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;离开教室&quot;</span>);<br>            <span class="hljs-comment">// 计数 -1</span><br>            countDownLatch.countDown();<br>        &#125;,String.valueOf(i)).start();<br>    &#125;<br>    countDownLatch.await();<br>    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;锁门&quot;</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1离开教室</span><br><span class="hljs-comment">5离开教室</span><br><span class="hljs-comment">4离开教室</span><br><span class="hljs-comment">6离开教室</span><br><span class="hljs-comment">2离开教室</span><br><span class="hljs-comment">3离开教室</span><br><span class="hljs-comment">main锁门</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="2-循环栅栏-CyclicBarrier"><a href="#2-循环栅栏-CyclicBarrier" class="headerlink" title="2. 循环栅栏 CyclicBarrier"></a>2. 循环栅栏 CyclicBarrier</h2><p>CyclicBarrier 是一个同步铺助类，它<strong>允许一组线程互相等待</strong>，直到到达某个公共屏障点(common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环的 barrier。</p>
<p>CyclicBarier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后(但在释放所有线程之前)，该命令只在每个屏障点运行一次。</p>
<ul>
<li>默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 已经到达屏障位置，线程被阻塞。</li>
<li><p>另外一个构造方法 <code>CyclicBarrier(int parties, Runnable barrierAction)</code>，其中 barrierAction 任务会在所有线程到达屏障后执行。</p>
</li>
<li><p><code>await()</code>: 参与者在所有的参与者都已经在此 barrier 上调用 <code>await</code> 方法之前一直等待</p>
</li>
</ul>
<blockquote>
<p>案例</p>
<p>集齐7颗龙珠就可以召唤神龙</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrirtTest</span> &#123;<br>    <span class="hljs-comment">// 创建固定值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER</span>  <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。</span><br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(NUMBER, () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;****集齐7颗龙珠就可以召唤神龙&quot;</span>);<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;星龙被收集到了&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 计数 +1</span><br>                    cyclicBarrier.await();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1星龙被收集到了</span><br><span class="hljs-comment">4星龙被收集到了</span><br><span class="hljs-comment">5星龙被收集到了</span><br><span class="hljs-comment">3星龙被收集到了</span><br><span class="hljs-comment">2星龙被收集到了</span><br><span class="hljs-comment">6星龙被收集到了</span><br><span class="hljs-comment">7星龙被收集到了</span><br><span class="hljs-comment">****集齐7颗龙珠就可以召唤神龙</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="3-信号量-Semaphore"><a href="#3-信号量-Semaphore" class="headerlink" title="3. 信号量 Semaphore"></a>3. 信号量 Semaphore</h2><p>一个计数信号量，从概念上讲，信号量维护了一个许可集，如有必要，在许可可用前会阻塞每一个 <code>acquire()</code>，然后再获取该许可。每个 <code>release()</code> 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动</p>
<p>Semaphore 通常用于限制可以访问某些资源的线程数目</p>
<p><strong>常用的构造方法</strong></p>
<ul>
<li><code>Semaphore(int permits)</code> 创建具有给定许可数和非公平设置的Semaphore</li>
<li><code>Semaphore(int permits, boolean fair)</code></li>
</ul>
<p><strong>常用方法</strong></p>
<ul>
<li><code>acquire()</code> 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断</li>
<li><code>release()</code> 释放一个许可，将其返回给信号量</li>
</ul>
<blockquote>
<p>案例</p>
<p>6辆汽车，停3个车位</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//创建Semaphore，设置许可数量</span><br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 抢占</span><br>                semaphore.acquire();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢到了车位&quot;</span>);<br>                <span class="hljs-comment">// 设置停车时间</span><br>                TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">3</span>));<br>                <span class="hljs-comment">// 离开车位</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------离开了车位&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//释放</span><br>                semaphore.release();<br>            &#125;<br>        &#125;, String.valueOf(i)).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1抢到了车位</span><br><span class="hljs-comment">3抢到了车位</span><br><span class="hljs-comment">2抢到了车位</span><br><span class="hljs-comment">1------离开了车位</span><br><span class="hljs-comment">4抢到了车位</span><br><span class="hljs-comment">3------离开了车位</span><br><span class="hljs-comment">5抢到了车位</span><br><span class="hljs-comment">5------离开了车位</span><br><span class="hljs-comment">6抢到了车位</span><br><span class="hljs-comment">6------离开了车位</span><br><span class="hljs-comment">4------离开了车位</span><br><span class="hljs-comment">2------离开了车位</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/28/JUC-3-%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/28/JUC-3-%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">JUC(3) 集合的线程安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-28 16:42:41 / Modified: 17:41:22" itemprop="dateCreated datePublished" datetime="2023-12-28T16:42:41+08:00">2023-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-集合线程不安全演示"><a href="#1-集合线程不安全演示" class="headerlink" title="1. 集合线程不安全演示"></a>1. 集合线程不安全演示</h2><p>以 ArrayList 为例，我们进入 ArrayList 源码，找到 add() 方法，源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>显然，add() 方法没有使用同步互斥，所以在多线程并发时，会出现线程异常，测试代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 创建ArrayList 集合</span><br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 创建10个线程，往 list 中添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-comment">// 向集合中添加内容</span><br>            list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>));<br>            <span class="hljs-comment">// 从集合中取出内容</span><br>            System.out.println(list);<br>        &#125;,String.valueOf(i)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>会出现如下异常</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312281659693.png" alt="image-20231228165924618"></p>
<h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><h3 id="2-1-Vector"><a href="#2-1-Vector" class="headerlink" title="2.1 Vector"></a>2.1 Vector</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p>源码如下, 使用 synchronized 修饰，但是这样做效率十分低下且占用资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    modCount++;<br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    elementData[elementCount++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-2-Collections"><a href="#2-2-Collections" class="headerlink" title="2.2 Collections"></a>2.2 Collections</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br></code></pre></td></tr></table></figure>
<p>进入 Collections 的底层，找到 <code>synchronizedList(List list)</code> 方法，源代码如下，返回指定列表支持的同步（线程安全的）列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">synchronizedList</span><span class="hljs-params">(List&lt;T&gt; list)</span> &#123;<br>    <span class="hljs-keyword">return</span> (list <span class="hljs-keyword">instanceof</span> RandomAccess ?<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) :<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedList</span>&lt;&gt;(list));<br>&#125;<br><br><span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">synchronizedList</span><span class="hljs-params">(List&lt;T&gt; list, Object mutex)</span> &#123;<br>    <span class="hljs-keyword">return</span> (list <span class="hljs-keyword">instanceof</span> RandomAccess ?<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list, mutex) :<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedList</span>&lt;&gt;(list, mutex));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-CopyOnWriteArrayList"><a href="#2-3-CopyOnWriteArrayList" class="headerlink" title="2.3 CopyOnWriteArrayList"></a>2.3 CopyOnWriteArrayList</h3><p>使用最多，涉及的底层原理为<strong>写时复制技术</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p>源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对比三者来看，Vector 和 Collections 虽然也可以实现同步，但由于这两种方法在底层都使用了 synchronized 重量级锁，使其效率很低，所以对 ArrayList 的同步主要采用 CopyOnWriteArrayList</p>
<h2 id="3-HashSet的线程不安全"><a href="#3-HashSet的线程不安全" class="headerlink" title="3. HashSet的线程不安全"></a>3. HashSet的线程不安全</h2><p>HashSet 同时读写时也会出现 ConcurrentModificationException 异常</p>
<p>其 add() 源代码如下, 没有对做同步处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其解决方法与 <code>CopyOnWriteArrayList</code> 类似，在 JDK1.8 中，也有一个类叫做 <code>CopyOnWriteArraySet</code>，其底层代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> al.addIfAbsent(e);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过 Debug 找到了对关键的一个函数，发现其实现方式与 CopyOnWriteArrayList 底层实现方式类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// e 表示添加的元素</span><br><span class="hljs-comment">// snapshot 表示被复制的列表</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addIfAbsent</span><span class="hljs-params">(E e, Object[] snapshot)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] current = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> current.length;<br>        <span class="hljs-keyword">if</span> (snapshot != current) &#123;<br>            <span class="hljs-comment">// Optimize for lost race to another addXXX operation</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">common</span> <span class="hljs-operator">=</span> Math.min(snapshot.length, len);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; common; i++)<br>                <span class="hljs-keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        Object[] newElements = Arrays.copyOf(current, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-HashMap的线程不安全"><a href="#4-HashMap的线程不安全" class="headerlink" title="4. HashMap的线程不安全"></a>4. HashMap的线程不安全</h2><p>HashMap 同时读写时一样会出现 ConcurrentModificationException 异常</p>
<p>进入 HashMap 底层，其 put(K key, V value) 源代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 JDK1.8 中，也有一个类叫做 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a> ，实现 HashMap 的同步问题，其底层代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-comment">// 若为空，就初始化</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <span class="hljs-comment">// 计算hash值，得到下标</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 传入参数</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">// 当有两个及以上的线程正在扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 在这里加上了锁</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/27/JUC-2-%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/27/JUC-2-%E9%94%81/" class="post-title-link" itemprop="url">JUC(2) 锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-27 22:57:13" itemprop="dateCreated datePublished" datetime="2023-12-27T22:57:13+08:00">2023-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-13 23:00:32" itemprop="dateModified" datetime="2024-02-13T23:00:32+08:00">2024-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1. synchronized"></a>1. synchronized</h2><h3 id="1-1-三种应用方式"><a href="#1-1-三种应用方式" class="headerlink" title="1.1 三种应用方式"></a>1.1 三种应用方式</h3><ul>
<li>一把锁只能同时被一个线程获取, 没有获得锁的线程只能等待；</li>
<li>每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候, 所有对象公用同一把锁</li>
<li>synchronized修饰的方法, 无论方法正常执行完毕还是抛出异常, 都会释放锁</li>
</ul>
<p><strong>对象锁</strong>：包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)</p>
<ul>
<li>方法锁：synchronized修饰普通方法, 锁对象默认为this</li>
<li>同步代码块锁：见下方代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">block1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">block2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 这个代码块使用的是第一把锁, 当他释放后, 后面的代码块由于使用的是第二把锁, 因此可以马上执行</span><br>    <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>        System.out.println(<span class="hljs-string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>        System.out.println(<span class="hljs-string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>类锁</strong>：指synchronize修饰<strong>静态方法</strong>或指定锁对象为Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// synchronized用在静态方法上, 默认的锁就是当前所在的Class类, 所以无论是哪个线程访问它, 需要的锁都只有一把</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 同上</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 所有线程需要的锁都是同一把</span><br>    <span class="hljs-keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-2-字节码分析"><a href="#1-2-字节码分析" class="headerlink" title="1.2 字节码分析"></a>1.2 字节码分析</h3><p>命令：<code>javap -c *.class</code> 文件反编译</p>
<ul>
<li>-v -verbose, 输出附加信息(行号、本地变量表、反汇编等详细信息)</li>
</ul>
<p><strong>同步代码块</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291637322.png" alt="image.png"></p>
<p>如果代码块中手动抛出了一个异常, 则只会有一个 <code>monitorexit</code></p>
<p><strong>普通同步方法</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291643627.png" alt="image.png"></p>
<p>调用指令将会检查方法的 <code>ACC_SYNCHRONIZED</code> 访问标志是否被设置, 如果设置了, 执行线程会将先持有 monitor 锁, 然后再执行该方法, 最后在方法完成(无论是否正常结束)时释放monitor</p>
<p><strong>静态同步方法</strong></p>
<p><code>ACC_STATIC</code>、<code>ACC_SYNCHRONIZED</code>访问标志区分该方法是否是静态同步方法</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291644440.png" alt="image.png"></p>
<h3 id="1-3-底层原语分析"><a href="#1-3-底层原语分析" class="headerlink" title="1.3 底层原语分析"></a>1.3 底层原语分析</h3><p><strong>为什么任何一个对象都可以成为一个锁</strong></p>
<ul>
<li><p>在 HotSpot 虚拟机中, monitor 采用 ObjectMonitor 实现</p>
</li>
<li><p>ObjectMonitor.java—-&gt;ObjectMonitor.cpp—-&gt;ObjectMonitor.hpp</p>
</li>
<li><p>每个对象天生都带着一个对象监视器, 每一个被锁住的对象都会和Monitor关联起来</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291658330.png" alt="img"></p>
<p>总结：指针指向Monitor对象(也称为管程或监视器)的真实地址。每个对象都存在着一个monitor与之关联, 当一个monitor被某个线程持有后, 它便处于锁定状态。在Java虚拟机(HotSpot)中, monitor是由ObjectMonitor实现的, 其主要的数据结构如下(位于HotSpot虚拟机源码ObjectMonitor.hpp文件, C++实现)：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291715842.png" alt="img"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402011943055.png" alt="image-20240201194318895"></p>
<h3 id="1-4-Lock接口"><a href="#1-4-Lock接口" class="headerlink" title="1.4 Lock接口"></a>1.4 Lock接口</h3><p>Lock 实现提供比使用 synchronized 方法和语句可以获得的更广泛的锁定操作。它们允许更灵活的结构化, 可能具有完全不同的属性, 并且可以支持多个相关联的对象 Condition 。</p>
<p>当在不同范围内发生锁定和解锁时, 必须注意确保在锁定时执行的所有代码由 try-finally 或 try-catch 保护, 以确保在必要时释放锁定。</p>
<p>Lock 实现提供了使用 synchronized 方法和语句的附加功能, 通过提供非阻塞尝试来获取锁 <code>tryLock()</code>, 尝试获取可被中断的锁 <code>lockInterruptibly()</code>, 以及尝试获取可以超时 <code>tryLock(long, TimeUnit)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建可重入锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//上锁</span><br>    lock.lock();<br>	<span class="hljs-comment">//功能操作</span><br>    ...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//解锁</span><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-synchronized锁升级"><a href="#2-synchronized锁升级" class="headerlink" title="2. synchronized锁升级"></a>2. synchronized锁升级</h2><p>根据对象头的 mark word 锁标志位来确定当前属于哪一种锁</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401311443678.png" alt="img" style="zoom: 50%;" /></p>
<blockquote>
<p>偏向锁：MarkWord存储的是偏向的线程ID</p>
<p>轻量锁：MarkWord存储的是指向线程栈中Lock Record的指针</p>
<p>重量锁：MarkWord存储的是指向堆中的monitor对象的指针</p>
</blockquote>
<p>在Java早期版本中, synchronized属于重量级锁, 效率低下, 因为监视器锁 (monitor)是依赖于底层的操作系统的Mutex Lock(系统互斥)来实现的, 挂起线程和恢复线程都需要转入内核态去完成</p>
<blockquote>
<p>Monitor, Java对象, 线程之间是如何关联的</p>
<ul>
<li>如果一个java对象被某个线程锁住, 则该对象的 Mark Word 字段中 LockWord 指向 Monitor 的起始地址</li>
<li>Monitor 的 owner 字段会存放拥有相关联对象锁的线程id</li>
</ul>
</blockquote>
<p>Java 6之后, 为了减少获得锁和释放锁所带来的性能消耗, 引入了轻量级锁和偏向锁</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402041656050.png" alt="在这里插入图片描述" style="zoom:80%;" /></p>
<h3 id="2-1-无锁"><a href="#2-1-无锁" class="headerlink" title="2.1 无锁"></a>2.1 无锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(ClassLayout.parseInstance(o).toPrintable());<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">java.lang.Object object internals:</span><br><span class="hljs-comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="hljs-comment">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="hljs-comment">  8   4        (object header: class)    0xf80001e5</span><br><span class="hljs-comment"> 12   4        (object alignment gap)    </span><br><span class="hljs-comment">Instance size: 16 bytes</span><br><span class="hljs-comment">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(o.hashCode()); <span class="hljs-comment">// 只有计算了才会存储下来</span><br>System.out.println(ClassLayout.parseInstance(o).toPrintable());<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2133927002</span><br><span class="hljs-comment">java.lang.Object object internals:</span><br><span class="hljs-comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="hljs-comment">  0   8        (object header: mark)     0x0000007f31245a01 (hash: 0x7f31245a; age: 0)</span><br><span class="hljs-comment">  8   4        (object header: class)    0xf80001e5</span><br><span class="hljs-comment"> 12   4        (object alignment gap)    </span><br><span class="hljs-comment">Instance size: 16 bytes</span><br><span class="hljs-comment">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="2-2-偏向锁"><a href="#2-2-偏向锁" class="headerlink" title="2.2 偏向锁"></a>2.2 偏向锁</h3><p>偏向锁：<strong>单线程竞争</strong>, 当线程A第一次竞争到锁时, 通过修改MarkWord中的偏向线程ID、偏向锁位。如果不存在其他线程竞争, 那么持有偏向锁的线程将永远不需要进行同步。</p>
<p>HotSpot的作者经过研究发现, 大多数情况下：<strong>在多线程情况下, 锁不仅不存在多线程竞争, 还存在由同一个线程多次获得的情况</strong>, 偏向锁就是在这种情况下出现的, 它的出现是为了解决只有一个线程执行同步时提高性能。<strong>当一段同步代码一直被同一个线程多次访问, 由于只有一个线程那么该线程在后续访问时便会自动获得锁</strong></p>
<p>只需要在锁第一次被拥有的时候, 记录下偏向线程ID。这样偏向线程就一直持有着锁 (后续这个线程进入和退出这段加了同步锁的代码块时, 不需要再次加锁和释放锁。而是直接会去检有锁的MarkWord里面是不是放的自己的线程ID)</p>
<ul>
<li>如果相等, 表示偏向锁是偏向于当前线程的, 就不需要再尝试获得锁了, 直到竞争发生才释放锁。以后每次同步, 检查锁的偏向线程ID与当前线程ID是否一致, 如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。</li>
<li>如果不等, 表示发生了竞争, 锁已经不是总是偏向于同一个线程了, 这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线程的ID<ul>
<li>竞争成功, 表示之前的线程不存在了, MarkWord里面的线程ID为新线程的ID, 锁不会升级, 仍然为偏向锁</li>
<li>竞争失败, 这时候可能需要升级变为轻量级锁, 才能保证线程间公平竞争锁。</li>
</ul>
</li>
</ul>
<blockquote>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时, 持有偏向锁的线程才会释放锁, 线程是<strong>不会主动释放偏向锁</strong>的。</p>
</blockquote>
<h4 id="启动偏向锁"><a href="#启动偏向锁" class="headerlink" title="启动偏向锁"></a>启动偏向锁</h4><p>测试命令与代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">java -XX:+PrintFlagsInitial | grep BiasedLock*<br><span class="hljs-comment">#     intx BiasedLockingBulkRebiasThreshold          = 20                                  &#123;product&#125;</span><br><span class="hljs-comment">#     intx BiasedLockingBulkRevokeThreshold          = 40                                  &#123;product&#125;</span><br><span class="hljs-comment">#     intx BiasedLockingDecayTime                    = 25000                               &#123;product&#125;</span><br><span class="hljs-comment">#     intx BiasedLockingStartupDelay                 = 4000                                &#123;product&#125;  启动延时</span><br><span class="hljs-comment">#     bool TraceBiasedLocking                        = false                               &#123;product&#125;</span><br><span class="hljs-comment">#     bool UseBiasedLocking                          = true                                &#123;product&#125;  使用偏向锁</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 不加会默认使用轻量级锁</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (o) &#123;<br>        System.out.println(ClassLayout.parseInstance(o).toPrintable());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">java.lang.Object object internals:</span><br><span class="hljs-comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="hljs-comment">  0   8        (object header: mark)     0x0000025ca1be3005 (biased: 0x0000000097286f8c; epoch: 0; age: 0)</span><br><span class="hljs-comment">  8   4        (object header: class)    0xf80001e5</span><br><span class="hljs-comment"> 12   4        (object alignment gap)    </span><br><span class="hljs-comment">Instance size: 16 bytes</span><br><span class="hljs-comment">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>启动偏向锁可以通过</p>
<ul>
<li>添加JVM参数 <code>-XX:BiasedLockingStartupDelay=0</code></li>
<li><code>TimeUnit.MILLISECONDS.sleep(4500);</code></li>
</ul>
<h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><p>当有另外一个线程逐步来竞争锁的时候, 就不能再使用偏向锁了, 要升级为轻量级锁, 偏向锁是等到竞争出现才释放锁的机制</p>
<p>竞争线程尝试CAS更新对象头失败, 会等到全局安全点(此时不会执行任何字节码)撤销偏向锁, 同时检查持有偏向锁的线程是否还在执行：</p>
<ul>
<li>第一个线程正在执行synchronized方法(处于同步块), 它还没有执行完, 其他线程来抢夺, 该偏向锁会被取消掉并出现锁升级, 此时轻量级锁由原来持有偏向锁的线程持有, 继续执行同步代码块, 而正在竞争的线程会自动进入自旋等待获得该轻量级锁</li>
<li>第一个线程执行完synchronized(退出同步块), 则将对象头设置为无锁状态并撤销偏向锁, 重新偏向</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402041252920.png" alt="img" style="zoom:50%;" /></p>
<blockquote>
<p>Java15以后逐步废弃偏向锁, 需要手动开启(维护成本高)</p>
</blockquote>
<h3 id="2-3-轻量级锁"><a href="#2-3-轻量级锁" class="headerlink" title="2.3 轻量级锁"></a>2.3 轻量级锁</h3><p>多线程竞争, 但是任意时候最多只有一个线程竞争, 即不存在锁竞争太激烈的情况, 也就没有线程阻塞, 本质是自旋锁CAS</p>
<p>轻量级锁是为了在线程近乎交替执行同步块时提高性能, 通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗</p>
<p>当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁</p>
<h4 id="轻量级锁的加锁与释放"><a href="#轻量级锁的加锁与释放" class="headerlink" title="轻量级锁的加锁与释放"></a>轻量级锁的加锁与释放</h4><p><strong>加锁</strong></p>
<p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间, 官方称为Displaced Mark Word (也即Lock Record, 锁记录)。若一个线程获得锁时发现是轻量级锁, 会把锁的Mark Word复制到自己的Displaced Mark Word里面。</p>
<p>拷贝成功后, 虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针, 并将Lock Record里的owner指针指向对象的Mark Word。</p>
<ul>
<li>如果成功, 当前线程获得锁</li>
<li>如果失败, 虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧<ul>
<li>是就说明当前线程已经拥有了这个对象的锁, 那就可以直接进入同步块继续执行</li>
<li>否则表示Mark Word已经被替换成了其他线程的锁记录, 说明在与其它线程竞争锁, 当前线程就尝试使用自旋来获取锁。</li>
</ul>
</li>
</ul>
<p>但是当自旋超过一定的次数, 或者一个线程在持有锁, 一个在自旋, 又有第三个来访时, 轻量级锁升级为重量级锁。</p>
<blockquote>
<p>加锁CAS说明：当前值是目前程序中Mark Word中的pointer的值, pointer的预期原值是null, 而目的值则是指向自己Lock Record的指针</p>
</blockquote>
<p><strong>释放</strong></p>
<p>在释放锁时, 当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争, 那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁, 那么CAS操作会失败, 此时会释放锁并唤醒被阻塞的线程</p>
<blockquote>
<p>解锁CAS说明：当前值是目前程序中的Mark Word的值, 预期值是Lock Record存的值, 而目的值是把Mark Word修改为Lock Record的值, 也就是修改为预期值</p>
</blockquote>
<h4 id="自旋升级"><a href="#自旋升级" class="headerlink" title="自旋升级"></a>自旋升级</h4><p>Java6之前</p>
<ul>
<li>默认启动, 默认情况下自旋次数超过 10 次 (通过 <code>-XX:PreBlockSpin=10</code> 来修改), 或者自旋线程数超过 CPU 核数的一半, 则升级为重量级锁</li>
</ul>
<p>Java6之后</p>
<ul>
<li>使用<strong>自适应自旋锁</strong>, 自旋的次数不是固定不变的, 而是根据同一个锁上一次自旋的时间拥有锁线程的状态来决定<ul>
<li>线程如果自旋成功了, 那下次自旋的最大次数会增加, 因为JVM认为既然上次成功了, 那么这一次也大概率会成功</li>
<li>如果很少会自旋成功, 那么下次会减少自旋的次数甚至不自旋, 避免CPU空转</li>
</ul>
</li>
</ul>
<h4 id="轻量级锁和偏向锁的区别"><a href="#轻量级锁和偏向锁的区别" class="headerlink" title="轻量级锁和偏向锁的区别"></a>轻量级锁和偏向锁的区别</h4><ul>
<li>争夺轻量锁失败时, 自旋尝试抢占锁<ul>
<li>轻量级锁的获取及释放依赖多次CAS原子指令, 而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</li>
</ul>
</li>
<li>轻量级锁每次退出同步块都需要释放锁, 而偏向锁是在竞争发生时才释放锁</li>
</ul>
<h3 id="2-4-重量级锁"><a href="#2-4-重量级锁" class="headerlink" title="2.4 重量级锁"></a>2.4 重量级锁</h3><p>有大量线程参与锁的竞争, 冲突性很高</p>
<p>Java中synchronized的重量级锁, 是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monitor enter指令, 在结束位置插入monitor exit指令</p>
<p>当线程执行到monitor enter指今时, 会尝试获取对象所对应的Monitor所有权, 如果获取到了, 即获取到了锁, 会在Monitor的owner中存放当前线程的id, 这样它将处于锁定状态, 除非退出同步块, 否则其他线程无法获取到这个Monitor</p>
<h3 id="2-5-锁升级补充"><a href="#2-5-锁升级补充" class="headerlink" title="2.5 锁升级补充"></a>2.5 锁升级补充</h3><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><p>当一个对象已经计算过一致性哈希码后, 它就再也无法进入偏向锁状态了, 直接升级为轻量级锁</p>
<p>当一个对象正处于偏向锁状态, 又收到需要计算一致性哈希码请求时, 它的偏向状态会被立即撤销, 并且锁会膨胀为重量级锁</p>
<ul>
<li>代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态(标志位为01)下的MarkWord, 其中可以存储原来的哈希码</li>
</ul>
<blockquote>
<p>在无锁状态下, Mark Word中可以存储对象的identity hash code值。当对象的hashCode()方法第一次被调用时, JVM会生成对应的identity hash code值并将该值存储到Mark Word中。</p>
<p>对于偏向锁, 在线程获取偏向锁时, 会用Thread ID和epoch值覆盖identity hash code所在的位置。如果一个对象的hashCode()方法已经被调用过一次之后, 这个对象不能被设置偏向锁。</p>
<p>升级为轻量级锁时, JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间, 用于存储锁对象的Mark Word拷贝, 该拷贝中可以包含identity hash code, 所以轻量级锁可以和 identity hash code共存, 哈希码和GC年龄自然保存在此, 释放锁后会将这些信息写回到对象头。</p>
<p>升级为重量级锁后, Mark Word保存的重量级锁指针, 代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark Word, 锁释放后也会将信息写回到对象头。</p>
</blockquote>
<h3 id="2-6-JIT编译器对锁的优化"><a href="#2-6-JIT编译器对锁的优化" class="headerlink" title="2.6 JIT编译器对锁的优化"></a>2.6 JIT编译器对锁的优化</h3><p>JIT：Just In Time Compiler，即时编译器</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 锁消除</span><br><span class="hljs-comment"> * 从JIT角度看相当于无视他，synchronized(o)不存在了</span><br><span class="hljs-comment"> * 这个锁对象并没有被共用扩散到其他线程使用</span><br><span class="hljs-comment"> * 极端的说就是根本没有加锁对象的底层机器码，消除了锁的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockClearUpDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        synchronized (object) &#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;hello ------ LockClearUpDemo&quot;);</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-comment">//锁消除问题，JIT会无视它，底层并没有加锁</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            System.out.println(<span class="hljs-string">&quot;-----------hello LockClearUpDemo&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + o.hashCode() + <span class="hljs-string">&quot;\t&quot;</span> + object.hashCode());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LockClearUpDemo</span> <span class="hljs-variable">lockClearUpDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockClearUpDemo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                lockClearUpDemo.m1();<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	229465744	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	219013680	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	1109337020	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	94808467	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	973369600	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	64667370	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	1201983305	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	573110659	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	1863380256	57319765</span><br><span class="hljs-comment"> * -----------hello LockClearUpDemo	1119787251	57319765</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 锁粗化</span><br><span class="hljs-comment"> * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器会把这几个synchronized块合并为一个大块</span><br><span class="hljs-comment"> * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提高了性能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockBigDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">objectLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;111111111111&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;222222222222&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;333333333333&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (objectLock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;444444444444&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//底层JIT的锁粗化优化为如下代码</span><br><span class="hljs-comment">//            synchronized (objectLock) &#123;</span><br><span class="hljs-comment">//                System.out.println(&quot;111111111111&quot;);</span><br><span class="hljs-comment">//                System.out.println(&quot;222222222222&quot;);</span><br><span class="hljs-comment">//                System.out.println(&quot;333333333333&quot;);</span><br><span class="hljs-comment">//                System.out.println(&quot;444444444444&quot;);</span><br><span class="hljs-comment">//            &#125;</span><br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-乐观锁-悲观锁-表锁-行锁-读锁-写锁"><a href="#3-乐观锁-悲观锁-表锁-行锁-读锁-写锁" class="headerlink" title="3. 乐观锁|悲观锁|表锁|行锁|读锁|写锁"></a>3. 乐观锁|悲观锁|表锁|行锁|读锁|写锁</h2><p><strong>悲观锁</strong>：认为自己在使用数据的时候<strong>一定有别的线程来修改数据</strong>, 因此在<strong>获取数据的时候会先加锁</strong>, 确保数据不会被别的线程修改, synchronized 和 Lock 的实现类都是悲观锁</p>
<ul>
<li>适合<strong>写操作多</strong>的场景, 先加锁可以保证写操作时数据正确, 显式的锁定之后再操作同步资源</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291312687.png" alt="image-20231229131203595" style="zoom:80%;" /></p>
<p><strong>乐观锁</strong>：认为自己在使用数据的时候<strong>不会有别的线程修改数据</strong>, <strong>不会添加锁</strong>, Java中使用无锁编程来实现, 只是在更新的时候去判断, 之前有没有别的线程更新了这个数据, 如果这个数据没有被更新, 当前线程将自己修改的数据成功写入, 如果已经被其他线程更新, 则根据不同的实现方式执行不同的操作, 比如：放弃修改、重试抢锁等等。判断规则有：<strong>版本号机制Version</strong>, 最常采用的是CAS算法, Java原子类中的递增操作就通过CAS自旋实现的。</p>
<ul>
<li>适合读操作多的场景, 不加锁的特性能够使其读操作的性能大幅提升, 乐观锁直接去操作同步资源, 是一种无锁算法</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291312054.png" alt="image-20231229131238997" style="zoom:80%;" /></p>
<p><strong>表锁</strong>：整个表操作, 不会发生死锁</p>
<p><strong>行锁</strong>：每个表中的单独一行进行加锁, 会发生死锁</p>
<p><strong>读锁</strong>：共享锁(可以有多个人读), 会发生死锁</p>
<p><strong>写锁</strong>：独占锁(只能有一个人写), 会发生死锁</p>
<h2 id="4-公平锁和非公平锁"><a href="#4-公平锁和非公平锁" class="headerlink" title="4. 公平锁和非公平锁"></a>4. 公平锁和非公平锁</h2><ul>
<li>公平锁：是指多个线程按照申请锁的顺序来获取锁, 这里类似于排队买票, 先来的人先买, 后来的人再队尾排着, 这是公平的<ul>
<li><code>Lock lock = new ReentrantLock(true)</code></li>
</ul>
</li>
<li>非公平锁：是指多个线程获取锁的顺序并不是按照申请的顺序, 有可能后申请的线程比先申请的线程优先获取锁, 在高并发环境下, 有可能造成<strong>优先级反转</strong>或者<strong>饥饿</strong>的状态(某个线程一直得不到锁)<ul>
<li><code>Lock lock = new ReentrantLock(false)</code>, 默认为非公平锁。</li>
</ul>
</li>
</ul>
<p>面试题：</p>
<ul>
<li><p>为什么会有公平锁/非公平锁的设计？为什么默认非公平？</p>
<ul>
<li><p>恢复挂起的线程到真正锁的获取还是有时间差的, 从开发人员来看这个时间微乎其微, 但是从CPU的角度来看, 这个时间差存在的还是很明显的。所以<strong>非公平锁能更充分地利用CPU的时间片, 尽量减少CPU空间状态时间</strong>。</p>
</li>
<li><p>使用多线程很重要的考量点是线程切换的开销, 当采用非公平锁时, <strong>当一个线程请求锁获取同步状态, 然后释放同步状态, 所以刚释放锁的线程在此刻再次获取同步状态的概率就变得很大, 所以就减少了线程的开销</strong>。</p>
</li>
</ul>
</li>
<li><p>什么时候用公平？什么时候用非公平？</p>
<ul>
<li>如果为了更高的吞吐量, 很显然非公平锁是比较合适的, 因为节省了很多线程切换的时间, 吞吐量自然就上去了；否则就用公平锁, 大家公平使用。</li>
</ul>
</li>
</ul>
<h2 id="5-可重入锁-递归锁"><a href="#5-可重入锁-递归锁" class="headerlink" title="5. 可重入锁(递归锁)"></a>5. 可重入锁(递归锁)</h2><ul>
<li><p>隐式锁(即synchronized关键字使用的锁), 默认是可重入锁</p>
<ul>
<li>在一个synchronized修饰的方法或者代码块的内部调用本类的其他synchronized修饰的方法或者代码块时, 是永远可以得到锁。</li>
</ul>
</li>
<li><p>显式锁(即Lock)也有 ReentrantLock 这样的可重入锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Guanghao Wei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2023-04-10 16:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReEntryLockDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                System.out.println(<span class="hljs-string">&quot;---------------外层调用&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;---------------中层调用&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;---------------内层调用&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 注意：加锁几次就需要解锁几次</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;---------------外层调用&quot;</span>);<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;---------------中层调用&quot;</span>);<br>                    lock.lock();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;---------------内层调用&quot;</span>);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        lock.unlock();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重入的实现机理</p>
<ul>
<li>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针</li>
<li>当执行monitorenter时, 如果目标锁对象的计数器为零, 那么说明它没有被其他线程所持有, Java虚拟机会将该锁对象的持有线程设置为当前线程, 并且将其计数器加1</li>
<li>在目标锁对象的计数器不为零的情况下, 如果锁对象的持有线程是当前线程, 那么Java虚拟机可以将其计数器加1, 否则需要等待, 直至持有线程释放该锁</li>
<li>当执行monitorexit时, Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放</li>
</ul>
<h2 id="6-死锁及排查"><a href="#6-死锁及排查" class="headerlink" title="6. 死锁及排查"></a>6. 死锁及排查</h2><p>死锁是指两个或两个以上的线程在执行过程中, 因抢夺资源而造成的一种互相等待的现象, 若无外力干涉, 则它们无法再继续推进下去。</p>
<p>产生原因：</p>
<ul>
<li>系统资源不足</li>
<li>进程运行推进顺序不合适</li>
<li>系统资源分配不当</li>
</ul>
<h3 id="6-1-排查死锁"><a href="#6-1-排查死锁" class="headerlink" title="6.1 排查死锁"></a>6.1 排查死锁</h3><p>纯命令</p>
<ul>
<li><p>jps -l</p>
</li>
<li><p>jstack 进程编号</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291707859.png" alt="在这里插入图片描述"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291323284.png" alt="image.png" style="zoom:80%;" /></p>
<p>图形化</p>
<ul>
<li>jconsole</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291323255.png" alt="image.png" style="zoom:80%;" /></p>
<h2 id="7-读写锁"><a href="#7-读写锁" class="headerlink" title="7. 读写锁"></a>7. 读写锁</h2><h3 id="7-1-读写锁的使用"><a href="#7-1-读写锁的使用" class="headerlink" title="7.1 读写锁的使用"></a>7.1 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9cd5212c8841">读写锁的使用</a></h3><p>读写锁(<code>ReentrantReadWriteLock</code>)：一个资源可以被多个读线程访问, 也可以被一个写线程访问, 但不能同时存在读写线程</p>
<ul>
<li>读读共享, 读写互斥, 写写互斥</li>
<li>支持锁降级, 不支持锁升级</li>
</ul>
<p>创建读写锁对象 <code>private ReadWriteLock rwLock = new ReentrantReadWriteLock();</code></p>
<p>写锁(<code>ReentrantReadWriteLock.WriteLock</code>)</p>
<ul>
<li>加锁: <code>rwLock.writeLock().lock()</code></li>
<li>解锁: <code>rwLock.writeLock().unlock()</code></li>
</ul>
<p>读锁(<code>ReentrantReadWriteLock.ReadLock</code>)</p>
<ul>
<li>加锁: <code>rwLock.readLock().lock()</code></li>
<li>解锁: <code>rwLock.readLock().unlock()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCache</span>&#123;<br>    <span class="hljs-comment">// 需要模仿从Map中取对象, 所以先穿件一个map对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 创建读写锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">rwlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>    <span class="hljs-comment">// 放数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value)</span> &#123;<br>        <span class="hljs-comment">// 添加写锁</span><br>        rwlock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在写操作&quot;</span>+key);<br>            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">300</span>);<br>            map.put(key, value);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;写完了&quot;</span>+key);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放写锁</span><br>            rwlock.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 取数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 添加读锁</span><br>        rwlock.readLock().lock();;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在取操作&quot;</span>+key);<br>            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">300</span>);<br>            map.get(key);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;取完了&quot;</span>+key);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放读锁</span><br>            rwlock.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-2-读写锁的演变"><a href="#7-2-读写锁的演变" class="headerlink" title="7.2 读写锁的演变"></a>7.2 读写锁的演变</h3><p>无锁无序 -&gt; 加独占锁 -&gt; 读写锁 -&gt; 邮戳锁</p>
<p>读写锁缺点</p>
<ul>
<li>造成锁饥饿, 一直读, 没有写操作</li>
<li>读的时候不能写, 只有读完才能写, 写的时候可以读</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291344843.png" alt="img"></p>
<h3 id="7-3-锁降级"><a href="#7-3-锁降级" class="headerlink" title="7.3 锁降级"></a>7.3 锁降级</h3><ul>
<li>将写锁降级为读锁: 遵循获取写锁、获取读锁再释放写锁的次序, 写锁能够降级为读锁</li>
<li>如果一个线程持有了写锁, 在没有释放写锁的情况下, 它还可以继续获得读锁。这就是写锁的降级, 降级成为了读锁。</li>
<li>如果释放了写锁, 那么就完全转换为读锁</li>
<li>如果有线程在读, 那么写线程是无法获取写锁的, 是悲观锁的策略</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291333512.png" alt="img" style="zoom: 50%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//可重入读写锁对象</span><br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> rwLock.readLock();<span class="hljs-comment">//读锁</span><br>    ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> rwLock.writeLock();<span class="hljs-comment">//写锁</span><br>    <span class="hljs-comment">//锁降级</span><br>    <span class="hljs-comment">//1 获取写锁</span><br>    writeLock.lock();<br>    System.out.println(<span class="hljs-string">&quot;---write&quot;</span>);<br>    <span class="hljs-comment">//2 获取读锁</span><br>    readLock.lock();<br>    System.out.println(<span class="hljs-string">&quot;---read&quot;</span>);<br>    <span class="hljs-comment">//3 释放写锁</span><br>    writeLock.unlock();<br>    <span class="hljs-comment">//4 释放读锁</span><br>    readLock.unlock();<br>&#125;<br><span class="hljs-comment">// 该顺序可正常执行</span><br><span class="hljs-comment">// 如果 1 2 互换则无法执行, 因为不支持锁升级, 在读锁后不允许写, 所以会被阻塞</span><br></code></pre></td></tr></table></figure>
<p><strong>锁降级的必要性</strong></p>
<p>主要是为了保证数据的可见性, 如果当前线程不获取读锁而是直接释放写锁, 假设此刻另一个线程(记作线程T)获取了写锁并修改了数据, 那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁, 即遵循锁降级的步骤, 则线程T将会被阻塞, 直到当前线程使用数据并释放读锁之后, 线程T才能获取写锁进行数据更新。</p>
<p>这时因为可能存在一个事务线程不希望自己的操作被别的线程中断, 而这个事务操作可能分成多部分操作更新不同的数据(或表)甚至非常耗时。如果长时间用写锁独占, 显然对于某些高响应的应用是不允许的, <strong>所以在完成部分写操作后, 退而使用读锁降级, 来允许响应其他进程的读操作。只有当全部事务完成后才真正释放锁。</strong></p>
<p>所以总结下锁降级的意义应该就是：在一边读一边写的情况下提高性能。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291338901.png" alt="img" style="zoom: 33%;" /></p>
<h2 id="8-邮戳锁-StampedLock"><a href="#8-邮戳锁-StampedLock" class="headerlink" title="8. 邮戳锁 StampedLock"></a>8. 邮戳锁 StampedLock</h2><p>StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化</p>
<p>Stamp代表了锁的状态(戳记，long类型)。当Stamp返回零时，表示线程获取锁失败，并且当释放锁或者转换锁的时候，都要传入最初获取的Stamp值。</p>
<ul>
<li>所有获取锁的方法，都返回一个邮戳，Stamp为零表示失败，其余都表示成功</li>
<li>所有释放锁的方法，都需要一个邮戳，这个Stamp必须是和成功获取锁时得到的Stamp一致</li>
</ul>
<p>StampedLock是不可重入的(如果一个线程已经持有了写锁，再去获取写锁会造成死锁)</p>
<p>StampedLock有三种访问模式：</p>
<ul>
<li>Reading(读模式悲观)：功能和ReentrantReadWriteLock的读锁类似</li>
<li>Writing(写模式)：功能和ReentrantReadWriteLock的写锁类似</li>
<li>Optimistic reading(乐观读模式)：无锁机制，类似于数据库中的乐观锁，<strong>支持读写并发</strong>，很乐观认为读时没人修改，假如被修改在实现升级为悲观读模式</li>
</ul>
<h3 id="8-1-锁饥饿"><a href="#8-1-锁饥饿" class="headerlink" title="8.1 锁饥饿"></a>8.1 锁饥饿</h3><p>锁饥饿问题：</p>
<ul>
<li>ReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，因此当前有可能会一直存在读锁，而无法获得写锁。</li>
</ul>
<p>如何解决锁饥饿问题：</p>
<ul>
<li>使用”公平”策略可以一定程度上缓解这个问题<ul>
<li><code>new ReentrantReadWriteLock(true)</code></li>
<li>但”公平”策略是以牺牲系统吞吐量为代价的</li>
</ul>
</li>
<li>StampedLock 采用<strong>乐观读锁</strong>方式<ul>
<li>采取乐观获取锁，其他线程尝试获取写锁时<strong>不会被阻塞</strong>，<strong>在获取乐观读锁后，需要对结果进行校验</strong></li>
</ul>
</li>
</ul>
<h3 id="8-2-代码示例"><a href="#8-2-代码示例" class="headerlink" title="8.2 代码示例"></a>8.2 代码示例</h3><p>传统的读写锁模式</p>
<ul>
<li>读的时候不能获取写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StampedLockDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">37</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">stampedLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.writeLock();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;写线程准备修改&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            number = number + <span class="hljs-number">13</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp);<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;写线程结束修改&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.readLock();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot; come in readLock codeBlock&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot; 正在读取中&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> number;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;获得成员变量值result: &quot;</span> + result);<br>            System.out.println(<span class="hljs-string">&quot;写线程没有修改成功，读锁时候写锁无法介入，传统的读写互斥&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockRead(stamp);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StampedLockDemo</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLockDemo</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            resource.read();<br>        &#125;, <span class="hljs-string">&quot;readThread&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot; come in&quot;</span>);<br>            resource.write();<br>        &#125;, <span class="hljs-string">&quot;writeThread&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * readThread	 come in readLock codeBlock</span><br><span class="hljs-comment"> * readThread	 正在读取中</span><br><span class="hljs-comment"> * writeThread	 come in</span><br><span class="hljs-comment"> * readThread	 正在读取中</span><br><span class="hljs-comment"> * readThread	 正在读取中</span><br><span class="hljs-comment"> * readThread	 正在读取中</span><br><span class="hljs-comment"> * readThread	获得成员变量值result: 37</span><br><span class="hljs-comment"> * 写线程没有修改成功，读锁时候写锁无法介入，传统的读写互斥</span><br><span class="hljs-comment"> * writeThread	写线程准备修改</span><br><span class="hljs-comment"> * writeThread	写线程结束修改</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>乐观读模式</p>
<ul>
<li>读的过程中也允许写锁介入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StampedLockDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">37</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">stampedLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.writeLock();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;写线程准备修改&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            number = number + <span class="hljs-number">13</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp);<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;写线程结束修改&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.tryOptimisticRead(); <span class="hljs-comment">// 乐观读</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> number;<br><br>        System.out.println(<span class="hljs-string">&quot;4秒前 stampedLock.validate方法值(true 无修改 false有修改)&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + stampedLock.validate(stamp));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot; 正在读取....&quot;</span> + i + <span class="hljs-string">&quot;秒后&quot;</span> + <span class="hljs-string">&quot;stampedLock.validate方法值(true 无修改 false有修改)&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + stampedLock.validate(stamp));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!stampedLock.validate(stamp)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;有人修改----------有写操作&quot;</span>);<br>            stamp = stampedLock.readLock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;从乐观读升级为悲观读&quot;</span>);<br>                result = number;<br>                System.out.println(<span class="hljs-string">&quot;重新悲观读后result：&quot;</span> + result);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                stampedLock.unlockRead(stamp);<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;finally value: &quot;</span> + result);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StampedLockDemo</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLockDemo</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            resource.read();<br>        &#125;, <span class="hljs-string">&quot;readThread&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot; come in&quot;</span>);<br>            resource.write();<br>        &#125;, <span class="hljs-string">&quot;writeThread&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 4秒前 stampedLock.validate方法值(true 无修改 false有修改)	true</span><br><span class="hljs-comment"> * readThread	 正在读取....0秒后stampedLock.validate方法值(true 无修改 false有修改)	true</span><br><span class="hljs-comment"> * readThread	 正在读取....1秒后stampedLock.validate方法值(true 无修改 false有修改)	true</span><br><span class="hljs-comment"> * writeThread	 come in</span><br><span class="hljs-comment"> * writeThread	写线程准备修改</span><br><span class="hljs-comment"> * writeThread	写线程结束修改</span><br><span class="hljs-comment"> * readThread	 正在读取....2秒后stampedLock.validate方法值(true 无修改 false有修改)	false</span><br><span class="hljs-comment"> * readThread	 正在读取....3秒后stampedLock.validate方法值(true 无修改 false有修改)	false</span><br><span class="hljs-comment"> * 有人修改----------有写操作</span><br><span class="hljs-comment"> * 从乐观读升级为悲观读</span><br><span class="hljs-comment"> * 重新悲观读后result：50</span><br><span class="hljs-comment"> * readThread	finally value: 50</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="8-2-优缺点"><a href="#8-2-优缺点" class="headerlink" title="8.2 优缺点"></a>8.2 优缺点</h3><ul>
<li>StampedLock不支持重入</li>
<li>StampedLock的悲观读锁和写锁都不支持条件变量(Condition)</li>
<li>使用StampedLock一定不要调用中断操作，即不要调用interrupt()方法</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/27/JUC-1-CompletableFuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/27/JUC-1-CompletableFuture/" class="post-title-link" itemprop="url">JUC(1) CompletableFuture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-27 21:37:59 / Modified: 22:55:14" itemprop="dateCreated datePublished" datetime="2023-12-27T21:37:59+08:00">2023-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-线程基础知识"><a href="#1-线程基础知识" class="headerlink" title="1. 线程基础知识"></a>1. 线程基础知识</h2><ul>
<li><p>1把锁：synchronized</p>
</li>
<li><p>2个并：</p>
<ul>
<li><p>并发（concurrent）：是在同一实体上的多个事件，是在<strong>一台机器</strong>上“<strong>同时</strong>”处理多个任务，同一时刻，其实是<strong>只有一个</strong>事情再发生。</p>
</li>
<li><p>并行（parallel）：是在不同实体上的多个事件，是在<strong>多台处理器</strong>上同时处理多个任务，同一时刻，大家都在做事情，你做你的，我做我的，各干各的。</p>
</li>
</ul>
</li>
<li><p>3个程：</p>
<ul>
<li><p>进程：在系统中运行的一个应用程序，每个进程都有它自己的内存空间和系统资源</p>
</li>
<li><p>线程：也被称为轻量级进程，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元。</p>
</li>
<li><p>管程：Monitor（锁），也就是我们平时所说的锁。Monitor其实是一种<strong>同步机制</strong>，它的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码，JVM中同步是基于进入和退出监视器（Monitor管程对象）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象和Java对象一同创建并销毁，底层由C++语言实现。</p>
</li>
</ul>
</li>
<li><p>线程分类（一般不做特别说明配置，默认都是用户线程）：</p>
<ul>
<li><p>用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。</p>
</li>
<li><p>守护线程：是一种特殊的线程为其他线程服务的，在后台默默地完成一些系统性的任务，比如垃圾回收线程就是最典型的例子。守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，守护线程伴随着JVM一同结束工作。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaemonDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 开始运行,&quot;</span> + (Thread.currentThread().isDaemon() ? <span class="hljs-string">&quot;守护线程&quot;</span> : <span class="hljs-string">&quot;用户线程&quot;</span>));<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.setDaemon(<span class="hljs-literal">true</span>);<span class="hljs-comment">//通过设置属性Daemon来设置当前线程是否为守护线程</span><br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 主线程结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><br>输出：<br>Thread-<span class="hljs-number">0</span> 开始运行,守护线程<br>main 主线程结束<br>    <br><span class="hljs-comment">// 在main主线程结束后，守护线程会伴随着JVM一同结束工作，即使还有循环没有结束</span><br></code></pre></td></tr></table></figure>
<h2 id="2-Future"><a href="#2-Future" class="headerlink" title="2. Future"></a>2. Future</h2><p>Future是Java5新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312272145993.png" alt="image.png"></p>
<h2 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3. FutureTask"></a>3. FutureTask</h2><p>目的：异步多线程任务执行且返回有结果，三个特点：<strong>多线程、有返回、异步任务</strong>（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）</p>
<p>代码实现：Runnable接口 + Callable接口 + Future接口 + FutureTask实现类。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312272149662.png" alt="在这里插入图片描述" style="zoom:80%;" /></p>
<blockquote>
<p>线程 Thread 构造函数仅接收 Runnable 类型参数，Runnable 无返回值</p>
<p>FutureTask 解决了无返回值问题，构造函数接收 Callable 类型，并且本身实现 Runnable 接口，可以作为 Thread 的构造函数参数</p>
<p>使用线程池的 submit() 可以省略构造线程并 start() 的代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">futureTaskDemo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;come in&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;task over&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    <br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ------忙其他任务&quot;</span>);<br><br>    <span class="hljs-comment">// 获取结果的三种方式</span><br>	<span class="hljs-comment">// System.out.println(futureTask.get());//这样会有阻塞的可能，在程序没有计算完毕的情况下。</span><br>	<span class="hljs-comment">// System.out.println(futureTask.get(3,TimeUnit.SECONDS));//只愿意等待三秒，计算未完成直接抛出异常</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//轮询</span><br>        <span class="hljs-keyword">if</span>(futureTask.isDone()) &#123;<br>            System.out.println(futureTask.get());<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>);<br>            System.out.println(<span class="hljs-string">&quot;正在处理中，不要催了，越催越慢&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>优点：Future + 线程池异步多线程任务配合，能显著提高程序的运行效率。</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p><code>get()</code>阻塞—-一旦调用get()方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞。</p>
</li>
<li><p><code>isDone()</code>轮询—-轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞。</p>
</li>
</ul>
</li>
<li><p>结论：Future对于结果的获取不是很友好，只能通过<strong>阻塞或轮询</strong>的方式得到任务的结果</p>
</li>
</ul>
<h2 id="4-CompletableFuture"><a href="#4-CompletableFuture" class="headerlink" title="4. CompletableFuture"></a>4. CompletableFuture</h2><p>FutureTask 只能通过<strong>阻塞或轮询</strong>的方式得到任务的结果，显然不是我们想要的</p>
<p>对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果。JDK8 设计的 CompletableFuture提供了一种<strong>观察者模式</strong>类似的机制，可以让任务执行完成后通知监听的一方。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312272203226.png" alt="在这里插入图片描述"></p>
<ul>
<li>CompletionStage<ul>
<li>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段</li>
<li>一个阶段的计算执行可以是一个Function, Consumer或者Runnable。比如: <ul>
<li><code>stage.thenApply(x -&gt; square(x)).thenAccept(x-&gt;System.out.println(x)).thenRun(()-&gt;System.out.println(&quot;123&quot;))</code></li>
</ul>
</li>
</ul>
</li>
<li>CompletableFuture<ul>
<li>提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以<strong>通过回调的方式处理计算结果</strong>，也提供了转换和组合CompletableFuture的方法</li>
<li>它可能代表一个明确完成的Future，也可能代表一个完成阶段（CompletionStage），它支持在计算完成以后触发一些函数或执行某些动作</li>
</ul>
</li>
</ul>
<p><strong>核心的四个静态方法，来创建一个异步任务</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312272212642.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>函数式编程相关见 <a target="_blank" rel="noopener" href="https://whalefall.top/2023/05/25/Java-8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">Java8函数式编程</a></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312272213121.png" alt="img"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completableFutureBuildDemo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;, executorService);<br><br>    System.out.println(completableFuture.get()); <span class="hljs-comment">// null</span><br><br>    CompletableFuture&lt;String&gt; objectCompletableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello supplyAsync&quot;</span>;<br>    &#125;, executorService);<br><br>    System.out.println(objectCompletableFuture.get()); <span class="hljs-comment">// hello supplyAsync</span><br><br>    executorService.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>executorService.shutdown()</code></p>
<ul>
<li>线程池会把正在执行的任务及队列中等待执行的任务都执行完毕后，再去关闭；</li>
<li>如果还有新的任务过来，线程池就会拒绝</li>
</ul>
</blockquote>
<h3 id="4-1-CompletableFuture-常用方法"><a href="#4-1-CompletableFuture-常用方法" class="headerlink" title="4.1 CompletableFuture 常用方法"></a>4.1 CompletableFuture 常用方法</h3><h4 id="获得结果"><a href="#获得结果" class="headerlink" title="获得结果"></a>获得结果</h4><ul>
<li><code>public T get()</code>: 获取结果，会阻塞</li>
<li><code>public T get(long timeout, TimeUnit unit)</code>: 设置超时时间</li>
<li><code>public T join()</code>: 和get一样的作用，只是不需要抛出异常</li>
<li><code>public T getNow(T valuelfAbsent)</code>: 计算完成就返回正常值，否则返回valuelfAbsent, 立即获取结果不阻塞</li>
</ul>
<h4 id="触发计算"><a href="#触发计算" class="headerlink" title="触发计算"></a>触发计算</h4><ul>
<li><code>public boolean complete(T value)</code>: 是否打断get方法立即返回括号值<ul>
<li>一旦调用了 <code>complete()</code> 方法，CompletableFuture 对象的状态会立即变为已完成，而且之后任何对该对象的计算都不会再触发异步任务的执行。如果该对象已经处于完成状态，再次调用 <code>complete()</code> 方法不会有任何效果。</li>
<li>如果异步任务已经抛出了异常，调用 <code>complete()</code> 方法将不会有任何效果。此时，可以使用 <code>completeExceptionally(Throwable ex)</code> 方法手动设置异步任务的异常结果。</li>
<li>如果有多个线程同时尝试调用 <code>complete()</code> 方法，只有第一个成功的线程能够设置结果，其他线程的调用将被忽略。</li>
</ul>
</li>
</ul>
<h4 id="对计算结果进行处理"><a href="#对计算结果进行处理" class="headerlink" title="对计算结果进行处理"></a>对计算结果进行处理</h4><ul>
<li><code>thenApply</code>：上一步有异常就叫停</li>
<li><code>handle</code>：上一步有异常，该步骤正常执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completableFutureApiDemo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;, threadPool).thenApply(f -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;222&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 除0异常</span><br>        <span class="hljs-keyword">return</span> f + <span class="hljs-number">2</span>;<br>    &#125;).handle((f, e) -&gt; &#123; <span class="hljs-comment">// 会正常执行</span><br>        System.out.println(<span class="hljs-string">&quot;3333&quot;</span>);<br>        <span class="hljs-keyword">return</span> f + <span class="hljs-number">2</span>;<br>    &#125;).whenComplete((v, e) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;----计算结果&quot;</span> + v);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;----出现异常, 计算结果&quot;</span> + v);<br>        &#125;<br>    &#125;).exceptionally(e -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;出现异常&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------主线程先去做其他事情&quot;</span>);<br>    threadPool.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>发生异常后进入exceptionally代码块，但是thenApply中的代码不会执行，whenComplete依旧会执行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">main------主线程先去做其他事情<br>222<br>3333<br>----出现异常, 计算结果null<br>出现异常<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312272234823.png" alt="img"></p>
<h4 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h4><ul>
<li><code>thenAccept</code></li>
</ul>
<p><strong>对比补充</strong></p>
<ul>
<li><code>thenRun(Runnable runnable)</code> :任务A执行完执行B，并且不需要A的结果</li>
<li><code>thenAccept(Consumer action)</code>: 任务A执行完执行B，B需要A的结果，但是任务B没有返回值</li>
<li><code>thenApply(Function fn)</code>: 任务A执行完执行B，B需要A的结果，同时任务B有返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;result&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());<span class="hljs-comment">//null</span><br>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;result&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());<span class="hljs-comment">//result null</span><br>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;result&quot;</span>).thenApply(f -&gt; f + <span class="hljs-number">2</span>).join());<span class="hljs-comment">//result2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>CompletableFuture和线程池说明</strong></p>
<ul>
<li><p>如果没有传入自定义线程池，都用默认线程池ForkJoinPool</p>
</li>
<li><p>如果你执行第一个任务时，传入了一个自定义线程池</p>
<ul>
<li><p>调用<code>thenRun</code>方法执行第二个任务时，则第二个任务和第一个任务时共用同一个线程池</p>
</li>
<li><p>调用<code>thenRunAsync</code>执行第二个任务时，则第一个任务使用的是你自定义的线程池，第二个任务使用的是ForkJoin线程池</p>
</li>
</ul>
</li>
<li><p>备注：可能是线程处理太快，系统优化切换原则，直接使用了 main 线程处理</p>
</li>
<li><code>thenAccept</code>和<code>thenAcceptAsync</code>，<code>thenApply</code>和<code>thenApplyAsync</code>等之间的区别同理</li>
</ul>
<h4 id="对计算速度进行选用"><a href="#对计算速度进行选用" class="headerlink" title="对计算速度进行选用"></a>对计算速度进行选用</h4><ul>
<li>谁快用谁</li>
<li><code>applyToEither</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    CompletableFuture&lt;String&gt; playA = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;A come in&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;playA&quot;</span>;<br>    &#125;, threadPool);<br><br><br>    CompletableFuture&lt;String&gt; playB = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;B come in&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;playB&quot;</span>;<br>    &#125;, threadPool);<br><br>    CompletableFuture&lt;String&gt; result = playA.applyToEither(playB, f -&gt; &#123;<br>        <span class="hljs-keyword">return</span> f + <span class="hljs-string">&quot; is winner&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A come in</span><br><span class="hljs-comment">     * B come in</span><br><span class="hljs-comment">     * main-----------winner:playA is winner</span><br><span class="hljs-comment">     */</span><br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-----------winner:&quot;</span> + result.join());<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="对计算结果合并"><a href="#对计算结果合并" class="headerlink" title="对计算结果合并"></a>对计算结果合并</h4><ul>
<li>两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给<code>thenCombine</code>来处理</li>
<li>先完成的等待其他分支任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 启动&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    &#125;);<br><br>    CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 启动&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br>    &#125;);<br><br>    CompletableFuture&lt;Integer&gt; finalResult = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;----------开始两个结果合并&quot;</span>);<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;);<br>    System.out.println(finalResult.join());<br><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ForkJoinPool.commonPool-worker-9 启动</span><br><span class="hljs-comment">ForkJoinPool.commonPool-worker-2 启动</span><br><span class="hljs-comment">----------开始两个结果合并</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><ul>
<li><code>allOf()</code>：当所有给定的 CompletableFuture 完成时，返回一个新的 CompletableFuture</li>
<li><code>anyOf()</code>：只要有一个任务执行完成后就返回 future 并将第一个完成的参数带着一起返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;f1&quot;</span>;<br>    &#125;);<br><br>    CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;f2&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-comment">// allof测试</span><br>    CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(f1, f2).thenApply(x -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;all&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br>    <span class="hljs-comment">// anyof测试</span><br>    CompletableFuture&lt;Object&gt; any = CompletableFuture.anyOf(f1, f2).thenApply(x -&gt; &#123;<br>        System.out.println(x);<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;);;<br>    <br><br>    System.out.println(System.currentTimeMillis() + <span class="hljs-string">&quot;:阻塞&quot;</span>);<br>    <span class="hljs-type">Void</span> <span class="hljs-variable">aVoid</span> <span class="hljs-operator">=</span> all.get();<br>    System.out.println(System.currentTimeMillis() + <span class="hljs-string">&quot;:阻塞结束&quot;</span>);<br><br>    <span class="hljs-comment">//一个需要耗时2秒，一个需要耗时3秒，只有当最长的耗时3秒的完成后，才会结束。</span><br>    System.out.println(<span class="hljs-string">&quot;任务均已完成。&quot;</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1703688408160:阻塞</span><br><span class="hljs-comment">	all</span><br><span class="hljs-comment">	1703688411161:阻塞结束</span><br><span class="hljs-comment">	任务均已完成。</span><br><span class="hljs-comment">    */</span><br>    <br>    System.out.println(any.get());<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    f2</span><br><span class="hljs-comment">    f2</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/12/SpringMVC-5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/12/SpringMVC-5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/" class="post-title-link" itemprop="url">SpringMVC(5) 异常处理、拦截器、参数校验、文件上传下载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-12 17:16:46" itemprop="dateCreated datePublished" datetime="2023-12-12T17:16:46+08:00">2023-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-15 12:26:10" itemprop="dateModified" datetime="2023-12-15T12:26:10+08:00">2023-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringMVC/" itemprop="url" rel="index"><span itemprop="name">SpringMVC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-全局异常处理机制"><a href="#1-全局异常处理机制" class="headerlink" title="1. 全局异常处理机制"></a>1. 全局异常处理机制</h2><p><strong>基于注解实现声明式异常处理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * description: 全局异常处理器,内部可以定义异常处理Handler!</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RestControllerAdvice</span> = <span class="hljs-doctag">@ControllerAdvice</span> + <span class="hljs-doctag">@ResponseBody</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 异常处理handler </span><br><span class="hljs-comment">      * <span class="hljs-doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span><br><span class="hljs-comment">      * 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span><br><span class="hljs-comment">      * </span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> e 获取异常对象!</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@return</span> 返回handler处理结果!</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerJsonDateException</span><span class="hljs-params">(HttpMessageNotReadableException e)</span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 当发生空指针异常会触发此方法!</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> e</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-meta">@ExceptionHandler(NullPointerException.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerNullException</span><span class="hljs-params">(NullPointerException e)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 所有异常都会触发此方法! 但是如果有具体的异常处理Handler, 具体异常处理Handler优先级更高!</span><br><span class="hljs-comment">      * 例如: 发生NullPointerException异常, 会触发handlerNullException方法,不会触发handlerException方法!</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> e</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerException</span><span class="hljs-params">(Exception e)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>基于配置</strong></p>
<p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p>
<p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p>
<p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>        	<span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        		properties的键表示处理器方法执行过程中出现的异常</span><br><span class="hljs-comment">        		properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span><br><span class="hljs-comment">        	--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    	exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionAttribute&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="2-拦截器"><a href="#2-拦截器" class="headerlink" title="2. 拦截器"></a>2. 拦截器</h2><h3 id="2-1-创建拦截器"><a href="#2-1-创建拦截器" class="headerlink" title="2.1 创建拦截器"></a>2.1 创建拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Process01Interceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-comment">// if( ! preHandler())&#123;return;&#125;</span><br>    <span class="hljs-comment">// 在处理请求的目标 handler 方法前执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.preHandle&quot;</span>);<br>         <br>        <span class="hljs-comment">// 返回true：放行</span><br>        <span class="hljs-comment">// 返回false：不放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 在目标 handler 方法之后，handler报错不执行!</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler + <span class="hljs-string">&quot;, modelAndView = &quot;</span> + modelAndView);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.postHandle&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">// 渲染视图之后执行(最后),一定执行!</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler + <span class="hljs-string">&quot;, ex = &quot;</span> + ex);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.afterCompletion&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312121728018.png" alt="img"></p>
<h3 id="2-2-拦截器的配置"><a href="#2-2-拦截器的配置" class="headerlink" title="2.2 拦截器的配置"></a>2.2 拦截器的配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableWebMvc</span>  <span class="hljs-comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-comment">//配置jsp对应的视图解析器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//快速配置jsp模板语言对应的</span><br>        registry.jsp(<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>,<span class="hljs-string">&quot;.jsp&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> &#123;<br>        configurer.enable();<br>    &#125;<br><br>    <span class="hljs-comment">//添加拦截器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br><br>        <span class="hljs-comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>());<br><br>        <span class="hljs-comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span><br>        <span class="hljs-comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>())<br>                .addPathPatterns(<span class="hljs-string">&quot;/common/request/one&quot;</span>,<span class="hljs-string">&quot;/common/request/tow&quot;</span>);<br><br><br>        <span class="hljs-comment">//排除匹配,排除应该在匹配的范围内排除</span><br>        <span class="hljs-comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span><br>        <span class="hljs-comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>())<br>                .addPathPatterns(<span class="hljs-string">&quot;/common/request/one&quot;</span>,<span class="hljs-string">&quot;/common/request/tow&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/common/request/tow&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-参数校验"><a href="#3-参数校验" class="headerlink" title="3. 参数校验"></a>3. 参数校验</h2><h3 id="3-1-校验概述"><a href="#3-1-校验概述" class="headerlink" title="3.1 校验概述"></a>3.1 校验概述</h3><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Null</td>
<td>标注值必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>标注值不可为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>标注值必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>标注值必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>标注值必须大于或等于 value</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>标注值必须小于或等于 value</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>标注值必须大于或等于 value</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>标注值必须小于或等于 value</td>
</tr>
<tr>
<td>@Size(max,min)</td>
<td>标注值大小必须在 max 和 min 限定的范围内</td>
</tr>
<tr>
<td>@Digits(integer,fratction)</td>
<td>标注值值必须是一个数字，且必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>标注值只能用于日期型，且必须是过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>标注值只能用于日期型，且必须是将来的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>标注值必须符合指定的正则表达式</td>
</tr>
</tbody>
</table>
</div>
<p>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Email</td>
<td>标注值必须是格式正确的 Email 地址</td>
</tr>
<tr>
<td>@Length</td>
<td>标注值字符串大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>标注值字符串不能是空字符串</td>
</tr>
<tr>
<td>@Range</td>
<td>标注值必须在指定的范围内</td>
</tr>
</tbody>
</table>
</div>
<p>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</p>
<p>配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</p>
<h3 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h3><ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!-- 校验注解 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.platform<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <br><span class="hljs-comment">&lt;!-- 校验注解实现--&gt;</span>        <br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.0.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.0.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>应用校验注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> jakarta.validation.constraints.Email;<br><span class="hljs-keyword">import</span> jakarta.validation.constraints.Min;<br><span class="hljs-keyword">import</span> org.hibernate.validator.constraints.Length;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">//age   10 &lt;= age</span><br>    <span class="hljs-meta">@Min(10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//name 3 &lt;= name.length &lt;= 6</span><br>    <span class="hljs-meta">@Length(min = 3,max = 10)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">//email 邮箱格式</span><br>    <span class="hljs-meta">@Email</span><br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>handler标记和绑定错误收集</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Validated</span> 代表应用校验注解! 必须添加!</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;save&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> <span class="hljs-meta">@RequestBody</span> User user,</span><br><span class="hljs-params">                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span><br><span class="hljs-params">                       BindingResult result)</span>&#123;<br>        <span class="hljs-comment">//判断是否有信息绑定错误! 有可以自行处理!</span><br>        <span class="hljs-keyword">if</span> (result.hasErrors())&#123;<br>            System.out.println(<span class="hljs-string">&quot;错误&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">errorMsg</span> <span class="hljs-operator">=</span> result.getFieldError().toString();<br>            <span class="hljs-keyword">return</span> errorMsg;<br>        &#125;<br>        <span class="hljs-comment">//没有,正常处理业务即可</span><br>        System.out.println(<span class="hljs-string">&quot;正常&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-检查是否为空"><a href="#3-3-检查是否为空" class="headerlink" title="3.3 检查是否为空"></a>3.3 检查是否为空</h3><p><code>@NotNull</code>、<code>@NotEmpty</code>、<code>@NotBlank</code> 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p>
<ol>
<li><p><code>@NotNull</code>  (包装类型不为null)</p>
<p> @NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解<strong>不能用于字符串类型的校验</strong>，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p>
</li>
<li><p><code>@NotEmpty</code> (集合类型长度大于0)</p>
<p> @NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 null 或者 size()==0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p>
</li>
<li><p><code>@NotBlank</code> （字符串，不为null，且不为”  “字符串）</p>
<p> @NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解<strong>只能用于字符串类型的校验</strong>。</p>
</li>
</ol>
<p>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p>
<h2 id="4-文件上传和下载"><a href="#4-文件上传和下载" class="headerlink" title="4. 文件上传和下载"></a>4. 文件上传和下载</h2><h3 id="4-1-文件下载"><a href="#4-1-文件下载" class="headerlink" title="4.1 文件下载"></a>4.1 文件下载</h3><p>使用 ResponseEntity 实现下载文件的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testDown&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//获取ServletContext对象</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> session.getServletContext();<br>    <span class="hljs-comment">//获取服务器中文件的真实路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> servletContext.getRealPath(<span class="hljs-string">&quot;/static/img/1.jpg&quot;</span>);<br>    <span class="hljs-comment">//创建输入流</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(realPath);<br>    <span class="hljs-comment">//创建字节数组</span><br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[is.available()];<br>    <span class="hljs-comment">//将流读到字节数组中</span><br>    is.read(bytes);<br>    <span class="hljs-comment">//创建HttpHeaders对象设置响应头信息</span><br>    MultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br>    <span class="hljs-comment">//设置要下载方式以及下载文件的名字</span><br>    headers.add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=1.jpg&quot;</span>);<br>    <span class="hljs-comment">//设置响应状态码</span><br>    <span class="hljs-type">HttpStatus</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> HttpStatus.OK;<br>    <span class="hljs-comment">//创建ResponseEntity对象</span><br>    ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; responseEntity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, statusCode);<br>    <span class="hljs-comment">//关闭输入流</span><br>    is.close();<br>    <span class="hljs-keyword">return</span> responseEntity;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-文件上传"><a href="#4-2-文件上传" class="headerlink" title="4.2 文件上传"></a>4.2 文件上传</h3><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data”</p>
<p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p>
<p>上传步骤：</p>
<p>a&gt;添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>b&gt;在SpringMVC的配置文件中添加配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>c&gt;控制器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testUp&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testUp</span><span class="hljs-params">(MultipartFile photo, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//获取上传的文件的文件名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> photo.getOriginalFilename();<br>    <span class="hljs-comment">//处理文件重名问题</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">hzName</span> <span class="hljs-operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>    fileName = UUID.randomUUID().toString() + hzName;<br>    <span class="hljs-comment">//获取服务器中photo目录的路径</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> session.getServletContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">photoPath</span> <span class="hljs-operator">=</span> servletContext.getRealPath(<span class="hljs-string">&quot;photo&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(photoPath);<br>    <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>        file.mkdir();<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">finalPath</span> <span class="hljs-operator">=</span> photoPath + File.separator + fileName;<br>    <span class="hljs-comment">//实现上传功能</span><br>    photo.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(finalPath));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/12/SpringMVC-4-RESTful%E9%A3%8E%E6%A0%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/12/SpringMVC-4-RESTful%E9%A3%8E%E6%A0%BC/" class="post-title-link" itemprop="url">SpringMVC(4) RESTful风格</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-12 17:12:43 / Modified: 17:15:18" itemprop="dateCreated datePublished" datetime="2023-12-12T17:12:43+08:00">2023-12-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringMVC/" itemprop="url" rel="index"><span itemprop="name">SpringMVC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-RESTful简介"><a href="#1-RESTful简介" class="headerlink" title="1. RESTful简介"></a>1. RESTful简介</h2><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p>
<p><strong>a&gt;资源</strong></p>
<p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p>
<p><strong>b&gt;资源的表述</strong></p>
<p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p>
<p><strong>c&gt;状态转移</strong></p>
<p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p>
<h2 id="2-RESTful的实现"><a href="#2-RESTful的实现" class="headerlink" title="2. RESTful的实现"></a>2. RESTful的实现</h2><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p>
<p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p>
<p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询操作</td>
<td>getUserById?id=1</td>
<td>user/1—&gt;get请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user—&gt;post请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deleteUser?id=1</td>
<td>user/1—&gt;delete请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user—&gt;put请求方式</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-HiddenHttpMethodFilter"><a href="#3-HiddenHttpMethodFilter" class="headerlink" title="3. HiddenHttpMethodFilter"></a>3. HiddenHttpMethodFilter</h2><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p>
<p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p>
<p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p>
<p>a&gt;当前请求的请求方式必须为post</p>
<p>b&gt;当前请求必须传输请求参数_method</p>
<p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p>
<p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
<p>目前为止，SpringMVC中提供了两个过滤器：<code>CharacterEncodingFilter</code> 和 <code>HiddenHttpMethodFilter</code></p>
<p>在web.xml中注册时，必须先注册<code>CharacterEncodingFilter</code>，再注册<code>HiddenHttpMethodFilter</code></p>
<p>原因：</p>
<ul>
<li><p>在 <code>CharacterEncodingFilter</code> 中通过 <code>request.setCharacterEncoding(encoding)</code> 方法设置字符集的</p>
</li>
<li><p><code>request.setCharacterEncoding(encoding)</code> 方法要求前面不能有任何获取请求参数的操作</p>
</li>
<li><p>而 <code>HiddenHttpMethodFilter</code> 恰恰有一个获取请求方式的操作：</p>
</li>
<li><p><code>String paramValue = request.getParameter(this.methodParam);</code></p>
</li>
</ul>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/12/SpringMVC-3-%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/12/SpringMVC-3-%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">SpringMVC(3) 响应数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-12 16:56:03 / Modified: 17:12:13" itemprop="dateCreated datePublished" datetime="2023-12-12T16:56:03+08:00">2023-12-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringMVC/" itemprop="url" rel="index"><span itemprop="name">SpringMVC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-页面跳转控制"><a href="#1-页面跳转控制" class="headerlink" title="1. 页面跳转控制"></a>1. 页面跳转控制</h2><h3 id="1-1-快速返回模板视图"><a href="#1-1-快速返回模板视图" class="headerlink" title="1.1 快速返回模板视图"></a>1.1 快速返回模板视图</h3><p>准备jsp页面和依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jsp需要依赖! jstl--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>jsp页面创建</p>
<p>建议位置：/WEB-INF/下，避免外部直接访问！</p>
<p>位置：/WEB-INF/views/home.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;<br>        $&#123;msg&#125;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
<p>配置jsp视图解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableWebMvc</span>  <span class="hljs-comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">//配置jsp对应的视图解析器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//快速配置jsp模板语言对应的</span><br>        registry.jsp(<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>,<span class="hljs-string">&quot;.jsp&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>handler返回视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  跳转到提交文件页面  /save/jump</span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> *  如果要返回jsp页面!</span><br><span class="hljs-comment"> *     1.方法返回值改成字符串类型</span><br><span class="hljs-comment"> *     2.返回逻辑视图名即可    </span><br><span class="hljs-comment"> *         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;</span><br><span class="hljs-comment"> *            + 逻辑视图名 +</span><br><span class="hljs-comment"> *         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;jump&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">jumpJsp</span><span class="hljs-params">(Model model)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;FileController.jumpJsp&quot;</span>);<br>    model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;request data!!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;home&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-2-转发和重定向"><a href="#1-2-转发和重定向" class="headerlink" title="1.2 转发和重定向"></a>1.2 转发和重定向</h3><p>Handler 方法返回值来实现快速转发，可以使用 redirect 或者 forward 关键字来实现重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/redirect-demo&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">redirectDemo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 重定向到 /demo 路径 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/demo&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/forward-demo&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">forwardDemo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 转发到 /demo 路径</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/demo&quot;</span>;<br>&#125;<br><span class="hljs-comment">//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！</span><br></code></pre></td></tr></table></figure>
<h3 id="1-3-使用Thymeleaf"><a href="#1-3-使用Thymeleaf" class="headerlink" title="1.3 使用Thymeleaf"></a>1.3 使用Thymeleaf</h3><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p>
<ol>
<li><code>ThymeleafView</code></li>
</ol>
<p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testHello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testHello</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312121704830.png" alt=""></p>
<ol>
<li>转发视图</li>
</ol>
<p>SpringMVC中默认的转发视图是<code>InternalResourceView</code></p>
<p>SpringMVC中创建转发视图的情况：</p>
<p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建<code>InternalResourceView</code>视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p>
<p>例如”forward:/“，”forward:/employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testForward&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testForward</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312121706160.png" alt="image-20210706201316593"></p>
<ol>
<li>重定向视图</li>
</ol>
<p>SpringMVC中默认的重定向视图是<code>RedirectView</code></p>
<p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p>
<p>例如”redirect:/“，”redirect:/employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRedirect&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedirect</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312121706269.png" alt="image-20210706201602267"></p>
<blockquote>
<p>注：</p>
<p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p>
</blockquote>
<ol>
<li>视图控制器view-controller</li>
</ol>
<p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">	path：设置处理的请求地址</span><br><span class="hljs-comment">	view-name：设置请求地址所对应的视图名称</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testView&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
<p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p>
<mvc:annotation-driven />

</blockquote>
<h2 id="2-返回JSON数据"><a href="#2-返回JSON数据" class="headerlink" title="2. 返回JSON数据"></a>2. 返回JSON数据</h2><p>导入jackson依赖, 添加json数据转化器(<code>@EnableWebMvc</code>)</p>
<p><code>@ResponseBody</code>注解: 将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端</p>
<p><code>@RestController</code>注解: 类上的 <code>@ResponseBody</code> 注解可以和 <code>@Controller</code> 注解合并为 <code>@RestController</code> 注解</p>
<h2 id="3-返回静态资源处理"><a href="#3-返回静态资源处理" class="headerlink" title="3. 返回静态资源处理"></a>3. 返回静态资源处理</h2><p>在 SpringMVC 配置配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span>  <span class="hljs-comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-comment">//配置jsp对应的视图解析器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//快速配置jsp模板语言对应的</span><br>        registry.jsp(<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>,<span class="hljs-string">&quot;.jsp&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> &#123;<br>        configurer.enable();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>web应用加入静态资源</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312121711439.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/10/30/SpringMVC-2-%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/30/SpringMVC-2-%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">SpringMVC(2) 接收数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-30 15:35:04" itemprop="dateCreated datePublished" datetime="2023-10-30T15:35:04+08:00">2023-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-12 17:05:13" itemprop="dateModified" datetime="2023-12-12T17:05:13+08:00">2023-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringMVC/" itemprop="url" rel="index"><span itemprop="name">SpringMVC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-访问路径设置"><a href="#1-访问路径设置" class="headerlink" title="1. 访问路径设置"></a>1. 访问路径设置</h2><ol>
<li><strong>精准路径匹配</strong></li>
</ol>
<ul>
<li><p>在<code>@RequestMapping</code>注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配</p>
</li>
<li><p>value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login success!!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li><strong>模糊路径匹配</strong></li>
</ol>
<ul>
<li>在<code>@RequestMapping</code>注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址</li>
<li><code>/*</code>: 只能匹配URL地址中的一层，如果想准确匹配两层，重复两次即可，如代码示例</li>
<li><code>/**</code>: 可以匹配URL地址中的任意层, 在使用<code>**</code>时，只能使用<code>/**/xxx</code>的方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/product/*/*&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;product show!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li><strong>类和方法级别区别</strong></li>
</ol>
<p><code>@RequestMapping</code> 注解可以用于类级别和方法级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//1.标记到handler方法</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/login&quot;)</span><br><br><span class="hljs-comment">//2.优化标记类+handler方法</span><br><span class="hljs-comment">//类上</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-comment">//handler方法上</span><br><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br></code></pre></td></tr></table></figure>
<ol>
<li><strong>附带请求方式限制</strong></li>
</ol>
<p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RequestMethod</span> &#123;<br>  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE<br>&#125;<br></code></pre></td></tr></table></figure>
<p>默认情况下：<code>@RequestMapping(&quot;/logout&quot;)</code> 任何请求方式都可以访问, 也可以通过method参数指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * method = RequestMethod.POST 可以指定单个或者多个请求方式!</span><br><span class="hljs-comment">     * 注意:违背请求方式会出现405异常!</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;, method = &#123;RequestMethod.POST, RequestMethod.GET&#125;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserController.login&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login success!!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li><strong>进阶注解</strong></li>
</ol>
<p><code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>注意：进阶注解只能添加到handler方法上，无法添加到类上</p>
<blockquote>
<p>目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串(put或delete)，则按照默认的请求方式get处理</p>
<p>若要发送put和delete请求，则需要通过spring提供的过滤器<code>HiddenHttpMethodFilter</code></p>
</blockquote>
<ol>
<li><strong><code>@RequestMapping</code>注解的 params 属性</strong></li>
</ol>
<p>params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p>
<ul>
<li><p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p>
</li>
<li><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p>
</li>
<li><p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p>
</li>
<li><p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><br><span class="hljs-meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span><br><span class="hljs-meta">        ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span><br><span class="hljs-meta">        ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>若当前请求满足 <code>@RequestMapping</code> 注解的 value 和 method 属性，但是不满足 params 属性，此时页面会报错400</p>
</blockquote>
<ol>
<li><strong><code>@RequestMapping</code>注解的headers属性</strong></li>
</ol>
<p>headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p>
<ul>
<li><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p>
</li>
<li><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p>
</li>
<li><p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p>
</li>
<li><p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p>
</li>
</ul>
<blockquote>
<p>若当前请求满足 <code>@RequestMapping</code> 注解的 value 和 method 属性，但是不满足 headers 属性，此时页面显示404错误，即资源未找到</p>
</blockquote>
<h2 id="2-接收参数"><a href="#2-接收参数" class="headerlink" title="2. 接收参数"></a>2. 接收参数</h2><h3 id="2-1-param-和-json-参数比较"><a href="#2-1-param-和-json-参数比较" class="headerlink" title="2.1 param 和 json 参数比较"></a>2.1 param 和 json 参数比较</h3><ol>
<li><p>参数编码：  </p>
<p> param 类型的参数会被编码为 ASCII 码。而 JSON 类型的参数会被编码为 UTF-8。</p>
</li>
<li><p>参数顺序：  </p>
<p> param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p>
</li>
<li><p>数据类型：  </p>
<p> param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p>
</li>
<li><p>嵌套性：  </p>
<p> param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p>
</li>
</ol>
<p>常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p>
<h3 id="2-2-param-参数接收"><a href="#2-2-param-参数接收" class="headerlink" title="2.2 param 参数接收"></a>2.2 param 参数接收</h3><p>只要形参数名和类型与传递参数相同，即可自动接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 可以利用形参列表, 直接接收前端传递的param参数!</span><br><span class="hljs-comment"> *    要求: 参数名 = 形参名   类型相同</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(value=&quot;/value&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">setupForm</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name + <span class="hljs-string">&quot;, age = &quot;</span> + age);<br>    <span class="hljs-keyword">return</span> name + age;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>@RequestParam</code> 注解</p>
<ul>
<li><code>value</code>：指定为形参赋值的请求参数的参数名</li>
<li><code>required</code>：设置是否必须传输此请求参数，默认值为true</li>
<li><code>defaultValue</code>：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</li>
</ul>
<p><strong>特殊情况: </strong></p>
<ol>
<li>一名多值: 多选框，提交的数据的时候一个key对应多个值，可以使用集合进行接收<br>如果使用一个字符串变量，接收到的是使用逗号拼接的结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  一名多值,可以使用集合接收即可!但是需要使用<span class="hljs-doctag">@RequestParam</span>注解指定</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(value=&quot;/mul&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">mulForm</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;hbs = &quot;</span> + hbs);<br>    <span class="hljs-keyword">return</span> hbs;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>实体接收: 要求属性名必须等于参数名</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> &#123;<br>    <span class="hljs-comment">// 在这里可以使用 user 对象的属性来接收请求参数</span><br>    System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-路径参数接收"><a href="#2-3-路径参数接收" class="headerlink" title="2.3 路径参数接收"></a>2.3 路径参数接收</h3><p><code>@PathVariable</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span><br><span class="hljs-comment">  * 形参列表取值: <span class="hljs-doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span><br><span class="hljs-comment">  * 			<span class="hljs-doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * 访问测试:  /user/1/root  -&gt; id = 1  uname = root</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id, </span><br><span class="hljs-params">                      <span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id + <span class="hljs-string">&quot;, uname = &quot;</span> + uname);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user_detail&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-4-JSON参数接收"><a href="#2-4-JSON参数接收" class="headerlink" title="2.4 JSON参数接收"></a>2.4 JSON参数接收</h3><p><code>@RequestBody</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/person&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">addPerson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Person person)</span> &#123;<br>  <span class="hljs-comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：springmvc handlerAdpater要配置json转化器, 配置类需要明确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span><br><br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span><br><span class="hljs-comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span><br><span class="hljs-comment">//2.可以不添加, springmvc会检查是否配置handlerMapping和handlerAdapter, 没有配置默认加载</span><br><span class="hljs-comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span><br><span class="hljs-meta">@EnableWebMvc</span>  <span class="hljs-comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>pom 添加 jackson 依赖</p>
<h2 id="3-接收-Cookie-数据"><a href="#3-接收-Cookie-数据" class="headerlink" title="3. 接收 Cookie 数据"></a>3. 接收 Cookie 数据</h2><p><code>@CookieValue</code> 注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs cookie">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>@CookieValue</code> 注解一共有三个属性：value、required、defaultValue，用法同<code>@RequestParam</code></p>
<h2 id="4-接受请求头数据"><a href="#4-接受请求头数据" class="headerlink" title="4. 接受请求头数据"></a>4. 接受请求头数据</h2><p><code>@RequestHeader</code> 注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs header">Host                    localhost:8080<br>Accept                  text/html,application/xhtml+xml,application/xml;q=0.9<br>Accept-Language         fr,en-gb;q=0.7,en;q=0.3<br>Accept-Encoding         gzip,deflate<br>Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7<br>Keep-Alive              300<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span><br><span class="hljs-params">    			   <span class="hljs-meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="hljs-type">long</span> keepAlive)</span> &#123; <br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>@RequestHeader</code> 注解一共有三个属性：value、required、defaultValue，用法同<code>@RequestParam</code></p>
<h2 id="5-原生-API-对象操作"><a href="#5-原生-API-对象操作" class="headerlink" title="5. 原生 API 对象操作"></a>5. 原生 API 对象操作</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">官方文档</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span><br><span class="hljs-comment"> * 注意: 接收原生对象,并不影响参数接收!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;api&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">api</span><span class="hljs-params">(HttpSession session , HttpServletRequest request,</span><br><span class="hljs-params">                  HttpServletResponse response)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br>    System.out.println(<span class="hljs-string">&quot;method = &quot;</span> + method);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;api&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-共享域对象操作"><a href="#6-共享域对象操作" class="headerlink" title="6. 共享域对象操作"></a>6. 共享域对象操作</h2><h3 id="6-1-属性-共享-域作用回顾"><a href="#6-1-属性-共享-域作用回顾" class="headerlink" title="6.1 属性(共享)域作用回顾"></a>6.1 属性(共享)域作用回顾</h3><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p>
<ol>
<li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li>
<li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li>
<li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li>
<li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li>
</ol>
<p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312121705479.png" alt="img"></p>
<h3 id="6-2-Request级别属性-共享-域"><a href="#6-2-Request级别属性-共享-域" class="headerlink" title="6.2 Request级别属性(共享)域"></a>6.2 Request级别属性(共享)域</h3><ol>
<li>使用 Model 类型的形参</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/attr/request/model&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testAttrRequestModel</span><span class="hljs-params">(Model model)</span> &#123;<br>    <span class="hljs-comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span><br>    <span class="hljs-comment">// 存入请求域这个动作也被称为暴露到请求域</span><br>    model.addAttribute(<span class="hljs-string">&quot;requestScopeMessageModel&quot;</span>,<span class="hljs-string">&quot;i am very happy[model]&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;target&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>使用 ModelMap 类型的形参</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testAttrRequestModelMap</span><span class="hljs-params">(ModelMap modelMap)</span> &#123;<br>    <span class="hljs-comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span><br>    <span class="hljs-comment">// 存入请求域这个动作也被称为暴露到请求域</span><br>    modelMap.addAttribute(<span class="hljs-string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="hljs-string">&quot;i am very happy[model map]&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;target&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>使用 Map 类型的形参</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/attr/request/map&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testAttrRequestMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span> &#123;<br>    <span class="hljs-comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span><br>    <span class="hljs-comment">// 存入请求域这个动作也被称为暴露到请求域</span><br>    map.put(<span class="hljs-string">&quot;requestScopeMessageMap&quot;</span>, <span class="hljs-string">&quot;i am very happy[map]&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;target&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>使用原生 request 对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/attr/request/original&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testAttrOriginalRequest</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>    request.setAttribute(<span class="hljs-string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="hljs-string">&quot;i am very happy[original]&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;target&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>使用 ModelAndView 对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ModelAndView有Model和View的功能</span><br><span class="hljs-comment"> * Model主要用于向请求域共享数据</span><br><span class="hljs-comment"> * View主要用于设置视图，实现页面跳转</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">testAttrByModelAndView</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.创建ModelAndView对象</span><br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    <span class="hljs-comment">// 2.存入模型数据</span><br>    modelAndView.addObject(<span class="hljs-string">&quot;requestScopeMessageMAV&quot;</span>, <span class="hljs-string">&quot;i am very happy[mav]&quot;</span>);<br>    <span class="hljs-comment">// 3.设置视图名称</span><br>    modelAndView.setViewName(<span class="hljs-string">&quot;target&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>Model、ModelMap、Map的关系</strong></p>
<p>Model、ModelMap、Map类型的参数其实本质上都是 <code>BindingAwareModelMap</code> 类型的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Model</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, Object&gt; &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendedModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ModelMap</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Model</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BindingAwareModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExtendedModelMap</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-3-Session级别属性-共享-域"><a href="#6-3-Session级别属性-共享-域" class="headerlink" title="6.3 Session级别属性(共享)域"></a>6.3 Session级别属性(共享)域</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/attr/session&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testAttrSession</span><span class="hljs-params">(HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//直接对session对象操作,即对会话范围操作!</span><br>    session.setAttribute(<span class="hljs-string">&quot;testSessionScope&quot;</span>, <span class="hljs-string">&quot;hello,session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;target&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-4-Application级别属性-共享-域"><a href="#6-4-Application级别属性-共享-域" class="headerlink" title="6.4 Application级别属性(共享)域"></a>6.4 Application级别属性(共享)域</h3><p>SpringMVC 会在初始化容器的时候，将 <code>servletContext</code> 对象存储到 IoC 容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ServletContext servletContext;<br><br><span class="hljs-meta">@RequestMapping(&quot;/attr/application&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">attrApplication</span><span class="hljs-params">()</span> &#123;<br>    servletContext.setAttribute(<span class="hljs-string">&quot;appScopeMsg&quot;</span>, <span class="hljs-string">&quot;i am hungry...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;target&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 或者通过session获取</span><br><span class="hljs-meta">@RequestMapping(&quot;/testApplication&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testApplication</span><span class="hljs-params">(HttpSession session)</span>&#123;<br>	<span class="hljs-type">ServletContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> session.getServletContext();<br>    application.setAttribute(<span class="hljs-string">&quot;testApplicationScope&quot;</span>, <span class="hljs-string">&quot;hello,application&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-解决获取请求参数的乱码问题"><a href="#7-解决获取请求参数的乱码问题" class="headerlink" title="7. 解决获取请求参数的乱码问题"></a>7. 解决获取请求参数的乱码问题</h2><p>解决获取请求参数的乱码问题，可以使用 SpringMVC 提供的编码过滤器<code>CharacterEncodingFilter</code>，但是必须在 web.xml 中进行注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置springMVC的编码过滤器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
<p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/10/30/SpringMVC-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/30/SpringMVC-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">SpringMVC(1) 核心组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-10-30 15:15:12 / Modified: 15:39:21" itemprop="dateCreated datePublished" datetime="2023-10-30T15:15:12+08:00">2023-10-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringMVC/" itemprop="url" rel="index"><span itemprop="name">SpringMVC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-核心组件"><a href="#1-核心组件" class="headerlink" title="1. 核心组件"></a>1. 核心组件</h2><p><strong>SpringMVC处理请求流程：</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310301516806.png" alt="img"></p>
<p><strong>SpringMVC涉及组件理解：</strong></p>
<p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code>  <code>DispatcherServlet</code> 做整体请求处理调度！</p>
<ol>
<li><code>DispatcherServlet</code>: SpringMVC提供，需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发</li>
<li><code>HandlerMapping</code>: SpringMVC提供，需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler</li>
<li><code>HandlerAdapter</code>: SpringMVC提供，需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器</li>
<li><code>Handler</code>: handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果</li>
<li><code>ViewResovler</code>: SpringMVC提供，需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的</li>
</ol>
<h2 id="2-快速体验"><a href="#2-快速体验" class="headerlink" title="2. 快速体验"></a>2. 快速体验</h2><ol>
<li>创建项目</li>
</ol>
<ul>
<li>注意：需要转成maven/web程序</li>
</ul>
<ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>6.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet.api</span>&gt;</span>9.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">servlet.api</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- springioc相关依赖  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- web相关依赖  --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用</span><br><span class="hljs-comment">         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’</span><br><span class="hljs-comment">         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的</span><br><span class="hljs-comment">         Servlet API，没有更新到 Jakarta EE 规范。</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.platform<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;servlet.api&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- springwebmvc相关依赖  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>Controller声明</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * handler就是controller内部的具体方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@RequestMapping</span>(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@ResponseBody</span> 代表向浏览器直接返回数据!</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/springmvc/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;HelloController.hello&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello springmvc!!&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ol>
<li>Spring MVC核心组件配置类</li>
</ol>
<blockquote>
<p>声明springmvc涉及组件信息的配置类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 导入handlerMapping和handlerAdapter的三种方式</span><br><span class="hljs-comment">// 1.自动导入handlerMapping和handlerAdapter [推荐]</span><br><span class="hljs-comment">// 2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span><br><span class="hljs-comment">// 3.使用@Bean方式配置handlerMapper和handlerAdapter</span><br><span class="hljs-meta">@EnableWebMvc</span>     <br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;)</span><br><span class="hljs-comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HandlerMapping <span class="hljs-title function_">handlerMapping</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestMappingHandlerMapping</span>();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HandlerAdapter <span class="hljs-title function_">handlerAdapter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestMappingHandlerAdapter</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ol>
<li>SpringMVC环境搭建</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!</span><br><span class="hljs-comment">//Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类</span><br><span class="hljs-comment">//getServletMappings 返回的地址 设置DispatherServlet对应处理的地址</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 指定service / mapper层的配置类</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 指定springmvc的配置类</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 设置dispatcherServlet的处理路径!</span><br><span class="hljs-comment">   * 一般情况下为 / 代表处理所有请求!</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;/&quot;</span> &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h3><p><strong>配置web.xml</strong></p>
<p>注册SpringMVC的前端控制器DispatcherServlet</p>
<p><strong>a&gt;默认配置方式</strong></p>
<p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为\<servlet-name>-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span><br><span class="hljs-comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span><br><span class="hljs-comment">        但是/不能匹配.jsp请求路径的请求</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>b&gt;扩展配置方式</strong></p>
<p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> 		作为框架的核心组件，在启动过程中有大量的初始化操作要做</span><br><span class="hljs-comment">		而这些操作放在第一次请求时才执行会严重影响访问速度</span><br><span class="hljs-comment">		因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span><br><span class="hljs-comment">	--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span><br><span class="hljs-comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span><br><span class="hljs-comment">        但是/不能匹配.jsp请求路径的请求</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
<p>\<url-pattern>标签中使用/和/*的区别：</p>
<p>/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求</p>
<p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p>
<p>/<em>则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/\</em>的写法</p>
</blockquote>
<p><strong>创建springMVC的配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 自动扫描包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br>    <br>                    <span class="hljs-comment">&lt;!-- 视图前缀 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br>    <br>                    <span class="hljs-comment">&lt;!-- 视图后缀 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">   处理静态资源，例如html、js、css、jpg</span><br><span class="hljs-comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span><br><span class="hljs-comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 开启mvc注解驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultCharset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;supportedMediaTypes&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/10/29/MyBatis-5-%E6%8F%92%E4%BB%B6-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/29/MyBatis-5-%E6%8F%92%E4%BB%B6-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" class="post-title-link" itemprop="url">MyBatis(5) 插件, 逆向工程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-29 00:26:00" itemprop="dateCreated datePublished" datetime="2023-10-29T00:26:00+08:00">2023-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-30 15:00:05" itemprop="dateModified" datetime="2023-10-30T15:00:05+08:00">2023-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-插件"><a href="#1-插件" class="headerlink" title="1. 插件"></a>1. 插件</h2><h3 id="1-1-插件机制"><a href="#1-1-插件机制" class="headerlink" title="1.1 插件机制"></a>1.1 插件机制</h3><p>MyBatis 对插件进行了标准化的设计，并提供了一套可扩展的插件机制。插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改 SQL 语句、映射语句的结果等。</p>
<p>具体来说，MyBatis 的插件机制包括以下三个组件：</p>
<ol>
<li><code>Interceptor</code>（拦截器）：定义一个拦截方法 <code>intercept</code>，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用。</li>
<li><code>Invocation</code>（调用）：实际上是对被拦截的方法的封装，封装了 <code>Object target</code>、<code>Method method</code> 和 <code>Object[] args</code> 这三个字段。</li>
<li><code>InterceptorChain</code>（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。</li>
</ol>
<p>插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解 <code>@Intercepts</code> 来标注需要拦截的对象和方法，然后在 MyBatis 的配置文件中添加插件即可。</p>
<h3 id="1-2-PageHelper"><a href="#1-2-PageHelper" class="headerlink" title="1.2 PageHelper"></a>1.2 PageHelper</h3><p>PageHelper 是 MyBatis 中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle 分页方式），支持多种数据库，并且使用非常简单。</p>
<p>使用说明：<a target="_blank" rel="noopener" href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md</a></p>
<p>使用示例：</p>
<ol>
<li>pom.xml引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>mybatis-config.xml配置分页插件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;helperDialect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>其中，<code>com.github.pagehelper.PageInterceptor</code> 是 PageHelper 插件的名称，<code>dialect</code> 属性用于指定数据库类型（支持多种数据库）</li>
</ul>
<ol>
<li>页插件使用</li>
</ol>
<p>在查询方法中使用分页：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTeacherRelationshipToMulti</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">OrderMapper</span> <span class="hljs-variable">orderMapper</span> <span class="hljs-operator">=</span> session.getMapper(OrderMapper.class);<br>	<span class="hljs-comment">// 开启分页功能 startPage(int pageNum, int pageSize)</span><br>    PageHelper.startPage(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 这里查出来的是就是分页后的结果了</span><br>    List&lt;Order&gt; allOrders = orderMapper.selectAllOrders();<br>    allOrders.forEach(System.out::println);<br><br>    PageInfo&lt;Order&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(allOrders);<br><br>    System.out.println(<span class="hljs-string">&quot;pageInfo = &quot;</span> + pageInfo);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> pageInfo.getTotal(); <span class="hljs-comment">// 获取总记录数</span><br>    System.out.println(<span class="hljs-string">&quot;total = &quot;</span> + total);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pages</span> <span class="hljs-operator">=</span> pageInfo.getPages();  <span class="hljs-comment">// 获取总页数</span><br>    System.out.println(<span class="hljs-string">&quot;pages = &quot;</span> + pages);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNum</span> <span class="hljs-operator">=</span> pageInfo.getPageNum(); <span class="hljs-comment">// 获取当前页码</span><br>    System.out.println(<span class="hljs-string">&quot;pageNum = &quot;</span> + pageNum);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageSize</span> <span class="hljs-operator">=</span> pageInfo.getPageSize(); <span class="hljs-comment">// 获取每页显示记录数</span><br>    System.out.println(<span class="hljs-string">&quot;pageSize = &quot;</span> + pageSize);<br>    List&lt;Order&gt; orders = pageInfo.getList(); <span class="hljs-comment">//获取查询页的数据集合</span><br>    System.out.println(<span class="hljs-string">&quot;orders = &quot;</span> + orders);<br>    orders.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310290058059.png" alt="image-20231029005818987"></p>
<p>常用数据</p>
<ul>
<li>pageNum：当前页的页码  </li>
<li>pageSize：每页显示的条数  </li>
<li>size：当前页显示的真实条数  </li>
<li>total：总记录数  </li>
<li>pages：总页数  </li>
<li>prePage：上一页的页码  </li>
<li>nextPage：下一页的页码</li>
<li>isFirstPage/isLastPage：是否为第一页/最后一页  </li>
<li>hasPreviousPage/hasNextPage：是否存在上一页/下一页  </li>
<li>navigatePages：导航分页的页码数  </li>
<li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li>
</ul>
<h2 id="2-逆向工程"><a href="#2-逆向工程" class="headerlink" title="2. 逆向工程"></a>2. 逆向工程</h2><p>MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件</p>
<p>MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。</p>
<h3 id="2-1-MyBatisX"><a href="#2-1-MyBatisX" class="headerlink" title="2.1 MyBatisX"></a>2.1 MyBatisX</h3><p>MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤：</p>
<ol>
<li>IDEA连接数据库后，选择要使用的表，右键使用插件</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310301345103.png" alt="image-20231030134544045"></p>
<ol>
<li>填写实体类生成的位置</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310301348933.png" alt="image-20231030134825882" style="zoom:67%;" /></p>
<ol>
<li>配置mapper模式</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310301351666.png" alt="image-20231030135156612" style="zoom:67%;" /></p>
<ol>
<li>生成结果</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310301353349.png" alt="image-20231030135338311" style="zoom:67%;" /></p>
<h3 id="2-2-MyBatis-Generator"><a href="#2-2-MyBatis-Generator" class="headerlink" title="2.2 MyBatis Generator"></a>2.2 MyBatis Generator</h3><ol>
<li>添加依赖和插件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 构建过程中用到的插件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 插件的依赖 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>创建MyBatis配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.whale.mybatis.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.whale.mybatis.mapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>创建逆向工程的配置文件</li>
</ol>
<ul>
<li>文件名必须是 <code>generatorConfig.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        targetRuntime: 执行生成的逆向工程的版本</span><br><span class="hljs-comment">        MyBatis3Simple: 生成基本的CRUD</span><br><span class="hljs-comment">        MyBatis3: 生成带条件的CRUD</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 数据库的连接信息 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                                <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ssmdb&quot;</span></span><br><span class="hljs-tag">                                <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;...&quot;</span></span><br><span class="hljs-tag">                                <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- javaBean的生成策略--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.whale.mybatis.pojo&quot;</span></span><br><span class="hljs-tag">                                    <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.whale.mybatis.mapper&quot;</span></span><br><span class="hljs-tag">                                 <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\resources&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- Mapper接口的生成策略 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span></span><br><span class="hljs-tag">                                     <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.whale.mybatis.mapper&quot;</span></span><br><span class="hljs-tag">                                     <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 逆向分析的表 --&gt;</span><br>                <span class="hljs-comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br>                <span class="hljs-comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_order&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Order&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_customer&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Customer&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>执行插件</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310301434052.png" alt="image-20231030143409994" style="zoom:80%;" /></p>
<ol>
<li>查看结果</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310301435031.png" alt="image-20231030143529990" style="zoom:67%;" /></p>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p><strong>查询</strong></p>
<ul>
<li><code>selectByExample</code>：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据</li>
<li><code>example.createCriteria().xxx</code>：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</li>
<li><code>example.or().xxx</code>：将之前添加的条件通过or拼接其他条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMBG</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">OrderMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(OrderMapper.class);<br><br>        <span class="hljs-comment">//查询所有数据</span><br>        List&lt;Order&gt; list1 = mapper.selectByExample(<span class="hljs-literal">null</span>);<br>        list1.forEach(System.out::println);<br><br>        <span class="hljs-comment">//根据条件查询</span><br>        <span class="hljs-type">OrderExample</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderExample</span>();<br>        example.createCriteria().andCustomerIdEqualTo(<span class="hljs-number">1</span>).andOrderIdGreaterThanOrEqualTo(<span class="hljs-number">4</span>);<br>        example.or().andOrderIdEqualTo(<span class="hljs-number">1</span>);<br>        List&lt;Order&gt; list2 = mapper.selectByExample(example);<br>        list2.forEach(System.out::println);<br>        <br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>增删改</strong></p>
<ul>
<li><code>updateByPrimaryKey()</code>：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null</li>
<li><p><code>updateByPrimaryKeySelective()</code>：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段</p>
</li>
<li><p><code>insert()</code></p>
</li>
<li><code>insertSelective()</code></li>
<li><code>deleteByExample()</code></li>
<li><code>deleteByPrimaryKey()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据主键更改</span><br>mapper.updateByPrimaryKey(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-literal">null</span>));<br>mapper.updateByPrimaryKeySelective(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;admin&quot;</span>,  <span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/10/27/MyBatis-4-%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/27/MyBatis-4-%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">MyBatis(4) 缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-27 20:11:16" itemprop="dateCreated datePublished" datetime="2023-10-27T20:11:16+08:00">2023-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-30 15:00:52" itemprop="dateModified" datetime="2023-10-30T15:00:52+08:00">2023-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1. 一级缓存"></a>1. 一级缓存</h2><p>一级缓存是<code>SqlSession</code>级别的，通过同一个<code>SqlSession</code>查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p>
<p>使一级缓存失效的四种情况:</p>
<ul>
<li>不同的<code>SqlSession</code>对应不同的一级缓存  </li>
<li>同一个<code>SqlSession</code>但是查询条件不同</li>
<li>同一个<code>SqlSession</code>两次查询期间执行了任何一次<strong>增删改</strong>操作</li>
<li>同一个<code>SqlSession</code>两次查询期间手动清空了缓存</li>
</ul>
<p>一级缓存是<strong>默认开启</strong>的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">OrderMapper</span> <span class="hljs-variable">orderMapper</span> <span class="hljs-operator">=</span> session.getMapper(OrderMapper.class);<br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order1</span> <span class="hljs-operator">=</span> orderMapper.selectOrderWithCustomerById(<span class="hljs-number">2</span>);<br>    System.out.println(order1);<br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> orderMapper.selectOrderWithCustomerById(<span class="hljs-number">2</span>);<br>    System.out.println(order2);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310272206039.png" alt="image-20231027220655955"></p>
<p>当两次查询中间执行一次插入操作, 一级缓存失效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">OrderMapper</span> <span class="hljs-variable">orderMapper</span> <span class="hljs-operator">=</span> session.getMapper(OrderMapper.class);<br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order1</span> <span class="hljs-operator">=</span> orderMapper.selectOrderWithCustomerById(<span class="hljs-number">2</span>);<br>    System.out.println(order1);<br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;o5&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;c01&quot;</span>, <span class="hljs-literal">null</span>));<br>    orderMapper.insertOrder(order);<br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> orderMapper.selectOrderWithCustomerById(<span class="hljs-number">2</span>);<br>    System.out.println(order2);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310281653397.png" alt="image-20231028165357327"></p>
<h2 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2. 二级缓存"></a>2. 二级缓存</h2><p>二级缓存是<code>SqlSessionFactory</code>级别，通过同一个<code>SqlSessionFactory</code>创建的<code>SqlSession</code>查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p>
<p>二级缓存开启的条件:</p>
<ul>
<li>在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置</li>
<li>在映射文件中添加标签<code>&lt;cache /&gt;</code></li>
<li>二级缓存必须在<code>SqlSession</code>关闭或提交之后有效</li>
<li>查询的数据所转换的实体类类型必须实现序列化的接口</li>
</ul>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTwoCache</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession1</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">OrderMapper</span> <span class="hljs-variable">mapper1</span> <span class="hljs-operator">=</span> sqlSession1.getMapper(OrderMapper.class);<br>        System.out.println(mapper1.selectOrderWithCustomerById(<span class="hljs-number">1</span>));<br>        sqlSession1.close();<br><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession2</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">OrderMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> sqlSession2.getMapper(OrderMapper.class);<br>        System.out.println(mapper2.selectOrderWithCustomerById(<span class="hljs-number">1</span>));<br>        sqlSession2.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 OrderMapper.xml 中添加 <code>&lt;cache/&gt;</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310282030660.png" alt="image-20231028203039622"></p>
<p>Order, Customer类实现 <code>Serializable</code> 接口</p>
<p>测试结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310282028453.png" alt="image-20231028202841386"></p>
<h3 id="2-1-MyBatis缓存查询的顺序"><a href="#2-1-MyBatis缓存查询的顺序" class="headerlink" title="2.1 MyBatis缓存查询的顺序"></a>2.1 MyBatis缓存查询的顺序</h3><ul>
<li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用  </li>
<li>如果二级缓存没有命中，再查询一级缓存  </li>
<li>如果一级缓存也没有命中，则查询数据库  </li>
<li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li>
</ul>
<h2 id="3-整合第三方缓存EHCache"><a href="#3-整合第三方缓存EHCache" class="headerlink" title="3. 整合第三方缓存EHCache"></a>3. 整合第三方缓存EHCache</h2><p><strong>通过第三方实现二级缓存</strong></p>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Mybatis核心 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- junit测试 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log4j2日志 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.21.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.21.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log4j2适配slf4j --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.21.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- slf4j-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.36<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>创建EHCache的配置文件ehcache.xml</p>
<ul>
<li>名字必须叫<code>ehcache.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 磁盘保存路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;D:\ehcache&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span><br><span class="hljs-tag">            <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">maxElementsOnDisk</span>=<span class="hljs-string">&quot;10000000&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;120&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;120&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;120&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;LRU&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">defaultCache</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置</p>
</blockquote>
<p>mapper文件配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认的二级缓存--&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;cache/&gt; --&gt;</span><br><br><span class="hljs-comment">&lt;!--使用EhcacheCache缓存--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>配置文件说明</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th>是否必须</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">maxElementsInMemory</td>
<td>是</td>
<td>在内存中缓存的element的最大数目</td>
</tr>
<tr>
<td style="text-align:left">maxElementsOnDisk</td>
<td>是</td>
<td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td>
</tr>
<tr>
<td style="text-align:left">eternal</td>
<td>是</td>
<td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效, 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td>
</tr>
<tr>
<td style="text-align:left">overflowToDisk</td>
<td>是</td>
<td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td>
</tr>
<tr>
<td style="text-align:left">timeToIdleSeconds</td>
<td>否</td>
<td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时, 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td>
</tr>
<tr>
<td style="text-align:left">timeToLiveSeconds</td>
<td>否</td>
<td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td>
</tr>
<tr>
<td style="text-align:left">diskSpoolBufferSizeMB</td>
<td>否</td>
<td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td>
</tr>
<tr>
<td style="text-align:left">diskPersistent</td>
<td>否</td>
<td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false</td>
</tr>
<tr>
<td style="text-align:left">diskExpiryThreadIntervalSeconds</td>
<td>否</td>
<td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s, 相应的线程会进行一次EhCache中数据的清理工作</td>
</tr>
<tr>
<td style="text-align:left">memoryStoreEvictionPolicy</td>
<td>否</td>
<td>当内存缓存达到最大，有新的element加入的时候，移除缓存中element的策略。 默认是LRU(最近最少使用)，可选的有LFU(最不常使用)和FIFO(先进先出)</td>
</tr>
</tbody>
</table>
</div>
<p>测试结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310282352842.png" alt="image-20231028235227770"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/10/26/MyBatis-Param%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/26/MyBatis-Param%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">MyBatis @Param分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-26 16:28:18" itemprop="dateCreated datePublished" datetime="2023-10-26T16:28:18+08:00">2023-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-30 15:00:56" itemprop="dateModified" datetime="2023-10-30T15:00:56+08:00">2023-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>当使用 MyBatis 时，如果接口中抽象方法有多个简单类型参数，MyBatis无法识别抽象方法参数的自定义名称，需要使用 <code>@Param</code> 为每个参数命名，以检查用户登录为例</p>
<p>有注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">checkLoginByParam</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String username, <span class="hljs-meta">@Param(&quot;pwd&quot;)</span> String password)</span>;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261632778.png" alt="image-20231026163255722"></p>
<p>无注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(String username, String password)</span>;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261633355.png" alt="image-20231026163359314"></p>
<h2 id="2-使用-Param"><a href="#2-使用-Param" class="headerlink" title="2. 使用@Param"></a>2. 使用@Param</h2><p>测试类代码如下，通过 debug 分析 <code>@Param</code> 在底层如何发挥作用</p>
<p>断点设置为 <code>checkLoginByParam</code> 行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCheckLoginByParam</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> SqlSessionUtils.getSqlSession();<br>    <span class="hljs-type">ParameterMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(ParameterMapper.class);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.checkLoginByParam(<span class="hljs-string">&quot;hoyt&quot;</span>, <span class="hljs-string">&quot;907&quot;</span>);<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>进入 <code>org.apache.ibatis.binding.MapperProxy.invoke</code></p>
<ul>
<li><code>public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable</code></li>
<li>从类名可以看出底层使用的是动态代理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> Object.class.equals(method.getDeclaringClass()) ? method.invoke(<span class="hljs-built_in">this</span>, args) : <span class="hljs-built_in">this</span>.cachedInvoker(method).invoke(proxy, method, args, <span class="hljs-built_in">this</span>.sqlSession);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;<br>        <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来先调用该类中 <code>cachedInvoker(method)</code> 方法返回 <code>MapperMethodInvoker</code>，再调用其 <code>invoke(proxy, method, args, this.sqlSession)</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261646968.png" alt="image-20231026164615912"></p>
<blockquote>
<p>此处 command 中的 name 即为 MyBatis Mapper 文件中的 <code>命名空间.方法id</code></p>
</blockquote>
<p><code>execute</code> 方法相对复杂，会对方法的类型分类讨论</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> &#123;<br>    Object result;<br>    Object param;<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.command.getType()) &#123;<br>        <span class="hljs-keyword">case</span> INSERT:<br>            param = <span class="hljs-built_in">this</span>.method.convertArgsToSqlCommandParam(args);<br>            result = <span class="hljs-built_in">this</span>.rowCountResult(sqlSession.insert(<span class="hljs-built_in">this</span>.command.getName(), param));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> UPDATE:<br>            param = <span class="hljs-built_in">this</span>.method.convertArgsToSqlCommandParam(args);<br>            result = <span class="hljs-built_in">this</span>.rowCountResult(sqlSession.update(<span class="hljs-built_in">this</span>.command.getName(), param));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DELETE:<br>            param = <span class="hljs-built_in">this</span>.method.convertArgsToSqlCommandParam(args);<br>            result = <span class="hljs-built_in">this</span>.rowCountResult(sqlSession.delete(<span class="hljs-built_in">this</span>.command.getName(), param));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SELECT:<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsVoid() &amp;&amp; <span class="hljs-built_in">this</span>.method.hasResultHandler()) &#123;<br>                <span class="hljs-built_in">this</span>.executeWithResultHandler(sqlSession, args);<br>                result = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsMany()) &#123;<br>                result = <span class="hljs-built_in">this</span>.executeForMany(sqlSession, args);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsMap()) &#123;<br>                result = <span class="hljs-built_in">this</span>.executeForMap(sqlSession, args);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsCursor()) &#123;<br>                result = <span class="hljs-built_in">this</span>.executeForCursor(sqlSession, args);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 会跳到这里继续执行</span><br>                param = <span class="hljs-built_in">this</span>.method.convertArgsToSqlCommandParam(args);<br>                result = sqlSession.selectOne(<span class="hljs-built_in">this</span>.command.getName(), param);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsOptional() &amp;&amp; (result == <span class="hljs-literal">null</span> || !<span class="hljs-built_in">this</span>.method.getReturnType().equals(result.getClass()))) &#123;<br>                    result = Optional.ofNullable(result);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FLUSH:<br>            result = sqlSession.flushStatements();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Unknown execution method for: &quot;</span> + <span class="hljs-built_in">this</span>.command.getName());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.method.getReturnType().isPrimitive() &amp;&amp; !<span class="hljs-built_in">this</span>.method.returnsVoid()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Mapper method &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.command.getName() + <span class="hljs-string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + <span class="hljs-built_in">this</span>.method.getReturnType() + <span class="hljs-string">&quot;).&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>这里也可以看到，传到底层的参数是只有值的，没有保存参数名</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261652877.png" alt="image-20231026165252847"></p>
</blockquote>
<p>执行到 <code>param = this.method.convertArgsToSqlCommandParam(args);</code> 然后该方法继续跳转到 <code>getNamedParams</code></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261656742.png" alt="image-20231026165632710"></p>
<p>此处关键点即为 names 成员变量，<code>private final SortedMap&lt;Integer, String&gt; names;</code>，在构造函数中被赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ParamNameResolver</span><span class="hljs-params">(Configuration config, Method method)</span> &#123;<br>    <span class="hljs-built_in">this</span>.useActualParamName = config.isUseActualParamName();<br>    Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); <span class="hljs-comment">// 获取参数类型</span><br>    Annotation[][] paramAnnotations = method.getParameterAnnotations(); <span class="hljs-comment">// 获取所有参数的所有注解, 一维数组是参数，二维是注解</span><br>    SortedMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">paramCount</span> <span class="hljs-operator">=</span> paramAnnotations.length; <span class="hljs-comment">// 参数数量</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">paramIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; paramIndex &lt; paramCount; ++paramIndex) &#123; <span class="hljs-comment">// 遍历参数</span><br>        <span class="hljs-keyword">if</span> (!isSpecialParameter(paramTypes[paramIndex])) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            Annotation[] var9 = paramAnnotations[paramIndex]; <span class="hljs-comment">// 该参数所有注解</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">var10</span> <span class="hljs-operator">=</span> var9.length; <span class="hljs-comment">// 该参数注解个数</span><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var11</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var11 &lt; var10; ++var11) &#123;<br>                <span class="hljs-type">Annotation</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> var9[var11];<br>                <span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> Param) &#123;<br>                    <span class="hljs-built_in">this</span>.hasParamAnnotation = <span class="hljs-literal">true</span>;<br>                    name = ((Param)annotation).value(); <span class="hljs-comment">// @Param注解的值，即变量名</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.useActualParamName) &#123;<br>                    name = <span class="hljs-built_in">this</span>.getActualParamName(method, paramIndex);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>                    name = String.valueOf(map.size());<br>                &#125;<br>            &#125;<br><br>            map.put(paramIndex, name); <span class="hljs-comment">// 将每个参数的下标和名称保存</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.names = Collections.unmodifiableSortedMap(map);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样就获取到了 <code>@Param</code> 中设置的变量名</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261703909.png" alt="image-20231026170320870"></p>
<p>回到 <code>getNamedParams</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getNamedParams</span><span class="hljs-params">(Object[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">paramCount</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.names.size();<br>    <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span> &amp;&amp; paramCount != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hasParamAnnotation &amp;&amp; paramCount == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 只有一个变量且没有标注@Param</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> args[(Integer)<span class="hljs-built_in">this</span>.names.firstKey()];<br>            <span class="hljs-keyword">return</span> wrapToMapIfCollection(value, <span class="hljs-built_in">this</span>.useActualParamName ? (String)<span class="hljs-built_in">this</span>.names.get(<span class="hljs-number">0</span>) : <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 标注了@Param或多个变量</span><br>            Map&lt;String, Object&gt; param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperMethod</span>.ParamMap();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>			<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">Iterator</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.names.entrySet().iterator(); var5.hasNext(); ++i) &#123;<br>                Map.Entry&lt;Integer, String&gt; entry = (Map.Entry)var5.next();<br>                param.put(entry.getValue(), args[(Integer)entry.getKey()]); <span class="hljs-comment">// 添加@Param设置的名称</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">genericParamName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;param&quot;</span> + (i + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.names.containsValue(genericParamName)) &#123; <span class="hljs-comment">// 避免覆盖@Param设置的名称</span><br>                    param.put(genericParamName, args[(Integer)entry.getKey()]); <span class="hljs-comment">// 添加通用变量名 param1, param2...</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> param;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在的param</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261713917.png" alt="image-20231026171340869"></p>
<h2 id="3-不使用-Param"><a href="#3-不使用-Param" class="headerlink" title="3. 不使用@Param"></a>3. 不使用@Param</h2><p>不使用 <code>@Param</code> 只能使用 arg0, arg1… 或者 param1, param2…</p>
<p>param 的情况已经分析过了，现在讨论使用 arg 的情况</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User checkLogin(String username, String password);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkLogin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>一样打断点进行分析，大部分和 2 一致，区别在于 <code>ParamNameResolver</code> 的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.useActualParamName) &#123;<br>        name = <span class="hljs-built_in">this</span>.getActualParamName(method, paramIndex); <span class="hljs-comment">// 进入了这里</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>        name = String.valueOf(map.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>后面就是方法的调用，不详细说明了</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261728813.png" alt="image-20231026172836774"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261728001.png" alt="image-20231026172855966"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261729580.png" alt="image-20231026172913541"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261729537.png" alt="image-20231026172936494"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261731955.png" alt="image-20231026173139900"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261733234.png" alt="image-20231026173338187"></p>
<p>最终names为</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261735781.png" alt="image-20231026173503741"></p>
<p>param为</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310261736411.png" alt="image-20231026173644373"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/10/25/MyBatis-3-%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/25/MyBatis-3-%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">MyBatis(3) 动态语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-25 23:20:28" itemprop="dateCreated datePublished" datetime="2023-10-25T23:20:28+08:00">2023-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-30 15:00:49" itemprop="dateModified" datetime="2023-10-30T15:00:49+08:00">2023-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-if-where"><a href="#1-if-where" class="headerlink" title="1. if, where"></a>1. if, where</h2><p>if：根据标签中test属性所对应的表达式决定标签中的内容是否需要拼接到SQL中</p>
<p>where：</p>
<ul>
<li>当where标签中有内容时，会自动生成where关键字，并且将内容前多余的and或or去掉</li>
<li>当where标签中没有内容时，此时where标签没有任何效果</li>
<li>注意：where标签不能将其中内容后面多余的and或or去掉</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>    select emp_id, emp_name, emp_salary from t_emp<br>    <span class="hljs-comment">&lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt;</span><br>            or emp_name = #&#123;empName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;gt;</span> 2000&quot;</span>&gt;</span><br>            or emp_salary &gt; #&#123;empSalary&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">         第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;?</span><br><span class="hljs-comment">         第二种情况：部分条件满足 WHERE emp_salary&gt;?</span><br><span class="hljs-comment">         第三种情况：所有条件都不满足 没有where子句</span><br><span class="hljs-comment">         --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="2-set"><a href="#2-set" class="headerlink" title="2. set"></a>2. set</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span><br>    update t_emp<br>    <span class="hljs-comment">&lt;!-- set emp_name = #&#123;empName&#125;, emp_salary = #&#123;empSalary&#125; --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span><br>            emp_name = #&#123;empName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span><br>            emp_salary = #&#123;empSalary&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where emp_id=#&#123;empId&#125;<br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">         第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?</span><br><span class="hljs-comment">         第二种情况：部分条件满足 SET emp_salary=?</span><br><span class="hljs-comment">         第三种情况：所有条件都不满足 update t_emp where emp_id=?</span><br><span class="hljs-comment">            没有set子句的update语句会导致SQL语法错误</span><br><span class="hljs-comment">     --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="3-trim"><a href="#3-trim" class="headerlink" title="3. trim"></a>3. trim</h2><p>使用trim标签控制条件部分两端是否包含某些字符</p>
<ul>
<li>prefix属性：指定要动态添加的前缀</li>
<li>suffix属性：指定要动态添加的后缀</li>
<li>prefixOverrides属性：指定要动态去掉的前缀，使用”|”分隔有可能的多个值</li>
<li>suffixOverrides属性：指定要动态去掉的后缀，使用”|”分隔有可能的多个值</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByConditionByTrim&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span><br>    select emp_id, emp_name, emp_age, emp_salary, emp_gender<br>    from t_emp<br>    <br>    <span class="hljs-comment">&lt;!-- prefix属性指定要动态添加的前缀 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- suffix属性指定要动态添加的后缀 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span><br>            emp_name=#&#123;empName&#125; and<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;gt;</span> 3000&quot;</span>&gt;</span><br>            emp_salary&gt;#&#123;empSalary&#125; and<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empAge <span class="hljs-symbol">&amp;lt;</span>= 20&quot;</span>&gt;</span><br>            emp_age=#&#123;empAge&#125; or<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empGender==&#x27;male&#x27;&quot;</span>&gt;</span><br>            emp_gender=#&#123;empGender&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="4-choose-when-otherwise"><a href="#4-choose-when-otherwise" class="headerlink" title="4. choose, when, otherwise"></a>4. choose, when, otherwise</h2><p>在多个分支条件中，仅执行一个。</p>
<ul>
<li>从上到下依次执行条件判断</li>
<li>遇到的第一个满足条件的分支会被采纳</li>
<li>被采纳分支后面的分支都将不被考虑</li>
<li>如果所有的when分支都不满足，那么就执行otherwise分支</li>
<li>when至少要有一个，otherwise最多只能有一个</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span><br>    select emp_id, emp_name, emp_salary from t_emp<br>    where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="hljs-symbol">&amp;lt;</span> 3000<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>1=1<span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     第一种情况：第一个when满足条件 where emp_name=?</span><br><span class="hljs-comment">     第二种情况：第二个when满足条件 where emp_salary &lt; 3000</span><br><span class="hljs-comment">     第三种情况：两个when都不满足 where 1=1 执行了otherwise</span><br><span class="hljs-comment">     --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="5-foreach"><a href="#5-foreach" class="headerlink" title="5. foreach"></a>5. foreach</h2><p>collection属性：要遍历的集合</p>
<p>item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象</p>
<p>separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符</p>
<p>open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串</p>
<p>close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串</p>
<p>index属性：这里起一个名字，便于后面引用</p>
<ul>
<li><p>遍历List集合，这里能够得到List集合的索引值</p>
</li>
<li><p>遍历Map集合，这里能够得到Map集合的key</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 批量插入 --&gt;</span><br><span class="hljs-comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertMoreByList&quot;</span>&gt;</span><br>    insert into t_emp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;values&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;myIndex&quot;</span>&gt;</span><br>        (null, #&#123;emp.empName&#125;, #&#123;emp.age&#125;, #&#123;emp.sex&#125;, #&#123;emp.email&#125;, #&#123;myIndex&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 批量删除 --&gt;</span><br><span class="hljs-comment">&lt;!--int deleteMoreByArray(@Param(&quot;eids&quot;) Integer[] eids);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMoreByArray&quot;</span>&gt;</span><br>    delete from t_emp where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>        eid = #&#123;eid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        delete from t_emp where eid in</span><br><span class="hljs-comment">        &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span><br><span class="hljs-comment">            #&#123;eid&#125;</span><br><span class="hljs-comment">        &lt;/foreach&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>关于foreach标签的collection属性</strong></p>
<p>如果没有给接口中List类型的参数使用<code>@Param</code>注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来：</p>
<p><code>Parameter &#39;orderIds&#39; not found. Available parameters are [arg0, collection, list]</code></p>
<p>数组类型可用的参数名为 [array, arg0]</p>
<p><strong>批量更新时需要注意</strong></p>
<p>上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs .properties">dev.url=jdbc:mysql://localhost:3306/mybatis-db?allowMultiQueries=true<br></code></pre></td></tr></table></figure>
<p>对应的foreach标签如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateEmployeeBatch&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;empList&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;;&quot;</span>&gt;</span><br>        update t_emp set emp_name = #&#123;emp.empName&#125; where emp_id = #&#123;emp.empId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="6-sql片段"><a href="#6-sql片段" class="headerlink" title="6. sql片段"></a>6. sql片段</h2><p>提取重复的 SQL 片段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mySelectSql&quot;</span>&gt;</span><br>    select emp_id, emp_name, emp_age, emp_salary, emp_gender from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>引用已提取的SQL片段</p>
<ul>
<li>直接嵌入到sql语句中即可</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用include标签引用声明的SQL片段 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;mySelectSql&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/10/25/MyBatis-2-%E5%A4%9A%E8%A1%A8%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/25/MyBatis-2-%E5%A4%9A%E8%A1%A8%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">MyBatis(2) 多表映射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-25 00:34:18" itemprop="dateCreated datePublished" datetime="2023-10-25T00:34:18+08:00">2023-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-30 15:00:46" itemprop="dateModified" datetime="2023-10-30T15:00:46+08:00">2023-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-对一映射"><a href="#1-对一映射" class="headerlink" title="1. 对一映射"></a>1. 对一映射</h2><blockquote>
<p>关键词: <code>association</code>标签/<code>javaType</code>属性/<code>property</code>属性</p>
</blockquote>
<p>设计实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer customerId;<br>    <span class="hljs-keyword">private</span> String customerName;<br>    <span class="hljs-keyword">private</span> List&lt;Order&gt; orderList;<span class="hljs-comment">// 对多关系</span><br>&#125;  <br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer orderId;<br>    <span class="hljs-keyword">private</span> String orderName;<br>    <span class="hljs-keyword">private</span> Customer customer;<span class="hljs-comment">// 对一关系</span><br>&#125;  <br></code></pre></td></tr></table></figure>
<h3 id="1-1-通过association标签实现"><a href="#1-1-通过association标签实现" class="headerlink" title="1.1 通过association标签实现"></a>1.1 通过association标签实现</h3><p>OrderMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> &#123;<br>	Order <span class="hljs-title function_">selectOrderWithCustomer</span><span class="hljs-params">(Integer orderId)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>OrderMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectOrderWithCustomerResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 使用association标签配置“对一”关联关系 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- javaType属性：一的一端类的全类名 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Order selectOrderWithCustomerById(Integer orderId);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectOrderWithCustomerById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectOrderWithCustomerResultMap&quot;</span>&gt;</span><br>    select order_id, order_name, c.customer_id, customer_name<br>    from t_order o<br>    left join ssmdb.t_customer c<br>        on o.customer_id = c.customer_id<br>    where o.order_id=#&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>经测试，将查询语句中的字段添加上表名不影响结果，例如将 <code>order_id</code> 改为 <code>o.order_id</code></p>
<p>配置文件中的 <code>&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</code> 也不影响结果</p>
</blockquote>
<p>测试结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310252026637.png" alt="image-20231025202642558"></p>
<h3 id="1-2-通过级联属性赋值实现"><a href="#1-2-通过级联属性赋值实现" class="headerlink" title="1.2 通过级联属性赋值实现"></a>1.2 通过级联属性赋值实现</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectOrderWithCustomerResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 也可以通过级联属性赋值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customer.customerId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customer.customerName&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="1-3-通过分步查询实现"><a href="#1-3-通过分步查询实现" class="headerlink" title="1.3 通过分步查询实现"></a>1.3 通过分步查询实现</h3><p>OrderMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectOrderWithCustomerByStepResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        select:设置分步查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</span><br><span class="hljs-comment">        column:设置分步查询的条件,字段名</span><br><span class="hljs-comment">        fetchType:当开启了全局的延迟加载之后，可通过此属性手动控制延迟加载的效果</span><br><span class="hljs-comment">        fetchType=&quot;lazy|eager&quot;: lazy表示延迟加载，eager表示立即加载</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customer&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;top.whalefall.mapper.CustomerMapper.selectOrderWithCustomerStepTwo&quot;</span> 	# <span class="hljs-attr">步骤二写在了另一个mapper文件中</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;eager&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Order selectOrderWithCustomerStepOne(Integer orderId);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectOrderWithCustomerStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectOrderWithCustomerByStepResultMap&quot;</span>&gt;</span><br>    select order_id, order_name, customer_id<br>    from t_order<br>    where order_id = #&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>CustomerMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Customer selectOrderWithCustomerStepTwo(Integer customerId);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectOrderWithCustomerStepTwo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    select customer_id, customer_name<br>    from t_customer<br>    where customer_id = #&#123;customerId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRelationshipToOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">OrderMapper</span> <span class="hljs-variable">orderMapper</span> <span class="hljs-operator">=</span> session.getMapper(OrderMapper.class);<br>    <span class="hljs-comment">// 查询Order对象，检查是否同时查询了关联的Customer对象</span><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectOrderWithCustomerStepOne(<span class="hljs-number">2</span>);<br>    log.info(<span class="hljs-string">&quot;order = &quot;</span> + order);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310270132590.png" alt="image-20231027013257480"></p>
<h2 id="2-对多映射"><a href="#2-对多映射" class="headerlink" title="2. 对多映射"></a>2. 对多映射</h2><blockquote>
<p>关键词: <code>collection</code>标签/<code>ofType</code>属性/<code>property</code>属性</p>
</blockquote>
<h3 id="2-1-通过collection标签实现"><a href="#2-1-通过collection标签实现" class="headerlink" title="2.1 通过collection标签实现"></a>2.1 通过collection标签实现</h3><p>CustomerMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Customer <span class="hljs-title function_">selectCustomerWithOrderListById</span><span class="hljs-params">(Integer customerId)</span>;<br></code></pre></td></tr></table></figure>
<p>CustomerMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- collection标签：映射“对多”的关联关系 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- ofType属性：集合属性中元素的类型 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Customer selectCustomerWithOrderListById(Integer customerId);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListResultMap&quot;</span>&gt;</span><br>    select c.customer_id, c.customer_name, o.order_id, o.order_name<br>    from t_customer c<br>    left join ssmdb.t_order o<br>        on c.customer_id = o.customer_id<br>    where c.customer_id = #&#123;customerId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310252303723.png" alt="image-20231025230346652"></p>
<h3 id="2-2-通过分步查询实现"><a href="#2-2-通过分步查询实现" class="headerlink" title="2.2 通过分步查询实现"></a>2.2 通过分步查询实现</h3><p>CustomerMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListByStepResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderList&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;top.whalefall.mapper.OrderMapper.selectCustomerWithOrderListStepTwo&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;eager&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Customer selectCustomerWithOrderListStepOne(Integer customerId);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListStepOne&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListByStepResultMap&quot;</span>&gt;</span><br>    select customer_id, customer_name<br>    from t_customer<br>    where customer_id = #&#123;customerId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>OrderMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;Order&gt; selectCustomerWithOrderListStepTwo(Integer customerId);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListStepTwo&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>    select order_id, order_name, customer_id<br>    from t_order<br>    where customer_id = #&#123;customerId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRelationshipToMulti</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">CustomerMapper</span> <span class="hljs-variable">customerMapper</span> <span class="hljs-operator">=</span> session.getMapper(CustomerMapper.class);<br>    <span class="hljs-comment">// 查询Customer对象同时将关联的Order集合查询出来</span><br>    <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> customerMapper.selectCustomerWithOrderListStepOne(<span class="hljs-number">1</span>);<br>    log.info(<span class="hljs-string">&quot;customer.getCustomerId() = &quot;</span> + customer.getCustomerId());<br>    log.info(<span class="hljs-string">&quot;customer.getCustomerName() = &quot;</span> + customer.getCustomerName());<br>    <span class="hljs-comment">// 如果设置为懒加载, 且不执行下面代码的话只会查第一步</span><br>    List&lt;Order&gt; orderList = customer.getOrderList();<br>    <span class="hljs-keyword">for</span> (Order order : orderList) &#123;<br>        log.info(<span class="hljs-string">&quot;order = &quot;</span> + order);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-多表映射优化"><a href="#3-多表映射优化" class="headerlink" title="3. 多表映射优化"></a>3. 多表映射优化</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">设置名</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">有效值</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>autoMappingBehavior</code></td>
<td style="text-align:left">指定 MyBatis 应如何自动映射列到字段或属性。NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td>
<td style="text-align:left">NONE, PARTIAL, FULL</td>
<td style="text-align:left">PARTIAL</td>
</tr>
</tbody>
</table>
</div>
<p>将 <code>autoMappingBehavior</code> 设置为full, 进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名=属性名，或者开启驼峰映射也可以自定映射）的result标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开启resultMap自动映射 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;FULL&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>省略 <code>result</code> 标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>	<span class="hljs-comment">&lt;!-- &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>		<span class="hljs-comment">&lt;!-- &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="4-延迟加载"><a href="#4-延迟加载" class="headerlink" title="4. 延迟加载"></a>4. 延迟加载</h2><p>分步查询的优点: 可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息:</p>
<ul>
<li><code>lazyLoadingEnabled</code>: 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载</li>
<li><code>aggressiveLazyLoading</code>: 当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载</li>
</ul>
<p>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sal。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=”lazy(延迟加载)eager(立即加载)’</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectOrderWithCustomerByStepResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        select:设置分步查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</span><br><span class="hljs-comment">        column:设置分步查询的条件,字段名</span><br><span class="hljs-comment">        fetchType:当开启了全局的延迟加载之后，可通过此属性手动控制延迟加载的效果</span><br><span class="hljs-comment">        fetchType=&quot;lazy|eager&quot;:lazy表示延迟加载，eager表示立即加载</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customer&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;top.whalefall.mapper.CustomerMapper.selectOrderWithCustomerStepTwo&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试类中只用到了 orderName, 不涉及 customer 信息, 因此只会执行第一步查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRelationshipToOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">OrderMapper</span> <span class="hljs-variable">orderMapper</span> <span class="hljs-operator">=</span> session.getMapper(OrderMapper.class);<br>    <span class="hljs-comment">// 查询Order对象，检查是否同时查询了关联的Customer对象</span><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectOrderWithCustomerStepOne(<span class="hljs-number">2</span>);<br>    log.info(<span class="hljs-string">&quot;order = &quot;</span> + order.getOrderName());<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310270143174.png" alt="image-20231027014331521"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
