<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 3 | Whale&#39;s Blog | Stay hungry, Stay foolish</title>

  
  <meta name="author" content="Whale">
  

  
  <meta name="description" content="码农预备役">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Whale&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whale&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Whale&#39;s Blog</a>
    </h1>
    <p class="site-description">Stay hungry, Stay foolish</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2023/10/23/MyBatis-1-基本使用/"><span>MyBatis(1) 基本使用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/10/23/MyBatis-1-基本使用/" rel="bookmark">
        <time class="entry-date published" datetime="2023-10-23T04:02:59.000Z">
          2023-10-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310231502376.png" alt="img"></p>
<p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Mybatis核心 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- junit测试 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>定义 mapper 接口和xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;<br>    Employee <span class="hljs-title function_">selectEmployee</span><span class="hljs-params">(Integer empId)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.atguigu.mapper.EmployeeMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployee&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.pojo.Employee&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt;</span><br>        select emp_id empId,emp_name empName, emp_salary empSalary from <br>           t_emp where emp_id = #&#123;empId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>方法名和 SQL 的 id 一致</li>
<li>方法返回值和 <code>resultType</code> 一致</li>
<li>方法的参数和 SQL 的参数一致</li>
<li>接口的全类名和映射配置文件的名称空间一致</li>
</ul>
<p>准备 MyBatis 配置文件</p>
<blockquote>
<p>习惯上命名为 mybatis-config.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- Mybatis的内置的事务管理器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 建立数据库连接的具体信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;</span><br>    <span class="hljs-comment">&lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;</span><br>      <br>    <span class="hljs-comment">&lt;!-- 可以直接指定其所在的包 --&gt;</span><br>    <span class="hljs-comment">&lt;!--  &lt;package name=&quot;mappers&quot;/&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/EmployeeMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>运行和测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectEmployee</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建SqlSessionFactory对象</span><br>    <span class="hljs-comment">// ①声明Mybatis全局配置文件的路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">mybatisConfigFilePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-comment">// ②以输入流的形式加载Mybatis配置文件</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(mybatisConfigFilePath);<br>    <span class="hljs-comment">// ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象</span><br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>    <span class="hljs-comment">// 2.使用SqlSessionFactory对象开启一个会话</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>    <span class="hljs-comment">// 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术)</span><br>    <span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">employeeMapper</span> <span class="hljs-operator">=</span> session.getMapper(EmployeeMapper.class);<br><br>    <span class="hljs-comment">// 4. 调用代理类方法既可以触发对应的SQL语句</span><br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeMapper.selectEmployee(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;employee = &quot;</span> + employee);<br><br>    <span class="hljs-comment">// 5.关闭SqlSession</span><br>    session.commit(); <span class="hljs-comment">//提交事务 [DQL不需要,其他需要]</span><br>    session.close(); <span class="hljs-comment">//关闭会话</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-SQL语句传参"><a href="#2-SQL语句传参" class="headerlink" title="2. SQL语句传参"></a>2. SQL语句传参</h2><h3 id="2-1-日志输出配置"><a href="#2-1-日志输出配置" class="headerlink" title="2.1 日志输出配置"></a>2.1 日志输出配置</h3><p>MyBatis 配置文件设计标签和顶层结构如下：</p>
<ul>
<li>configuration（配置）<ul>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a><ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li>
</ul>
</li>
</ul>
<p>可以在配置文件使用<strong>settings标签</strong>设置，输出运过程SQL日志！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">设置名</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">有效值</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">logImpl</td>
<td style="text-align:left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td style="text-align:left"><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310231529791.png" alt="image-20231023152901677"></td>
<td style="text-align:left">未设置</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- SLF4J 选择slf4j输出！ --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2 #{}, ${}"></a>2.2 <code>#&#123;&#125;, $&#123;&#125;</code></h3><p><strong>#{}</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310231547469.png" alt="image-20231023154722087"></p>
<ul>
<li>MyBatis 会将 SQL 语句中的 <code>#&#123;&#125;</code> 转换为问号占位符。</li>
</ul>
<p><strong>${}</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310231545559.png" alt="image-20231023154524366"></p>
<p><code>$&#123;&#125;</code>形式传参，底层MyBatis做的是字符串拼接操作, 通常不会使用，有 SQL 注入的风险</p>
<blockquote>
<p>一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用${}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)</span><br>User <span class="hljs-title function_">findByColumn</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;column&quot;)</span> String column, <span class="hljs-meta">@Param(&quot;value&quot;)</span> String value)</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-数据输入"><a href="#3-数据输入" class="headerlink" title="3. 数据输入"></a>3. 数据输入</h2><h3 id="3-1-单个简单类型参数"><a href="#3-1-单个简单类型参数" class="headerlink" title="3.1 单个简单类型参数"></a>3.1 单个简单类型参数</h3><p>单个简单类型参数，在<code>#&#123;&#125;</code>中可以随意命名，但是没有必要。通常还是使用和接口方法参数同名</p>
<h3 id="3-2-多个简单类型参数"><a href="#3-2-多个简单类型参数" class="headerlink" title="3.2 多个简单类型参数"></a>3.2 多个简单类型参数</h3><p>当有多个简单类型参数时，MyBatis无法识别抽象方法参数的自定义名称，需要使用 <code>@Param</code> 标记</p>
<p>或者通过 arg0, arg1; param1, param2 表示</p>
<h3 id="3-3-Map类型参数"><a href="#3-3-Map类型参数" class="headerlink" title="3.3 Map类型参数"></a>3.3 Map类型参数</h3><p>若mapper接口方法的参数有多个时,可以手动将这些参数放在一个map中存储</p>
<ul>
<li>只需要通过<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>以<strong>键</strong>的方式访问值即可,但是需要注意后者的单引号问题</li>
<li>如果有很多零散的参数需要传递，但是没有对应的实体类类型可以使用，封装到Map中会很简洁</li>
</ul>
<h3 id="3-4-实体类类型参数"><a href="#3-4-实体类类型参数" class="headerlink" title="3.4 实体类类型参数"></a>3.4 实体类类型参数</h3><p>以属性的方式访问值即可</p>
<p>MyBatis会根据 <code>#&#123;&#125;</code> 中传入的数据，加工成 <code>getXxx()</code> 方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到 <code>#&#123;&#125;</code> 解析后的问号占位符的位置</p>
<h2 id="4-数据输出"><a href="#4-数据输出" class="headerlink" title="4. 数据输出"></a>4. 数据输出</h2><p>数据输出总体上有两种形式：</p>
<ul>
<li>增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可</li>
<li>查询操作的查询结果，需要我们指定输出数据类型</li>
</ul>
<p>以及插入场景下，实现主键数据回显</p>
<h3 id="4-1-返回单个简单类型"><a href="#4-1-返回单个简单类型" class="headerlink" title="4.1 返回单个简单类型"></a>4.1 返回单个简单类型</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>  select count(*) from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>select标签，通过resultType指定查询返回值类型！</p>
<p>resultType = “全限定符｜别名｜如果是返回集合类型，写范型类型即可”</p>
<blockquote>
<p>Mybatis 内部给常用的数据类型设定了很多别名。</p>
<p>以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等</p>
<p><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">别名问题</a></p>
</blockquote>
<h3 id="4-2-返回实体类对象"><a href="#4-2-返回实体类对象" class="headerlink" title="4.2 返回实体类对象"></a>4.2 返回实体类对象</h3><p>通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployee&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;</span><br>  select emp_id empId, emp_name empName, emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>或者通过<strong>增加全局配置自动识别对应关系</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 具体配置 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="4-3-返回Map类型"><a href="#4-3-返回Map类型" class="headerlink" title="4.3 返回Map类型"></a>4.3 返回Map类型</h3><p><strong>若查询出的数据只有一条</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; <span class="hljs-title function_">getUserByIdToMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id)</span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByIdToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select * from t_user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>返回的结果中key为属性名</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310241905604.png" alt="image-20231024190557526"></p>
<p><strong>若查询出多条数据</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserToMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select * from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>可以通过map类型的list集合接收</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">getAllUserToMap</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310241908349.png" alt="image-20231024190838306"></p>
<ol>
<li>可以在mapper接口的方法上添加 <code>@MapKey</code> 注解，此时就可以将每条数据转换的<strong>map集合作为值</strong>，以<strong>某个字段的值作为键</strong>，放在同一个map集合中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapKey(&quot;id&quot;)</span><br>Map&lt;String, Object&gt; <span class="hljs-title function_">getAllUserToMap</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310241910262.png" alt="image-20231024191038218"></p>
<h3 id="4-4-返回List类型"><a href="#4-4-返回List类型" class="headerlink" title="4.4 返回List类型"></a>4.4 返回List类型</h3><p>不需要任何特殊处理，在resultType属性中还是设置<strong>实体类类型</strong>即可</p>
<h3 id="4-5-返回主键值"><a href="#4-5-返回主键值" class="headerlink" title="4.5 返回主键值"></a>4.5 返回主键值</h3><p><strong>自增长类型主键</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- int insertEmployee(Employee employee); --&gt;</span><br><span class="hljs-comment">&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;</span><br><span class="hljs-comment">&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployee&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;empId&quot;</span>&gt;</span><br>  insert into t_emp(emp_name, emp_salary) values(#&#123;empName&#125;, #&#123;empSalary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>MyBatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回</p>
</blockquote>
<p><strong>非自增长类型主键</strong></p>
<p>对于不支持自增型主键的数据库(例如 Oracle)或者字符串类型主键，则可以使用 <code>selectKey</code> 子元素。<code>selectKey</code> 元素将会首先运行，id 会被设置，然后插入语句会被调用</p>
<p>使用 <code>selectKey</code> 帮助插入UUID作为字符串类型主键示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>        SELECT UUID() as id<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    INSERT INTO user (id, username, password) <br>    VALUES (<br>        #&#123;id&#125;,<br>        #&#123;username&#125;,<br>        #&#123;password&#125;<br>    )<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>通过 <code>keyProperty</code> 属性来指定查询到的 UUID 赋值给对象中的 <code>id</code> 属性，而 <code>resultType</code> 属性指定了 UUID 的类型为 <code>java.lang.String</code>。</p>
<p>需要注意的是，<code>selectKey</code> 在插入语句的前面，这是因为 MySQL 在 <code>insert</code> 语句中只支持一个 <code>select</code> 子句，而 <code>selectKey</code> 中查询 UUID 的语句就是一个 <code>select</code> 子句，因此我们需要将其放在前面。</p>
<p>最后，在将 <code>User</code> 对象插入到 <code>user</code> 表中时，我们直接使用对象中的 <code>id</code> 属性来插入主键值。</p>
<h3 id="4-6-实体类属性和数据库字段对应关系"><a href="#4-6-实体类属性和数据库字段对应关系" class="headerlink" title="4.6 实体类属性和数据库字段对应关系"></a>4.6 实体类属性和数据库字段对应关系</h3><p><strong>别名对应</strong></p>
<ul>
<li>SQL语句中手动转换</li>
</ul>
<p><strong>全局配置自动识别驼峰式命名规则</strong></p>
<ul>
<li>SQL语句中可以不使用别名</li>
</ul>
<p><strong>resultMap</strong></p>
<p>使用 <code>resultMap</code> 标签定义对应关系，再在后面的SQL语句中引用这个对应关系</p>
<p>此处简单介绍一下，涉及到一对多多对一映射的在后面部分展开</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByRMResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empId&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_salary&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empSalary&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByRM&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectEmployeeByRMResultMap&quot;</span>&gt;</span><br>  select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="5-Mapper标签总结"><a href="#5-Mapper标签总结" class="headerlink" title="5. Mapper标签总结"></a>5. Mapper标签总结</h2><p><strong>select 标签</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPerson&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span>&gt;</span><br>    SELECT * FROM PERSON WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>select 元素允许配置很多属性来配置每条语句的行为细节：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td><code>resultType</code></td>
<td>期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td>
</tr>
<tr>
<td><code>resultMap</code></td>
<td>对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td><code>statementType</code></td>
<td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>insert, update 和 delete 标签</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td><code>statementType</code></td>
<td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td><code>useGeneratedKeys</code></td>
<td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td><code>keyProperty</code></td>
<td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
<tr>
<td><code>keyColumn</code></td>
<td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Backend/">Backend</a>, <a href="/categories/Backend/MyBatis/">MyBatis</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/MyBatis/">MyBatis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/10/21/Spring-3-声明式事务/"><span>Spring(3) 声明式事务</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/10/21/Spring-3-声明式事务/" rel="bookmark">
        <time class="entry-date published" datetime="2023-10-21T07:09:13.000Z">
          2023-10-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-声明式事务概念"><a href="#1-声明式事务概念" class="headerlink" title="1. 声明式事务概念"></a>1. 声明式事务概念</h2><p><strong>编程式事务</strong>指通过编写代码的方式直接控制事务的提交和回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> ...; <br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 开启事务：关闭事务的自动提交</span><br>    conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 提交事务</span><br>    conn.commit();<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    <span class="hljs-comment">// 回滚事务</span><br>    conn.rollBack();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">// 释放数据库连接</span><br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li>
<li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li>
</ul>
<p><strong>声明式事务</strong>是指使用注解或 XML 配置的方式来控制事务的提交和回滚。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310221516616.png" alt="image-20231022151604444"></p>
<p>Spring声明式事务对应依赖</p>
<ul>
<li>spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li>
<li>spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager</li>
<li>spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate/Jpa等</li>
</ul>
<p>Spring声明式事务对应事务管理器接口</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310221519594.png" alt="img"></p>
<p><code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code>可用于整合 <code>JDBC</code>方式、<code>JdbcTemplate</code>方式、<code>Mybatis</code>方式的事务实现</p>
<p><code>DataSourceTransactionManager</code>类中的主要方法：</p>
<ul>
<li><code>doBegin()</code>：开启事务</li>
<li><code>doSuspend()</code>：挂起事务</li>
<li><code>doResume()</code>：恢复挂起的事务</li>
<li><code>doCommit()</code>：提交事务</li>
<li><code>doRollback()</code>：回滚事务</li>
</ul>
<h2 id="2-基于注解的声明式事务"><a href="#2-基于注解的声明式事务" class="headerlink" title="2. 基于注解的声明式事务"></a>2. 基于注解的声明式事务</h2><h3 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h3><p>配置类上添加 <code>@EnableTransactionManagement</code>, 实例化 <code>TransactionManager</code> 组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;top.whalefall&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(<span class="hljs-meta">@Value(&quot;$&#123;whale.url&#125;&quot;)</span>String url,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Value(&quot;$&#123;whale.driver&#125;&quot;)</span>String driver,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Value(&quot;$&#123;whale.username&#125;&quot;)</span>String username,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Value(&quot;$&#123;whale.password&#125;&quot;)</span>String password)</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        dataSource.setDriverClassName(driver);<br>        dataSource.setUrl(url);<br>        dataSource.setUsername(username);<br>        dataSource.setPassword(password);<br><br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>        <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>();<br>        jdbcTemplate.setDataSource(dataSource);<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 装配事务管理实现对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataSource</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用声明事务注解 <code>@Transactional</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeInfo</span><span class="hljs-params">()</span>&#123;<br>    studentDao.updateAgeById(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 被回滚</span><br>    System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>); <span class="hljs-comment">// 这行会执行</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    studentDao.updateNameById(<span class="hljs-string">&quot;test1&quot;</span>,<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>将 <code>@Transactional</code> 标记在类上会作用在类中所有方法，设置的事务属性也会延续影响到方法执行时的事务属性</p>
<p>对一个方法来说，离它最近的 <code>@Transactional</code> 注解中的事务属性设置生效</p>
</blockquote>
<h3 id="2-2-事务属性"><a href="#2-2-事务属性" class="headerlink" title="2.2 事务属性"></a>2.2 事务属性</h3><p><strong>只读</strong></p>
<p><code>@Transactional(readOnly = true)</code></p>
<p><strong>超时时间</strong></p>
<p><code>@Transactional(timeout = 3)</code></p>
<ul>
<li>单位为秒，默认为 -1，永不超时</li>
<li>超时会执行回滚</li>
</ul>
<p><strong>事务异常</strong></p>
<p><code>@Transactional(rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class)</code></p>
<ul>
<li>默认只针对运行时异常回滚，编译时异常不回滚</li>
<li><code>rollbackFor</code>: 指定哪些异常类才会回滚，默认是 <code>RuntimeException and Error</code> 异常方可回滚</li>
<li><code>noRollbackFor</code>: 指定哪些异常不会回滚, 默认没有指定, 如果指定, 应该在 <code>rollbackFor</code> 的范围内</li>
</ul>
<p><strong>事务隔离级别</strong></p>
<p><code>@Transactional(isolation = Isolation.REPEATABLE_READ)</code></p>
<ul>
<li>isolation: 设置事务的隔离级别, mysql默认是repeatable read</li>
</ul>
<p>数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p>
<ol>
<li>读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</li>
<li>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</li>
<li>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</li>
<li>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</li>
</ol>
<p><strong>事务传播行为</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310230038490.png" alt="img" style="zoom:67%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MethodA</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    MethodB();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！</span><br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MethodB</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>@Transactional</code> 注解通过 <code>propagation</code> 属性设置事务的传播行为</p>
<ul>
<li>它的默认值是 <code>Propagation propagation() default Propagation.REQUIRED;</code></li>
<li>可选值由 <code>org.springframework.transaction.annotation.Propagation</code> 枚举类提供<ul>
<li><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入当前事务，否则创建一个新事务。</li>
</ul>
<ol>
<li><code>Propagation.REQUIRES_NEW</code>：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。</li>
<li><code>Propagation.NESTED</code>：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。</li>
<li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务，否则以非事务方式执行。</li>
<li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式执行，如果当前存在事务，挂起该事务。</li>
<li><code>Propagation.MANDATORY</code>：必须在一个已有的事务中执行，否则抛出异常。</li>
<li><code>Propagation.NEVER</code>：必须在没有事务的情况下执行，否则抛出异常。</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<p>在<strong>同一个类</strong>中，对于 <code>@Transactional</code> 注解的方法调用，事务传播行为<strong>不会生效</strong>。这是因为 Spring 框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此 <code>@Transactional</code> 注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Backend/">Backend</a>, <a href="/categories/Backend/Spring/">Spring</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Spring/">Spring</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/10/19/Java动态代理/"><span>Java动态代理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/10/19/Java动态代理/" rel="bookmark">
        <time class="entry-date published" datetime="2023-10-19T06:05:11.000Z">
          2023-10-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. <a target="_blank" rel="noopener" href="https://whalefall.top/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-3-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1">代理模式</a></h2><p>代理模式分为 3 种角色</p>
<ul>
<li><strong>Subject（抽象主题角色）</strong>：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法</li>
<li><strong>RealSubject（真实主题角色</strong>）：真正实现业务逻辑的类</li>
<li><strong>Proxy（代理主题角色）</strong>：用来代理和封装真实主题</li>
</ul>
<p><strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p>
<ul>
<li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在<strong>代理类的字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li>
<li>而<strong>动态</strong>代理的源码是在程序运行期间由<strong>JVM</strong>根据反射等机制<strong>动态地生成</strong>，所以在运行前并不存在代理类的字节码文件</li>
</ul>
<h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService target; <span class="hljs-comment">// 被代理的对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceProxy</span><span class="hljs-params">(UserService target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br>        before();<br>        target.select();    <span class="hljs-comment">// 这里才实际调用真实主题角色的方法</span><br>        after();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;     <span class="hljs-comment">// 在执行方法之前执行</span><br>        ...<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;      <span class="hljs-comment">// 在执行方法之后执行</span><br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p>
<ol>
<li>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</li>
</ol>
<ul>
<li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong></li>
<li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li>
</ul>
<ol>
<li>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护</strong></li>
</ol>
<h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><blockquote>
<p><strong>为什么类可以动态地生成？</strong></p>
<p>JVM的类加载过程分为 5 个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据访问入口</li>
</ol>
<p>由于《Java虚拟机规范》对这三点要求并不具体，因此实现非常灵活。例如第一点<strong>获取类的二进制字节流</strong>就有很多途径：</p>
<ul>
<li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li>
<li>从网络中获取，典型的应用是 Applet</li>
<li><strong>运行时计算生成</strong>，这种场景使用最多的是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 类中，就是用了 <code>ProxyGenerator.generateProxyClass()</code> 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li>
<li>由其它文件生成，典型应用是JSP，由JSP文件生成对应的Class文件</li>
<li>从数据库中读取</li>
<li>从加密文件中获取等等</li>
</ul>
</blockquote>
<p>为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：</p>
<ol>
<li>通过代理类和目标类实现同一个接口的方式 -&gt; <strong>JDK动态代理</strong></li>
<li>通过代理类继承目标类的方式 -&gt; <strong>CGLIB动态代理</strong></li>
</ol>
<h3 id="3-1-JDK动态代理"><a href="#3-1-JDK动态代理" class="headerlink" title="3.1 JDK动态代理"></a>3.1 JDK动态代理</h3><p>JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>。通过案例来说明</p>
<p>编写一个调用逻辑处理器 <code>LogHandler</code> 类，提供日志增强功能，并实现 <code>InvocationHandler</code> 接口；在 <code>LogHandler</code> 中维护一个目标对象，这个对象是被代理的对象（真实主题角色）；在 <code>invoke</code> 方法中编写方法调用的逻辑处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <br>    Object target;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LogHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.printf(<span class="hljs-string">&quot;log start time [%s]&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.printf(<span class="hljs-string">&quot;log end time [%s]&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">JDKProxyTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span><br>    System.getProperties().setProperty(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>    <br>    <span class="hljs-comment">// 1. 创建被代理的对象</span><br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>    <span class="hljs-comment">// 2. 获取对应ClassLoader, userService的类为UserServiceImpl</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> userService.getClass().getClassLoader();<br>    <span class="hljs-comment">// 3. 获取所有接口的Class, 这里的userService只实现了一个接口UserService</span><br>    Class&lt;?&gt;[] interfaces = userService.getClass().getInterfaces();<br>    <span class="hljs-comment">// 4. 创建一个将传给代理类的调用请求处理器, 代理对象上的方法调用实际为调用 InvocationHandler 的 invoke 方法</span><br>    <span class="hljs-comment">//    这里创建的是一个自定义的日志处理器, 须传入实际的执行对象 userService</span><br>    <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">logHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogHandler</span>(userService);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        5.根据上面提供的信息, 创建代理对象, 在这个过程中，</span><br><span class="hljs-comment">           a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span><br><span class="hljs-comment">           b.然后根据相应的字节码转换成对应的class，</span><br><span class="hljs-comment">           c.然后调用newInstance()创建代理实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);<br>    proxy.select();<br>    proxy.update();<br>    <br>    <span class="hljs-comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span><br>    ProxyUtils.generateClassFile(userService.getClass(), <span class="hljs-string">&quot;UserServiceProxy&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310191458920.png" alt="image-20231019145819867"></p>
<blockquote>
<p>因为 <code>InvocationHandler</code> 是一个函数接口，可以使用匿名内部类或Lambda表达式简化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">JDKProxyByLambdaTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) Proxy<br>            .newProxyInstance(userService.getClass().getClassLoader(),<br>                              userService.getClass().getInterfaces(),<br>                              ((proxy1, method, args) -&gt; &#123;<br>                                  System.out.printf(<span class="hljs-string">&quot;log start time [%s]\n&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                                  <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(userService, args);<br>                                  System.out.printf(<span class="hljs-string">&quot;log end time [%s]\n&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                                  <span class="hljs-keyword">return</span> result;<br>                              &#125;));<br>    proxy.select();<br>    proxy.update();<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-2-代理类源码分析"><a href="#3-2-代理类源码分析" class="headerlink" title="3.2 代理类源码分析"></a>3.2 代理类源码分析</h3><p>通过上面测试类的配置，可以在target的类路径下找到代理类的class文件，反编译得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m4;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceProxy</span><span class="hljs-params">(InvocationHandler var1)</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-built_in">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m4, (Object[])<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, (Object[])<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>            m4 = Class.forName(<span class="hljs-string">&quot;top.whale.proxy.UserService&quot;</span>).getMethod(<span class="hljs-string">&quot;select&quot;</span>);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>            m3 = Class.forName(<span class="hljs-string">&quot;top.whale.proxy.UserService&quot;</span>).getMethod(<span class="hljs-string">&quot;update&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchMethodError</span>(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoClassDefFoundError</span>(var3.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从 <code>UserServiceProxy</code> 的代码中可以发现：</p>
<ul>
<li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li>
<li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li>
<li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li>
<li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li>
<li>调用方法的时候通过 <code>super.h.invoke(this, m3, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>LogHandler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑</li>
</ul>
<p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法</p>
<h3 id="3-3-CGLIB动态代理"><a href="#3-3-CGLIB动态代理" class="headerlink" title="3.3 CGLIB动态代理"></a>3.3 CGLIB动态代理</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310191602766.png" alt="img"></p>
<p>CGLIB动态代理是代理类去继承目标类，然后重写目标类的方法，每次调用代理类的方法都会被方法拦截器拦截，在拦截器中才是调用目标类的该方法的逻辑</p>
<p>JDK动态代理中提供了一个<code>Proxy</code>类来创建代理类，而在CGLIB动态代理中也提供了一个类似的类<code>Enhancer</code></p>
<p>编写 <code>LogInterceptor</code> ，实现 <code>MethodInterceptor</code>，用于方法的拦截回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o 表示要进行增强的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method 表示拦截的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 执行结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.printf(<span class="hljs-string">&quot;log start time [%s]\n&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环</span><br>        <span class="hljs-comment">// methodProxy.invokeSuper执行的是原始类的方法，method.invoke执行的是子类的方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, objects);<br>        System.out.printf(<span class="hljs-string">&quot;log end time [%s]\n&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cglibTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>    enhancer.setSuperclass(UserDAO.class);<br>    enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogInterceptor</span>());<br>    <span class="hljs-type">UserDAO</span> <span class="hljs-variable">proxyDao</span> <span class="hljs-operator">=</span> (UserDAO) enhancer.create();<br>    proxyDao.select();<br>    proxyDao.update();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310191620680.png" alt="image-20231019162025635"></p>
<blockquote>
<p>同样可以使用匿名内部类或Lambda表达式简化</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Language/">Language</a>, <a href="/categories/Language/Java/">Java</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/10/16/Spring-2-AOP/"><span>Spring(2) AOP</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/10/16/Spring-2-AOP/" rel="bookmark">
        <time class="entry-date published" datetime="2023-10-16T11:51:30.000Z">
          2023-10-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-AOP思想及术语"><a href="#1-AOP思想及术语" class="headerlink" title="1. AOP思想及术语"></a>1. AOP思想及术语</h2><p>见<a target="_blank" rel="noopener" href="https://whalefall.top/2023/02/16/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-1-Spring/#%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-AOP">服务端开发</a></p>
<h2 id="2-Spring-AOP基于注解方式实现"><a href="#2-Spring-AOP基于注解方式实现" class="headerlink" title="2. Spring AOP基于注解方式实现"></a>2. Spring AOP基于注解方式实现</h2><h3 id="2-1-Spring-AOP底层技术"><a href="#2-1-Spring-AOP底层技术" class="headerlink" title="2.1 Spring AOP底层技术"></a>2.1 Spring AOP底层技术</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310191643921.png" alt="img"></p>
<p>动态代理见<a target="_blank" rel="noopener" href="https://whalefall.top/2023/10/19/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">Java动态代理</a></p>
<ul>
<li>JDK 动态代理：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口</li>
<li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口</li>
<li>AspectJ：早期的AOP实现的框架，Spring AOP借用了AspectJ中的AOP注解</li>
</ul>
<h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @Aspect表示这个类是一个切面类</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-comment">// @Component注解保证这个切面类能够放入IOC容器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;        <br>    <span class="hljs-comment">// @Before注解：声明当前方法是前置通知方法</span><br>    <span class="hljs-comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span><br>    <span class="hljs-meta">@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogBeforeCore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP前置通知] 方法开始了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogAfterSuccess</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogAfterException</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogFinallyEnd</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>
<p>开启 aspectj 注解支持</p>
<ol>
<li>XML方式: <code>&lt;aop:aspectj-autoproxy /&gt;</code></li>
<li>配置类方式: <code>@EnableAspectJAutoProxy</code></li>
</ol>
<p>编写测试类及运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)</span><br><span class="hljs-meta">@SpringJUnitConfig(value = &#123;MyConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Calculator calculator;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCalculator</span><span class="hljs-params">()</span>&#123;<br>        calculator.add(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310201502163.png" alt="image-20231020150244112"></p>
<h3 id="2-3-获取通知细节信息"><a href="#2-3-获取通知细节信息" class="headerlink" title="2.3 获取通知细节信息"></a>2.3 获取通知细节信息</h3><p><strong>JoinPoint接口</strong></p>
<p>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参</p>
<ul>
<li>JoinPoint 接口通过 <code>getSignature()</code> 方法获取目标方法的签名（方法声明时的完整信息）</li>
<li>通过目标方法签名对象获取方法名</li>
<li>通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value = &quot;execution(public int top.whalefall.CalculatorPureImpl.add(int, int))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printBeforeCore</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>    <span class="hljs-comment">// 1. 通过JoinPoint对象获取目标方法签名对象</span><br>    <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> joinPoint.getSignature();<br><br>    <span class="hljs-comment">// 2. 通过方法的签名对象获取目标方法的详细信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> signature.getName();<br>    System.out.println(<span class="hljs-string">&quot;methodName = &quot;</span> + methodName);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> signature.getModifiers();<br>    System.out.println(<span class="hljs-string">&quot;modifiers = &quot;</span> + modifiers);<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">declaringTypeName</span> <span class="hljs-operator">=</span> signature.getDeclaringTypeName();<br>    System.out.println(<span class="hljs-string">&quot;declaringTypeName = &quot;</span> + declaringTypeName);<br><br>    <span class="hljs-comment">// 3. 通过JoinPoint对象获取外界调用目标方法时传入的实参列表</span><br>    Object[] args = joinPoint.getArgs();<br>    System.out.println(<span class="hljs-string">&quot;[AOP前置通知]&quot;</span> + methodName + <span class="hljs-string">&quot;方法开始了, 参数列表: &quot;</span> + Arrays.asList(args));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310202052311.png" alt="image-20231020205220248"></p>
<blockquote>
<p>注: 这里显示的是接口的方法签名</p>
</blockquote>
<p><strong>方法返回值</strong></p>
<p>在返回通知中，通过 <code>@AfterReturning</code> 注解的 returning 属性获取目标方法的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(value = &quot;execution(public int top.whalefall.CalculatorPureImpl.add(int, int))&quot;,</span><br><span class="hljs-meta">                returning = &quot;targetMethodReturnValue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogAfterSuccess</span><span class="hljs-params">(JoinPoint joinPoint, Object targetMethodReturnValue)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>    System.out.println(<span class="hljs-string">&quot;[AOP返回通知]&quot;</span> + methodName + <span class="hljs-string">&quot;方法成功返回了, 返回值是: &quot;</span> + targetMethodReturnValue);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310202107167.png" alt="image-20231020210702117"></p>
<p><strong>异常对象捕获</strong></p>
<p>在异常通知中，通过 <code>@AfterThrowing</code> 注解的throwing属性获取目标方法抛出的异常对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterThrowing(value = &quot;execution(public int top.whalefall.CalculatorPureImpl.add(int, int))&quot;,</span><br><span class="hljs-meta">               throwing = &quot;targetMethodException&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogAfterException</span><span class="hljs-params">(JoinPoint joinPoint, Throwable targetMethodException)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>    System.out.println(<span class="hljs-string">&quot;[AOP异常通知]&quot;</span> + methodName + <span class="hljs-string">&quot;方法抛异常了, 异常类型是: &quot;</span> + targetMethodException.getClass().getName());<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310202120891.png" alt="image-20231020212030852"></p>
<h3 id="2-4-切点表达式"><a href="#2-4-切点表达式" class="headerlink" title="2.4 切点表达式"></a>2.4 切点表达式</h3><p><strong>切点表达式语法</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310210026505.png" alt="img"></p>
<ul>
<li>第一位：execution() 固定开头</li>
<li>第二位：方法访问修饰符</li>
<li>第三位：方法返回值<ul>
<li>注：execution(<em> </em>) 是错误语法</li>
<li>execution(*) == 只要不考虑 返回值 或者 访问修饰符 相当于全部不考虑了</li>
</ul>
</li>
<li>第四位：指定包的地址<ul>
<li><code>*</code>: 任意一层的任意命名</li>
<li><code>..</code>: 任意层, 任意命名, 不能用作包开头</li>
<li>任何包使用 <code>*..</code></li>
</ul>
</li>
<li>第五位：指定类名称<ul>
<li><code>*</code>: 任意类名</li>
<li>部分任意: <code>com..service.impl.*Impl</code></li>
<li><code>*..*</code>: 任意包任意类</li>
</ul>
</li>
<li>第六位：指定方法名称<ul>
<li>语法与类名一致</li>
<li>任意访问修饰符, 任意类的任意方法: <code>* *..*.*</code></li>
</ul>
</li>
<li>第七位：方法参数<ul>
<li>模糊值: 任意参数 有 或者 没有 (..)</li>
<li>第一个参数是字符串的方法 (String..)</li>
<li>最后一个参数是字符串 (..String)</li>
<li>字符串开头, int结尾 (String..int)</li>
<li>包含int类型 (..int..)</li>
</ul>
</li>
</ul>
<p><strong>重用切点表达式</strong></p>
<p>同一类内部引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(public int top.whalefall.CalculatorPureImpl.add(int, int))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">declarePointCut</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-meta">@Before(value = &quot;declarePointCut()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printBeforeCore</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure>
<p>不同类中引用</p>
<p>只需要添加类的全限定符 + 方法名即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value = &quot;top.whalefall.LogAspect.declarPointCut()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">roundAdvice</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>建议将切点表达式统一存储到一个类中进行集中管理和维护</p>
</blockquote>
<h3 id="2-5-环绕通知"><a href="#2-5-环绕通知" class="headerlink" title="2.5 环绕通知"></a>2.5 环绕通知</h3><p><code>@Around</code> == <code>@Before</code> + <code>@After</code> == <code>@Before</code> + <code>@AfterReturning</code> + <code>@AfterThrowing</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(value = &quot;execution(public int top.whalefall.CalculatorPureImpl.sub(int, int))&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">manageTransaction</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogManager.getLogger(LogAspect.class);<br>    <span class="hljs-comment">// 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组</span><br>    Object[] args = joinPoint.getArgs();<br>    <span class="hljs-comment">// 通过ProceedingJoinPoint对象获取目标方法的签名对象</span><br>    <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> joinPoint.getSignature();<br>    <span class="hljs-comment">// 通过签名对象获取目标方法的方法名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> signature.getName();<br>    <span class="hljs-comment">// 声明变量用来存储目标方法的返回值</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">targetMethodReturnValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 在目标方法执行前：开启事务（模拟）</span><br>        log.info(<span class="hljs-string">&quot;[AOP 环绕通知] 开启事务，方法名：&quot;</span> + methodName + <span class="hljs-string">&quot;，参数列表：&quot;</span> + Arrays.asList(args));<br>        <span class="hljs-comment">// 通过ProceedingJoinPoint对象调用目标方法</span><br>        <span class="hljs-comment">// 目标方法的返回值一定要返回给外界调用者</span><br>        targetMethodReturnValue = joinPoint.proceed(args);<br>        <span class="hljs-comment">// 在目标方法成功返回后：提交事务（模拟）</span><br>        log.info(<span class="hljs-string">&quot;[AOP 环绕通知] 提交事务，方法名：&quot;</span> + methodName + <span class="hljs-string">&quot;，方法返回值：&quot;</span> + targetMethodReturnValue);<br>    &#125;<span class="hljs-keyword">catch</span> (Throwable e)&#123;<br>        <span class="hljs-comment">// 在目标方法抛异常后：回滚事务（模拟）</span><br>        log.info(<span class="hljs-string">&quot;[AOP 环绕通知] 回滚事务，方法名：&quot;</span> + methodName + <span class="hljs-string">&quot;，异常：&quot;</span> + e.getClass().getName());<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 在目标方法最终结束后：释放数据库连接</span><br>        log.info(<span class="hljs-string">&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot;</span> + methodName);<br>    &#125;<br>    <span class="hljs-keyword">return</span> targetMethodReturnValue;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310211438004.png" alt="image-20231021143809949"></p>
<h3 id="2-6-切面优先级设置"><a href="#2-6-切面优先级设置" class="headerlink" title="2.6 切面优先级设置"></a>2.6 切面优先级设置</h3><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。</p>
<ul>
<li>优先级高的切面：外面</li>
<li>优先级低的切面：里面</li>
</ul>
<p>使用 <code>@Order</code> 注解可以控制切面的优先级(用在类上)：</p>
<ul>
<li><code>@Order(较小的数)</code>：优先级高</li>
<li><code>@Order(较大的数)</code>：优先级低</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310211449489.png" alt="img" style="zoom: 50%;" /></p>
<blockquote>
<p>如果目标类有接口, Spring自动选择使用jdk动态代理</p>
<p>如果目标类没有接口, Spring自动选择cglib动态代理</p>
</blockquote>
<h2 id="3-Spring-AOP基于XML方式实现"><a href="#3-Spring-AOP基于XML方式实现" class="headerlink" title="3. Spring AOP基于XML方式实现"></a>3. Spring AOP基于XML方式实现</h2><p>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置目标类的bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;calculatorPure&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 配置切面类的bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.aop.aspect.LogAspect&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 配置AOP --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置切入点表达式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *..*.*(..))&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- aop:aspect标签：配置切面 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- ref属性：关联切面类的bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logAspect&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- aop:before标签：配置前置通知 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- method属性：指定前置通知的方法名 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printLogBeforeCore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;logPointCut&quot;</span>/&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- aop:after-returning标签：配置返回通知 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span></span><br><span class="hljs-tag">                <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printLogAfterCoreSuccess&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;logPointCut&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;targetMethodReturnValue&quot;</span>/&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- aop:after-throwing标签：配置异常通知 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span></span><br><span class="hljs-tag">                <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printLogAfterCoreException&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;logPointCut&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;targetMethodException&quot;</span>/&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- aop:after标签：配置后置通知 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printLogCoreFinallyEnd&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;logPointCut&quot;</span>/&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- aop:around标签：配置环绕通知 --&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="4-Spring-AOP对获取Bean的影响"><a href="#4-Spring-AOP对获取Bean的影响" class="headerlink" title="4. Spring AOP对获取Bean的影响"></a>4. Spring AOP对获取Bean的影响</h2><div class="table-container">
<table>
<thead>
<tr>
<th>有无接口</th>
<th>实现类个数</th>
<th>有无切面</th>
<th>根据接口获取bean</th>
<th>根据类获取bean</th>
</tr>
</thead>
<tbody>
<tr>
<td>有</td>
<td>1</td>
<td>无</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>有</td>
<td>多个</td>
<td>无</td>
<td>不可以</td>
<td>可以</td>
</tr>
<tr>
<td>有</td>
<td>1</td>
<td>有</td>
<td>可以</td>
<td>不可以，<strong>容器中的是代理类的对象</strong></td>
</tr>
<tr>
<td>无</td>
<td>1</td>
<td>有</td>
<td></td>
<td>可以，cglib通过继承生成的代理类</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Backend/">Backend</a>, <a href="/categories/Backend/Spring/">Spring</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Spring/">Spring</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/10/01/Spring-1-IoC/"><span>Spring(1) IoC</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/10/01/Spring-1-IoC/" rel="bookmark">
        <time class="entry-date published" datetime="2023-10-01T15:59:18.000Z">
          2023-10-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Spring IoC / DI 实现步骤</p>
<ol>
<li>配置元数据(基于XML、基于注解、基于配置类)</li>
<li><p>实例化IoC容器(可从本地文件系统、CLASSPATH等加载配置元数据)</p>
</li>
<li><p>获取Bean(组件)</p>
</li>
</ol>
</blockquote>
<h2 id="1-完全XML配置方式"><a href="#1-完全XML配置方式" class="headerlink" title="1. 完全XML配置方式"></a>1. 完全XML配置方式</h2><h3 id="1-1-Bean信息声明配置"><a href="#1-1-Bean信息声明配置" class="headerlink" title="1.1 Bean信息声明配置"></a>1.1 Bean信息声明配置</h3><p>基于<strong>无参数构造函数</strong>的实例化</p>
<ul>
<li>默认需要空构造函数</li>
<li><code>&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;/&gt;</code></li>
</ul>
<p>基于<strong>静态工厂方法</strong>的实例化</p>
<ul>
<li>组件类中需要有静态工厂方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ClientService</span> <span class="hljs-variable">clientService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientService</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ClientService</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientService <span class="hljs-title function_">createInstance</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> clientService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span></span><br><span class="hljs-tag">  	  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ClientService&quot;</span></span><br><span class="hljs-tag">  	  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>factory-method: 指定静态工厂方法，<strong>该方法必须是static方法</strong></li>
</ul>
<p>基于<strong>实例工厂方法</strong>的实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultServiceLocator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ClientServiceImpl</span> <span class="hljs-variable">clientService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientServiceImpl</span>();<br><br>    <span class="hljs-keyword">public</span> ClientService <span class="hljs-title function_">createClientServiceInstance</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> clientService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 将工厂类进行ioc配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.DefaultServiceLocator&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span></span><br><span class="hljs-tag">  	  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span></span><br><span class="hljs-tag">  	  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createClientServiceInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>factory-bean: 指定当前容器中工厂Bean的名称。</p>
</li>
<li><p>factory-method: 指定实例工厂方法名。<strong>实例方法必须是非static的</strong></p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310020013837.png" alt="img"></p>
<h3 id="1-2-Bean依赖注入配置"><a href="#1-2-Bean依赖注入配置" class="headerlink" title="1.2 Bean依赖注入配置"></a>1.2 Bean依赖注入配置</h3><p>基于<strong>构造函数</strong>的依赖注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 场景1: 多参数，可以按照相应构造函数的**顺序**注入数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.UserService&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- value直接注入基本类型值 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;赵伟风&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 被引用类bean声明 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.UserDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 场景2: 多参数，可以按照相应构造函数的**名称**注入数据 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.UserService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;赵伟风&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.UserDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 场景3: 多参数，可以按照相应构造函数的**角标**注入数据 </span><br><span class="hljs-comment">         index从0开始 构造函数(0,1,2....)      --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.UserService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;赵伟风&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.UserDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>constructor-arg：可以引用构造参数</p>
<ul>
<li>name属性指定参数名</li>
<li>index属性指定参数角标</li>
<li>value属性指定普通属性值</li>
<li>ref引用其他bean的标识</li>
</ul>
</li>
</ul>
<p>基于<strong>Setter方法</strong>的依赖注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simpleMovieLister&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.SimpleMovieLister&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- setter方法，注入movieFinder对象的标识id</span><br><span class="hljs-comment">         name = 属性名  ref = 引用bean的id值    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;movieFinder&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;movieFinder&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- setter方法，注入基本数据类型movieName</span><br><span class="hljs-comment">         name = 属性名 value = 基本类型值        --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;movieName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;消失的她&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;movieFinder&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.MovieFinder&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>property：可以给setter方法对应的属性赋值</p>
<ul>
<li>name: <strong>set方法标识</strong></li>
<li>ref: 引用bean的标识id</li>
<li>value: 基本属性值</li>
</ul>
</li>
</ul>
<h3 id="1-3-IoC容器创建和使用"><a href="#1-3-IoC容器创建和使用" class="headerlink" title="1.3 IoC容器创建和使用"></a>1.3 IoC容器创建和使用</h3><p>容器实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式1: 实例化并且指定配置文件</span><br><span class="hljs-comment">//参数：String...locations 传入一个或者多个配置文件</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;services.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>);<br><br><span class="hljs-comment">//方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式]</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>();<br>iocContainer1.setConfigLocations(<span class="hljs-string">&quot;services.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>);<br>iocContainer1.refresh();   <br></code></pre></td></tr></table></figure>
<p>Bean对象获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式1: 根据id获取</span><br><span class="hljs-comment">//没有指定类型,返回为Object,需要类型转化!</span><br><span class="hljs-type">HappyComponent</span> <span class="hljs-variable">happyComponent</span> <span class="hljs-operator">=</span> (HappyComponent) iocContainer.getBean(<span class="hljs-string">&quot;bean的id标识&quot;</span>);<br><br><span class="hljs-comment">//方式2: 根据类型获取</span><br><span class="hljs-comment">//根据类型获取,要求同类型(当前类,或者子类,或者接口的实现类)只能有一个对象交给IoC容器管理</span><br><span class="hljs-comment">//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题</span><br><span class="hljs-type">HappyComponent</span> <span class="hljs-variable">happyComponent</span> <span class="hljs-operator">=</span> iocContainer.getBean(HappyComponent.class);<br><br><span class="hljs-comment">//方式3: 根据id和类型获取</span><br><span class="hljs-type">HappyComponent</span> <span class="hljs-variable">happyComponent</span> <span class="hljs-operator">=</span> iocContainer.getBean(<span class="hljs-string">&quot;bean的id标识&quot;</span>, HappyComponent.class);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，<br>只要返回的是true就可以认定为和类型匹配，能够获取到。</p>
</blockquote>
<h3 id="1-4-Bean作用域和周期方法配置"><a href="#1-4-Bean作用域和周期方法配置" class="headerlink" title="1.4 Bean作用域和周期方法配置"></a>1.4 Bean作用域和周期方法配置</h3><p><strong>组件作用域</strong></p>
<p>作用域可选值</p>
<ul>
<li>singleton：单实例，在IOC容器初始化时创建，为默认作用域</li>
<li>prototype：多实例，在获取bean时创建</li>
</ul>
<blockquote>
<p>如果是在 WebApplicationContext 环境下还会有另外两个作用域(不常用)</p>
<ul>
<li>request：请求范围内有效的实例，每次请求创建</li>
<li>session：会话范围内有效的实例，每次会话创建</li>
</ul>
</blockquote>
<p>作用域配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;happyMachine8&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.ioc.HappyMachine&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;machineName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;happyMachine&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;happyComponent8&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.ioc.HappyComponent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;componentName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;happyComponent&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>周期方法</strong></p>
<p>概念：当IoC容器实例化和销毁组件对象的时候进行调用的方法</p>
<p>声明：方法命名随意，但是要求方法必须是 <strong>public void 无形参列表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanOne</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 初始化逻辑</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanTwo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 释放资源逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.BeanOne&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanTwo&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.BeanTwo&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;cleanup&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="1-5-FactoryBean特性和使用"><a href="#1-5-FactoryBean特性和使用" class="headerlink" title="1.5 FactoryBean特性和使用"></a>1.5 FactoryBean特性和使用</h3><p><code>FactoryBean</code> 接口是Spring IoC容器实例化逻辑的可插拔性点。</p>
<ul>
<li>配置复杂的Bean对象时，可以将创建过程存储在<code>FactoryBean</code>的getObject方法</li>
</ul>
<p><code>FactoryBean</code>接口提供三种方法：</p>
<ul>
<li><code>T getObject()</code>: 返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！</li>
<li><code>boolean isSingleton()</code>: 如果此 FactoryBean 返回单例，则返回 true。此方法的默认实现返回 true</li>
<li><code>Class&lt;?&gt; getObjectType()</code>: 返回 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回<code>null</code></li>
</ul>
<p>使用场景</p>
<ol>
<li><p>代理类的创建</p>
</li>
<li><p>第三方框架整合</p>
</li>
<li>复杂对象实例化等</li>
</ol>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现FactoryBean接口时需要指定泛型</span><br><span class="hljs-comment">// 泛型类型就是当前工厂要生产的对象的类型</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HappyFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;HappyMachine&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> String machineName;<br>        <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> HappyMachine <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 方法内部模拟创建、设置一个对象的复杂过程</span><br>        <span class="hljs-type">HappyMachine</span> <span class="hljs-variable">happyMachine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HappyMachine</span>();<br>        happyMachine.setMachineName(<span class="hljs-built_in">this</span>.machineName);<br>        <span class="hljs-keyword">return</span> happyMachine;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-comment">// 返回要生产的对象的类型</span><br>        <span class="hljs-keyword">return</span> HappyMachine.class;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- FactoryBean机制 --&gt;</span><br><span class="hljs-comment">&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;happyMachine7&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.ioc.HappyFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;machineName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;iceCreamMachine&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testExperiment07</span><span class="hljs-params">()</span>  &#123;<br><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">iocContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-bean-07.xml&quot;</span>);<br><br>    <span class="hljs-comment">//注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象</span><br>    <span class="hljs-type">HappyMachine</span> <span class="hljs-variable">happyMachine</span> <span class="hljs-operator">=</span> iocContainer.getBean(<span class="hljs-string">&quot;happyMachine7&quot;</span>,HappyMachine.class);<br>    System.out.println(<span class="hljs-string">&quot;happyMachine = &quot;</span> + happyMachine);<br><br>    <span class="hljs-comment">//如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可!  &amp;happyMachine7 这是一种固定的约束</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> iocContainer.getBean(<span class="hljs-string">&quot;&amp;happyMachine7&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;bean = &quot;</span> + bean);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>FactoryBean和BeanFactory区别</p>
<p><strong>FactoryBean</strong> 是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。</p>
<ul>
<li>一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！</li>
</ul>
<p><strong>BeanFactory</strong> 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。</p>
<p>配置文件导入外部属性文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入外部属性文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-注解-XML方式"><a href="#2-注解-XML方式" class="headerlink" title="2. 注解+XML方式"></a>2. 注解+XML方式</h2><h3 id="2-1-Bean注解标记和扫描"><a href="#2-1-Bean注解标记和扫描" class="headerlink" title="2.1 Bean注解标记和扫描"></a>2.1 Bean注解标记和扫描</h3><p>Spring提供了以下注解, 功能上没有区别</p>
<ul>
<li><code>@Component</code>: 泛化的注解, 表示容器中的一个组件</li>
<li><code>@Repository</code></li>
<li><code>@Service</code></li>
<li><code>@Controller</code></li>
</ul>
<p><strong>配置文件确定扫描范围</strong></p>
<ol>
<li>基本扫描配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置自动扫描的包 --&gt;</span><br><span class="hljs-comment">&lt;!-- 1.包要精准,提高性能!</span><br><span class="hljs-comment">     2.会扫描指定的包和子包内容</span><br><span class="hljs-comment">     3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu.components&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>排除指定组件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定不扫描的组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu.components&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- context:exclude-filter标签：指定排除规则 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>type的一些可选项</p>
<p>使用注解: <a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-componentscan-filter-type">https://www.baeldung.com/spring-componentscan-filter-type</a></p>
<p>使用配置文件: <a target="_blank" rel="noopener" href="https://blog.csdn.net/aa1049372051/article/details/46928977">https://blog.csdn.net/aa1049372051/article/details/46928977</a></p>
</blockquote>
<ol>
<li>扫描指定组件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 仅扫描指定的组件 --&gt;</span><br><span class="hljs-comment">&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;</span><br><span class="hljs-comment">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu.ioc.components&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>组件BeanName问题</strong></p>
<ul>
<li>默认情况为类名首字母小写</li>
<li>可以在注解上使用value属性指定(注解中只设置一个属性时，value属性名可以省略)</li>
</ul>
<h3 id="2-2-Bean作用域和周期方法注解"><a href="#2-2-Bean作用域和周期方法注解" class="headerlink" title="2.2 Bean作用域和周期方法注解"></a>2.2 Bean作用域和周期方法注解</h3><p><strong>作用域注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span> <span class="hljs-comment">//单例, 默认值</span><br><span class="hljs-comment">//@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanOne</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<p><strong>周期方法注解</strong></p>
<ul>
<li>周期方法要求：方法命名随意，但必须是 public void 无形参列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanOne</span> &#123;<br>  <span class="hljs-meta">@PostConstruct</span>  <span class="hljs-comment">//注解制指定初始化方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 初始化逻辑</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanTwo</span> &#123;<br>  <span class="hljs-meta">@PreDestroy</span> <span class="hljs-comment">//注解指定销毁方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 释放资源逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-Bean属性赋值"><a href="#2-3-Bean属性赋值" class="headerlink" title="2.3 Bean属性赋值"></a>2.3 Bean属性赋值</h3><p><strong>引用类型</strong></p>
<p>使用 <code>@Autowired</code>，标记位置：</p>
<ul>
<li>成员变量</li>
<li>构造函数</li>
<li>setter方法</li>
</ul>
<p>当类型匹配的 bean 不止一个时：</p>
<ul>
<li>没有 <code>@Qualifier</code> 注解：根据 <code>@Autowired</code> 标记位置<strong>成员变量的变量名</strong>作为 bean 的 id 进行匹配</li>
<li>使用 <code>@Qualifier</code> 注解：根据 <code>@Qualifier</code> 注解中指定的名称(value属性)作为 bean 的 id 进行匹配</li>
</ul>
<blockquote>
<p>当 <code>@Autowired</code> 注解设置 required = false 表示如果没有匹配的就不装配</p>
</blockquote>
<p><strong>基本类型</strong></p>
<p><code>@Value</code> 通常用于注入外部属性</p>
<p>首先编写外部属性文件，然后配置文件中引入外部文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">catalog.name</span>=<span class="hljs-string">MovieCatalog</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入外部配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;application.properties&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用 <code>@Value</code> 注解读取配置</p>
<p><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-value-annotation">https://www.baeldung.com/spring-value-annotation</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 情况1: <span class="hljs-doctag">@Value</span>(&quot;str&quot;) 直接注入常量</span><br><span class="hljs-comment"> * 情况2: $&#123;key&#125; 取外部配置key对应的值!</span><br><span class="hljs-comment"> * 情况3: $&#123;key:defaultValue&#125; 没有key,可以给与默认值</span><br><span class="hljs-comment"> * 情况4: #&#123;someBean.someValue&#125; 从其他bean取值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Value(&quot;$&#123;catalog:hahaha&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//hahaha</span><br></code></pre></td></tr></table></figure>
<h3 id="2-4-Resource"><a href="#2-4-Resource" class="headerlink" title="2.4 @Resource"></a>2.4 @Resource</h3><p>也可用于依赖注入，与 <code>@Autowired</code> 区别如下：</p>
<p><code>@Resource(name=&#39;test&#39;) == @Autowired + @Qualifier(value=&#39;test&#39;)</code></p>
<ul>
<li>@Resource注解默认<strong>根据Bean名称装配</strong>，未指定name时，使用属性名作为name。通过name找不到的话会自动通过类型装配</li>
<li>@Autowired注解默认<strong>根据类型装配</strong>，如果想根据名称装配，需要配合@Qualifier注解一起用</li>
<li>@Resource注解用在属性上、setter方法上。</li>
<li>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</li>
</ul>
<p>@Resource注解属于JDK扩展包，所以不在JDK当中，【<strong>高于JDK11或低于JDK8需要引入以下依赖</strong>】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>JSR(Java Specification Requests)是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列：</p>
<ol>
<li>JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解：</li>
</ol>
<ul>
<li><code>@Deprecated</code></li>
<li><code>@Override</code></li>
<li><code>@SuppressWarnings</code>: 抑制编译时产生的警告消息。</li>
<li><code>@SafeVarargs</code>: 标识一个有安全性警告的可变参数方法。</li>
<li><code>@FunctionalInterface</code>: 标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。</li>
</ul>
<ol>
<li>JSR-250: 这个JSR主要用于在Java EE 5中定义一些支持注解。包括：</li>
</ol>
<ul>
<li><code>@Resource</code>: 标识一个需要注入的资源</li>
<li><code>@PostConstruct</code>: 标识一个方法作为初始化方法。</li>
<li><code>@PreDestroy</code>: 标识一个方法作为销毁方法。</li>
<li><code>@RolesAllowed</code>: 标识授权角色</li>
<li><code>@PermitAll</code>: 标识一个活动无需进行身份验证。</li>
<li><code>@DenyAll</code>: 标识不提供针对该方法的访问控制。</li>
<li><code>@DeclareRoles</code>: 声明安全角色。</li>
</ul>
<ol>
<li>JSR-269: 这个JSR主要是Java SE 6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有：</li>
</ol>
<ul>
<li><code>@SupportedAnnotationTypes</code>: 标识注解处理器所处理的注解类型。</li>
<li><code>@SupportedSourceVersion</code>: 标识注解处理器支持的Java源码版本。</li>
</ul>
<ol>
<li>JSR-330: 该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括：</li>
</ol>
<ul>
<li><code>@Named</code>: 标识一个被依赖注入的组件的名称。</li>
<li><code>@Inject</code>: 标识一个需要被注入的依赖组件。</li>
<li><code>@Singleton</code>: 标识一个组件的生命周期只有一个唯一的实例。</li>
</ul>
<p><strong>JSR只规定了注解和注解的含义，不提供实现</strong>，由第三方框架(Spring)和库来实现</p>
</blockquote>
<h2 id="3-注解-配置类方式"><a href="#3-注解-配置类方式" class="headerlink" title="3. 注解+配置类方式"></a>3. 注解+配置类方式</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202310152355021.png" alt="img" style="zoom: 80%;" /></p>
<h3 id="3-1-配置类和注解扫描"><a href="#3-1-配置类和注解扫描" class="headerlink" title="3.1 配置类和注解扫描"></a>3.1 配置类和注解扫描</h3><p>创建配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//标注当前类是配置类，替代application.xml    </span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">//使用注解读取外部配置，替代&lt;context:property-placeholder&gt;标签</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:application.properties&quot;)</span><br><span class="hljs-comment">//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan&gt;标签</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>创建IoC容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">iocContainerAnnotation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfiguration.class);<br><br><span class="hljs-comment">// 也可以先使用无参构造函数创建，然后再配置</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">iocContainerAnnotation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br><span class="hljs-comment">//外部设置配置类</span><br>iocContainerAnnotation.register(MyConfiguration.class);<br><span class="hljs-comment">//刷新后方可生效！！</span><br>iocContainerAnnotation.refresh();<br></code></pre></td></tr></table></figure>
<h3 id="3-2-Bean"><a href="#3-2-Bean" class="headerlink" title="3.2 @Bean"></a>3.2 @Bean</h3><p><strong>@Bean定义组件</strong></p>
<p>将第三方jar包中的类，添加到IoC容器中，例如将Druid连接池对象存储到IoC容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果第三方类进行IoC管理,无法直接使用@Component相关注解</span><br><span class="hljs-comment">//解决方案: xml方式可以使用&lt;bean标签</span><br><span class="hljs-comment">//解决方案: 配置类方式,可以使用方法返回值+@Bean注解</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">createDataSource</span><span class="hljs-params">(<span class="hljs-meta">@Value(&quot;$&#123;jdbc.user&#125;&quot;)</span> String username,</span><br><span class="hljs-params">                                   <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password,</span><br><span class="hljs-params">                                   <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span><br><span class="hljs-params">                                   <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driverClassName)</span>&#123;<br>    <span class="hljs-comment">//使用Java代码实例化</span><br>    <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    dataSource.setUsername(username);<br>    dataSource.setPassword(password);<br>    dataSource.setUrl(url);<br>    dataSource.setDriverClassName(driverClassName);<br>    <span class="hljs-comment">//返回结果即可</span><br>    <span class="hljs-keyword">return</span> dataSource;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>@Bean生成BeanName问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Bean &#123;<br>    <span class="hljs-comment">//name与value都可以指定Bean的id</span><br>    <span class="hljs-meta">@AliasFor(&quot;name&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String[] name() <span class="hljs-keyword">default</span> &#123;&#125;;<br>  <br>    <span class="hljs-comment">//autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。</span><br>    <span class="hljs-comment">//autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标，</span><br>    <span class="hljs-comment">//可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">autowireCandidate</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">//指定初始化方法</span><br>    String <span class="hljs-title function_">initMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//指定销毁方法</span><br>    String <span class="hljs-title function_">destroyMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;(inferred)&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>@Bean(&quot;name&quot;) == @Bean(value=&quot;name&quot;) == @Bean(name=&quot;name&quot;)</code></p>
<p>缺省情况下 Bean 名称与方法名称相同</p>
<p><strong>@Bean指定初始化和销毁方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanOne</span> &#123;<br>  	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-comment">// initialization logic</span><br>  	&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-comment">// destruction logic</span><br>  	&#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;cleanup&quot;)</span><br>    <span class="hljs-keyword">public</span> BeanOne <span class="hljs-title function_">beanOne</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanOne</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>@Bean Scope作用域</strong></p>
<p>同2.2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> Encryptor <span class="hljs-title function_">encryptor</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>@Bean方法之间依赖</strong></p>
<ol>
<li><p>可以通过在一个 @Bean 方法中直接调用其他 @Bean 方法来获取 Bean 实例，虽然是方法调用，也是通过IoC容器获取对应的Bean</p>
</li>
<li><p>通过方法参数传递 Bean 实例的引用来解决 Bean 实例之间的依赖关系</p>
</li>
</ol>
<ul>
<li>如果该类型只有一个Bean，直接指定类型即可</li>
<li>如果有多个bean，参数名即为要指定的bean名称</li>
</ul>
<h3 id="3-3-Import扩展"><a href="#3-3-Import扩展" class="headerlink" title="3.3 @Import扩展"></a>3.3 @Import扩展</h3><p><code>@Import</code> 注解允许从另一个配置类加载 <code>@Bean</code> 定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigA</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> A <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(ConfigA.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigB</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> B <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同时，在实例化上下文时<strong>不需要同时指定</strong> <code>ConfigA.class</code> 和 <code>ConfigB.class</code>，只需显式提供 <code>ConfigB</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(ConfigB.class);<br><br><span class="hljs-comment">// now both beans A and B will be available...</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ctx.getBean(A.class);<br><span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ctx.getBean(B.class);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>整合 Spring 与 JUnit</p>
<ul>
<li>不需要创建IOC容器对象</li>
<li>任何需要的bean都可以在测试类中直接享受自动装配</li>
</ul>
<p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--junit5测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试注解使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-context.xml&quot;&#125;)  //指定配置文件xml</span><br><span class="hljs-meta">@SpringJUnitConfig(value = &#123;BeanConfig.class&#125;)</span>  <span class="hljs-comment">//指定配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Junit5IntegrationTest</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> User user;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJunit5</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Backend/">Backend</a>, <a href="/categories/Backend/Spring/">Spring</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Spring/">Spring</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/08/24/SpringBoot-1-核心特性/"><span>SpringBoot(1) 核心特性</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/08/24/SpringBoot-1-核心特性/" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-24T06:52:21.000Z">
          2023-08-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>本文使用的 SpringBoot 版本为 3.0.5, 最小需要 jdk17</p>
</blockquote>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 所有springboot项目都必须继承自 spring-boot-starter-parent --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application.executable-jar">官方文档</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringBoot应用打包插件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用 <code>mvn package</code> 打包后，通过 <code>java -jar</code> 即可运行</p>
<h3 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h3><p>通过书写配置文件 <code>application.properties/yml</code> 完成配置</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html">官方支持的配置</a></li>
</ul>
<h3 id="依赖管理机制"><a href="#依赖管理机制" class="headerlink" title="依赖管理机制"></a>依赖管理机制</h3><ul>
<li>导入场景启动器的依赖时不需要声明版本号<ul>
<li>原因：每个boot项目都有一个父项目<code>spring-boot-starter-parent</code><ul>
<li><code>spring-boot-starter-parent</code>的父项目是<code>spring-boot-dependencies</code>(版本仲裁中心)</li>
</ul>
</li>
<li><strong>版本仲裁中心</strong>声明了所有常见的jar的依赖版本</li>
</ul>
</li>
<li><p>自定义版本号：利用maven的就近原则</p>
<ul>
<li><p>直接在当前项目<code>properties</code>标签中声明父项目用的版本属性的key</p>
<ul>
<li>例如: <code>&lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;</code></li>
</ul>
</li>
<li><p>直接在<strong>导入依赖的时候声明版本</strong></p>
</li>
</ul>
</li>
<li><p>第三方的jar包自行声明版本</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/1679294529375-4ee1cd26-8ebc-4abf-bff9-f8775e10c927.png" alt="img" style="zoom:80%;" /></p>
<h3 id="自动配置机制"><a href="#自动配置机制" class="headerlink" title="自动配置机制"></a>自动配置机制</h3><ul>
<li><p>默认的包扫描规则</p>
<ul>
<li>SpringBoot只会扫描主程序所在的包及其下面的子包，自动的component-scan功能</li>
<li><p>自定义扫描路径</p>
<ul>
<li><code>@SpringBootApplication(scanBasePackages = &quot;com.atguigu&quot;)</code></li>
<li><code>@ComponentScan(&quot;com.atguigu&quot;)</code> 直接指定扫描的路径</li>
</ul>
</li>
</ul>
</li>
<li><p>配置默认值</p>
<ul>
<li><strong>配置文件</strong>的所有配置项是和某个<strong>类的对象值</strong>进行一一绑定的。</li>
<li>绑定了配置文件中每一项值的类：<strong>属性配置类</strong>。</li>
<li><p>比如：</p>
<ul>
<li><code>ServerProperties</code>绑定了所有Tomcat服务器有关的配置</li>
<li><code>MultipartProperties</code>绑定了所有文件上传相关的配置</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server">官方文档</a></li>
</ul>
</li>
</ul>
</li>
<li><p>按需加载自动配置</p>
<ul>
<li>场景启动器除了会导入相关功能依赖，导入一个<code>spring-boot-starter</code>，是所有<code>starter</code>的<code>starter</code></li>
<li><code>spring-boot-starter</code>导入了一个包 <code>spring-boot-autoconfigure</code>。包中囊括了所有场景的<code>AutoConfiguration</code><strong>自动配置类</strong></li>
<li><p>虽然全场景的自动配置都在 <code>spring-boot-autoconfigure</code>这个包，但并不是全都开启的</p>
<ul>
<li>导入哪个场景就开启哪个自动配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/1679970508234-3c6b8ecc-6372-4eb5-8c67-563054d1a72d.png" alt="img"></p>
<h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><ul>
<li><p><code>@Configuration</code>, <code>@SpringBootConfiguration</code>: 配置类, 使用上无区别</p>
</li>
<li><p><code>@Bean</code>, <code>@Scope</code>: 用于注册 bean 以及声明该 bean 的作用域, 通过修改函数名或者<code>@Bean</code>的值可设置 bean 的名称(组件名默认是函数名)</p>
</li>
<li><p><code>@Import</code>: 对第三方包中的组件进行注册时，除了可以在函数上使用 <code>@Bean</code>, 也可以在<strong>配置类</strong>上使用 <code>@Import(xxx.class)</code>(组件名默认为全类名)</p>
</li>
</ul>
<h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Backend/">Backend</a>, <a href="/categories/Backend/SpringBoot/">SpringBoot</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SpringBoot/">SpringBoot</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/07/12/软件工程与计算Ⅱ/"><span>软件工程与计算Ⅱ</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/07/12/软件工程与计算Ⅱ/" rel="bookmark">
        <time class="entry-date published" datetime="2023-07-12T04:09:06.000Z">
          2023-07-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="第一、二章-软件工程概论"><a href="#第一、二章-软件工程概论" class="headerlink" title="第一、二章 软件工程概论"></a>第一、二章 软件工程概论</h2><h3 id="软件工程（名词解释）"><a href="#软件工程（名词解释）" class="headerlink" title="软件工程（名词解释）"></a>软件工程（名词解释）</h3><ol>
<li>应用系统的、规范的、可量化的方法，来开发、运行和维护软件，即将工程应用到软件</li>
<li>对 (1) 中各种方法的研究</li>
</ol>
<h3 id="从1950s—2000s之间的特点"><a href="#从1950s—2000s之间的特点" class="headerlink" title="从1950s—2000s之间的特点"></a>从1950s—2000s之间的特点</h3><ul>
<li>1950s：科学计算；以机器为中心进行编程；像生产硬件一样生产软件</li>
<li>1960s：业务应用；软件不同于硬件；用软件工艺的方式生产软件</li>
<li>1970s：结构化方法；瀑布模型；强调规则和纪律。奠定了软件工程的基础</li>
<li>1980s：追求生产力最大化；现代结构化方法/面向对象编程广泛应用；重视过程的作用</li>
<li>1990s：企业为中心的大规模软件系统开发；追求快速开发、可变更性和用户价值；web应用出现</li>
<li>2000s：大规模web应用；大量面向大众的web产品；追求快速开发、可变更性、用户价值和创新</li>
</ul>
<h2 id="第四章-项目启动"><a href="#第四章-项目启动" class="headerlink" title="第四章 项目启动"></a>第四章 项目启动</h2><h3 id="如何管理团队"><a href="#如何管理团队" class="headerlink" title="如何管理团队"></a>如何管理团队</h3><ol>
<li><p>团队结构：主程序员团队；民主团队；开放团队</p>
</li>
<li><p>团队建设：建立团队章程；持续成功；和谐沟通；避免团队杀手</p>
</li>
</ol>
<h3 id="质量保障措施"><a href="#质量保障措施" class="headerlink" title="质量保障措施"></a>质量保障措施</h3><ol>
<li>需求开发：需求评审、需求度量</li>
<li>体系结构：体系结构评审、集成测试</li>
<li>详细设计：详细设计评审、设计度量、集成测试</li>
<li>实现：代码评审、代码度量、测试</li>
<li>测试：测试、测试度量</li>
</ol>
<h3 id="配置管理活动"><a href="#配置管理活动" class="headerlink" title="配置管理活动"></a>配置管理活动</h3><ol>
<li>标识配置项</li>
<li>版本管理</li>
<li>变更控制</li>
<li>配置审计</li>
<li>状态报告</li>
<li>软件发布管理</li>
</ol>
<h2 id="第五章-软件需求基础"><a href="#第五章-软件需求基础" class="headerlink" title="第五章 软件需求基础"></a>第五章 软件需求基础</h2><h3 id="需求定义"><a href="#需求定义" class="headerlink" title="需求定义"></a>需求定义</h3><ol>
<li>用户为了解决问题或达到某些目标所需要的条件或能力</li>
<li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</li>
<li>对 (1) 或 (2) 中一个条件或一种能力的文档化描述</li>
</ol>
<h3 id="需求的三个层次"><a href="#需求的三个层次" class="headerlink" title="需求的三个层次"></a>需求的三个层次</h3><p>【题型】给出一个实例，给出三个层次的例子；对给定的需求实例，判断其层次</p>
<p>【示例】</p>
<ol>
<li><p>系统使用三个月后，销售额应该提高20%（业务需求）</p>
</li>
<li><p>系统要帮助收银员完成销售处理（用户需求）</p>
</li>
<li><p>收银员输入商品的标识和数量时，系统要显示商品的描述、单价、数量和总价（系统级需求）</p>
</li>
</ol>
<p>【描述】</p>
<ol>
<li><p>业务需求：抽象层次最高的需求称为业务需求，是系统建立的战略出发点，表现为高层次的目标，描述了组织为什么要开发系统</p>
</li>
<li><p>用户需求：执行实际工作的用户对系统所能完成的具体任务的期望，描述了系统能够帮助用户做些什么</p>
</li>
<li><p>系统级需求：用户对系统行为的期望，每个系统及需求反映了一次外界与系统的交互行为，或者系统的一个实现细节</p>
</li>
</ol>
<h3 id="需求的类型"><a href="#需求的类型" class="headerlink" title="需求的类型"></a>需求的类型</h3><p>【题型】对给定实例，给出其不同类型的需求例子；对给定的需求示例，判断需求类型</p>
<p>【需求分类】项目需求、过程需求和系统需求（软件需求、硬件需求和其他需求）</p>
<p>【软件需求分类】</p>
<ol>
<li><p>功能需求：和系统主要工作相关的需求，即在不考虑物理约束的情况下，用户希望系统能够执行的活动，这些活动可以帮助用户完成任务</p>
</li>
<li><p>性能需求：速度、容量、吞吐量、负载、实时性</p>
</li>
<li><p>质量属性：可靠性、可用性、安全性、可维护性、可移植性、易用性</p>
</li>
<li><p>对外接口：系统和环境中其他系统之间需要建立的接口，包括用户界面、硬件接口、软件接口、网络通信接口</p>
</li>
<li><p>约束：进行系统构造时需要遵守的约定，例如编程语言、硬件设施等</p>
</li>
<li><p>数据需求：功能需求的补充，是需要在数据库、文件或者其他介质中存储的数据描述</p>
</li>
</ol>
<h2 id="第六章-需求分析方法"><a href="#第六章-需求分析方法" class="headerlink" title="第六章 需求分析方法"></a>第六章 需求分析方法</h2><h3 id="建立用例图"><a href="#建立用例图" class="headerlink" title="建立用例图"></a>建立用例图</h3><p>【四要素】用例、参与者、关系、系统边界</p>
<p>【步骤】</p>
<ol>
<li>进行目标分析与确定解决方向</li>
<li>寻找参与者</li>
<li>寻找用例</li>
<li>细化用例</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712193813264.png" alt="image-20230712193813264"></p>
<h3 id="建立分析类图（概念类图、领域模型）"><a href="#建立分析类图（概念类图、领域模型）" class="headerlink" title="建立分析类图（概念类图、领域模型）"></a>建立分析类图（概念类图、领域模型）</h3><p>【基本元素】对象、类、链接、关联（聚合）、继承</p>
<p>【图示】</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712131001510.png" alt="image-20230712131001510"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712131008234.png" alt="image-20230712131008234"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712131013064.png" alt="image-20230712131013064"></p>
<p>【步骤】</p>
<ol>
<li><p>对每个用例文本描述，尤其是场景描述，建立局部的概念类图</p>
</li>
<li><p>将所有用例产生的局部概念类图进行合并，建立软件系统的整体概念类图</p>
</li>
</ol>
<p>【建立局部概念类图】</p>
<ol>
<li><p>识别候选类</p>
</li>
<li><p>确定概念类</p>
</li>
<li><p>识别关联</p>
</li>
<li><p>识别重要属性</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712131047057.png" alt="image-20230712131047057"></p>
<h3 id="建立系统顺序图"><a href="#建立系统顺序图" class="headerlink" title="建立系统顺序图"></a>建立系统顺序图</h3><p>系统顺序图是将整个系统看作一个黑箱的对象而描述的简单顺序图形式，他强调外部参与者和系统的交互行为，重点展示系统级事件</p>
<p>【步骤】</p>
<ol>
<li><p>确定上下文环境</p>
</li>
<li><p>根据用例描述找到交互对象</p>
</li>
<li><p>按照用例描述中的流程顺序，逐步添加消息</p>
</li>
</ol>
<p>【图例】</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712133632656.png" alt="image-20230712133632656"><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712133636625.png" alt="image-20230712133636625"></p>
<h3 id="建立状态图"><a href="#建立状态图" class="headerlink" title="建立状态图"></a>建立状态图</h3><p>【要素】</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/clip_image002.jpg" alt="img"></p>
<p>【步骤】</p>
<ol>
<li><p>确定上下文环境</p>
</li>
<li><p>识别状态</p>
</li>
<li><p>建立状态转换</p>
</li>
<li><p>补充详细信息，完善状态图</p>
</li>
</ol>
<h2 id="第七章-需求文档化与验证"><a href="#第七章-需求文档化与验证" class="headerlink" title="第七章 需求文档化与验证"></a>第七章 需求文档化与验证</h2><h3 id="为什么建立需求规格说明？结合实验进行说明"><a href="#为什么建立需求规格说明？结合实验进行说明" class="headerlink" title="为什么建立需求规格说明？结合实验进行说明"></a>为什么建立需求规格说明？结合实验进行说明</h3><ol>
<li>软件开发过程中，子任务和人员之间存在错综复杂的关系，存在大量的沟通和交流，所以软件系统开发需要编写多种不同类型的文档，每种文档都针对项目中需要进行广泛交流的内容</li>
<li>软件需求是项目中需要进行广泛交流的内容之一，所以需求开发阶段需要进行需求的文档化</li>
</ol>
<h3 id="对给定的需求示例，判断并修正其错误（对给定的需求规格说明片段，找出并修正其错误）"><a href="#对给定的需求示例，判断并修正其错误（对给定的需求规格说明片段，找出并修正其错误）" class="headerlink" title="对给定的需求示例，判断并修正其错误（对给定的需求规格说明片段，找出并修正其错误）"></a>对给定的需求示例，判断并修正其错误（对给定的需求规格说明片段，找出并修正其错误）</h3><p>【需求文档化要点】</p>
<ol>
<li><p>技术文档写作要点：简洁、精确、易读（查询）、易修改</p>
</li>
<li><p>需求书写要点：使用用户术语、可验证、可行性</p>
</li>
<li><p>需求规格说明文档书写要点：充分利用标准的文档模板、保持所有内容位置得当；保持文档内的需求集具有完备性和一致性；为需求划分优先级</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712134722603.png" alt="image-20230712134722603"></p>
<h3 id="对给定的需求实例，设计功能测试用例，结合测试方法"><a href="#对给定的需求实例，设计功能测试用例，结合测试方法" class="headerlink" title="对给定的需求实例，设计功能测试用例，结合测试方法"></a>对给定的需求实例，设计功能测试用例，结合测试方法</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712134738179.png" alt="image-20230712134738179"></p>
<h2 id="第八章-软件设计基础"><a href="#第八章-软件设计基础" class="headerlink" title="第八章 软件设计基础"></a>第八章 软件设计基础</h2><h3 id="软件设计定义"><a href="#软件设计定义" class="headerlink" title="软件设计定义"></a>软件设计定义</h3><ol>
<li>软件设计是关于软件对象的设计，是一种设计活动，具有设计的普遍特性</li>
<li>软件设计既指软件对象实现的规格说明，也指产生这个规格说明的过程</li>
</ol>
<h3 id="软件设计的核心思想"><a href="#软件设计的核心思想" class="headerlink" title="软件设计的核心思想"></a>软件设计的核心思想</h3><p>抽象和分解</p>
<ol>
<li>抽象是在纵向上聚焦各子系统的接口。抽象可以分离接口和实现，让人更好地关注系统本质，从而降低复杂度</li>
<li>分解是在横向上将系统分割为几个相对简单的子系统以及各子系统之间的关系。分解之后只需要关注经过抽象的相对简单的子系统及其相互间的关系，从而降低复杂度</li>
</ol>
<h3 id="软件工程设计的三个层次及各层主要思想"><a href="#软件工程设计的三个层次及各层主要思想" class="headerlink" title="软件工程设计的三个层次及各层主要思想"></a>软件工程设计的三个层次及各层主要思想</h3><p>【高层设计】</p>
<p>基于反映软件高层抽象的构件层次，描述系统的高层结构、关注点和设计决策</p>
<p>【中层设计】</p>
<p>更加关注组成构件的模块的划分、导入/导出、过程之间调用关系或者类之间的协作</p>
<p>【低层设计】</p>
<p>深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等</p>
<h2 id="第九、十章-软件体系结构设计与构建"><a href="#第九、十章-软件体系结构设计与构建" class="headerlink" title="第九、十章 软件体系结构设计与构建"></a>第九、十章 软件体系结构设计与构建</h2><h3 id="体系结构的概念"><a href="#体系结构的概念" class="headerlink" title="体系结构的概念"></a>体系结构的概念</h3><p>一个软件系统的体系结构规定了系统的计算部件与部件之间的交互</p>
<h3 id="体系结构风格的优缺点"><a href="#体系结构风格的优缺点" class="headerlink" title="体系结构风格的优缺点"></a>体系结构风格的优缺点</h3><p><strong>主程序/子程序</strong></p>
<ul>
<li>优点：流程清晰，易于理解；强控制性</li>
<li>缺点：<ul>
<li>程序调用是一种强耦合的连接方式，非常依赖交互方的接口规格，这会使系统难以修改和复用</li>
<li>程序调用的连接方式限制了各部件之间的数据交互，可能会使不同部件使用隐含的共享数据交流，产生不必要的公共耦合，进而破坏它的“正确性”控制能力</li>
</ul>
</li>
</ul>
<p><strong>面向对象式</strong></p>
<ul>
<li>优点：内部实现的可修改性；易开发、易理解、易复用的结构组织</li>
<li>缺点：接口的耦合性；标识的耦合性；副作用（Ex. A 和 B 都修改 C）</li>
</ul>
<p><strong>分层</strong></p>
<ul>
<li>优点：设计机制清晰，易于理解；支持并行开发；更好的可复用性和内部可修改性</li>
<li>缺点：交互协议难以修改；性能损失；难以确定层次数量和粒度</li>
</ul>
<p><strong>MVC</strong></p>
<ul>
<li>优点：易开发性；视图和控制的可修改性；适宜于网络系统开发的特征</li>
<li>缺点：复杂性；模型修改困难</li>
</ul>
<h3 id="体系结构设计的过程"><a href="#体系结构设计的过程" class="headerlink" title="体系结构设计的过程"></a>体系结构设计的过程</h3><ol>
<li>分析关键需求和项目约束</li>
<li>选择体系结构风格</li>
<li>进行软件体系结构逻辑设计</li>
<li>依赖逻辑设计进行软件体系结构物理设计</li>
<li>完善软件体系结构设计</li>
<li>定义构件接口</li>
<li>迭代过程 3-6</li>
</ol>
<h3 id="包的原则"><a href="#包的原则" class="headerlink" title="包的原则"></a>包的原则</h3><p><strong>重用发布等价原则 REP</strong></p>
<p>（不要把很多用例放在一个包里），一个包中的类应该形成一个可复用和可发布的模块，模块提供一致的功能，减少复用者的工作</p>
<p><strong>共同封闭原则 CCP</strong></p>
<p>（不要把一个用例拆成多个包），最小化变化给程序员造成的影响，一起变化的类放在一个包里</p>
<p><strong>共同重用原则 CRP</strong></p>
<p>根据公共复用给类分组，一个包里的类应当一起被复用，常常导致细分包</p>
<blockquote>
<p>CCP和CRP原则互相排斥：CCP使维护者更简单，CRP使复用者更简单；CCP包更大，CRP包更小</p>
</blockquote>
<p><strong>无环依赖原则 ACP</strong></p>
<p>包的依赖结构应该是一个有向无环图</p>
<p><strong>稳定依赖原则 SDP</strong></p>
<p>向下接口的依赖是不稳定依赖</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712141123090.png" alt="image-20230712141123090"></p>
<p><strong>稳定抽象原则 SAP</strong></p>
<p>稳定包应是抽象包，不稳定包应是具体包</p>
<h3 id="体系结构构件之间接口的定义"><a href="#体系结构构件之间接口的定义" class="headerlink" title="体系结构构件之间接口的定义"></a>体系结构构件之间接口的定义</h3><p>根据分配的需求确定模块对外接口，如逻辑层接口根据页面的需求得到，数据层接口根据逻辑层调用得到</p>
<p>根据刺激与响应确定接口，依据详细规格明确接口内容（参数，返回值）</p>
<ol>
<li><p>通常情况，VIEW的需接口可以直接作为响应LOGIC的供接口</p>
</li>
<li><p>通常情况，LOGIC的需接口需要分解为同层模块和不同DATA的供接口</p>
</li>
</ol>
<h3 id="体系结构开发集成测试用例（Stub和Driver）"><a href="#体系结构开发集成测试用例（Stub和Driver）" class="headerlink" title="体系结构开发集成测试用例（Stub和Driver）"></a>体系结构开发集成测试用例（Stub和Driver）</h3><ol>
<li><p>依据模块接口建立桩程序</p>
<p>桩（Stub）：自顶向下集成，先集成和测试上层的模块，下层的模块使用伪装的具有相同接口的桩，比真实程序简单得多，是用最简单的逻辑。</p>
</li>
<li><p>编写驱动程序，在桩程序的帮助下进行集成测试</p>
<p>驱动（Driver）：自底向上集成，从底层的模块集成起，测试的时候上层的模块使用伪装的相同接口的驱动</p>
</li>
<li><p>持续集成：提倡尽早集成和频繁集成</p>
<p>尽早集成指开发之初就利用 stub 集成起来，频繁集成指每次完成一些开发任务，就用开发结果替换 stub 中相应组件</p>
<p>好处：a. 防止软件开发中出现无法集成与发布的情况。 b. 有利于检查和发现集成缺陷</p>
<p>工具链：利用版本控制工具和持续集成工具</p>
</li>
</ol>
<h2 id="第十一章-人机交互设计"><a href="#第十一章-人机交互设计" class="headerlink" title="第十一章 人机交互设计"></a>第十一章 人机交互设计</h2><h3 id="易用性概念-Useability"><a href="#易用性概念-Useability" class="headerlink" title="易用性概念(Useability)"></a>易用性概念(Useability)</h3><p>易用性是人机交互中一个既重要又复杂的概念，不仅关注人使用系统的过程，同时还关注系统对使用它的人所产生的作用。因为比较复杂，所以易用性不是单维度的质量属性，而是多维度的质量属性，包括易学性、易记性、效率、出错率和主观满意度</p>
<h3 id="能够列出至少5个界面设计的注意事项，并加以解释"><a href="#能够列出至少5个界面设计的注意事项，并加以解释" class="headerlink" title="能够列出至少5个界面设计的注意事项，并加以解释"></a>能够列出至少5个界面设计的注意事项，并加以解释</h3><p>【题型】例子违反了哪几条界面设计原则/很好的运用了哪些原则？</p>
<ol>
<li><p>简洁设计：不要使用太大的菜单，不要在一个窗口表现过多的信息类别，不要在一个表单中使用太多的颜色和字体作为线索，等等</p>
</li>
<li><p>一致性设计：遵循用户已有的精神模型，不要出现相似任务具有不同的交互机制（例如按钮位置不一致）</p>
</li>
<li><p>低出错率设计：首先帮助用户避免犯错，设计不让用户犯严重错误的系统，错误出现时，系统要提供简洁、有建设性、具体的指导来帮助用户消除错误</p>
</li>
<li><p>易记性设计：减少用户的记忆负担，方式有：逐层递进展示信息、使用直观的快捷方式、设置有意义的默认值</p>
</li>
</ol>
<h3 id="精神模型、差异性"><a href="#精神模型、差异性" class="headerlink" title="精神模型、差异性"></a>精神模型、差异性</h3><p>精神模型：用户进行人机交互时头脑中的任务模型，人机交互设计需要依据精神模型进行隐喻设计</p>
<p>差异性：不同用户群体的任务模型是有差异的，可以划分为新手用户、专家用户、熟练用户</p>
<p>【新手用户】是对业务不熟悉的人，设计系统时要关注易学性，进行业务导航，尽量避免出错</p>
<p>【专家用户】是能熟练操作计算机完成业务的人，设计系统要关注效率</p>
<p>【熟练用户】介于新手和专家之间，要在易学性和效率之间折中</p>
<h3 id="导航、反馈、协作式设计"><a href="#导航、反馈、协作式设计" class="headerlink" title="导航、反馈、协作式设计"></a>导航、反馈、协作式设计</h3><p><strong>导航</strong></p>
<ul>
<li>为用户提供一个完成任务的入口，好的导航会让这个入口非常符合人的精神模型</li>
<li>有全局结构和局部结构两种方式<ul>
<li>全局结构包括窗口、菜单、列表、快捷方式等，主要以功能分层和任务交互过程为依据</li>
<li>局部结构包括可视化控件布局与组合、按钮设置、文本颜色等，主要以用户关注的任务细节为依据</li>
</ul>
</li>
</ul>
<p><strong>反馈</strong></p>
<ul>
<li>提示用户交互行为的结果，但不能打断用户工作时的意识流</li>
</ul>
<p><strong>协作式设计</strong></p>
<ul>
<li>人和计算机是人机交互的两方，其中人的因素是比较固定的，一定时期内不会发生大的变化，所以要让二者交互顺畅，就需要让计算机更多地适应人的因素，这也是人机交互设计以用户为中心的根本原因</li>
<li>这种调整计算机因素以更好地适应并帮助用户地设计方式就成为协作式设计</li>
</ul>
<h2 id="第十二章-详细设计概述"><a href="#第十二章-详细设计概述" class="headerlink" title="第十二章 详细设计概述"></a>第十二章 详细设计概述</h2><h3 id="详细设计的出发点"><a href="#详细设计的出发点" class="headerlink" title="详细设计的出发点"></a>详细设计的出发点</h3><p>软件详细设计在软件体系结构设计之后进行，以需求开发的结果和软件体系结构的结果为出发点</p>
<h3 id="职责分配"><a href="#职责分配" class="headerlink" title="职责分配"></a>职责分配</h3><p>通过职责建立静态模型</p>
<p>【抽象对象的职责】类的职责主要由两部分组成：属性职责和方法职责。属性表示对象的状态，方法表示对象的行为</p>
<p>【抽象类之间的关系】类与类之间存在一定关系。关系表达了相应职责的划分与组合。它们的强弱顺序为：依赖 &lt; 关联 &lt; 聚合 &lt; 组合 &lt; 继承</p>
<p>【添加辅助类】帮助实现所有功能</p>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>通过协作建立动态模型</p>
<p>【抽象对象之间的协作】有两种方法</p>
<ol>
<li><p>从小到大，将对象的小职责聚合形成大职责</p>
</li>
<li><p>从大到小，将大职责分配给各个小对象</p>
</li>
</ol>
<h3 id="控制风格"><a href="#控制风格" class="headerlink" title="控制风格"></a>控制风格</h3><p>为了完成某一个大职责，需要对职责的分配做很多决策。控制风格决定了决策谁来做和怎么做决策。</p>
<p>【集中式】作决策的往往只有一个对象，由这个对象决定怎么来分配职责，怎么实现大的职责</p>
<p>【委托式】做出决策的对象不止一个，分别承担一定的职责，做出一定的决策，从而实现大的职责</p>
<p>【分散式】无法找到明确的控制对象，每个对象只承担一个相对较小的职责，完全由各个对象自治的方式来实现大的职责</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712155653249.png" alt="image-20230712155653249"></p>
<h3 id="给定分析类图、系统顺序图和设计因素描述，建立设计类图或者详细顺序图"><a href="#给定分析类图、系统顺序图和设计因素描述，建立设计类图或者详细顺序图" class="headerlink" title="给定分析类图、系统顺序图和设计因素描述，建立设计类图或者详细顺序图"></a>给定分析类图、系统顺序图和设计因素描述，建立设计类图或者详细顺序图</h3><p>抽象类的职责 -&gt; 抽象类之间的关系 -&gt; 添加辅助类</p>
<p>辅助类：接口类、数据类、启动类、控制器类等</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712155731069.png" alt="image-20230712155731069"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712155735000.png" alt="image-20230712155735000"></p>
<h3 id="协作的测试"><a href="#协作的测试" class="headerlink" title="协作的测试"></a>协作的测试</h3><p>类间协作的桩程序：Mock Object</p>
<h2 id="第十三章-详细设计中的模块化与信息隐藏"><a href="#第十三章-详细设计中的模块化与信息隐藏" class="headerlink" title="第十三章 详细设计中的模块化与信息隐藏"></a>第十三章 详细设计中的模块化与信息隐藏</h2><h3 id="耦合与内聚"><a href="#耦合与内聚" class="headerlink" title="耦合与内聚"></a>耦合与内聚</h3><p>耦合描述的是两个模块之间关系的复杂程度</p>
<p>内聚描述的是一个模块内部的联系的紧密性</p>
<h3 id="对例子说明它们之间的耦合程度与内聚，给出理由"><a href="#对例子说明它们之间的耦合程度与内聚，给出理由" class="headerlink" title="对例子说明它们之间的耦合程度与内聚，给出理由"></a>对例子说明它们之间的耦合程度与内聚，给出理由</h3><p>【耦合】（高-&gt;低）</p>
<ol>
<li><p>内容耦合（一个模块直接修改另一模块内容，GOTO语句，共享代码，内部类肯定是内容耦合）</p>
</li>
<li><p>公共耦合（模块间共享全局变量，文件，设备等）</p>
</li>
<li><p>重复耦合（两个模块有相同的业务逻辑代码）</p>
</li>
<li><p>控制耦合（一个模块给另一个模块传递控制信息，共享逻辑）</p>
</li>
<li><p>印记耦合（传递的数据结构只使用了一部分）</p>
</li>
<li><p>数据耦合（只共享对方需要的数据）</p>
</li>
</ol>
<p>【内聚】（高-&gt;低）</p>
<ol>
<li><p>信息内聚（模块每个操作都有各自入口点，相对独立，所有操作在相同数据结构上完成，如：栈）</p>
</li>
<li><p>功能内聚（模块只执行一个操作或达成单一目的，如：计算平方根，决定最短路径）</p>
</li>
<li><p>通信内聚（对相同数据执行不同操作：查书名、查作者、查出版商）</p>
</li>
<li><p>过程内聚（与步骤有关：守门员传后卫，后卫传中场，中场传前锋）</p>
</li>
<li><p>时间内聚（一系列与时间有关的操作：起床、刷牙、吃早点）</p>
</li>
<li><p>逻辑内聚（一系列可替换的操作：坐车去、坐飞机去、坐船去，switch）</p>
</li>
<li><p>偶然内聚（多个不相关操作）</p>
</li>
</ol>
<h3 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h3><p>【基本思想】每个模块都隐藏一个重要的设计决策。</p>
<p>每个模块都承担一定的职责，对外表现为一份契约，并且在这份契约之下隐藏着只有这个模块知道的设计决策或者秘密，决策的实现细节只有模块自己知道</p>
<p>【两种常见的信息隐藏决策】</p>
<p>根据需求分配的职责、内部实现机制</p>
<p>【题型】</p>
<p>对例子，说明其信息隐藏程度好坏</p>
<h2 id="第十四章-详细设计中面向对象方法下的模块化"><a href="#第十四章-详细设计中面向对象方法下的模块化" class="headerlink" title="第十四章 详细设计中面向对象方法下的模块化"></a>第十四章 详细设计中面向对象方法下的模块化</h2><h3 id="模块化的原则"><a href="#模块化的原则" class="headerlink" title="模块化的原则"></a>模块化的原则</h3><p>【降低隐式耦合】</p>
<ol>
<li><p>全局变量是有害的</p>
</li>
<li><p>显式（代码清晰，不进行不必要的隐藏）</p>
</li>
<li><p>不要有代码重复</p>
</li>
</ol>
<p>【降低访问耦合】</p>
<ol>
<li><p>针对接口编程：供接口、需接口</p>
</li>
<li><p>接口分离原则（ISP）：将一个统一的接口匹配为多个更独立的接口</p>
</li>
<li><p>迪米特法则：不要出现a.getB().methodB()</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712161113622.png" alt="image-20230712161113622"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712161116282.png" alt="image-20230712161116282"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>【降低继承耦合】</p>
<ol>
<li><p>里氏替换原则（LSP）：只要调用一个接口，不论是哪种子类或者父类自身，都可以完成相同语义的工作（因为接口没有被改变），（子类的前置条件必须与超类前置条件相同或更少，子类方法后置条件必须与超类方法后置条件相同会更多）</p>
</li>
<li><p>使用组合代替继承</p>
</li>
</ol>
<p>【提高内聚】</p>
<ol>
<li><p>单一职责原则</p>
</li>
<li><p>集中信息与行为</p>
</li>
</ol>
<h2 id="第十五章-详细设计中面向对象方法下的信息隐藏"><a href="#第十五章-详细设计中面向对象方法下的信息隐藏" class="headerlink" title="第十五章 详细设计中面向对象方法下的信息隐藏"></a>第十五章 详细设计中面向对象方法下的信息隐藏</h2><h3 id="信息隐藏的含义"><a href="#信息隐藏的含义" class="headerlink" title="信息隐藏的含义"></a>信息隐藏的含义</h3><p>一个模块应该通过稳定的接口对外表现其所承载的需求，而隐藏它对需求的内部实现细节。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol>
<li><p>将数据和行为同时包含在类中</p>
</li>
<li><p>分离对外接口与内部实现</p>
</li>
</ol>
<p>封装实现细节：封装数据和行为；封装内部结构；封装其他对象的引用；封装类型信息；封装潜在变更</p>
<h3 id="OCP"><a href="#OCP" class="headerlink" title="OCP"></a>OCP</h3><p>开闭原则OCP：对扩展开放，对修改封闭，即发生变更时，只需要添加新的代码而不需要修改原有的代码</p>
<p>违反OCP原则的典型标志：switch或if-else</p>
<p>可以使用多态来保证</p>
<h3 id="DIP"><a href="#DIP" class="headerlink" title="DIP"></a>DIP</h3><p>依赖倒置原则DIP（与工厂结合紧密，解决new的创建问题）</p>
<ol>
<li><p>抽象不应该依赖于细节，细节应该依赖于抽象。（抽象是稳定的，细节是不稳定的）</p>
</li>
<li><p>高层模块不应该依赖于低层模块，而是双方都依赖于抽象。（抽象是稳定的，高低层模块都可能是不稳定的）</p>
</li>
</ol>
<p>为具体类建立抽象接口并分离该接口是实现DIP的基本手段</p>
<h2 id="第十六章-设计模式"><a href="#第十六章-设计模式" class="headerlink" title="第十六章 设计模式"></a>第十六章 设计模式</h2><h3 id="如何实现可修改性、可扩展性、灵活性"><a href="#如何实现可修改性、可扩展性、灵活性" class="headerlink" title="如何实现可修改性、可扩展性、灵活性"></a>如何实现可修改性、可扩展性、灵活性</h3><p>通过接口与实现分离，Java中有两种方式</p>
<ol>
<li><p>通过接口和实现该接口的类</p>
</li>
<li><p>通过子类继承父类</p>
</li>
</ol>
<p>对于实现的可修改性，两种方式都没有任何耦合性</p>
<p>对于实现的可扩展性，可通过新的子类的创建来实现</p>
<p>对于实现的灵活性，可以通过多态的方式来实现</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712165122139.png" alt="image-20230712165122139"></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712165134077.png" alt="image-20230712165134077"></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712165157920.png" alt="image-20230712165157920"></p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712165211255.png" alt="image-20230712165211255"></p>
<h2 id="第十七、十八章-软件构造与代码设计"><a href="#第十七、十八章-软件构造与代码设计" class="headerlink" title="第十七、十八章 软件构造与代码设计"></a>第十七、十八章 软件构造与代码设计</h2><h3 id="构造包含的活动"><a href="#构造包含的活动" class="headerlink" title="构造包含的活动"></a>构造包含的活动</h3><p>详细设计、编程、测试、调试、代码评审、集成与构建、构造管理</p>
<h3 id="重构、测试驱动开发、结对编程的概念"><a href="#重构、测试驱动开发、结对编程的概念" class="headerlink" title="重构、测试驱动开发、结对编程的概念"></a>重构、测试驱动开发、结对编程的概念</h3><p>【重构】修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构</p>
<p>【测试驱动开发】编写一段代码前，优先完成该段代码的测试代码</p>
<p>【结对编程】两个程序员挨着坐在一起，共同协作进行软件构造活动</p>
<h3 id="给定代码段示例，对其进行改进或者发现其中的问题"><a href="#给定代码段示例，对其进行改进或者发现其中的问题" class="headerlink" title="给定代码段示例，对其进行改进或者发现其中的问题"></a>给定代码段示例，对其进行改进或者发现其中的问题</h3><p>【易读性】</p>
<ul>
<li><p>格式（使用缩进与对齐，将相关逻辑组织在一起，使用空行分隔逻辑，语句分行）</p>
</li>
<li><p>命名</p>
</li>
<li><p>注释（文档注释、内部注释）</p>
</li>
</ul>
<p>【易维护性】</p>
<ul>
<li><p>小型任务（分解为多个高内聚、低耦合的小任务）</p>
</li>
<li><p>复杂决策（使用新的布尔变量来简化，使用有意义的名称封装复杂决策，表驱动编程）</p>
</li>
<li><p>数据使用（不要将变量用于与命名不符的目的，不要将单个变量用于多个目的，限制全局变量，不要使用突兀的数字与字符）</p>
</li>
<li><p>明确依赖关系</p>
</li>
</ul>
<p>【可靠性】</p>
<ul>
<li><p>契约式设计</p>
</li>
<li><p>防御式编程</p>
</li>
</ul>
<p>【使用模型辅助设计复杂代码】</p>
<ul>
<li>决策表、伪代码、程序流程图</li>
</ul>
<h3 id="单元测试用例的设计"><a href="#单元测试用例的设计" class="headerlink" title="单元测试用例的设计"></a>单元测试用例的设计</h3><ol>
<li><p>为方法开发测试用例（根据方法的规格、方法代码的逻辑结构）</p>
</li>
<li><p>使用Mock Object测试类方法</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712165834545.png" alt="image-20230712165834545"></p>
<ol>
<li>为类开发测试用例</li>
</ol>
<h3 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h3><p>如果一个函数或方法，在前置条件满足的情况下开始执行，完成后能够满足后置条件，那么这个函数或方法就是正确、可靠的。有异常与断言两种方式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712165859268.png" alt="image-20230712165859268"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712165903024.png" alt="image-20230712165903024"></p>
<h3 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h3><p>在一个方法与其他方法、操作系统、硬件等外界环境交互时，不能确保外界都是正确的，所以要在外界发生错误时，保护方法内部不受损害</p>
<p>会增加整体代码复杂度，降低易读性和性能，但显著提高程序的可靠性</p>
<h3 id="表驱动"><a href="#表驱动" class="headerlink" title="表驱动"></a>表驱动</h3><p>复杂决策包装成决策表</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712170007005.png" alt="image-20230712170007005"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712170010619.png" alt="image-20230712170010619"></p>
<h3 id="代码复杂度度量"><a href="#代码复杂度度量" class="headerlink" title="代码复杂度度量"></a>代码复杂度度量</h3><p>圈复杂度：从 1 开始，每次遇到 if/while/for/repeat 就加 1，case语句每种情况都加 1</p>
<h2 id="第十九章-软件测试"><a href="#第十九章-软件测试" class="headerlink" title="第十九章 软件测试"></a>第十九章 软件测试</h2><h3 id="掌握白盒测试和黑盒测试的常见方法，并能够进行优缺点比较"><a href="#掌握白盒测试和黑盒测试的常见方法，并能够进行优缺点比较" class="headerlink" title="掌握白盒测试和黑盒测试的常见方法，并能够进行优缺点比较"></a>掌握白盒测试和黑盒测试的常见方法，并能够进行优缺点比较</h3><p>【黑盒测试】</p>
<p>基于规格的技术，黑盒测试是把测试对象看做一个黑盒子，完全基于输入和输出数据来判定测试对象的正确性</p>
<p>常见方法：等价类划分、边界值分析、决策表、状态转换</p>
<p>【白盒测试】</p>
<p>基于代码的技术，白盒测试将测试对象看作透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作</p>
<h3 id="白盒测试三种不同的方法"><a href="#白盒测试三种不同的方法" class="headerlink" title="白盒测试三种不同的方法"></a>白盒测试三种不同的方法</h3><p>【语句覆盖】确保被测试对象的每一行程序代码都至少执行一次</p>
<p>【条件覆盖】确保程序中每个判断的每个结果都至少满足一次</p>
<p>【路径覆盖】确保程序中每条独立的执行路径都至少执行一次</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230712170210765.png" alt="image-20230712170210765"></p>
<h3 id="给出一个场景，判断应该使用哪种测试方法，如何去写"><a href="#给出一个场景，判断应该使用哪种测试方法，如何去写" class="headerlink" title="给出一个场景，判断应该使用哪种测试方法，如何去写"></a>给出一个场景，判断应该使用哪种测试方法，如何去写</h3><p>对给定的场景和要求的测试方法，设计测试用例</p>
<ol>
<li><p>给出功能需求，则要求写功能测试用例</p>
</li>
<li><p>给出设计图，则要求写集成测试用例，Stub and Driver</p>
</li>
<li><p>给出方法描述，则要求写单元测试用例，Mock Object</p>
</li>
<li><p>JUnit基本使用方法</p>
</li>
</ol>
<h2 id="第二十、二十一章-软件交付、软件维护与演化"><a href="#第二十、二十一章-软件交付、软件维护与演化" class="headerlink" title="第二十、二十一章 软件交付、软件维护与演化"></a>第二十、二十一章 软件交付、软件维护与演化</h2><h3 id="如何理解软件维护的重要性"><a href="#如何理解软件维护的重要性" class="headerlink" title="如何理解软件维护的重要性"></a>如何理解软件维护的重要性</h3><ol>
<li>出现新的需求，如果不维护，软件将减少甚至失去服务用户的使用</li>
<li>随着软件产品的生命周期越来越长，在软件生存期内外界环境发生变化的可能性越来越大，软件需要经常修改以适应外界变化</li>
<li>软件产品中存在缺陷，当这些缺陷在使用中暴露出来时，必须予以及时的解决</li>
</ol>
<h3 id="开发可维护软件的方法"><a href="#开发可维护软件的方法" class="headerlink" title="开发可维护软件的方法"></a>开发可维护软件的方法</h3><ol>
<li><p>考虑软件的可变更性：分析需求的易变性，为变更进行设计</p>
</li>
<li><p>为降低维护困难而开发：编写详细的技术文档并保持及时更新，保证代码的可读性，维护需求跟踪链，维护回归测试基线</p>
</li>
</ol>
<h3 id="演化式生命周期模型"><a href="#演化式生命周期模型" class="headerlink" title="演化式生命周期模型"></a>演化式生命周期模型</h3><p>初始开发 -&gt; 演化 -&gt; 服务 -&gt; 逐步淘汰 -&gt; 停止</p>
<p>【初始开发】可以实现全部需求，也可以只包含部分需求—对用户来说非常重要和紧急的最高优先级需求</p>
<p>【演化】可能会有预先安排的需求增量，也可能完全是对变更请求的处理，保持软件产品的持续增值。</p>
<p>【服务】不再持续地增加自己的价值，而只是周期性地修正已有的缺陷</p>
<p>【逐步淘汰】不再提供软件产品的任何服务，即不再继续维护该软件</p>
<p>【停止】正式退出使用状态。开发者不再维护，用户也不再使用</p>
<h3 id="用户文档、系统文档"><a href="#用户文档、系统文档" class="headerlink" title="用户文档、系统文档"></a>用户文档、系统文档</h3><p>用户文档：为用户编写参考指南或者操作教程，常见有用户使用手册、联机帮助文档</p>
<p>系统文档：更注重系统维护方面的内容</p>
<h3 id="逆向工程、再工程"><a href="#逆向工程、再工程" class="headerlink" title="逆向工程、再工程"></a>逆向工程、再工程</h3><p>逆向工程：分析目标系统，标识系统的部件及其交互关系，并且使用其它形式或者更高层的抽象创建系统表现的过程</p>
<p>再工程：检查和改造一个目标系统，用新的模式及其实现复原该目标系统</p>
<h2 id="第二十二、二十三章-软件开发过程模型与职业基础"><a href="#第二十二、二十三章-软件开发过程模型与职业基础" class="headerlink" title="第二十二、二十三章 软件开发过程模型与职业基础"></a>第二十二、二十三章 软件开发过程模型与职业基础</h2><h3 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h3><p>需求工程 -&gt; 软件设计 -&gt; 软件实现 -&gt; 软件测试 -&gt; 软件交付 -&gt; 软件维护</p>
<h3 id="解释与比较不同过程模型（要求、特征描述、优点、缺点）"><a href="#解释与比较不同过程模型（要求、特征描述、优点、缺点）" class="headerlink" title="解释与比较不同过程模型（要求、特征描述、优点、缺点）"></a>解释与比较不同过程模型（要求、特征描述、优点、缺点）</h3><p><strong>构建-修复模型</strong></p>
<ul>
<li><p>特征：对软件开发活动没有任何规划和组织，是完全依靠开发人员个人能力进行软件开发的方式</p>
</li>
<li><p>缺点：</p>
<ul>
<li>没有对开发工作进行规范和组织，一旦开发活动超过个人的控制能力，开发活动就无法有效进行</li>
<li>没有分析需求的真实性，给软件开发带来很大的风险</li>
<li>没有考虑软件结构的质量，使得软件结构在不断地修改中越来越差，直至无法修改</li>
<li>没有考虑测试和程序的可维护性，也没有任何文档，软件的维护十分困难</li>
</ul>
</li>
<li><p>适用范围：</p>
<ul>
<li>软件规模很小，只需要几百行代码，开发复杂度个人能够胜任</li>
<li>软件对质量的要求不高，即使出错也无所谓</li>
<li>只关注开发活动，对后期维护的要求不高，甚至不需要维护</li>
</ul>
</li>
</ul>
<p><strong>瀑布模型</strong></p>
<ul>
<li>特征：要求每个活动的结果必须要进行验证，并且只有在经过验证之后才能作为后续开发活动的基础，被看作“文档驱动”</li>
<li>优点：为软件开发活动定义了清晰的阶段划分，让开发者能够以关注点分离的方式更好地进行那些复杂的软件项目的开发活动</li>
<li>缺点：<ul>
<li>对文档的过高期望</li>
<li>对开发活动的线性假设</li>
<li>客户、用户参与不够</li>
<li>里程碑粒度过粗</li>
</ul>
</li>
<li>适用范围：<ul>
<li>需求非常成熟、稳定、没有不确定的内容，也不会发生变化</li>
<li>所需的技术成熟、可靠、没有不确定的技术难点，也没有开发人员不熟悉的技术问题</li>
<li>复杂度适中，不至于产生太大的文档负担和过粗的里程碑</li>
</ul>
</li>
</ul>
<p><strong>增量迭代模型</strong></p>
<ul>
<li>特征：项目开始时，通过系统需求开发和核心体系结构设计活动完成项目对前景和范围的界定，然后再将后续开发活动组织为多个迭代、并行的瀑布式开发活动。（需求驱动）</li>
<li>优点：<ul>
<li>使用迭代式开发，具有更好的适用性</li>
<li>并行开发可以帮助缩短软件产品的开发时间</li>
<li>渐进交付可以加强用户反馈，降低开发风险</li>
</ul>
</li>
<li>缺点：<ul>
<li>由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构</li>
<li>增量迭代模型需要一个完备、清晰的项目前景和范围以进行并行开发规划，但是在一些不稳定的领域，不确定性太多或者需求变化非常频繁，很难在项目开始就确定前景和范围</li>
</ul>
</li>
<li>适用范围：<ul>
<li>大规模软件系统开发</li>
</ul>
</li>
</ul>
<p><strong>演化模型</strong></p>
<ul>
<li>特征：可以更好地应对需求变更，将软件开发活动组织为多个迭代、并行的瀑布式开发活动</li>
<li>优点：<ul>
<li>使用迭代式开发，具有更好的适用性，尤其适用于需求变更频繁或者不确定性较多的软件系统开发</li>
<li>并行开发可以帮助缩短软件产品的开发时间</li>
<li>渐进交付可以加强用户反馈，降低开发风险</li>
</ul>
</li>
<li>缺点：<ul>
<li>无法在项目早期阶段确定项目范围，所以项目的整体计划、进度调度，尤其是商务协商事宜无法准确把握</li>
<li>后续迭代的开发活动是在前导迭代的基础上进行修改和扩展的，这容易让后续迭代忽略分析与设计工作，蜕变为构建-修复方式</li>
</ul>
</li>
<li>适用范围：<ul>
<li>不稳定领域的大规模软件系统开发</li>
</ul>
</li>
</ul>
<p><strong>原型模型</strong></p>
<ul>
<li>特征：注重使用抛弃式原型，而不是演化式原型</li>
<li>优点：<ul>
<li>对原型方法的使用加强了与客户、用户的交流，可以让最终产品取得更好的满意度</li>
<li>适用于非常新颖的领域，这些领域因为新颖所以有着大量的不确定性</li>
</ul>
</li>
<li>缺点：<ul>
<li>原型方法能够解决风险，但自身也能带来新的风险</li>
<li>实践中，很多项目负责人不舍得抛弃“抛弃式原型”，使得质量较差的代码进入了最终产品，导致了最终产品的低质量</li>
</ul>
</li>
<li>适用范围：<ul>
<li>有着大量不确定性的新颖领域进行开发活动组织</li>
</ul>
</li>
</ul>
<p><strong>螺旋模型</strong></p>
<ul>
<li><p>特征：尽早解决比较高的风险，风险驱动</p>
</li>
<li><p>优点：可以降低风险，减少项目因风险造成的损失</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p>风险解决需要使用原型手段，也就会存在原型自身带来的风险</p>
</li>
<li><p>模型过于复杂，不利于管理者依据其组织软件开发活动</p>
</li>
</ul>
</li>
<li><p>适用范围</p>
<ul>
<li>高风险的大规模软件系统开发</li>
</ul>
</li>
</ul>
<h3 id="软件工程知识体系的知识域"><a href="#软件工程知识体系的知识域" class="headerlink" title="软件工程知识体系的知识域"></a>软件工程知识体系的知识域</h3><p>需求、设计、构造、测试、维护、配置管理、工程管理、工程过程、工程工具和方法、质量</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/软件工程与计算/">软件工程与计算</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件工程/">软件工程</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/07/08/数据管理基础/"><span>数据管理基础</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/07/08/数据管理基础/" rel="bookmark">
        <time class="entry-date published" datetime="2023-07-08T13:16:30.000Z">
          2023-07-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="01-绪论"><a href="#01-绪论" class="headerlink" title="01-绪论"></a>01-绪论</h1><h2 id="1-数据管理方式"><a href="#1-数据管理方式" class="headerlink" title="1. 数据管理方式"></a>1. 数据管理方式</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914210001864.png" alt="image-20220914210001750" style="zoom:80%;" /></p>
<ul>
<li>为什么需要数据库/数据有哪些管理方式，各自特点是什么</li>
</ul>
<h2 id="2-几个基本概念"><a href="#2-几个基本概念" class="headerlink" title="2. 几个基本概念"></a>2. 几个基本概念</h2><ul>
<li>数据：数据库中存储的基本对象，是描述事物的符号记录。</li>
<li><strong>数据的含义称为语义</strong>，数据与其语义是不可分的。<ul>
<li>93是数据，它可以是成绩、体重、钱数，这些是语义</li>
</ul>
</li>
<li><strong>数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。</strong></li>
<li>数据库系统的构成：数据库、数据库管理系统(DBMS，及其应用开发工具)，应用程序，数据库管理员(DBA)。</li>
</ul>
<h2 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3. 数据模型"></a>3. 数据模型</h2><ul>
<li>概念模型、逻辑模型、物理模型</li>
<li><strong>(必考)</strong>考点：概念 —&gt; E-R图 —&gt; 关系</li>
</ul>
<h3 id="3-1-概念模型"><a href="#3-1-概念模型" class="headerlink" title="3.1 概念模型"></a>3.1 概念模型</h3><ul>
<li>用于数据库设计，用 E-R 图来描述现实世界的概念模型。</li>
<li>概念：<ul>
<li>实体: 客观存在并可相互区别的事物称为实体</li>
<li>属性: 实体所具有的某一特性称为属性</li>
<li>码: 唯一标识实体的属性集称为码</li>
<li>实体型: 用实体名及其属性名集合来抽象和刻画同类实体称为实体型</li>
<li>实体集: 同一类型实体的集合称为实体集</li>
<li>联系: 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体(型)内部的联系和实体(型)之间的联系</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220616222137824.png" alt="image-20220616222137824"></p>
<h3 id="3-2-逻辑模型"><a href="#3-2-逻辑模型" class="headerlink" title="3.2 逻辑模型"></a>3.2 逻辑模型</h3><blockquote>
<p>问题：如何”多快好省”地将信息世界转换为机器世界？</p>
<p>方案 1：尽量独立于应用层，采用”中立”的方式表达概念模型，体现为<strong>关系数据库</strong></p>
<p>方案 2：在应用层中，使用特定数据结构，并在逻辑模型中高效支持这一数据结构，体现为 NoSQL 数据库</p>
<p>方案 *：通用数据结构采用方案 1，关键性数据结构采用方案2</p>
</blockquote>
<h4 id="3-2-1-关系模型的数据结构"><a href="#3-2-1-关系模型的数据结构" class="headerlink" title="3.2.1 关系模型的数据结构"></a>3.2.1 关系模型的数据结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211035926.png" alt="image-20220914211035814"></p>
<ul>
<li>规范条件：关系必须是规范化的，满足一定的规范条件。</li>
<li>最基本的规范条件(1NF)：关系的每一个分量必须是一个<strong>不可分</strong>的数据项，<strong>不允许表中还有表</strong>。</li>
<li>关系的完整性约束条件：<strong>实体完整性、参照完整性、用户定义的完整性</strong>。</li>
</ul>
<h4 id="3-2-2-关系模型的优缺点"><a href="#3-2-2-关系模型的优缺点" class="headerlink" title="3.2.2 关系模型的优缺点"></a>3.2.2 关系模型的优缺点</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220616223641721.png" alt="image-20220616223641721"></p>
<h4 id="3-2-3-NoSQL"><a href="#3-2-3-NoSQL" class="headerlink" title="3.2.3 NoSQL"></a>3.2.3 NoSQL</h4><ul>
<li>基于Key-Value存储模型</li>
<li>BigTable 模型：<code>(row:string, column:string, time:int64) ==&gt; string</code></li>
<li>基于文档模型</li>
<li>基于图模型：记为 G(V,E)，V 为结点集合，每个结点具有若干属性，E 为边集合，也可以具有若干属性。</li>
</ul>
<h2 id="4-数据库系统的结构"><a href="#4-数据库系统的结构" class="headerlink" title="4. 数据库系统的结构"></a>4. 数据库系统的结构</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220616224445417.png" alt="image-20220616224445417"></p>
<p>模式（Schema）</p>
<ul>
<li>数据库逻辑结构和特征的描述</li>
<li><p>是型的描述，不涉及具体值</p>
<ul>
<li>反映的是数据的结构及其联系</li>
</ul>
</li>
<li><p>模式是相对稳定的</p>
</li>
</ul>
<p>实例（Instance）</p>
<ul>
<li><p>反映数据库某一时刻的状态</p>
<ul>
<li>模式的一个具体值</li>
</ul>
</li>
<li><p>同一个模式可以有很多实例</p>
</li>
<li><p>实例随数据库中的数据的更新而变动</p>
</li>
</ul>
<h3 id="4-1-模式-逻辑模式"><a href="#4-1-模式-逻辑模式" class="headerlink" title="4.1 模式(逻辑模式)"></a>4.1 模式(逻辑模式)</h3><ul>
<li>一个数据库只有一个模式：数据库中全体数据的逻辑结构和特征的描述</li>
<li>模式的地位：是数据库系统模式结构的中间层<ul>
<li>与数据的物理存储细节和硬件环境无关</li>
<li>与具体的应用程序、开发工具及高级程序设计语言无关</li>
</ul>
</li>
<li>模式的定义<ul>
<li>数据的逻辑结构(数据项的名字、类型、取值范围等)</li>
<li>数据之间的联系</li>
<li>数据有关的安全性、完整性要求</li>
</ul>
</li>
</ul>
<h3 id="4-2-外模式-用户模式、子模式"><a href="#4-2-外模式-用户模式、子模式" class="headerlink" title="4.2 外模式(用户模式、子模式)"></a>4.2 外模式(用户模式、子模式)</h3><ul>
<li>数据库用户(包括应用程序员和最终用户)使用的局部数据的逻辑结构和特征的描述</li>
<li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li>
<li>外模式的用途<ul>
<li>保证数据库安全性的一个有力措施</li>
<li>每个用户只能看见和访问所对应的外模式中的数据</li>
</ul>
</li>
</ul>
<h3 id="4-3-内模式-存储模式"><a href="#4-3-内模式-存储模式" class="headerlink" title="4.3 内模式(存储模式)"></a>4.3 内模式(存储模式)</h3><ul>
<li>是数据物理结构和存储方式的描述</li>
<li>是数据在数据库内部的表示方式</li>
<li>一个数据库只有一个内模式</li>
</ul>
<h3 id="4-4-外模式-模式映像"><a href="#4-4-外模式-模式映像" class="headerlink" title="4.4 外模式/模式映像"></a>4.4 外模式/模式映像</h3><ul>
<li>同一个模式可以有任意多个外模式 </li>
<li>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</li>
<li>映象定义通常包含在各自外模式的描述中</li>
<li>保证数据的逻辑独立性<ul>
<li>当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变</li>
<li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li>
</ul>
</li>
</ul>
<h3 id="4-5-模式-内模式映像"><a href="#4-5-模式-内模式映像" class="headerlink" title="4.5 模式/内模式映像"></a>4.5 模式/内模式映像</h3><ul>
<li>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。<ul>
<li>例如，说明逻辑记录和字段在内部是如何表示的</li>
</ul>
</li>
<li>数据库中模式／内模式映象是唯一的</li>
<li>保证数据的物理独立性<ul>
<li>当数据库的存储结构改变了(例如选用了另一种存储结构)，数据库管理员修改模式／内模式映象，使模式保持不变。</li>
<li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li>
</ul>
</li>
</ul>
<h2 id="5-数据库系统的组成"><a href="#5-数据库系统的组成" class="headerlink" title="5. 数据库系统的组成"></a>5. 数据库系统的组成</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211054979.png" alt="image-20220914211054979"></p>
<h1 id="02-关系型数据库"><a href="#02-关系型数据库" class="headerlink" title="02-关系型数据库"></a>02-关系型数据库</h1><ul>
<li><p>域(D)、笛卡尔积(D*D)、元组((d1,d2,d3))、关系、属性、码</p>
</li>
<li><p><strong>候选码</strong>：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为<strong>候选码</strong>。</p>
<ul>
<li>关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li>
</ul>
</li>
<li><p><strong>主码</strong>：若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。</p>
</li>
<li><p><strong>主属性与非主属性</strong>：<strong>候选码的诸属性称为主属性</strong>。不包含在任何侯选码中的属性称为<strong>非主属性或非码属性</strong>。</p>
</li>
</ul>
<h2 id="1-关系"><a href="#1-关系" class="headerlink" title="1. 关系"></a>1. 关系</h2><h3 id="1-1-关系的类别"><a href="#1-1-关系的类别" class="headerlink" title="1.1 关系的类别"></a>1.1 关系的类别</h3><p>基本关系(基本表或基表)</p>
<ul>
<li>实际存在的表，是实际存储数据的逻辑表示</li>
</ul>
<p>查询表</p>
<ul>
<li>查询结果对应的表</li>
</ul>
<p>视图表</p>
<ul>
<li>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li>
</ul>
<h3 id="1-2-基本关系的性质"><a href="#1-2-基本关系的性质" class="headerlink" title="1.2 基本关系的性质"></a>1.2 基本关系的性质</h3><ul>
<li><p>列是同质的（Homogeneous）</p>
<ul>
<li>每一列中的分量是同一类型的数据，来自同一个域</li>
</ul>
</li>
<li><p>不同的列可出自同一个域</p>
</li>
<li><p>列的次序可以任意交换</p>
</li>
<li><p>任意两个元组的候选码不能相同</p>
</li>
<li><p>行的次序可以任意交换</p>
</li>
<li><p>分量必须取原子值</p>
</li>
</ul>
<h3 id="1-3-关系模式"><a href="#1-3-关系模式" class="headerlink" title="1.3 关系模式"></a>1.3 关系模式</h3><ul>
<li><p>关系模式（Relation Schema）是型，关系是值</p>
</li>
<li><p>关系模式是对关系的描述</p>
<ul>
<li><p>元组集合的结构</p>
</li>
<li><p>完整性约束条件</p>
</li>
</ul>
</li>
<li><p>关系模式可以形式化地表示为：$R(U,D,DOM,F)$</p>
<ul>
<li>$R$：关系名 </li>
<li>$U$：组成该关系的属性名集合</li>
<li>$D$：$U$中属性所来自的域</li>
<li>$DOM$：属性向域的映象集合</li>
<li>$F$：属性间数据的依赖关系的集合</li>
</ul>
</li>
<li><p>关系模式通常可以简记为 $R(U)$ 或 $R(A_1, A_2, …, A_n)$</p>
<ul>
<li>$A$: 属性名</li>
<li>注：域名及属性向域的映象常常直接说明为属性的类型、长度</li>
</ul>
</li>
<li><p>关系模式和关系往往笼统称为关系, 通过上下文加以区别</p>
</li>
</ul>
<h2 id="2-数据库完整性"><a href="#2-数据库完整性" class="headerlink" title="2. 数据库完整性"></a>2. 数据库完整性</h2><ul>
<li><p>实体完整性：主属性不为空</p>
</li>
<li><p>参照完整性：外码为空或者等于相应的某个主码</p>
</li>
<li><p>用户定义完整性：</p>
<p>例：课程(课程号，课程名，学分)</p>
<ul>
<li><p>“课程名”属性必须取唯一值</p>
</li>
<li><p>非主属性”课程名”也不能取空值</p>
</li>
<li><p>“学分”属性只能取值{1，2，3，4}</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3. 关系代数"></a>3. 关系代数</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707092725928.png" alt="image-20230707092725928"></p>
<h3 id="3-1-传统的集合操作"><a href="#3-1-传统的集合操作" class="headerlink" title="3.1 传统的集合操作"></a>3.1 传统的集合操作</h3><ul>
<li><p><strong>基本操作：并、差、交、(广义)笛卡尔积</strong></p>
<ul>
<li>进行 并、交、差 操作的关系应具有相同的目(即两个关系都有n个属性)且相应属性取自同一个域</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095153880.png" alt="image-20230707095153880"></p>
<ul>
<li><p>笛卡尔积：$R \times S$, $m+n$列, $k_1 \times k_2$个元组</p>
<ul>
<li><p>$R$: $n$目关系, $k_1$个元组</p>
</li>
<li><p>$S$: $m$目关系, $k_2$个元组</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095238550.png" alt="image-20230707095238550"></p>
<h3 id="3-2-使用的记号"><a href="#3-2-使用的记号" class="headerlink" title="3.2 使用的记号"></a>3.2 使用的记号</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095023441.png" alt="image-20230707095023441"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707093726034.png" alt="image-20230707093726034" style="zoom:80%;" /></p>
<h3 id="3-3-专门的关系运算"><a href="#3-3-专门的关系运算" class="headerlink" title="3.3 专门的关系运算"></a>3.3 专门的关系运算</h3><p><strong>选择</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095444581.png" alt="image-20230707095444581"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095453321.png" alt="image-20230707095453321"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>投影</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095525948.png" alt="image-20230707095525948"></p>
<p><strong>连接</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095631079.png" alt="image-20230707095631079"></p>
<ul>
<li>$\theta$ 为 “=” 的连接运算称为<strong>等值连接</strong></li>
<li><strong>自然连接</strong>是一种特殊的等值连接，要求比较的分量必须是同名的属性组，并将结果中重复的属性列去掉</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707100140151.png" alt="image-20230707100140151"></p>
<ul>
<li>悬浮元组、外连接</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707100440461.png" alt="image-20230707100440461"></p>
<p><strong>除</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707102247390.png" alt="image-20230707102247390"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707102435112.png" alt="image-20230707102435112"></p>
<h1 id="03-关系数据库标准语言SQL"><a href="#03-关系数据库标准语言SQL" class="headerlink" title="03-关系数据库标准语言SQL"></a>03-关系数据库标准语言SQL</h1><ul>
<li>SQL 结构化查询语言，是关系数据库的标准语言。集数据定义语言(DDL)，数据操纵语言(DML)，数据控制语言(DCL)功能于一体。</li>
<li>仅有 9 个动词：<code>CREATE, DROP, ALTER, SELECT, INSERT, UPDATE, DELETE, GRANT, REVOKE</code></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707102845313.png" alt="image-20230707102845313"></p>
<h2 id="1-SQL数据定义"><a href="#1-SQL数据定义" class="headerlink" title="1. SQL数据定义"></a>1. SQL数据定义</h2><h3 id="1-1-层次化的数据库对象命名机制"><a href="#1-1-层次化的数据库对象命名机制" class="headerlink" title="1.1 层次化的数据库对象命名机制"></a>1.1 层次化的数据库对象命名机制</h3><ul>
<li>一个关系数据库管理系统的实例(Instance)中可以建立多个数据库(database)</li>
<li>一个数据库中可以建立多个模式(schema)</li>
<li>一个模式下通常包括多个表(table)、视图(view)和索引(index)等数据库对象</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211108258.png" alt="image-20220914211108258"></p>
<h3 id="1-2-数据定义"><a href="#1-2-数据定义" class="headerlink" title="1.2 数据定义"></a>1.2 数据定义</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707110148151.png" alt="image-20230707110148151"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>表定义子句<span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-operator">&lt;</span>视图定义子句<span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-operator">&lt;</span>授权定义子句<span class="hljs-operator">&gt;</span>]<br><br><span class="hljs-keyword">DROP</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>CASCADE<span class="hljs-operator">|</span>RESTRICT<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>      (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]<br>      [,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]] <br>      [,<span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span>]);<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>［RESTRICT<span class="hljs-operator">|</span>CASCADE］;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>    [<span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [完整性约束]]<br>    [<span class="hljs-keyword">ADD</span> <span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>    [<span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [CASCADE<span class="hljs-operator">|</span>RESTRICT]]<br>    [<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span> [RESTRICT<span class="hljs-operator">|</span>CASCADE]]<br>    [<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure>
<ul>
<li><p>RESTRICT：删除表是有限制的。</p>
<ul>
<li><p>欲删除的基本表不能被其他表的约束所引用</p>
</li>
<li><p>如果存在依赖该表的对象，则此表不能被删除</p>
</li>
</ul>
</li>
<li><p>CASCADE：删除该表没有限制。</p>
<ul>
<li>在删除基本表的同时，相关的依赖对象一起删除</li>
</ul>
</li>
</ul>
<h3 id="1-3-索引"><a href="#1-3-索引" class="headerlink" title="1.3 索引"></a>1.3 索引</h3><ul>
<li><p>建立索引的目的：加快查询速度</p>
</li>
<li><p>关系数据库管理系统中常见索引</p>
<ul>
<li><p>顺序文件上的索引</p>
</li>
<li><p>B+树索引</p>
</li>
<li><p>散列（hash）索引</p>
</li>
<li><p>位图索引</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>][,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>]]...);<br><br><span class="hljs-keyword">ALTER</span> INDEX <span class="hljs-operator">&lt;</span>旧索引名<span class="hljs-operator">&gt;</span> RENAME <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>新索引名<span class="hljs-operator">&gt;</span>;<br><br><span class="hljs-keyword">DROP</span> INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔</li>
<li>次序：指定索引值的排列次序，升序：ASC，降序：DESC, 缺省值：ASC</li>
<li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li>
<li>CLUSTER：表示要建立的索引是聚簇索引</li>
</ul>
<h3 id="1-4-数据字典"><a href="#1-4-数据字典" class="headerlink" title="1.4 数据字典"></a>1.4 数据字典</h3><ul>
<li><p>数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：</p>
<ul>
<li>关系模式定义</li>
<li>视图定义</li>
<li>索引定义</li>
<li>完整性约束定义</li>
<li>各类用户对数据库的操作权限</li>
<li>统计信息等</li>
</ul>
</li>
<li><p>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。</p>
</li>
</ul>
<h2 id="2-SQL数据查询"><a href="#2-SQL数据查询" class="headerlink" title="2. SQL数据查询"></a>2. SQL数据查询</h2><h3 id="2-1-单表查询"><a href="#2-1-单表查询" class="headerlink" title="2.1 单表查询"></a>2.1 单表查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DISTINCT</span>] <span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span>] ...<br>	<span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>] ... <span class="hljs-operator">|</span> (<span class="hljs-operator">&lt;</span>select_caluse<span class="hljs-operator">&gt;</span>)<br>	[<span class="hljs-keyword">AS</span>] <span class="hljs-operator">&lt;</span>alias<span class="hljs-operator">&gt;</span><br>	[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>conditional_expression<span class="hljs-operator">&gt;</span>]<br>	[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>colName<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>conditional_expression<span class="hljs-operator">&gt;</span>]]<br>	[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>colName<span class="hljs-operator">&gt;</span>] [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]];<br>	<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果未对查询结果分组，聚集函数将作用于整个查询结果</span><br><span class="hljs-comment">HAVING短语与WHERE子句的区别：作用对象不同</span><br><span class="hljs-comment">- WHERE子句作用于基表或视图，从中选择满足条件的元组</span><br><span class="hljs-comment">- HAVING短语作用于组，从中选择满足条件的组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> Sno <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">SELECT</span> Sno, <span class="hljs-built_in">AVG</span>(Grade) <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(Grade) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">90</span>;<br><br>谓词： [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;&lt;匹配串&gt;&#x27;</span> [<span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;&lt;换码字符&gt;&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211119795.png" alt="image-20220914211119795"></p>
<ul>
<li><p>通配符 % 表示任意长度(包括0), ‘_’ 表示任意单个字符</p>
</li>
<li><p>聚集函数：COUNT, SUM, AVG, MAX, MIN</p>
</li>
</ul>
<h3 id="2-2-连接查询"><a href="#2-2-连接查询" class="headerlink" title="2.2 连接查询"></a>2.2 连接查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/* [例 3.49] 查询每个学生及其选修课程的情况 */</span><br><span class="hljs-keyword">SELECT</span> Student.<span class="hljs-operator">*</span>, SC.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student, SC<br><span class="hljs-keyword">WHERE</span> Student.Sno <span class="hljs-operator">=</span> SC.Sno;<br><br><span class="hljs-comment">/* 对上例使用自然连接 */</span><br><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade<br><span class="hljs-keyword">FROM</span> Student, SC<br><span class="hljs-keyword">WHERE</span> Student.Sno <span class="hljs-operator">=</span> SC.Sno;<br><br><span class="hljs-comment">/* [例 3.53] 改写 [例 3.49] </span><br><span class="hljs-comment">	左外连接：列出左表中所有的元组 */</span><br><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUT</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> (Student.Sno<span class="hljs-operator">=</span>SC.Sno);<br><br><span class="hljs-comment">/* [例3.54]查询每个学生的学号、姓名、选修 的课程名及成绩 */</span><br><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Cname, Grade<br><span class="hljs-keyword">FROM</span> Student, SC, Course <span class="hljs-comment">/*多表连接*/</span><br><span class="hljs-keyword">WHERE</span> Student.Sno <span class="hljs-operator">=</span> SC.Sno<br><span class="hljs-keyword">AND</span> SC.Cno <span class="hljs-operator">=</span> Course.Cno;<br><br># 自身连接<br><span class="hljs-keyword">SELECT</span> FIRST.Cno, SECOND.Cpno<br><span class="hljs-keyword">FROM</span> Course <span class="hljs-keyword">FIRST</span>, Course <span class="hljs-keyword">SECOND</span><br><span class="hljs-keyword">WHERE</span> FIRST.Cpno <span class="hljs-operator">=</span> SECOND.Cno;<br><br></code></pre></td></tr></table></figure>
<h3 id="2-3-嵌套查询"><a href="#2-3-嵌套查询" class="headerlink" title="2.3 嵌套查询"></a>2.3 嵌套查询</h3><ul>
<li>将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为嵌套查询</li>
<li>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt;&gt;）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname	     <span class="hljs-comment">/*外层查询/父查询*/</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sno <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> Sno       <span class="hljs-comment">/*内层查询/子查询*/</span><br>	<span class="hljs-keyword">FROM</span> SC<br>	<span class="hljs-keyword">WHERE</span> Cno<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2&#x27;</span><br>);<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707120633946.png" alt="image-20230707120633946"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707125025133.png" alt="image-20230707125025133"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄<br><span class="hljs-keyword">SELECT</span> Sname,Sage<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage <span class="hljs-operator">&lt;</span> <span class="hljs-keyword">ANY</span> (<br>    <span class="hljs-keyword">SELECT</span> Sage<br>    <span class="hljs-keyword">FROM</span> Student<br>    <span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span><br>) <span class="hljs-keyword">AND</span> Sdept <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;CS&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>带有<strong>EXISTS</strong>谓词的子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 查询所有选修了<span class="hljs-number">1</span>号课程的学生姓名<br><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>(<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>	<span class="hljs-keyword">FROM</span> SC<br>	<span class="hljs-keyword">WHERE</span> Sno <span class="hljs-operator">=</span> Student.Sno <span class="hljs-keyword">AND</span> Cno<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br>);<br><br># 查询与&quot;刘晨&quot;在同一个系学习的学生<br><span class="hljs-keyword">SELECT</span> Sno,Sname,Sdept<br><span class="hljs-keyword">FROM</span> Student S1<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> Student S2<br>    <span class="hljs-keyword">WHERE</span> S2.Sdept <span class="hljs-operator">=</span> S1.Sdept <span class="hljs-keyword">AND</span> S2.Sname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;刘晨&#x27;</span><br>);<br><br># 查询选修了全部课程的学生姓名<br><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> Course<br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> SC<br>        <span class="hljs-keyword">WHERE</span> Sno<span class="hljs-operator">=</span> Student.Sno <span class="hljs-keyword">AND</span> Cno<span class="hljs-operator">=</span> Course.Cno<br>    )<br>);<br></code></pre></td></tr></table></figure>
<h3 id="2-4-集合查询"><a href="#2-4-集合查询" class="headerlink" title="2.4 集合查询"></a>2.4 集合查询</h3><ul>
<li>并操作 UNION<ul>
<li>将多个查询结果合并起来时，系统自动去掉重复元组</li>
<li>UNION ALL：将多个查询结果合并起来时，保留重复元组 </li>
</ul>
</li>
<li>交操作 INTERSECT</li>
<li>差操作 EXCEPT</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># [例 <span class="hljs-number">3.64</span>] 查询计算机科学系的学生及年龄不大于<span class="hljs-number">19</span>岁的学生。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage <span class="hljs-operator">&lt;=</span> <span class="hljs-number">19</span>;<br><br># [例<span class="hljs-number">3.66</span>] 查询计算机科学系的学生与年龄不大于<span class="hljs-number">19</span>岁的学生的交集。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span> <br><span class="hljs-keyword">INTERSECT</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage <span class="hljs-operator">&lt;=</span> <span class="hljs-number">19</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span><br><span class="hljs-keyword">EXCEPT</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage <span class="hljs-operator">&lt;=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure>
<h3 id="2-5-基于派生表的查询"><a href="#2-5-基于派生表的查询" class="headerlink" title="2.5 基于派生表的查询"></a>2.5 基于派生表的查询</h3><p>子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这时子查询生成的临时派生表成为主查询的查询对象</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno, Cno<br><span class="hljs-keyword">FROM</span> SC, (<br>    <span class="hljs-keyword">SELECT</span> Sno, <span class="hljs-built_in">Avg</span>(Grade) <br>    <span class="hljs-keyword">FROM</span> SC<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br>) <span class="hljs-keyword">AS</span> Avg_sc(avg_sno,avg_grade)<br><span class="hljs-keyword">WHERE</span> SC.Sno <span class="hljs-operator">=</span> Avg_sc.avg_sno <span class="hljs-keyword">and</span> SC.Grade <span class="hljs-operator">&gt;=</span> Avg_sc.avg_grade<br></code></pre></td></tr></table></figure>
<p>如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student, (<br>    <span class="hljs-keyword">SELECT</span> Sno<br>    <span class="hljs-keyword">FROM</span> SC<br>    <span class="hljs-keyword">WHERE</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br>) <span class="hljs-keyword">AS</span> SC1<br><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC1.Sno;<br></code></pre></td></tr></table></figure>
<h2 id="3-数据更新"><a href="#3-数据更新" class="headerlink" title="3. 数据更新"></a>3. 数据更新</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[, <span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>...)]<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-operator">&lt;</span>常量<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[, <span class="hljs-operator">&lt;</span>常量<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]... );<br><br># 插入子查询结果<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Dept_age(Sdept,Avg_age)<br>    <span class="hljs-keyword">SELECT</span> Sdept，<span class="hljs-built_in">AVG</span>(Sage)<br>    <span class="hljs-keyword">FROM</span> Student<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sdept;<br><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">SET</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>[, <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>];<br><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure>
<h2 id="4-SQL中的空值"><a href="#4-SQL中的空值" class="headerlink" title="4. SQL中的空值"></a>4. SQL中的空值</h2><ul>
<li>判断空值用 <code>IS NULL</code> 或 <code>IS NOT NULL</code>。</li>
<li>有<code>NOT NULL</code>、<code>UNIQUE</code>限制的属性不能为空值，码不能为空值。</li>
<li>空值与其他值的算术运算结果为空值，空值与其他值的比较运算结果为 <code>UNKNOWN</code></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211132547.png" alt="image-20220914211132547"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># [例 <span class="hljs-number">3.83</span>] 选出选修<span class="hljs-number">1</span>号课程的不及格的学生以及缺考的学生。<br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Grade <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span><br>  <span class="hljs-keyword">AND</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Grade <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br>  <span class="hljs-keyword">AND</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br><br># 或者<br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br>  <span class="hljs-keyword">AND</span> (Grade <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span> <span class="hljs-keyword">OR</span> Grade <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>);<br></code></pre></td></tr></table></figure>
<h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5. 视图"></a>5. 视图</h2><ul>
<li><p>从一个或几个基本表(或视图)导出的表，是一个虚表。数据库中只存放视图的定义，不存放视图对应的数据。</p>
</li>
<li><p>基表中的数据发生变化，从视图中查询出的数据也随之改变</p>
</li>
<li><p><strong>视图的作用：</strong></p>
<ol>
<li>视图能够简化用户的操作</li>
<li>使用户能够以多种角度看待同一数据</li>
<li>提供了一定程度的逻辑独立性</li>
<li>提供安全保护</li>
<li>可以更清晰地表达查询</li>
</ol>
</li>
</ul>
<h3 id="5-1-定义视图"><a href="#5-1-定义视图" class="headerlink" title="5.1 定义视图"></a>5.1 定义视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>]...)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br><br># 建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> IS_Student <span class="hljs-keyword">AS</span> <br>    <span class="hljs-keyword">SELECT</span> Sno,Sname,Sage<br>    <span class="hljs-keyword">FROM</span>  Student<br>    <span class="hljs-keyword">WHERE</span>  Sdept<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;IS&#x27;</span><br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为行列子集视图</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>WITH CKECK OPTION：表示对视图进行更新操作时要保证<strong>更新后的行满足谓词条件</strong>(即子查询中的条件)</li>
<li>组成视图的属性列名：全部省略或全部指定</li>
<li>关系数据库管理系统执行 CREATE VIEW 语句时只是把视图定义存入数据字典，并不执行其中的 SELECT 语句。</li>
<li>在对视图查询时，按视图的定义从基本表中将数据查出</li>
</ul>
<h3 id="5-2-删除视图"><a href="#5-2-删除视图" class="headerlink" title="5.2 删除视图"></a>5.2 删除视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [CASCADE];<br># 如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除<br></code></pre></td></tr></table></figure>
<h3 id="5-3-查询视图"><a href="#5-3-查询视图" class="headerlink" title="5.3 查询视图"></a>5.3 查询视图</h3><ul>
<li>用户角度：查询视图与查询基本表相同</li>
<li>关系数据库管理系统实现视图查询的方法<ul>
<li>视图消解法（View Resolution）<ul>
<li>进行有效性检查</li>
<li>转换成等价的对基本表的查询</li>
<li>执行修正后的查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 在信息系学生的视图中找出年龄小于<span class="hljs-number">20</span>岁的学生。<br><span class="hljs-keyword">SELECT</span> Sno,Sage<br><span class="hljs-keyword">FROM</span> IS_Student<br><span class="hljs-keyword">WHERE</span> Sage<span class="hljs-operator">&lt;</span><span class="hljs-number">20</span>;<br><br># 视图消解转换后的查询语句为：<br><span class="hljs-keyword">SELECT</span> Sno,Sage       <br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;IS&#x27;</span> <span class="hljs-keyword">AND</span> Sage<span class="hljs-operator">&lt;</span><span class="hljs-number">20</span>;<br><br># 有些情况下，视图消解法不能生成正确的查询。<br># 例如：在S_G视图中查询平均成绩在<span class="hljs-number">90</span>分以上的学生学号和平均成绩<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> S_G<br><span class="hljs-keyword">WHERE</span> Gavg<span class="hljs-operator">&gt;=</span><span class="hljs-number">90</span>;<br><br># 正确的消解转换后<br><span class="hljs-keyword">SELECT</span> Sno, <span class="hljs-built_in">AVG</span>(Grade)<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(Grade)<span class="hljs-operator">&gt;=</span><span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure>
<h3 id="5-更新视图"><a href="#5-更新视图" class="headerlink" title="5. 更新视图"></a>5. 更新视图</h3><ul>
<li>转换为对基本表的更新</li>
<li>允许对行列子集视图进行更新</li>
<li>对其他类型视图的更新不同系统有不同限制。<ul>
<li>一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新。</li>
<li>一个不允许更新的视图上定义的视图也不允许更新。</li>
</ul>
</li>
</ul>
<h1 id="04-数据库安全性"><a href="#04-数据库安全性" class="headerlink" title="04-数据库安全性"></a>04-数据库安全性</h1><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707143008735.png" alt="image-20230707143008735"></p>
<h2 id="1-自主存取控制"><a href="#1-自主存取控制" class="headerlink" title="1. 自主存取控制"></a>1. 自主存取控制</h2><ul>
<li><p>自主存取控制，简称<strong>DAC</strong></p>
</li>
<li><p>C2级</p>
</li>
<li><p><strong>缺点：可能存在数据的无意泄露</strong></p>
<ul>
<li>原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</li>
<li>解决：对系统控制下的所有主客体实施强制存取控制策略</li>
</ul>
</li>
</ul>
<h3 id="1-1-GRANT"><a href="#1-1-GRANT" class="headerlink" title="1.1 GRANT"></a>1.1 GRANT</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211142564.png" alt="image-20220914211142564"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION ];<br># <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION 子句：可以再授予其他用户，不允许循环授权<br><br># [例<span class="hljs-number">4.1</span>] 把查询 Student 表和修改学生学号权限授给用户 U1<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">UPDATE</span>(Sno), <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">TO</span> U1;<br><br># [例<span class="hljs-number">4.2</span>] 把对Student表和Course表的全部权限授予所有用户<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILIGES <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student, Course<br><span class="hljs-keyword">TO</span> PUBLIC;<br></code></pre></td></tr></table></figure>
<h3 id="1-2-REVOKE"><a href="#1-2-REVOKE" class="headerlink" title="1.2 REVOKE"></a>1.2 REVOKE</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">REVOKE</span>语句的一般格式为：<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[CASCADE <span class="hljs-operator">|</span> RESTRICT];<br><br># [例<span class="hljs-number">4.8</span>] 把用户U4修改学生学号的权限收回<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">UPDATE</span>(Sno) <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">FROM</span> U4;<br><br># [例<span class="hljs-number">4.9</span>] 收回所有用户对表 SC 的查询权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> SC<br><span class="hljs-keyword">FROM</span> PUBLIC;<br><br># [例<span class="hljs-number">4.10</span>] 把用户U5对SC表的 <span class="hljs-keyword">INSERT</span>权限收回<br># 将用户U5的<span class="hljs-keyword">INSERT</span>权限收回的时候使用CASCADE，则同时收回U6或U7的<span class="hljs-keyword">INSERT</span>权限，否则拒绝执行该语句<br># 如果U6或U7还从其他用户处获得对SC表的<span class="hljs-keyword">INSERT</span>权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">INSERT</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> SC<br><span class="hljs-keyword">FROM</span> U5 <br>CASCADE;<br></code></pre></td></tr></table></figure>
<h3 id="1-3-创建数据库模式的权限"><a href="#1-3-创建数据库模式的权限" class="headerlink" title="1.3 创建数据库模式的权限"></a>1.3 创建数据库模式的权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"># 该命令不是 <span class="hljs-keyword">SQL</span> 标准<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-operator">&lt;</span>username<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span>] [DBA <span class="hljs-operator">|</span> RESOURCE <span class="hljs-operator">|</span> <span class="hljs-keyword">CONNECT</span>];<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211153494.png" alt="image-20220914211153494"></p>
<h3 id="1-4-数据库角色"><a href="#1-4-数据库角色" class="headerlink" title="1.4 数据库角色"></a>1.4 数据库角色</h3><ul>
<li>数据库角色：被命名的一组与数据库操作相关的权限<ul>
<li>角色是权限的集合</li>
<li>可以为一组具有相同权限的用户创建一个角色</li>
<li>简化授权的过程</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 角色的创建<br><span class="hljs-keyword">CREATE</span> ROLE <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span>;<br># 给角色授权<br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span>对象名 <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br># 将一个角色授予其他的角色或用户<br># 该语句把角色授予某用户，或授予另一个角色<br># 授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION<br># 指定了<span class="hljs-keyword">WITH</span> ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色<br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]... <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色或用户<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色或用户<span class="hljs-operator">&gt;</span>]... [<span class="hljs-keyword">WITH</span> ADMIN OPTION];<br><br># 角色权限的收回<br># 用户可以回收角色的权限，从而修改角色拥有的权限<br># <span class="hljs-keyword">REVOKE</span>执行者是角色的创建者或拥有在这个(些)角色上的ADMIN OPTION<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br># [例<span class="hljs-number">4.11</span>] 通过角色来实现将一组权限授予一个用户。<br><span class="hljs-keyword">CREATE</span> ROLE R1;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">UPDATE</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">TO</span> R1;<br><span class="hljs-keyword">GRANT</span> R1 <span class="hljs-keyword">TO</span> 王平,张明,赵玲;<br><span class="hljs-keyword">REVOKE</span> R1 <span class="hljs-keyword">FROM</span> 王平;<br># 角色的权限修改<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">TO</span> R1;<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">FROM</span> R1;<br></code></pre></td></tr></table></figure>
<h2 id="2-强制存取控制"><a href="#2-强制存取控制" class="headerlink" title="2. 强制存取控制"></a>2. 强制存取控制</h2><ul>
<li><p>强制存取控制，简称<strong>MAC</strong></p>
<ul>
<li>每一个数据对象被标以一定的密级</li>
<li>每一个用户也被授予某一个级别的许可证</li>
<li>对于任意一个对象，只有具有合法许可证的用户才可以存取</li>
</ul>
</li>
<li><p>B1级</p>
</li>
<li><p>主体的敏感度标记称为许可证级别(Clearance Level)，客体的敏感度标记称为密级(Classification Level)。</p>
</li>
<li><p>敏感度标记分成若干级别</p>
<ul>
<li>绝密(Top Secret，TS)</li>
<li>机密(Secret，S)</li>
<li>可信(Confidential，C)</li>
<li>公开(Public，P)</li>
<li>TS&gt;=S&gt;=C&gt;=P</li>
</ul>
</li>
<li><p><strong>强制存取控制规则：</strong></p>
<ul>
<li>仅当主体的许可证级别<strong>大于或等于</strong>客体的密级时， 该主体才能<strong>读取</strong>相应的客体</li>
<li>仅当主体的许可证级别<strong>小于或等于</strong>客体的密级时，该主体才能<strong>写</strong>相应的客体</li>
</ul>
</li>
</ul>
<blockquote>
<p>规则 1 的必要性是明显的。</p>
<p>规则 2 是为了防止把数据的密级从高流向低。如许可证级别为 TS 的主体读取密级为 TS 的客体并以密级 P 写回，造成数据泄露。在规则 2 下，用户可以把写入的对象赋予高于自己许可证级别的密级，一旦数据被写入，该用户自己也不能读取该数据了。</p>
<p>规则 2 应该理解为：主体写入的客体内容<strong>可以被赋予高于主体许可证级别的密级</strong>，而不是：主体可以修改密级高于该主体许可证级别的客体。</p>
</blockquote>
<ul>
<li>实现强制存取控制时要首先实现自主存取控制<ul>
<li>原因：较高安全性级别提供的安全保护要包含较低级别的所有保护</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211205087.png" alt="image-20220914211205087"></p>
<h2 id="3-视图、审计、数据加密及其他"><a href="#3-视图、审计、数据加密及其他" class="headerlink" title="3. 视图、审计、数据加密及其他"></a>3. 视图、审计、数据加密及其他</h2><h3 id="3-1-视图机制"><a href="#3-1-视图机制" class="headerlink" title="3.1 视图机制"></a>3.1 视图机制</h3><p>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707145256935.png" alt="image-20230707145256935"></p>
<h3 id="3-2-审计"><a href="#3-2-审计" class="headerlink" title="3.2 审计"></a>3.2 审计</h3><ul>
<li>启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面</li>
<li>审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容</li>
<li>C2以上安全级别的DBMS必须具有审计功能</li>
<li>审计很费时间和空间</li>
<li>DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能</li>
<li>审计功能主要用于安全性要求较高的部门</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 对修改SC表结构或修改SC表数据的操作进行审计<br>AUDIT <span class="hljs-keyword">ALTER</span>, <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> SC;<br><br># 取消对SC表的一切审计<br>NOAUDIT <span class="hljs-keyword">ALTER</span>,<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> SC;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-数据加密"><a href="#3-3-数据加密" class="headerlink" title="3.3 数据加密"></a>3.3 数据加密</h3><ul>
<li><p>防止数据库中数据在存储和传输中失密的有效手段</p>
</li>
<li><p>加密方法</p>
<ul>
<li>存储加密</li>
<li>传输加密</li>
</ul>
</li>
<li><p>透明存储加密</p>
<ul>
<li><p>内核级加密保护方式，对用户完全透明</p>
</li>
<li><p>将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密</p>
</li>
<li><p>数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可</p>
</li>
<li><p>内核级加密方法: 性能较好，安全完备性较高</p>
</li>
</ul>
</li>
<li><p>非透明存储加密</p>
<ul>
<li>通过多个加密函数实现</li>
</ul>
</li>
<li><p>链路加密</p>
<ul>
<li><p>在链路层进行加密</p>
</li>
<li><p>传输信息由报头和报文两部分组成</p>
</li>
<li><p>报文和报头均加密</p>
</li>
</ul>
</li>
<li><p>端到端加密</p>
<ul>
<li><p>在发送端加密，接收端解密</p>
</li>
<li><p>只加密报文不加密报头</p>
</li>
<li><p>所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-其他安全性保护"><a href="#3-4-其他安全性保护" class="headerlink" title="3.4 其他安全性保护"></a>3.4 其他安全性保护</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707145610596.png" alt="image-20230707145610596"></p>
<h1 id="05-数据库完整性"><a href="#05-数据库完整性" class="headerlink" title="05-数据库完整性"></a>05-数据库完整性</h1><ul>
<li>数据的完整性：防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li>
</ul>
<h2 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1. 实体完整性"></a>1. 实体完整性</h2><ul>
<li><p><code>CREATE TABLE</code>中用<code>PRIMARY KEY</code>定义</p>
</li>
<li><p>单属性构成的码有两种说明方法 </p>
<ul>
<li><p>定义为列级约束条件</p>
</li>
<li><p>定义为表级约束条件</p>
</li>
</ul>
</li>
<li><p>对多个属性构成的码只有一种说明方法</p>
<ul>
<li>定义为表级约束条件</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 在列级定义主码<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student<br>    (  Sno  <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>)  <span class="hljs-keyword">PRIMARY</span> KEY,<br>      Sname  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,     <br>      Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>),<br>      Sage  <span class="hljs-type">SMALLINT</span>,<br>      Sdept  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br>    );<br><br># 在表级定义主码<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student<br>    (  Sno  <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>),  <br>       Sname  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>       Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>),<br>       Sage  <span class="hljs-type">SMALLINT</span>,<br>       Sdept  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>),<br>       <span class="hljs-keyword">PRIMARY</span> KEY (Sno)<br>     ); <br></code></pre></td></tr></table></figure>
<p>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：</p>
<ul>
<li><p>检查主码值是否唯一，如果不唯一则拒绝插入或修改</p>
<ul>
<li>检查记录中主码值是否唯一的一种方法是进行全表扫描<ul>
<li>十分耗时</li>
</ul>
</li>
<li>为避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，如B+树索引</li>
</ul>
</li>
<li><p>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</p>
</li>
</ul>
<h2 id="2-参照完整性"><a href="#2-参照完整性" class="headerlink" title="2. 参照完整性"></a>2. 参照完整性</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620141341336.png" alt="image-20220620141341336"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 定义SC中的参照完整性<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SC (<br>    Sno  <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>	Cno  <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <br>	Grade  <span class="hljs-type">SMALLINT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno, Cno),   <span class="hljs-comment">/*在表级定义实体完整性*/</span><br>    <span class="hljs-keyword">FOREIGN</span> KEY (Sno) <span class="hljs-keyword">REFERENCES</span> Student(Sno), <span class="hljs-comment">/*在表级定义参照完整性*/</span><br>    <span class="hljs-keyword">FOREIGN</span> KEY (Cno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)  <span class="hljs-comment">/*在表级定义参照完整性*/</span><br>);<br><br># 显式说明参照完整性的违约处理示例<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> (<br>    Sno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>，<br>    Cno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>，<br>    Grade  <span class="hljs-type">SMALLINT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno,Cno)， 			<br>    <span class="hljs-keyword">FOREIGN</span> KEY (Sno) <span class="hljs-keyword">REFERENCES</span> Student(Sno) <br>    	<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE       <span class="hljs-comment">/*级联删除SC表中相应的元组*/</span><br>    	<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE,      <span class="hljs-comment">/*级联更新SC表中相应的元组*/</span><br>    <span class="hljs-keyword">FOREIGN</span> KEY (Cno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)	                    <br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">NO</span> ACTION     <br>    	<span class="hljs-comment">/*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/</span><br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE   <br>    	<span class="hljs-comment">/*当更新course表中的cno时，级联更新SC表中相应的元组*/</span><br>);<br></code></pre></td></tr></table></figure>
<h2 id="3-用户定义完整性"><a href="#3-用户定义完整性" class="headerlink" title="3. 用户定义完整性"></a>3. 用户定义完整性</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># [例 <span class="hljs-number">5.7</span>] Student 表的 Ssex 只允许取“男”或“女”。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student (<br>    Sno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>)), <span class="hljs-comment">/*性别属性 Ssex 只允许取&#x27;男&#x27;或&#x27;女&#x27; */</span><br>    Sage  <span class="hljs-type">SMALLINT</span>,<br>    Sdept <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br>);<br><br># [例 <span class="hljs-number">5.8</span>] SC 表的 Grade 的值应该在 <span class="hljs-number">0</span> 和 <span class="hljs-number">100</span> 之间。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SC (<br>    Sno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>),<br>    Cno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>),<br>    Grade <span class="hljs-type">SMALLINT</span> <span class="hljs-keyword">CHECK</span> (Grade <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> Grade <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100</span>), <span class="hljs-comment">/*Grade 取值范围是 0 到 100*/</span><br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno, Cno),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (Sno) <span class="hljs-keyword">REFERENCES</span> Student (Sno),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (Cno) <span class="hljs-keyword">REFERENCES</span> Course (Cno)<br>);<br><br># [例 <span class="hljs-number">5.9</span>]当学生的性别是男时，其名字不能以 Ms.打头。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student (<br>    Sno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>),<br>    Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>)),<br>    Sage  <span class="hljs-type">SMALLINT</span>,<br>    Sdept <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno),<br>    <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">OR</span> Sname <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Ms.%&#x27;</span>) <span class="hljs-comment">/*定义了元组中 Sname 和 Ssex 两个属性值之间的约束条件*/</span><br>);<br><br># [例 <span class="hljs-number">5.10</span>]建立学生登记表 Student，要求学号在 <span class="hljs-number">90000</span><span class="hljs-operator">~</span><span class="hljs-number">99999</span> 之间，姓名不能取空值，年龄小于 <span class="hljs-number">30</span>，性别只能是“男”或“女”。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student (<br>    Sno   <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">99999</span>),<br>    Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">CONSTRAINT</span> C2 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    Sage  <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>),<br>    Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CONSTRAINT</span> C4 <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-keyword">IN</span> ( ‘男’,<span class="hljs-string">&#x27;女&#x27;</span>)),<br>    <span class="hljs-keyword">CONSTRAINT</span> StudentKey <span class="hljs-keyword">PRIMARY</span> KEY (Sno)<br>);<br><br># [例 <span class="hljs-number">5.11</span>]建立教师表 TEACHER，要求每个教师的应发工资不低于 <span class="hljs-number">3000</span> 元。应发工资是工资列 Sal 与扣除项 Deduct 之和。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> TEACHER (<br>    Eno    <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">PRIMARY</span> KEY, <span class="hljs-comment">/*在列级定义主码*/</span><br>    Ename  <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    Job    <span class="hljs-type">CHAR</span>(<span class="hljs-number">8</span>),<br>    Sal    <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>),<br>    Deduct <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>),<br>    Deptno <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">2</span>),<br>    <span class="hljs-keyword">CONSTRAINT</span> TEACHERFKey <span class="hljs-keyword">FOREIGN</span> KEY (Deptno)<br>        <span class="hljs-keyword">REFERENCES</span> DEPT (Deptno),<br>    <span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sal <span class="hljs-operator">+</span> Deduct <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3000</span>)<br>);<br><br># [例 <span class="hljs-number">5.12</span>]去掉例 <span class="hljs-number">5.10</span> Student 表中对性别的限制。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C4;<br><br># [例 <span class="hljs-number">5.13</span>] 修改表 Student 中的约束条件，要求学号改为在 <span class="hljs-number">900000</span><span class="hljs-operator">~</span><span class="hljs-number">999999</span> 之间，年龄由小于 <span class="hljs-number">30</span> 改为小于 <span class="hljs-number">40</span> 可以先删除原来的约束条件，再增加新的约束条件<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C1;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">900000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">999999</span>);<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C3;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure>
<h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><ul>
<li>SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。</li>
<li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</li>
<li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行</li>
<li>如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">CHECK</span>子句<span class="hljs-operator">&gt;</span>;<br><span class="hljs-keyword">DROP</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span>;<br><br># 限制数据库课程最多<span class="hljs-number">60</span>名学生选修<br><span class="hljs-keyword">CREATE</span> ASSERTION ASSE_SC_DB_NUM<br><span class="hljs-keyword">CHECK</span> (<span class="hljs-number">60</span> <span class="hljs-operator">&gt;=</span> (<br>    <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-comment">/*此断言的谓词涉及聚集操作count的SQL语句*/</span><br>    <span class="hljs-keyword">From</span> Course, SC<br>    <span class="hljs-keyword">Where</span> SC.Cno<span class="hljs-operator">=</span>Course.Cno <span class="hljs-keyword">and</span> Course.Cname <span class="hljs-operator">=</span><span class="hljs-string">&#x27;数据库&#x27;</span>)<br>);<br><br># 限制每个学期每一门课程最多<span class="hljs-number">60</span>名学生选修<br><span class="hljs-keyword">CREATE</span> ASSERTION ASSE_SC_CNUM<br><span class="hljs-keyword">CHECK</span> (<span class="hljs-number">60</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-keyword">ALL</span> (<br>    <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-comment">/*此断言的谓词涉及聚集操作 count 和分组函数group by的SQL语句*/</span><br>    <span class="hljs-keyword">From</span> SC<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cno, TERM)<br>);<br></code></pre></td></tr></table></figure>
<h2 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5. 触发器"></a>5. 触发器</h2><ul>
<li><p>触发器保存在数据库服务器中(远端)</p>
</li>
<li><p>任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</p>
</li>
<li><p>触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力</p>
</li>
<li><p>触发器类型</p>
<ul>
<li>行级触发器(FOR EACH ROW)</li>
<li>语句级触发器(FOR EACH STATEMENT)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 例如,在TEACHER表上创建一个AFTER <span class="hljs-keyword">UPDATE</span>触发器，触发事件是<span class="hljs-keyword">UPDATE</span>语句<br><span class="hljs-keyword">UPDATE</span> TEACHER <span class="hljs-keyword">SET</span> Deptno<span class="hljs-operator">=</span><span class="hljs-number">5</span>;<br># 假设表TEACHER有<span class="hljs-number">1000</span>行  <br># 如果是语句级触发器，那么执行完该语句后，触发动作只发生一次<br># 如果是行级触发器，触发动作将执行<span class="hljs-number">1000</span>次<br></code></pre></td></tr></table></figure>
</li>
<li><p>执行顺序</p>
<ul>
<li>执行该表上的BEFORE触发器;</li>
<li>激活触发器的SQL语句;</li>
<li>执行该表上的AFTER触发器。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 语法格式<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span>  <br>&#123;BEFORE <span class="hljs-operator">|</span> AFTER&#125; <span class="hljs-operator">&lt;</span>触发事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span><span class="hljs-operator">|</span><span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>变量<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> &#123;<span class="hljs-type">ROW</span> <span class="hljs-operator">|</span> STATEMENT&#125;<br>[<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>] <span class="hljs-operator">&lt;</span>触发动作体<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br><br># 当对表SC的Grade属性进行修改时，若分数增加了<span class="hljs-number">10</span><span class="hljs-operator">%</span>则将此次操作记录到下面表中：SC_U（Sno,Cno,Oldgrade,Newgrade）其中Oldgrade是修改前的分数，Newgrade是修改后的分数<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span>  SC_T		<br>AFTER <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OF</span> Grade <span class="hljs-keyword">ON</span> SC<br><span class="hljs-keyword">REFERENCING</span><br>	<span class="hljs-keyword">OLD</span> <span class="hljs-type">row</span> <span class="hljs-keyword">AS</span> OldTuple,<br>	<span class="hljs-keyword">NEW</span> <span class="hljs-type">row</span> <span class="hljs-keyword">AS</span> NewTuple<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> 	<br><span class="hljs-keyword">WHEN</span> (NewTuple.Grade <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1.1</span> <span class="hljs-operator">*</span> OldTuple.Grade)<br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SC_U(Sno,Cno,OldGrade,NewGrade)  <br>    <span class="hljs-keyword">VALUES</span>(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)<br><br># 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> Student_Count<br>AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> Student<br><span class="hljs-keyword">REFERENCING</span><br>	<span class="hljs-keyword">NEW</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">AS</span> DELTA<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> STATEMENT<br>	<span class="hljs-comment">/*语句级触发器, 即执行完INSERT语句后下面的触发动作体才执行一次*/</span><br>	<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentInsertLog (Numbers)<br>   	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> DELTA<br>   	<br># 定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于<span class="hljs-number">4000</span>元，如果低于<span class="hljs-number">4000</span>元，自动改为<span class="hljs-number">4000</span>元&quot;<br>CREATE TRIGGER Insert_Or_Update_Sal<br>BEFORE INSERT OR UPDATE ON Teacher /*触发事件是插入或更新操作*/<br>REFERENCING NEW row AS newTuple<br>FOR EACH ROW  /*行级触发器*/<br>BEGIN    /*定义触发动作体，是PL/SQL过程块*/<br>	IF (newTuple.Job=&#x27;教授&#x27;) AND (newTuple.Sal &lt; 4000)<br>     	THEN newTuple.Sal :=4000;<br> 	END IF;<br>END;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707163220219.png" alt="image-20230707163220219"></p>
<h1 id="06-关系数据理论-重点"><a href="#06-关系数据理论-重点" class="headerlink" title="06-关系数据理论(重点)"></a>06-关系数据理论(重点)</h1><h2 id="1-关系模式及范式"><a href="#1-关系模式及范式" class="headerlink" title="1. 关系模式及范式"></a>1. 关系模式及范式</h2><ul>
<li>关系模式由五部分组成，是一个五元组：$R(U, D, DOM, F)$<ul>
<li>关系名 $R$ 是符号化的元组语义</li>
<li>$U$ 为一组属性</li>
<li>$D$ 为属性组 $U$ 中的属性所来自的域</li>
<li>$DOM$ 为属性到域的映射</li>
<li>$F$ 为属性组 $U$ 上的一组数据依赖</li>
</ul>
</li>
<li>由于 $D$、$DOM$ 与模式设计关系不大，因此可以把关系模式看作一个三元组：$R\lt U,F\gt$</li>
<li>作为二维表，关系要符合一个最基本的条件：每个分量必须是<strong>不可分开</strong>的数据项。满足了这个条件的关系模式就属于第一范式(1NF)。</li>
<li>一个低一级范式的关系模式，通过模式分解(schema decomposition)可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化(normalization)。</li>
</ul>
<h2 id="2-函数依赖"><a href="#2-函数依赖" class="headerlink" title="2. 函数依赖"></a>2. 函数依赖</h2><ul>
<li><p>设 $R(U)$ 是一个属性集 $U$ 上的关系模式，$X$ 和 $Y$ 是 $U$ 的子集。若对于 $R(U)$ 的任意一个可能的关系 $r$，$r$ 中不可能存在两个元组在 $X$ 上的属性值相等，而在 $Y$ 上的属性值不等，则称” $X$ 函数确定 $Y$ “或” $Y$ <strong>函数依赖</strong>于 $X$ “，记作 $X \rightarrow Y$，$X$ 称为这个函数依赖的决定因素。</p>
</li>
<li><p>函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。</p>
</li>
<li><p>在关系模式 $R(U) $ 中，对于 $U$ 的子集 $X$ 和 $Y$：</p>
<ul>
<li>若 $X \rightarrow Y$，但 $Y \nsubseteq X$，则称 $X \rightarrow Y$ 是<strong>非平凡的函数依赖</strong>。</li>
<li>若 $X \rightarrow Y$，但 $Y \subseteq X$，则称 $X \rightarrow Y$ 是<strong>平凡的函数依赖</strong>。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620150346359.png" style="zoom: 67%;" /></p>
</li>
<li><p>在 $R(U)$ 中，如果 $X \rightarrow Y$，并且对于 $X$ 的任何一个真子集 $X’$, 都有 $X’ \nrightarrow Y$，则称 $Y$ 对 $X$ <strong>完全函数依赖</strong>，记作 $X\stackrel{F}{\rightarrow}Y$。</p>
</li>
<li><p>若 $X \rightarrow Y$，但 $Y$ 不完全函数依赖于 $X$，则称 $Y$ 对 $X$ <strong>部分函数依赖</strong>，记作$X\stackrel{P}{\rightarrow}Y$。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620150857674.png" style="zoom: 67%;" /></p>
<ul>
<li><p>在 $R(U)$ 中，如果 $X \rightarrow Y(Y \nsubseteq X)$，$Y \nrightarrow X$，$Y \rightarrow Z(Z\nsubseteq Y)$，则称 $Z$ 对 $X$ <strong>传递函数依赖</strong> 。记为$X\stackrel{传递}{\longrightarrow}Z$</p>
<ul>
<li>如果 $Y \rightarrow X$, 即 $X\leftarrow\rightarrow Y$, 则 $Z$ 直接依赖于 $X$, 而不是传递函数依赖</li>
</ul>
</li>
<li><p>设 $K$ 为 $R \lt U,F \gt$ 中的属性或属性组合。若 $K\stackrel{F}{\rightarrow}U$，则 $K$ 称为 $R$ 的一个候选码。</p>
<ul>
<li><strong>如果 $U$ 函数依赖于 $K$，即 $K\rightarrow U$，则 $K$ 称为超码。</strong>候选码是一类特殊的超码，即候选码的超集一定是超码，候选码的任意一个真子集都不是超码。</li>
</ul>
</li>
<li><p>关系模式 $R$ 中属性或属性组 $X$ 并非 $R$ 的码，但 $X$ 是另一个关系模式的码，则称 $X$ 是 $R$ 的<strong>外部码</strong>(Foreign key)也称<strong>外码</strong>。</p>
</li>
</ul>
<h2 id="3-1NF"><a href="#3-1NF" class="headerlink" title="3. 1NF"></a>3. 1NF</h2><ul>
<li><p>如果一个关系模式 $R$ 的所有属性都是<strong>不可分</strong>的基本数据项，则 $R\in1NF$</p>
</li>
<li><p>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707174656934.png" alt="image-20230707174656934"></p>
<ul>
<li><p>问题</p>
<ul>
<li><p><strong>数据冗余</strong>: 浪费大量的存储空间, 每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同</p>
</li>
<li><p><strong>更新异常</strong>: 数据冗余，更新数据时，维护数据完整性代价大, 某系更换系主任后，必须修改与该系学生有关的每一个元组</p>
</li>
<li><p><strong>插入异常</strong>: 如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库</p>
</li>
<li><p><strong>删除异常</strong>: 如果某个系的学生全部毕业了，则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-2NF"><a href="#4-2NF" class="headerlink" title="4. 2NF"></a>4. 2NF</h2><ul>
<li>若关系模式 $R∈1NF$，并且每一个非主属性都<strong>完全函数依赖</strong>于任何一个候选码，则 $R∈2NF$。</li>
<li>性质：<strong>不存在(某非主属性)部分依赖</strong>(于某一候选码)。</li>
<li>如果不是2NF，会产生的问题：<ul>
<li>插入异常<ul>
<li>如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。</li>
</ul>
</li>
<li>删除异常<ul>
<li>如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。</li>
</ul>
</li>
<li>修改复杂<ul>
<li>如果一个学生选了多门课，则Sdept，Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化。</li>
</ul>
</li>
</ul>
</li>
<li>出现这种问题的原因：例子中有两类非主属性<ul>
<li>一类如Grade，它对码完全函数依赖</li>
<li>另一类如Sdept、Sloc，它们对码不是完全函数依赖</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>1NF</th>
<th>2NF</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707183704294.png" alt="image-20230707183704294"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707183717257.png" alt="image-20230707183717257"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-3NF"><a href="#5-3NF" class="headerlink" title="5. 3NF"></a>5. 3NF</h2><ul>
<li>设关系模式 $R \lt U,F \gt \in 1NF$，若 $R$ 中不存在这样的码 $X$、属性组 $Y$ 及非主属性 $Z(Z \nsupseteq Y)$，使得 $X→Y,Y→Z$ 成立，$Y↛X$ 不成立，则称 $R \lt U,F \gt \in 3NF$。</li>
<li>性质：<strong>不存在非主属性传递依赖、部分依赖于码</strong></li>
<li><p>在 2NF 的解决方案中，SL 存在传递依赖</p>
<ul>
<li>解决方案为把 S-L 分解为 S-D 和 D-L。分解后的关系不再存在传递依赖，消除了问题 3。</li>
</ul>
</li>
<li><p>问题：可能存在主属性对码的部分依赖和传递依赖</p>
</li>
</ul>
<h2 id="6-BCNF"><a href="#6-BCNF" class="headerlink" title="6. BCNF"></a>6. BCNF</h2><ul>
<li>设关系模式 $R\lt U,F\gt \in1NF$，若 $X \rightarrow Y$ 且 $Y\nsubseteq X$ 时 $X$ 必含有码，则 $R\lt U,F\gt \in BCNF$。</li>
<li>换言之，在关系模式 $R\lt U,F\gt$ 中，如果每一个决定属性集都包含候选码，则 $R\in BCNF$</li>
<li><p>性质</p>
<ul>
<li>所有<strong>非主属性</strong>都完全函数依赖于每个码</li>
<li>所有<strong>主属性</strong>都完全函数依赖于每个不包含它的码</li>
<li><strong>每一个决定属性集都包含候选码</strong>(亦即没有任何属性完全函数依赖于非码的任何一组属性)</li>
</ul>
</li>
<li><p>一个模式中的关系模式如果都属于 BCNF，那么在函数依赖范畴内，它已实现了彻底的分离，已<strong>消除了插入和删除的异常</strong>。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707220316470.png" alt="image-20230707220316470"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707220326240.png" alt="image-20230707220326240"></p>
<h2 id="7-多值依赖"><a href="#7-多值依赖" class="headerlink" title="7. 多值依赖"></a>7. 多值依赖</h2><div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707220916334.png" alt="image-20230707220916334"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707220952865.png" alt="image-20230707220952865"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>设 $R(U)$ 是属性集 $U$ 上的一个关系模式。$X,Y,Z$ 是 $U$ 的子集，并且 $Z=U-X-Y$。关系模式 $R(U)$ 中多值依赖 $X\rightarrow\rightarrow Y$ 成立，当且仅当对 $R(U)$ 的任一关系 $r$，给定的一对 $(x,z)$ 值，有一组 $Y$ 的值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关<ul>
<li>对于 $C$ 的每一个值，$T$ 有一组值与之对应，而不论 $B$ 取何值。因此 $T$ 多值依赖于 $C$，即$C\rightarrow\rightarrow T$。</li>
</ul>
</li>
<li>多值依赖的另一个等价的定义：</li>
<li>在 $R(U)$ 的任一关系 $r$ 中，如果存在元组 $t, s$ 使得 $t[X]=s[X]$，那么就必然存在元组 $w, v\in r$ ( $w, v$ 可以与 $s, t$ 相同), 使得 $w[X]=v[X]=t[X]$, 而 $w[Y]=t[Y], w[Z]=s[Z], v[Y]=s[Y], v[Z]=t[Z]$<ul>
<li>即交换 $s, t$ 元组的 $Y$ 值所得到的两个新元组必在 $r$ 中，则 $Y$ 多值依赖于 $X$, 记为 $X\rightarrow\rightarrow Y$, 这里 $X, Y$ 是 $U$ 的子集，$Z=U-X-Y$</li>
</ul>
</li>
<li>平凡多值依赖和非平凡的多值依赖<ul>
<li>若 $X\rightarrow\rightarrow Y$，而 $Z=\phi$, 则 $Z$ 为空，则称 $X\rightarrow\rightarrow Y$ 为<strong>平凡的多值依赖</strong></li>
<li>否则称 $X\rightarrow\rightarrow Y$ 为<strong>非平凡的多值依赖</strong></li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707225346465.png" alt="image-20230707225346465"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707225431454.png" alt="image-20230707225431454"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>多值依赖具有对称性，如上图<ul>
<li>若 $X\rightarrow\rightarrow Y$，则 $X\rightarrow\rightarrow Z$, 其中 $Z=U-X-Y$</li>
</ul>
</li>
<li>多值依赖具有传递性<ul>
<li>若 $X\rightarrow\rightarrow Y, Y\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow Z-Y$</li>
</ul>
</li>
</ul>
<p><strong>多值依赖与函数依赖的区别</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707225923985.png" alt="image-20230707225923985"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707225931151.png" alt="image-20230707225931151"></p>
<h2 id="8-4NF"><a href="#8-4NF" class="headerlink" title="8. 4NF"></a>8. 4NF</h2><ul>
<li>关系模式 $R\lt U, F\gt \in 1NF$, 如果对于 $R$ 的每个非平凡多值依赖 $X\rightarrow\rightarrow Y$ ($Y \nsubseteq X$), $X$ 都含有码，则 $R\lt U, F\gt \in 4NF$</li>
<li>4NF 就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF 所允许的非平凡多值依赖实际上是函数依赖。<ul>
<li>如果一个关系模式是 4NF，则必为 BCNF</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707230441209.png" alt="image-20230707230441209"></p>
<h1 id="07-数据库设计"><a href="#07-数据库设计" class="headerlink" title="07-数据库设计"></a>07-数据库设计</h1><h2 id="1-数据库设计概述"><a href="#1-数据库设计概述" class="headerlink" title="1. 数据库设计概述"></a>1. 数据库设计概述</h2><ul>
<li>数据库设计六个阶段<ul>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
<li>数据库实施</li>
<li>数据库运行与维护</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620161145477.png" alt="image-20220620161145477"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620161200602.png" alt="image-20220620161200602"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620161259854.png" alt="image-20220620161259854"></p>
<h2 id="2-E-R-模型"><a href="#2-E-R-模型" class="headerlink" title="2. E-R 模型"></a>2. E-R 模型</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211417680.png" alt="image-20220914211417680"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620163405397.png" alt="image-20220620163405397"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620163427313.png" alt="image-20220620163427313"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620163557292.png" alt="image-20220620163557292"></p>
<h2 id="3-逻辑结构设计"><a href="#3-逻辑结构设计" class="headerlink" title="3. 逻辑结构设计"></a>3. 逻辑结构设计</h2><h3 id="3-1-转换原则"><a href="#3-1-转换原则" class="headerlink" title="3.1 转换原则"></a>3.1 转换原则</h3><ul>
<li>一个实体型转换为一个关系模式</li>
<li>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</li>
<li>一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li>
<li>一个m:n联系转换为一个关系模式</li>
<li>三个或三个以上实体间的一个多元联系转换为一个关系模式</li>
<li>具有相同码的关系模式可合并</li>
</ul>
<h3 id="3-2-水平分解"><a href="#3-2-水平分解" class="headerlink" title="3.2 水平分解"></a>3.2 水平分解</h3><ul>
<li><p>把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。</p>
</li>
<li><p>根据二八原则把经常使用的 20% 数据分解出来。</p>
</li>
</ul>
<h3 id="3-3-垂直分解"><a href="#3-3-垂直分解" class="headerlink" title="3.3 垂直分解"></a>3.3 垂直分解</h3><ul>
<li><p>把关系模式的属性分为若干子集合，形成若干个子关系模式。</p>
</li>
<li><p>原则：经常在一起使用的属性从关系中分解出来。</p>
</li>
<li>优点：提高了某些事务的效率</li>
<li>缺点：可能使另一些事务不得不执行连接操作，降低了效率</li>
</ul>
<h2 id="4-物理结构设计"><a href="#4-物理结构设计" class="headerlink" title="4. 物理结构设计"></a>4. 物理结构设计</h2><h3 id="4-1-关系模式存取方法"><a href="#4-1-关系模式存取方法" class="headerlink" title="4.1 关系模式存取方法"></a>4.1 关系模式存取方法</h3><ul>
<li>B+树索引存取方法</li>
<li>Hash索引存取方法</li>
<li>聚簇存取方法</li>
</ul>
<h3 id="4-2-聚簇"><a href="#4-2-聚簇" class="headerlink" title="4.2 聚簇"></a>4.2 聚簇</h3><ul>
<li>为了提高某个属性(或属性组)的查询速度，把这个或这些属性(称为聚簇码)上具有相同值的元组集中存放在连续的物理块中称为聚簇。</li>
<li>该属性（或属性组）称为聚簇码（cluster key）</li>
<li>选择聚簇存储方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系（一个数据库可以建立多个聚簇，一个关系只能加入一个聚簇）</li>
</ul>
<h1 id="08-数据库编程"><a href="#08-数据库编程" class="headerlink" title="08-数据库编程"></a>08-数据库编程</h1><h2 id="1-jdbc"><a href="#1-jdbc" class="headerlink" title="1. jdbc"></a>1. jdbc</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加载数据库驱动；</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">// 建立连接</span><br>conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 创建 Statement 对象，用于向数据库发送 SQL 语句；</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM `user`&quot;</span>;<br><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);<br><span class="hljs-comment">// 获取 ResultSet 对象，取出数据，此对象代表结果集；</span><br><span class="hljs-keyword">while</span> (resultSet.next()) &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(“id”); <br>    ......<br>&#125;<br><span class="hljs-comment">// 释放资源，断开与数据库的连接。</span><br>resultSet.close();	<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure>
<h2 id="2-过程化SQL"><a href="#2-过程化SQL" class="headerlink" title="2. 过程化SQL"></a>2. 过程化SQL</h2><p>定义部分</p>
<ul>
<li><p>DECLARE 变量、常量、游标、异常等</p>
<ul>
<li><p>定义的变量、常量等只能在该基本块中使用</p>
</li>
<li><p>当基本块执行结束时，定义就不再存在</p>
</li>
</ul>
</li>
</ul>
<p>执行部分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SQL</span>语句、过程化<span class="hljs-keyword">SQL</span>的流程控制语句<br>EXCEPTION<br>    异常处理部分        		<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708101233701.png" alt="image-20230708101233701"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708101250429.png" alt="image-20230708101250429"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708101256956.png" alt="image-20230708101256956"></p>
<h2 id="3-存储过程和函数"><a href="#3-存储过程和函数" class="headerlink" title="3. 存储过程和函数"></a>3. 存储过程和函数</h2><h3 id="3-1-存储过程"><a href="#3-1-存储过程" class="headerlink" title="3.1 存储过程"></a>3.1 存储过程</h3><p>过程化SQL块类型</p>
<ul>
<li>命名块：编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块 </li>
<li>匿名块：每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 创建存储过程<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 过程名([参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>,...]) <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>过程化<span class="hljs-keyword">SQL</span>块<span class="hljs-operator">&gt;</span>；<br><br># 利用存储过程来实现下面的应用：从账户<span class="hljs-number">1</span>转指定数额的款项到账户<span class="hljs-number">2</span>中。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> TRANSFER(inAccount <span class="hljs-type">INT</span>, outAccount <span class="hljs-type">INT</span>, amount <span class="hljs-type">FLOAT</span>) <span class="hljs-comment">/*定义存储过程TRANSFER，其参数为转入账户、转出账户、转账额度*/</span><br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">DECLARE</span>		<span class="hljs-comment">/*定义变量*/</span><br>totalDepositOut <span class="hljs-type">Float</span>;<br>totalDepositIn <span class="hljs-type">Float</span>;<br>inAccountnum <span class="hljs-type">INT</span>;<br><span class="hljs-keyword">BEGIN</span>    <span class="hljs-comment">/*检查转出账户的余额 */</span>	                       <br>    <span class="hljs-keyword">SELECT</span> Total <span class="hljs-keyword">INTO</span> totalDepositOut <span class="hljs-keyword">FROM</span> Accout <br>    <span class="hljs-keyword">WHERE</span> accountnum <span class="hljs-operator">=</span> outAccount; <br><br>    IF totalDepositOut <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span><br>        <span class="hljs-comment">/*如果转出账户不存在或账户中没有存款*/</span><br>        <span class="hljs-keyword">ROLLBACK</span>; 	   <span class="hljs-comment">/*回滚事务*/</span><br>        <span class="hljs-keyword">RETURN</span>;<br>    <span class="hljs-keyword">END</span> IF; <br><br>    IF totalDepositOut <span class="hljs-operator">&lt;</span> amount <span class="hljs-keyword">THEN</span>    	<span class="hljs-comment">/*如果账户存款不足*/</span><br>        <span class="hljs-keyword">ROLLBACK</span>; 				<span class="hljs-comment">/*回滚事务*/</span><br>        <span class="hljs-keyword">RETURN</span>;<br>    <span class="hljs-keyword">END</span> IF;<br><br>    <span class="hljs-keyword">SELECT</span> Accountnum <span class="hljs-keyword">INTO</span> inAccountnum <span class="hljs-keyword">FROM</span> Account<br>    <span class="hljs-keyword">WHERE</span> accountnum<span class="hljs-operator">=</span>inAccount;<br><br>    IF inAccount <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span>  		<span class="hljs-comment">/*如果转入账户不存在*/</span>   <br>        <span class="hljs-keyword">ROLLBACK</span>; 	         	 		<span class="hljs-comment">/*回滚事务*/</span><br>        <span class="hljs-keyword">RETURN</span>;<br>    ENDIF;<br><br>    <span class="hljs-keyword">UPDATE</span> Account <span class="hljs-keyword">SET</span> total<span class="hljs-operator">=</span>total <span class="hljs-operator">-</span> amount<br>    <span class="hljs-keyword">WHERE</span> accountnum<span class="hljs-operator">=</span>outAccount; <span class="hljs-comment">/* 修改转出账户余额，减去转出额 */</span><br>    <span class="hljs-keyword">UPDATE</span> Account <span class="hljs-keyword">SET</span> total<span class="hljs-operator">=</span>total <span class="hljs-operator">+</span> amount <br>    <span class="hljs-keyword">WHERE</span> accountnum<span class="hljs-operator">=</span>inAccount;  <span class="hljs-comment">/* 修改转入账户余额，增加转入额 */</span><br><br>    <span class="hljs-keyword">COMMIT</span>;                      <span class="hljs-comment">/* 提交转账事务 */</span><br><span class="hljs-keyword">END</span>;<br><br># 执行存储过程<br><span class="hljs-keyword">CALL</span><span class="hljs-operator">/</span>PERFORM <span class="hljs-keyword">PROCEDURE</span> 过程名([参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>,...]);<br># 从账户<span class="hljs-number">01003815868</span>转<span class="hljs-number">10000</span>元到<span class="hljs-number">01003813828</span>账户中<br><span class="hljs-keyword">CALL</span> <span class="hljs-keyword">PROCEDURE</span> TRANSFER(<span class="hljs-number">01003813828</span>, <span class="hljs-number">01003815868</span>, <span class="hljs-number">10000</span>);<br><br># 修改存储过程<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">PROCEDURE</span> 过程名<span class="hljs-number">1</span> RENAME <span class="hljs-keyword">TO</span> 过程名<span class="hljs-number">2</span>;<br><br># 删除存储过程<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> 过程名();<br></code></pre></td></tr></table></figure>
<h3 id="3-2-函数"><a href="#3-2-函数" class="headerlink" title="3.2 函数"></a>3.2 函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"># 函数的定义语句格式<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> 函数名 ([参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>,...]) <span class="hljs-keyword">RETURNS</span> <span class="hljs-operator">&lt;</span>类型<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>过程化<span class="hljs-keyword">SQL</span>块<span class="hljs-operator">&gt;</span>;<br><br># 函数的执行语句格式<br><span class="hljs-keyword">CALL</span><span class="hljs-operator">/</span><span class="hljs-keyword">SELECT</span> 函数名 ([参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>,...]);<br><br># 修改函数<br># 重命名<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">FUNCTION</span> 过程名<span class="hljs-number">1</span> RENAME <span class="hljs-keyword">TO</span> 过程名<span class="hljs-number">2</span>;<br># 重新编译<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">FUNCTION</span> 过程名 COMPILE;<br></code></pre></td></tr></table></figure>
<h1 id="09-关系查询处理和查询优化"><a href="#09-关系查询处理和查询优化" class="headerlink" title="09-关系查询处理和查询优化"></a>09-关系查询处理和查询优化</h1><h2 id="1-查询处理"><a href="#1-查询处理" class="headerlink" title="1. 查询处理"></a>1. 查询处理</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708103015176.png" alt="image-20230708103015176"></p>
<ul>
<li><p>查询检查的任务</p>
<ul>
<li>合法权检查</li>
<li>视图转换</li>
<li>安全性检查</li>
<li>完整性初步检查</li>
</ul>
</li>
<li><p>检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式</p>
</li>
<li><p>查询优化分类 </p>
<ul>
<li><p>代数优化/逻辑优化：指关系代数表达式的优化</p>
</li>
<li><p>物理优化：指存取路径和底层操作算法的选择</p>
</li>
</ul>
</li>
<li><p>查询优化的选择依据</p>
<ul>
<li><p>基于规则(rule based)</p>
</li>
<li><p>基于代价(cost based)</p>
</li>
<li><p>基于语义(semantic based)</p>
</li>
</ul>
</li>
<li><p>选择操作典型实现方法：</p>
<ul>
<li>全表扫描方法 (Table Scan)</li>
<li>索引扫描方法 (Index Scan)</li>
</ul>
</li>
<li><p>连接操作是查询处理中最耗时的操作之一，只讨论等值连接(或自然连接)最常用的实现算法</p>
<ul>
<li>嵌套循环算法(nested loop join) </li>
<li>排序-合并算法(sort-merge join 或 merge join)</li>
<li>索引连接(index join)算法 </li>
<li>Hash Join算法 </li>
</ul>
</li>
</ul>
<h2 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h2><ul>
<li>优化实例</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708105857753.png" alt="image-20230708105857753"></p>
<h2 id="3-代数优化"><a href="#3-代数优化" class="headerlink" title="3. 代数优化"></a>3. 代数优化</h2><ul>
<li>代数优化策略：通过对关系代数表达式的等价变换来提高查询效率</li>
</ul>
<h3 id="3-1-常见的等价变换规则"><a href="#3-1-常见的等价变换规则" class="headerlink" title="3.1 常见的等价变换规则"></a>3.1 常见的等价变换规则</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708110154079.png" alt="image-20230708110154079"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708110200675.png" alt="image-20230708110200675"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708110209664.png" alt="image-20230708110209664"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708110229723.png" alt="image-20230708110229723"></p>
<h3 id="3-2-典型的启发式规则"><a href="#3-2-典型的启发式规则" class="headerlink" title="3.2 典型的启发式规则"></a>3.2 典型的启发式规则</h3><ul>
<li><p>选择运算应尽可能先做</p>
</li>
<li><p>把投影运算和选择运算同时进行</p>
<ul>
<li>如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。</li>
</ul>
</li>
<li><p>把投影同其前或其后的双目运算结合起来</p>
</li>
<li><p>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算</p>
<ul>
<li>连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间。 </li>
</ul>
</li>
<li><p>找出公共子表达式</p>
<ul>
<li><p>如果这种重复出现的子表达式的结果不是很大的关系，并且从外存中读入这个关系比计算该子表达式的时间少得多，则先计算一次公共子表达式并把结果写入中间文件是合算的。</p>
</li>
<li><p>当查询的是视图时，定义视图的表达式就是公共子表达式的情况</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-物理优化"><a href="#4-物理优化" class="headerlink" title="4. 物理优化"></a>4. 物理优化</h2><ul>
<li>对于一个查询语句有许多存取方案，它们的执行效率不同，仅仅进行代数优化是不够的</li>
<li>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划</li>
</ul>
<p>选择操作的启发式规则</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708111109471.png" alt="image-20230708111109471"></p>
<p>连接操作的启发式规则</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708112057124.png" alt="image-20230708112057124"></p>
<h1 id="10-数据库恢复技术"><a href="#10-数据库恢复技术" class="headerlink" title="10-数据库恢复技术"></a>10-数据库恢复技术</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><ul>
<li>事物的<strong>ACID</strong>特性<ul>
<li><strong>原子性(Atomicity)</strong></li>
<li><strong>一致性(Consistency)</strong></li>
<li><strong>隔离性(Isolation)</strong></li>
<li><strong>持续性(Durability)</strong></li>
</ul>
</li>
<li>可能的破坏原因<ul>
<li>多个事务并行运行时，不同事务的操作交叉执行</li>
<li>事务在运行过程中被强行停止</li>
</ul>
</li>
</ul>
<h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><ul>
<li>事务是数据库的逻辑工作单位</li>
<li>事务中包括的诸操作要么都做，要么都不做</li>
</ul>
<h3 id="1-2-一致性"><a href="#1-2-一致性" class="headerlink" title="1.2 一致性"></a>1.2 一致性</h3><ul>
<li>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</li>
<li>一致性状态：数据库中只包含成功事务提交的结果。</li>
<li>不一致状态：<ul>
<li>数据库系统运行中发生故障，有些事务尚未完成就被迫中断</li>
<li>这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态。</li>
</ul>
</li>
</ul>
<h3 id="1-3-隔离性"><a href="#1-3-隔离性" class="headerlink" title="1.3 隔离性"></a>1.3 隔离性</h3><ul>
<li>一个事务的执行不能被其他事务干扰</li>
<li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li>
<li>并发执行的各个事务之间不能互相干扰</li>
</ul>
<h3 id="1-4-持续性也称永久性"><a href="#1-4-持续性也称永久性" class="headerlink" title="1.4 持续性也称永久性"></a>1.4 持续性也称永久性</h3><ul>
<li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li>
<li>接下来的其他操作或故障不应该对其执行结果有任何影响。</li>
</ul>
<h2 id="2-故障和数据库恢复"><a href="#2-故障和数据库恢复" class="headerlink" title="2. 故障和数据库恢复"></a>2. 故障和数据库恢复</h2><ul>
<li><p>故障种类</p>
<ul>
<li>事物内部的故障</li>
<li>系统故障</li>
<li>介质故障</li>
<li>计算机病毒</li>
</ul>
</li>
<li><p>系统故障</p>
<ul>
<li>称为软故障，是指造成系统停止运转的任何事件(特定类型的硬件错误(如CPU故障)、操作系统故障、数据库管理系统代码错误、系统断电)，使得系统要重新启动。<ul>
<li>整个系统的正常运行突然被破坏</li>
<li>所有正在运行的事务都非正常终止</li>
<li>不破坏数据库</li>
<li>内存中数据库缓冲区的信息全部丢失</li>
</ul>
</li>
<li>发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。<ul>
<li>恢复策略：系统重新启动时，恢复程序让所有<strong>非正常终止的事务回滚，强行撤消(UNDO)所有未完成事务。</strong></li>
</ul>
</li>
<li>发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失。<ul>
<li>恢复策略：系统重新启动时，恢复程序需要<strong>重做(REDO)所有已提交的事务</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>介质故障<ul>
<li>称为硬故障，指外存故障、磁盘损坏、磁头碰撞、瞬时强磁场干扰。</li>
<li>介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。</li>
<li>介质故障比前两类故障的可能性小得多，但破坏性大得多。</li>
</ul>
</li>
</ul>
<h2 id="3-数据转储"><a href="#3-数据转储" class="headerlink" title="3. 数据转储"></a>3. 数据转储</h2><ul>
<li><p>转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。</p>
<ul>
<li>备用的数据文本称为后备副本(backup)或后援副本。</li>
</ul>
</li>
<li><p><strong>静态转储</strong>：</p>
<ol>
<li><p>在系统中无运行事务时进行的转储操作</p>
</li>
<li><p>转储开始时数据库处于一致性状态</p>
</li>
<li><p>转储期间不允许对数据库的任何存取、修改活动</p>
</li>
<li><p>得到的一定是一个数据一致性的副本</p>
</li>
</ol>
</li>
<li><p><strong>动态转储</strong>：</p>
<ol>
<li><p>转储操作与用户事务并发进行</p>
</li>
<li><p>转储期间允许对数据库进行存取或修改</p>
</li>
</ol>
<ul>
<li>利用动态转储得到的副本进行故障恢复：<ul>
<li>需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件</li>
<li>后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>海量转储</strong>：每次转储全部数据库</p>
</li>
<li><p><strong>增量转储</strong>：只转储上次转储后更新过的数据</p>
</li>
</ul>
<h2 id="4-日志文件"><a href="#4-日志文件" class="headerlink" title="4. 日志文件"></a>4. 日志文件</h2><ul>
<li>日志文件(log file)是用来记录事务对数据库的更新操作的文件。</li>
<li><p>日志文件的格式</p>
<ul>
<li><p>以记录为单位的日志文件</p>
</li>
<li><p>以数据块为单位的日志文件</p>
</li>
</ul>
</li>
<li>用途<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
</li>
</ul>
<h3 id="4-1-日志文件的作用"><a href="#4-1-日志文件的作用" class="headerlink" title="4.1 日志文件的作用"></a>4.1 日志文件的作用</h3><ul>
<li><p>事务故障恢复和系统故障恢复必须用日志文件。</p>
</li>
<li><p>在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。</p>
</li>
<li>在静态转储方式中，也可以建立日志文件。<ul>
<li>当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态</li>
<li>利用日志文件，<strong>把已完成的事务进行重做处理</strong></li>
<li>对故障发生时<strong>尚未完成的事务进行撤销处理</strong></li>
<li>不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态</li>
</ul>
</li>
</ul>
<h3 id="4-2-登记日志文件"><a href="#4-2-登记日志文件" class="headerlink" title="4.2 登记日志文件"></a>4.2 登记日志文件</h3><ul>
<li>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则：<ul>
<li>登记的次序严格按并发事务执行的时间次序</li>
<li>必须先写日志文件，后写数据库<ul>
<li>写日志文件操作：把表示这个修改的日志记录写到日志文件中</li>
<li>写数据库操作：把对数据的修改写到数据库中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-恢复策略"><a href="#5-恢复策略" class="headerlink" title="5. 恢复策略"></a>5. 恢复策略</h2><h3 id="5-1-事务故障的恢复"><a href="#5-1-事务故障的恢复" class="headerlink" title="5.1 事务故障的恢复"></a>5.1 事务故障的恢复</h3><ul>
<li>事务故障：事务在运行至正常终止点前被终止。</li>
<li>恢复方法：由恢复子系统利用日志文件撤消(UNDO)此事务已对数据库进行的修改</li>
<li>恢复步骤：<ul>
<li>反向扫描文件日志(即从最后向前扫描日志文件)，查找该事务的更新操作。</li>
<li>对该事务的更新操作执行逆操作。即将日志记录中”更新前的值” 写入数据库。</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li>
<li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li>
</ul>
</li>
</ul>
<h3 id="5-2-系统故障的恢复"><a href="#5-2-系统故障的恢复" class="headerlink" title="5.2 系统故障的恢复"></a>5.2 系统故障的恢复</h3><ul>
<li>系统故障造成数据库不一致状态的原因：<ul>
<li>未完成事务对数据库的更新可能已写入数据库</li>
<li>已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库</li>
</ul>
</li>
<li>恢复步骤：<ul>
<li>正向扫描日志文件(即从头扫描日志文件)，将故障发生前已经提交的事务标记进入<strong>重做队列</strong>，将故障发生时尚未提交的事务标记进入<strong>撤销队列</strong></li>
<li>对撤销队列中事务进行撤销处理</li>
<li>对重做队列中事务进行重做处理</li>
</ul>
</li>
</ul>
<h3 id="5-3-介质故障的恢复"><a href="#5-3-介质故障的恢复" class="headerlink" title="5.3 介质故障的恢复"></a>5.3 介质故障的恢复</h3><ul>
<li>介质故障的恢复的工作：<ul>
<li>重装数据库</li>
<li>重做已完成的事务</li>
</ul>
</li>
<li>恢复步骤：<ul>
<li>装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。<ul>
<li>对于静态转储的数据库副本，装入后数据库即处于一致性状态</li>
<li>对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法(即 REDO+UNDO )，才能将数据库恢复到一致性状态。</li>
</ul>
</li>
<li>装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。<ul>
<li>首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。</li>
<li>然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中”更新后的值”写入数据库。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-具有检查点的恢复技术"><a href="#6-具有检查点的恢复技术" class="headerlink" title="6. 具有检查点的恢复技术"></a>6. 具有检查点的恢复技术</h2><ul>
<li><p>具有检查点（checkpoint）的恢复技术</p>
<ul>
<li><p>在日志文件中增加检查点记录（checkpoint）</p>
</li>
<li><p>增加重新开始文件</p>
</li>
<li><p>恢复子系统在登录日志文件期间动态地维护日志</p>
</li>
</ul>
</li>
<li><p>检查点记录的内容</p>
<ul>
<li><p>建立检查点时刻所有正在执行的事务清单</p>
</li>
<li><p>这些事务最近一个日志记录的地址</p>
</li>
</ul>
</li>
<li><p>重新开始文件的内容</p>
<ul>
<li>记录各个检查点记录在日志文件中的地址</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708120633972.png" alt="image-20230708120633972"></p>
<h3 id="6-1-动态维护日志文件的方法"><a href="#6-1-动态维护日志文件的方法" class="headerlink" title="6.1 动态维护日志文件的方法"></a>6.1 动态维护日志文件的方法</h3><ul>
<li>周期性地执行如下操作：建立检查点，保存数据库状态。</li>
<li>具体步骤是：<ul>
<li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上</li>
<li>在日志文件中写入一个检查点记录</li>
<li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中</li>
<li>把检查点记录在日志文件中的地址写入一个重新开始文件</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211443951.png" alt="image-20220914211443951"></p>
<h3 id="6-2-利用检查点的恢复步骤"><a href="#6-2-利用检查点的恢复步骤" class="headerlink" title="6.2 利用检查点的恢复步骤"></a>6.2 利用检查点的恢复步骤</h3><ul>
<li>具体步骤</li>
<li><p>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中<strong>找到最后一个检查点记录</strong>。</p>
</li>
<li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单 ACTIVE-LIST，把 ACTIVE-LIST 暂时放入 UNDO-LIST 队列，REDO 队列暂为空。</p>
<ul>
<li>从检查点开始正向扫描日志文件，直到日志文件结束<ul>
<li>如有新开始的事务 $T_i$，把 $T_i$ 暂时放入 UNDO-LIST 队列</li>
<li>如有提交的事务 $T_i$，把 $T_i$ 从 UNDO-LIST 队列移到 REDO-LIST 队列；直到日志文件结束</li>
</ul>
</li>
</ul>
</li>
<li><p>对 UNDO-LIST 中的每个事务执行 UNDO 操作</p>
</li>
<li><p>对 REDO-LIST 中的每个事务执行 REDO 操作</p>
</li>
</ul>
<h2 id="7-数据库镜像"><a href="#7-数据库镜像" class="headerlink" title="7. 数据库镜像"></a>7. 数据库镜像</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708121111140.png" alt="image-20230708121111140"></p>
<h1 id="11-并发控制"><a href="#11-并发控制" class="headerlink" title="11-并发控制"></a>11-并发控制</h1><h2 id="1-并发控制概述"><a href="#1-并发控制概述" class="headerlink" title="1. 并发控制概述"></a>1. 并发控制概述</h2><ul>
<li><p>事务是并发控制的基本单位。</p>
</li>
<li><p>并发控制机制的任务：</p>
<ul>
<li>对并发操作进行正确调度</li>
<li>保证事务的隔离性</li>
<li>保证数据库的一致性</li>
</ul>
</li>
<li>并发控制技术<ul>
<li>封锁(Locking)</li>
<li>时间戳(Timestamp)</li>
<li>乐观控制法</li>
<li>多版本并发控制(MVCC)</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620195047507.png" alt="image-20220620195047507"></p>
<ul>
<li>事务串行执行</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211455910.png" alt="image-20220914211455910"></p>
<ul>
<li>交叉并发方式</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211505544.png" alt="image-20220914211505544"></p>
<ul>
<li>同时并发方式</li>
</ul>
<h2 id="2-并发操作带来的数据不一致性"><a href="#2-并发操作带来的数据不一致性" class="headerlink" title="2. 并发操作带来的数据不一致性"></a>2. 并发操作带来的数据不一致性</h2><h3 id="2-1-丢失修改"><a href="#2-1-丢失修改" class="headerlink" title="2.1 丢失修改"></a>2.1 丢失修改</h3><ul>
<li>两个事务 $T_1$ 和 $T_2$ 读入同一数据并修改，$T_2$ 的提交结果破坏了 $T_1$ 提交的结果，导致 $T_1$ 的修改被丢失。</li>
</ul>
<h3 id="2-2-不可重复读"><a href="#2-2-不可重复读" class="headerlink" title="2.2 不可重复读"></a>2.2 不可重复读</h3><ul>
<li>不可重复读是指事务 $T_1$ 读取数据后，事务 $T_2$ 执行更新操作，使 $T_1$ 无法再现前一次读取结果(例如为了校对需要重复读)。</li>
<li>不可重复读包括三种情况，后两种不可重复读有时也称为幻影现象：<ul>
<li>一读一改：事务 $T_1$ 读取某一数据后，事务 $T_2$ 对其做了修改，当事务 $T_1$ 再次读该数据时，得到与前一次不同的值 。</li>
<li>一读一删：事务 $T_1$ 按一定条件从数据库中读取了某些数据记录后，事务 $T_2$ 删除了其中部分记录，当 $T_1$ 再次按相同条件读取数据时，发现某些记录神秘地消失了。</li>
<li>一读一加：事务 $T_1$ 按一定条件从数据库中读取某些数据记录后，事务 $T_2$ 插入了一些记录，当 $T_1$ 再次按相同条件读取数据时，发现多了一些记录。</li>
</ul>
</li>
</ul>
<h3 id="2-3-读”脏”数据"><a href="#2-3-读”脏”数据" class="headerlink" title="2.3 读”脏”数据"></a>2.3 读”脏”数据</h3><ul>
<li>读”脏”数据是指：<ul>
<li>事务 $T_1$ 修改某一数据，并将其写回磁盘</li>
<li>事务 $T_2$ 读取同一数据后，$T_1$ 由于某种原因被撤销</li>
<li>这时 $T_1$ 已修改过的数据恢复原值，$T_2$ 读到的数据就与数据库中的数据不一致</li>
<li>$T_2$ 读到的数据就为”脏”数据，即不正确的数据</li>
</ul>
</li>
</ul>
<h2 id="3-封锁"><a href="#3-封锁" class="headerlink" title="3. 封锁"></a>3. 封锁</h2><ul>
<li>封锁就是事务 $T$ 在对某个数据对象(例如表、记录等)操作之前，先向系统发出请求，对其加锁。</li>
<li>加锁后事务 $T$ 就对该数据对象有了一定的控制，在事务 $T$ 释放它的锁之前，其它的事务不能更新此数据对象。</li>
<li><p>基本封锁类型：</p>
<ul>
<li>排它锁(eXclusive Locks，简记为 X 锁)</li>
<li>共享锁(Share Locks，简记为 S 锁)</li>
</ul>
</li>
<li><p>排它锁又称为写锁，表示<strong>正在写，其他事务不能读</strong>。</p>
<ul>
<li>若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其它任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。保证其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</li>
</ul>
</li>
<li><p>共享锁又称为读锁，表示<strong>正在读，其他事务不能写</strong>。</p>
<ul>
<li>若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其它事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。保证其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708122018750.png" alt="image-20230708122018750"></p>
<h3 id="3-1-封锁协议"><a href="#3-1-封锁协议" class="headerlink" title="3.1 封锁协议"></a>3.1 封锁协议</h3><h4 id="3-1-1-一级封锁协议"><a href="#3-1-1-一级封锁协议" class="headerlink" title="3.1.1 一级封锁协议"></a>3.1.1 一级封锁协议</h4><ul>
<li>事务 T 在<strong>修改数据 R 之前必须先对其加 X 锁</strong>，直到<strong>事务结束</strong>(COMMIT 或 ROLLBACK)才释放。</li>
<li>一级封锁协议可<strong>防止丢失修改</strong>，并<strong>保证事务 T 是可恢复的</strong>。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它<strong>不能保证可重复读</strong>和<strong>不读”脏”数据</strong>。</li>
</ul>
<h4 id="3-1-2-二级封锁协议"><a href="#3-1-2-二级封锁协议" class="headerlink" title="3.1.2 二级封锁协议"></a>3.1.2 二级封锁协议</h4><ul>
<li>一级封锁协议加上事务 T 在<strong>读取数据 R 之前必须先对其加 S 锁</strong>，<strong>读完后</strong>即可释放S锁。</li>
<li>二级封锁协议可以<strong>防止丢失修改</strong>和<strong>读”脏”数据</strong>。在二级封锁协议中，由于读完数据后即可释放 S 锁，所以它<strong>不能保证可重复读</strong>。</li>
</ul>
<h4 id="3-1-3-三级封锁协议"><a href="#3-1-3-三级封锁协议" class="headerlink" title="3.1.3 三级封锁协议"></a>3.1.3 三级封锁协议</h4><ul>
<li>一级封锁协议加上事务 T 在<strong>读取数据 R 之前必须先对其加 S 锁</strong>，直到<strong>事务结束</strong>才释放。</li>
<li>三级封锁协议可<strong>防止丢失修改、读脏数据和不可重复读</strong>。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708122424625.png" alt="image-20230708122424625"></p>
<h3 id="3-2-活锁"><a href="#3-2-活锁" class="headerlink" title="3.2 活锁"></a>3.2 活锁</h3><ul>
<li>因为优先级低而永远等待</li>
<li>避免活锁：采用先来先服务的策略</li>
</ul>
<h3 id="3-3-死锁"><a href="#3-3-死锁" class="headerlink" title="3.3 死锁"></a>3.3 死锁</h3><ul>
<li>原因：两个或多个事务都已封锁了一些数据对象，然后又都请求对已被其他事务封锁的数据对象加锁，从而出现死等待。</li>
<li><p>预防：破坏产生死锁的条件</p>
<ul>
<li>一次封锁法<ul>
<li>要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。</li>
<li>问题：<ul>
<li>降低系统并发度</li>
<li>难以事先精确确定封锁对象</li>
</ul>
</li>
</ul>
</li>
<li>顺序封锁法<ul>
<li>预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁</li>
<li>问题：<ul>
<li>维护成本</li>
<li>难以实现</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>诊断并解除死锁(常用)</p>
<ul>
<li><strong>超时法</strong>：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。</li>
<li><strong>等待图法</strong>：并发控制子系统周期性地(比如每隔数秒)生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。</li>
</ul>
</li>
<li>解除死锁<ul>
<li>选择一个处理死锁代价最小的事务，将其撤消</li>
<li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li>
</ul>
</li>
</ul>
<h2 id="4-事务调度"><a href="#4-事务调度" class="headerlink" title="4. 事务调度"></a>4. 事务调度</h2><ul>
<li>串行调度是正确的。执行结果等价于串行调度的调度也是正确的，称为<strong>可串行化调度</strong>。</li>
<li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。</li>
<li><strong>可串行性(Serializability)</strong>是并发事务正确调度的准则：一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</li>
</ul>
<h3 id="4-1-冲突可串行化"><a href="#4-1-冲突可串行化" class="headerlink" title="4.1 冲突可串行化"></a>4.1 冲突可串行化</h3><ul>
<li>一个调度 Sc 在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 Sc’，如果 Sc’ 是串行的，称调度 Sc 是冲突可串行化的调度</li>
</ul>
<h3 id="4-2-两段锁协议"><a href="#4-2-两段锁协议" class="headerlink" title="4.2 两段锁协议"></a>4.2 两段锁协议</h3><ul>
<li><p>两段锁协议，指所有事务必须分两个阶段对数据项加锁和解锁 ：</p>
<ul>
<li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li>
</ul>
</li>
<li><p>在此协议下，事务分为两个阶段：</p>
<ul>
<li>第一阶段是获得封锁，也称为扩展阶段：事务可以申请获得任何数据项上的任何类型的锁，但是<strong>不能释放任何锁</strong></li>
<li>第二阶段是释放封锁，也称为收缩阶段：事务可以释放任何数据项上的任何类型的锁，但是<strong>不能再申请任何锁</strong></li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620204053987.png" alt="image-20220620204053987"></p>
<ul>
<li>事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。</li>
<li>但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。</li>
</ul>
<h2 id="5-封锁粒度"><a href="#5-封锁粒度" class="headerlink" title="5. 封锁粒度"></a>5. 封锁粒度</h2><ul>
<li>封锁粒度与系统的并发度和并发控制的开销密切相关：<ul>
<li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li>
<li>封锁的粒度越小，并发度较高，但系统开销也就越大</li>
</ul>
</li>
</ul>
<h3 id="5-1-多粒度封锁"><a href="#5-1-多粒度封锁" class="headerlink" title="5.1 多粒度封锁"></a>5.1 多粒度封锁</h3><ul>
<li>多粒度封锁：在一个系统中同时支持多种封锁粒度供不同的事务选择。</li>
<li>选择封锁粒度，同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度：<ul>
<li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li>
<li>需要处理大量元组的用户事务：以关系为封锁单元</li>
<li>只处理少量元组的用户事务：以元组为封锁单位</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211518287.png" alt="image-20220914211518287"></p>
<ul>
<li>多粒度封锁协议允许多粒度树中的每个结点被独立地加锁。</li>
<li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。</li>
<li>在多粒度封锁中一个数据对象可能以两种方式封锁：<ul>
<li><strong>显式封锁</strong>：直接加到数据对象上的封锁</li>
<li><strong>隐式封锁</strong>：是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁</li>
</ul>
</li>
<li><p>显式封锁和隐式封锁的效果是一样的。</p>
</li>
<li><p>系统检查封锁冲突时既要检查显式封锁，还要检查隐式封锁。</p>
</li>
<li>对某个数据对象加锁，系统要检查：<ul>
<li>该数据对象：有无显式封锁与之冲突</li>
<li>所有上级结点：检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突(由上级结点已加的封锁造成的)冲突</li>
<li>所有下级结点：看上面的显式封锁是否与本事务的隐式封锁(将加到下级结点的封锁)冲突</li>
</ul>
</li>
</ul>
<h3 id="5-2-意向锁"><a href="#5-2-意向锁" class="headerlink" title="5.2 意向锁"></a>5.2 意向锁</h3><ul>
<li>引进意向锁目的：提高对某个数据对象加锁时系统的检查效率。</li>
<li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。</li>
<li>对任一结点加基本锁，必须先对它的上层结点加意向锁。<ul>
<li>意向共享锁(IS 锁)：表示它的后裔结点拟(意向)加 S 锁。</li>
<li>意向排它锁(IX 锁)：表示它的后裔结点拟(意向)加 X 锁。</li>
<li>共享意向排它锁(SIX 锁)：表示对它加 S 锁，再加 IX 锁，即 SIX = S + IX。<ul>
<li>例：对某个表加SIX锁，则表示该事务要读整个表(所以要对该表加S锁)，同时会更新个别元组(所以要对该表加IX锁)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211529089.png" alt="image-20220914211529168"></p>
<ul>
<li>申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。</li>
<li>具有意向锁的多粒度封锁方法：提高了系统的并发度，减少了加锁和解锁的开销，在实际的数据库管理系统产品中得到广泛应用。</li>
</ul>
<h1 id="12-NoSQL数据模型"><a href="#12-NoSQL数据模型" class="headerlink" title="12-NoSQL数据模型"></a>12-NoSQL数据模型</h1><h2 id="1-阻抗失谐"><a href="#1-阻抗失谐" class="headerlink" title="1. 阻抗失谐"></a>1. 阻抗失谐</h2><ul>
<li><p>SQL 操作所<strong>使用及返回的数据都是关系元组</strong>，不能包含嵌套记录或列表等任何结构。而<strong>内存中的数据结构则无此限制</strong>，它可以使用的数据组织形式比关系更丰富。</p>
</li>
<li><p>关系模型和内存中的数据结构之间存在差异。这种现象通常称为<strong>阻抗失谐</strong>。</p>
</li>
<li><p>如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成关系形式。于是就发生了阻抗失谐：<strong>需要在两种不同的表示形式之间转译</strong>。</p>
</li>
<li><p>解决方法</p>
<ul>
<li>面向对象数据库</li>
<li>对象-关系映射框架</li>
</ul>
</li>
<li>问题：<ul>
<li>查询性能问题</li>
<li>集成问题</li>
</ul>
</li>
</ul>
<h2 id="2-应用程序数据库与集成数据库"><a href="#2-应用程序数据库与集成数据库" class="headerlink" title="2. 应用程序数据库与集成数据库"></a>2. 应用程序数据库与集成数据库</h2><ul>
<li><p>SQL 充当了应用程序之间的一种集成机制。数据库在这种情况下成了<strong>集成数据库</strong></p>
<ul>
<li>通常由不同团队所开发的多个应用程序，将其数据存储在一个公用的数据库中。</li>
<li>所有应用程序都在操作内容一致的持久数据，提高了数据通信的效率</li>
<li>为了能将很多应用程序集成起来，数据库的结构比单个应用程序所要用到的结构复杂得多</li>
<li>如果某个应用程序想要修改存储的数据，那么它就得和所有使用此数据库的其他应用程序相调。</li>
<li>各种应用程序的结构和性能要求不尽相同，数据库通常不能任由应用程序更新其数据。为了保持数据库的完整性，我们需要将这一责任交由数据库自身负责。</li>
</ul>
</li>
<li><p>将数据库视为<strong>“应用程序数据库”</strong>，其内容只能由一个应用程序的代码库直接访问</p>
<ul>
<li><p>由于只有开发应用程序的团队才需要知道其结构，模式的维护与更新就更容易了。由于应用程序开发团队同时管理数据库和应用程序代码，因此可以把维护数据库完整性的工作放在应用程序代码中。</p>
</li>
<li><p>交互工作转交由应用程序接口来完成</p>
</li>
<li>在使用应用程序数据库后，由于内部数据库与外部通信服务之间已经解耦，所以外界并不关心数据如何存储，这样就可以选用非关系型数据库了</li>
</ul>
</li>
</ul>
<h2 id="3-集群"><a href="#3-集群" class="headerlink" title="3. 集群"></a>3. 集群</h2><ul>
<li>纵向扩展(scale up)：功能强大的计算机、更多的处理器、磁盘存储空间和内存。但成本高、扩展尺度有限。</li>
<li>横向扩展(scale out)：采用由多个小型计算机组成的集群。集群中的小型机使用性价比较高的硬件，降低扩展所需的成本。</li>
<li>关系型数据库并不是设计给集群用的。</li>
</ul>
<h2 id="4-NoSQL登场"><a href="#4-NoSQL登场" class="headerlink" title="4. NoSQL登场"></a>4. NoSQL登场</h2><ul>
<li>不使用关系模型</li>
<li>在集群中运行良好</li>
<li>开源</li>
<li>适用于 21 世纪的互联网公司</li>
<li><strong>无模式</strong></li>
</ul>
<h2 id="5-分布式模型"><a href="#5-分布式模型" class="headerlink" title="5. 分布式模型"></a>5. 分布式模型</h2><ul>
<li>数据分布有两条路径：<strong>分片与复制</strong><ul>
<li>“分片”是将不同数据存放在不同节点中</li>
<li>“复制”是将同一份数据拷贝至多个节点<ul>
<li>“主从式” 和 “对等式”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-1-分片"><a href="#5-1-分片" class="headerlink" title="5.1 分片"></a>5.1 分片</h3><ul>
<li>把数据的各个部分存放于不同的服务器中，以此实现横向扩展。该技术就叫”分片”。</li>
<li>为达成目标，必须保证需要同时访问的那些数据都存放在同一节点上，而且节点必须排布好这些数据块，使访问速度最优。</li>
<li>采用应用程序的逻辑实现分片</li>
<li>采用NoSQL数据库提供的”自动分片”功能</li>
<li>分片可以同时提升读取与写入效率</li>
<li>分片对改善数据库的”故障恢复能力”帮助并不大。尽管数据分布在不同的节点上，但是和”单一服务器”方案一样，<strong>只要某节点出错，那么该分片上的数据就无法访问了</strong><ul>
<li>在发生故障时，只有访问此数据的那些用户才会受影响，而其余用户则能正常访问</li>
<li>由于多节点问题，从实际效果出发，分片技术可能会降低数据库的错误恢复能力</li>
</ul>
</li>
</ul>
<h3 id="5-2-主从复制"><a href="#5-2-主从复制" class="headerlink" title="5.2 主从复制"></a>5.2 主从复制</h3><ul>
<li><p>在”主从式分布”中</p>
<ul>
<li><p>其中有一个节点叫做”主节点”，或”主要节点”。主节点存放权威数据，而且通常负责处理数据<strong>更新</strong>操作。</p>
</li>
<li><p>其余节点都叫”从节点”，或”次要节点”，和主节点保持同步，负责<strong>读取</strong>操作。</p>
</li>
</ul>
</li>
<li><p>在需要频繁读取数据集的情况下，”主从复制”(master-slave replication) 有助于提升数据访问性能</p>
</li>
<li><p>“主从复制”可以增强”读取操作的故障恢复能力”(read resilience)</p>
<ul>
<li>万一主节点出错了，那么从节点依然可以处理读取请求。</li>
<li>主节点出错之后，除非将其恢复，或另行指派新的主节点，否则数据库就无法处理写入操作。</li>
<li>在主节点出错之后，由于拥有内容与主节点相同的从节点，很快就能指派一个从节点作为新的主节点，从而具备故障恢复能力。</li>
<li>主节点可以手工指派，也可自动选择。 </li>
</ul>
</li>
</ul>
<h3 id="5-3-对等复制"><a href="#5-3-对等复制" class="headerlink" title="5.3 对等复制"></a>5.3 对等复制</h3><ul>
<li>“对等复制” 它没有”主节点”这一概念。所有”副本”(replica) 地位相同，都可以接受写入请求，而且丢失其中一个副本，并不影响整个数据库的访问。</li>
</ul>
<h3 id="5-4-结合复制与分片"><a href="#5-4-结合复制与分片" class="headerlink" title="5.4 结合复制与分片"></a>5.4 结合复制与分片</h3><ul>
<li><strong>结合”主从复制”与”分片”</strong><ul>
<li>如果同时使用”主从复制”与”分片”，那么就意味着整个系统有多个主节点，然而对每项数据来说，负责它的主节点只有一个</li>
<li>根据配置需要，同一个节点既可以做某些数据的主节点，也可以充当其他数据的从节点，此外，也可以指派全职的主节点或从节点</li>
</ul>
</li>
<li><strong>结合”对等复制”与”分片”</strong><ul>
<li>数据可能分布于集群中的数十个或数百个节点上。在采用”对等复制”方案时，一开始可以用 “3” 作为复制因子(replication factor), 也就是把每个分片数据放在 3 个节点中。一旦某个节点出错，那么它上面保存的那些分片数据会由其他节点重建</li>
</ul>
</li>
</ul>
<h2 id="6-放宽”一致性”和”持久性”约束"><a href="#6-放宽”一致性”和”持久性”约束" class="headerlink" title="6. 放宽”一致性”和”持久性”约束"></a>6. 放宽”一致性”和”持久性”约束</h2><h3 id="6-1-使用事务保障”一致性”"><a href="#6-1-使用事务保障”一致性”" class="headerlink" title="6.1 使用事务保障”一致性”"></a>6.1 使用事务保障”一致性”</h3><ul>
<li>使用”事务”达成强一致性</li>
<li>引入放松”隔离级别”(isolation level)的功能，以允许查询操作读取尚未提交的数据。<ul>
<li>读未提交，一个事务可以读取另一个未提交事务的数据。脏读</li>
<li>读已提交，一个事务要等另一个事务提交后才能读取数据。不可重复读</li>
<li>可重复读，在开始读取数据(事务开启)时，不再允许修改操作。幻读</li>
<li>可串行化，事务串行化顺序执行。严格一致性，效率是一个问题</li>
</ul>
</li>
</ul>
<h3 id="6-2-CAP定理"><a href="#6-2-CAP定理" class="headerlink" title="6.2 CAP定理"></a>6.2 CAP定理</h3><ul>
<li><p>CAP定理：给定<strong>“一致性”、”可用性”、”分区耐受性”</strong> 这三个属性，我们只能同时满足其中两个属性。</p>
<ul>
<li>“一致性”</li>
<li>“可用性”，如果客户可以同集群中的某个节点通信，那么该节点就必然能够处理读取及写入操作。</li>
<li>“分区耐受性”，如果发生通信故障，导致整个集群被分割成多个无法互相通信的分区时(这种情况也叫”脑裂”，split brain)，集群仍然可用。</li>
</ul>
</li>
<li><p>CA系统：具备”一致性”(Consistency)与”可用性”(Availability)，但却不具备”分区耐受性”的系统</p>
<ul>
<li>大多数关系型数据库</li>
</ul>
</li>
<li><p>CA集群</p>
<ul>
<li>无法保证”分区耐受性”，这使得一旦”分区”发生，所有节点必须停止运作</li>
<li>CAP中的，可用性定义为”系统中某个无故障节点所接收的每一条请求，无论成功或失败，都必将得到响应。”</li>
<li>介于此时所有节点均为故障节点，不违反CAP中的”可用性”</li>
</ul>
</li>
</ul>
<h3 id="6-3-BASE"><a href="#6-3-BASE" class="headerlink" title="6.3 BASE"></a>6.3 BASE</h3><ul>
<li>与关系型数据库所支持的ACID事务不同，NoSQL系统具备”BASE属性”<ul>
<li>基本可用，Basically Available</li>
<li>柔性状态，Soft state</li>
<li>最终一致性，Eventual consistency </li>
</ul>
</li>
</ul>
<h3 id="6-4-“一致性”与”延迟”-之间取舍"><a href="#6-4-“一致性”与”延迟”-之间取舍" class="headerlink" title="6.4 “一致性”与”延迟” 之间取舍"></a>6.4 “一致性”与”延迟” 之间取舍</h3><ul>
<li>在权衡分布式数据库的”一致性”时，与其考虑如何权衡”一致性”与”可用性”，不如思考怎样在”一致性”与”延迟”(latency)之间取舍。<ul>
<li>参与交互操作的节点越多，”一致性”就越好</li>
<li>然而，每新增一个节点，都会使交互操作的响应时间变长</li>
<li>“可用性”可以视为能够忍受的最大延迟时间，一旦延迟过高，我们就放弃操作，并认为数据不可用</li>
<li>这样一来，就和”CAP定理”对”可用性”所下的定义相当吻合了</li>
</ul>
</li>
</ul>
<h2 id="7-仲裁"><a href="#7-仲裁" class="headerlink" title="7. 仲裁"></a>7. 仲裁</h2><h3 id="7-1-写入仲裁"><a href="#7-1-写入仲裁" class="headerlink" title="7.1 写入仲裁"></a>7.1 写入仲裁</h3><ul>
<li>保强一致性(strong consistency)，需要使用多少个节点才行?</li>
<li>对等式分布模型：如果发生两个相互冲突的写入操作，那么只有其中一个操作能为超过半数的节点所认可，$W&gt;N/2$ 。即，参与写入操作的节点数(W)，必须超过副本节点数(N)的一半。副本个数又称为复制因子</li>
<li>主从式分布模型：只需要向主节点中写入数据</li>
</ul>
<h3 id="7-2-读取仲裁"><a href="#7-2-读取仲裁" class="headerlink" title="7.2 读取仲裁"></a>7.2 读取仲裁</h3><ul>
<li>想要保证能够读到最新数据，必须与多少个节点联系才行?</li>
<li>对等式分布模型：只有当 $R+W&gt;N$ 时，才能保证读取操作的强一致性。其中，执行读取操作时所需联系的节点数(R)，确认写入操作时所需征询的节点数(W)，以及复制因子(N)</li>
<li>主从式分布模型：只需从主节点中读取数据</li>
</ul>
<h2 id="8-如何存放，适合做什么，不适合做什么"><a href="#8-如何存放，适合做什么，不适合做什么" class="headerlink" title="8. 如何存放，适合做什么，不适合做什么"></a>8. 如何存放，适合做什么，不适合做什么</h2><h3 id="8-1-键值数据库"><a href="#8-1-键值数据库" class="headerlink" title="8.1 键值数据库"></a>8.1 键值数据库</h3><ul>
<li>定义：键值数据库是一张简单的哈希表，主要用在所有数据库访问均通过主键来操作的情况下。</li>
<li>适用案例<ul>
<li><strong>存放会话信息</strong><ul>
<li>因为全部会话内容都可以用一条 PUT 请求来存放，而且只需一条 GET 请求就能取得。</li>
<li>由于会话中的所有信息都放在一个对象中，所以这种单请求操作很迅速。</li>
</ul>
</li>
<li><strong>用户配置信息</strong><ul>
<li>内容可全部放在一个对象里，只用一次 GET 操作即获取某位用户的全部配置信息。</li>
</ul>
</li>
<li><strong>购物车数据</strong><ul>
<li>可把购物信息放在 value 属性中，并将其绑定到 userid 这个键名上。</li>
</ul>
</li>
</ul>
</li>
<li>不适用案例<ul>
<li><strong>数据间关系</strong></li>
<li><strong>含有多项操作的事务</strong></li>
<li><strong>查询数据</strong></li>
</ul>
</li>
</ul>
<h3 id="8-2-文档数据库"><a href="#8-2-文档数据库" class="headerlink" title="8.2 文档数据库"></a>8.2 文档数据库</h3><ul>
<li>定义：文档数据库所存放的文档，就相当于键值数据库所存放的”值”。文档数据库可视为其值可查的键值数据库。</li>
<li>适用案例<ul>
<li><strong>事件记录</strong></li>
<li><strong>内容管理系统及博客平台</strong></li>
<li><strong>电子商务应用程序</strong></li>
</ul>
</li>
<li>不适用案例<ul>
<li><strong>包含多项操作的事务</strong></li>
<li><strong>查询持续变化的聚合结构</strong></li>
</ul>
</li>
</ul>
<h3 id="8-3-列族数据库"><a href="#8-3-列族数据库" class="headerlink" title="8.3 列族数据库"></a>8.3 列族数据库</h3><ul>
<li>定义：可以存储关键字及其映射值,并且可以把值分成多个列族，让每个列族代表一张数据映射表</li>
<li>适用案例<ul>
<li><strong>事件记录</strong></li>
<li><strong>内容管理系统及博客平台</strong></li>
<li><strong>计数器</strong></li>
<li><strong>限期</strong></li>
</ul>
</li>
<li>不适用案例<ul>
<li><strong>需要以 ACID 事务执行写入及读取操作的系统。</strong></li>
</ul>
</li>
</ul>
<h3 id="8-4-图数据库"><a href="#8-4-图数据库" class="headerlink" title="8.4 图数据库"></a>8.4 图数据库</h3><ul>
<li><p>定义：图数据库可存放实体及实体间关系。实体也叫”节点”，它们具有属性。关系又叫”边”，它们也有属性。</p>
</li>
<li><p>适用案例：</p>
<ul>
<li><strong>互联数据</strong></li>
<li><strong>安排运输路线、分派货物和基于位置的服务</strong></li>
</ul>
</li>
<li><p>不适用案例</p>
<ul>
<li><strong>更新全部或某子集内的实体时</strong></li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/数据管理基础/">数据管理基础</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/数据管理基础/">数据管理基础</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/07/06/夏令营-计网往年卷/"><span>计网往年卷</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/07/06/夏令营-计网往年卷/" rel="bookmark">
        <time class="entry-date published" datetime="2023-07-06T11:47:27.000Z">
          2023-07-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><ol>
<li>B: 传输介质标准；100：速率，BASE：基带传输，T：双绞线（F是光纤），X：不同标准</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220624163532468.png" alt="image-20220624163532468"></p>
<ol>
<li>C: 根交换机所有端口都是指定端口</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220624164334179.png" alt="image-20220624164334179"></p>
<ol>
<li>B: DR 发送链路状态信息到网段上其它所有路由器，用多播地址224.0.0.5，为了保证DR/BDR看见网端上所有路由器发送的链路状态，给所有DR/BDR的多播地址是224.0.0.6</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706195515353.png" alt="image-20230706195515353"></p>
<ol>
<li>B，ISDN的服务之一BRI，2B+1D，B：64kbps，D：16kbps</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625001634262.png" alt="image-20220625001634262"></p>
<ol>
<li>A, 在二层交换机上有三种转发方式：<ul>
<li>直通转发（cut-through switching ）：只需要等收到目标 MAC 之后就可以开启转发进程。</li>
<li>存储转发（Store-and-Forward switching）：首先交换机启动接收进程，开始收取帧，从”Preamble”字段开始，一直到最后的 CRC，当这个完整的帧收取完成之后，交换机开始启动转发进程，根据接收帧所示的 DMAC，也就是目标 MAC 地址来决定转发策略，如果在 MAC 地址表中存在，那么转发到相对应的端口；如果不存在，则泛洪到所有端口。</li>
<li>无碎片转发（segment-free switching）：“无碎片转发”这种转发方式其实是和直通转发一样的，只是比直通转发收取了更多的信息之后再进行转发，无碎片转发就是收取64字节才开始转发的，减少了转发出错的几率。</li>
</ul>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625002226235-16560877481771.png" alt="image-20220625002226235"></p>
<ol>
<li>D</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706224420264.png" alt="image-20230706224420264"></p>
<h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><ol>
<li>B</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706200219838.png" alt="image-20230706200219838"></p>
<ol>
<li>ABD</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706202301861.png" alt="image-20230706202301861"></p>
<ol>
<li>BC</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625002610080.png" alt="image-20220625002610080"></p>
<ol>
<li>BC，传输层和数据链路层有流量控制</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706211512764.png" alt="image-20230706211512764"></p>
<ol>
<li>AE</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625003324294.png" alt="image-20220625003324294"></p>
<ol>
<li>AC</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706212056429.png" alt="image-20230706212056429"></p>
<ol>
<li>ACD</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625142755604.png" alt="image-20220625142755604"></p>
<h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><h2 id="2010"><a href="#2010" class="headerlink" title="2010"></a>2010</h2><p><strong>单选</strong><br>1-5: DBCDB</p>
<p>6-10: CCCDA</p>
<p>11-16: CDC<code>B</code>CB</p>
<p><strong>多选</strong></p>
<ol>
<li>BF</li>
<li>ACD</li>
<li>A</li>
<li><code>B</code></li>
<li><code>A</code>BD</li>
<li>A<code>B</code>D</li>
<li>AD</li>
<li>ACDE</li>
<li>CD</li>
<li>AC</li>
</ol>
<p><strong>名词解释</strong></p>
<ul>
<li><p>IEEE MAC Sub-layer</p>
<ul>
<li>电气与电子工程师协会的 MAC 子层划分，IEEE 将数据链路层分成 LLC 和 MAC 两个子层。MAC 控制各个 host 对 media 的使用权。MAC 子层定义了 frame 如何在物理线上运输，处理物理地址，定义网络拓扑和网线使用规则。</li>
</ul>
</li>
<li><p>Split Horizon</p>
<ul>
<li>水平分割，是一种避免路由环路的出现和加快路由汇聚的技术。水平分割法的规则和原理是路由器从某个接口接收到的更新信息不允许再从这个接口发回去。</li>
</ul>
</li>
<li><p>Flow Control</p>
<ul>
<li>流量控制，让发送方的发送速率不要太快，要让接收方来得及接收。</li>
</ul>
</li>
<li><p>Socket</p>
<ul>
<li>套接字，IP+端口</li>
</ul>
</li>
<li><p>DNS</p>
<ul>
<li>域名系统，因特网上作为域名和 IP 地址相互映射的一个分布式数据库，将域名转化为 IP 地址</li>
</ul>
</li>
<li><p>Time Division Multiplexing</p>
<ul>
<li>时分复用，采用同一物理连接的不同时段来传输不同的信号。</li>
</ul>
</li>
<li><p>ADSL</p>
<ul>
<li>非对称数字用户线（Asymmetric Digital Subscriber Line），用数字技术对现有的模拟电话用户线进行改造，使它能承载宽带数字业务。ADSL 下行带宽远远大于上行带宽，因此得名“非对称”。</li>
</ul>
</li>
<li><p>Computer Virus</p>
<ul>
<li>电脑病毒</li>
</ul>
</li>
</ul>
<p><strong>简答</strong></p>
<ol>
<li>DTBATF</li>
</ol>
<p>D(MAC2, MACR2, 110.2, 100.3)</p>
<p>T(MAC2, MACR2, 110.2, 100.3)</p>
<p>B(MAC2, MACR2, 110.2, 100.3)</p>
<p>A(MACR1, MACR4, 110.2, 100.3)</p>
<p>T(MACR1, MACR4, 110.2, 100.3)</p>
<p>F(MACR1, MACR4, 110.2, 100.3)</p>
<ol>
<li></li>
<li><p>A: 202.102.32.0/25<br>B: 202.102.32.136/29<br>C: 202.102.32.144/28<br>D: 202.102.32.128/27<br>E: 202.102.32.0/24</p>
</li>
</ol>
<h2 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h2><p><strong>单选</strong></p>
<p>1-5：DBBCC</p>
<p>6-10: BDBAB</p>
<p>11-15: ADCAC</p>
<p><strong>多选</strong></p>
<ol>
<li>ACD</li>
<li>BC</li>
<li>ABD</li>
<li>ABD</li>
<li>AD</li>
<li><code>BC</code></li>
<li>AC</li>
<li><code>AE</code></li>
</ol>
<p><strong>名词解释</strong></p>
<ul>
<li>Full duplex<ul>
<li>全双工：通信的双方可以同时发送和接收信息。</li>
</ul>
</li>
<li><p>OSI reference model</p>
<ul>
<li>OSI将计算机网络体系结构(architecture）划分为以下七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</li>
</ul>
</li>
<li><p>CSMA/CD</p>
<ul>
<li>载波监听多点接入/碰撞检测。“多点接入”就是说明这是总线型网络，“载波监听”就是用电子技术检测总线上有没有其他计算机也在发送。“碰撞检测”也就是“边发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。</li>
</ul>
</li>
<li>STP<ul>
<li>生成树协议，该协议可应用于在网络中建立树形拓扑，消除网络中的环路，并且可以通过一定的方法实现路径冗余，但不是一定可以实现路径冗余</li>
</ul>
</li>
<li>RARP<ul>
<li>反向地址转换协议，发出要反向解析的物理地址并希望返回其对应的IP地址</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Split horizon</li>
<li>DNS</li>
<li>Time Division Multiplexing</li>
</ul>
</blockquote>
<p><strong>简答</strong></p>
<ol>
<li>同，DTBATF</li>
<li>同</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706212520888.png" alt="image-20230706212520888"></p>
<ol>
<li><p>A: 192.168.20.0/26</p>
</li>
</ol>
<p>B: 192.168.20.144/29</p>
<p>C: 192.168.20.128/28</p>
<p>D: 192.168.20.64/26</p>
<p>RTA-RTB: 192.168.20.152/30</p>
<p>RTA-RTC: 192.168.20.156/30</p>
<p>RTC-RTD: 192.168.20.160/30</p>
<ol>
<li>同</li>
</ol>
<h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><p><strong>名词解释</strong></p>
<ul>
<li>PPP<ul>
<li>点对点协议，为在点对点连接上传输多协议数据包提供一个标准方法</li>
</ul>
</li>
<li>UDP<ul>
<li>用户数据报协议，提供面向事务的简单不可靠、无连接、无确认、无流控制的信息传送服务</li>
</ul>
</li>
<li>HTTP<ul>
<li>超文本传输协议，一个简单的请求-响应协议，定义了客户端与服务器端请求和应答的标准</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Split horizon</li>
<li>CSMA/CD</li>
<li>DNS</li>
<li>Time Division Multiplexing</li>
<li>RARP</li>
</ul>
</blockquote>
<p><strong>简答</strong></p>
<ol>
<li>Tell the similarities and differences between the OSI reference model and TCP/IP model</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706223126435.png" alt="image-20230706223126435"></p>
<ol>
<li>For convenient management,a company plans to divide the 195.3.1.0 into five sub,and the number of computers does not exceed 15.Calculate the subnet ip address.Write the ip address of each subset and the subnet mask.<ul>
<li>195.3.1.0 255.255.255.224</li>
<li>195.3.1.32 255.255.255.224</li>
<li>195.3.1.64 255.255.255.224</li>
<li>195.3.1.96 255.255.255.224</li>
<li>195.3.1.128 255.255.255.224</li>
</ul>
</li>
<li>Host A send two continuous TCP packet to host B, and their sequence number are 70 and 100.Questions：<ul>
<li>How many bytes of data does the first packet carry?<ul>
<li>30</li>
</ul>
</li>
<li>What is the acknowledgement number of the packet that host B send back to host A ? receives the first packet?<ul>
<li>71</li>
</ul>
</li>
<li>If the acknowledgement number of the packet that host B send back after receiving the packet is 180, how many bytes of the second packet?<ul>
<li>80</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><p><strong>选择</strong></p>
<p>端⼝号的范围（0到65535）</p>
<p>802.11b的最⼤速率（11Mbps）</p>
<p>新增考点：</p>
<ul>
<li>crossroad 和交换机／路由器连接，各种线的用法</li>
<li>ipv4，ipv6 各自位数，差别</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706215829967.png" alt="image-20230706215829967"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706215858137.png" alt="image-20230706215858137"></p>
<p><strong>名词解释</strong></p>
<ul>
<li>FTP<ul>
<li>文件传输协议, 在网络上进行文件传输的一套标准协议，基于TCP，面向连接</li>
</ul>
</li>
<li>ICMP<ul>
<li>因特网控制报文协议, ICMP允许主机或者路由器报告差错情况和提供有关异常情况的报告</li>
</ul>
</li>
<li>NAT<ul>
<li>网络地址转换, 将网络内部的私有IP地址转换为公有IP地址以节省IP地址的方法</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>PPP</li>
<li>DNS</li>
<li>Time Division Multiplexing</li>
<li>CSMA/CD</li>
<li>Full-delpex</li>
</ul>
</blockquote>
<p><strong>简答</strong></p>
<ol>
<li><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706220133370.png" alt="image-20230706220133370"></p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>可达节点</th>
<th>下一跳路由</th>
<th>距离</th>
</tr>
</thead>
<tbody>
<tr>
<td>N1</td>
<td>C</td>
<td>6</td>
</tr>
<tr>
<td>N2</td>
<td>A</td>
<td>5</td>
</tr>
<tr>
<td>N3</td>
<td>C</td>
<td>7</td>
</tr>
<tr>
<td>N6</td>
<td>C</td>
<td>5</td>
</tr>
<tr>
<td>N8</td>
<td>C</td>
<td>4</td>
</tr>
<tr>
<td>N9</td>
<td>F</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>在 distance-vector-protocol 中写出 3 种解决环路的方法</li>
</ol>
<ul>
<li>定义最大值</li>
<li>水平分割</li>
<li>路由中毒</li>
<li>计时器</li>
</ul>
<ol>
<li>建立连接和中止连接时TCP的过程</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706221144044.png" alt="image-20230706221144044"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706221117603.png" alt="image-20230706221117603"></p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><p><strong>单选</strong></p>
<p>1-5 DDBCA</p>
<p>6-10 DDCB<code>A</code></p>
<p>11-15 ABCCD</p>
<p><strong>多选</strong></p>
<ol>
<li>ABD</li>
<li>E</li>
<li>AE</li>
<li>ACD</li>
<li>BCE</li>
<li>BC</li>
<li>AB</li>
<li>ABD</li>
</ol>
<p><strong>名词解释</strong></p>
<ul>
<li>CHAP<ul>
<li>挑战握手认证协议，比PAP更加可靠的认证协议，使用MD5加密</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>PPP</li>
<li>RARP</li>
<li>ICMP</li>
<li>CSMA/CD</li>
<li>FTP</li>
<li>TDM</li>
<li>DNS</li>
</ul>
</blockquote>
<p><strong>简答</strong></p>
<ol>
<li>RIP，类似往年</li>
<li>路径，往年</li>
<li>TCP/IP和OSI异同，往年</li>
<li>子网划分，lab1、lab2、lab3各有1个file server、1个打印机和30、32、60计算机<ul>
<li>分配 128.198.63.0/24<ul>
<li>1：128.198.63.128/26</li>
<li>2：128.198.63.64/26</li>
<li>3：128.198.63.0/26</li>
</ul>
</li>
<li>如果给lab1分配128.198.63.0/27是否可以？为什么？<ul>
<li>不可以，不够</li>
</ul>
</li>
</ul>
</li>
<li>001101 画出NRZ码、曼彻斯特码、差分曼彻斯特码</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706224047690.png" alt="image-20230706224047690"></p>
<ol>
<li>TCP建立和断开链接过程，往年</li>
</ol>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p><strong>名词解释</strong></p>
<ul>
<li>SMTP<ul>
<li>简单邮件传输协议, E-mail服务器通过SMTP发送邮件</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>PPP</li>
<li>CMDA/CD</li>
<li>CHAP</li>
<li>ICMP</li>
<li>TDM</li>
<li>ARP</li>
<li>HTTP</li>
</ul>
</blockquote>
<p><strong>简答</strong></p>
<ul>
<li>RIP路由更新</li>
<li>子网划分</li>
<li>OSI model 和 TCP/IP model的异同点</li>
<li>不归零、曼彻斯特、差分曼彻斯特编码</li>
<li>2010年第四题 DTBATF</li>
</ul>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p><strong>名词解释</strong></p>
<ul>
<li>HTML<ul>
<li>超文本标记语言，用来编写网页</li>
</ul>
</li>
<li>CIDR<ul>
<li>无类别域间路由，不区分A,B,C类地址，可以将多个路由合并成一条路由，从而减少路由表中的路由条目，以减轻路由器的负担</li>
</ul>
</li>
<li>ISP<ul>
<li>互联网服务提供商，向广大用户综合提供互联网接入业务、信息业务和增值业务的电信运营商</li>
</ul>
</li>
<li>URL<ul>
<li>统一资源定位符，对可以从因特网上得到的资源的位置和访问方法的一种简洁表示</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>PPP</li>
<li>SMTP</li>
<li>ICMP</li>
<li>ARP</li>
</ul>
</blockquote>
<p><strong>简答</strong></p>
<ul>
<li>一些经典原题</li>
</ul>
<ol>
<li>if you have a PC installed an Eternet NIC(IP address 192.168.100.4) and want to visit the web station 202.119.32.102, describe the process of getting appropriate MAC address by using transparent gateway.<ul>
<li>give the Source MAC, Destination MAC, Source IP, Destination Ip in each key frame transferred.</li>
</ul>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230706225752625.png" alt="image-20230706225752625"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>源MAC</th>
<th>目标MAC</th>
<th>源IP</th>
<th>目标IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AA</td>
<td>BB</td>
<td>192.168.100.4</td>
<td>202.119.32.102</td>
</tr>
<tr>
<td>2</td>
<td>CC</td>
<td>DD</td>
<td>192.168.100.4</td>
<td>202.119.32.102</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>已知UDP报头的16进制表示： 0c 32 00 35 00 1c e1 46<ul>
<li>源端口？目的端口？<ul>
<li>3122, 53</li>
</ul>
</li>
<li>报文内容长度？<ul>
<li>28字节</li>
</ul>
</li>
<li>服务端还是客户端发的？<ul>
<li>客户端</li>
</ul>
</li>
<li>应该问的是服务类型，就是端口号是哪种服务的，比如80代表HTTP<ul>
<li>DNS</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p><strong>单选</strong></p>
<p>1-5 DBACB</p>
<p>6-10 DDCBC</p>
<p>11-15 ABCCD</p>
<p><strong>多选</strong></p>
<ol>
<li>ABD</li>
<li>ACD</li>
<li>AE</li>
<li>EF</li>
<li>BCE</li>
<li>BC</li>
<li>AD</li>
<li>ABD</li>
</ol>
<p><strong>名词解释</strong></p>
<ul>
<li>CSMA/CA<ul>
<li>载波监听多点接入/碰撞避免, 发送站点在发送数据前，以控制短帧刺激接收站点发送应答短帧，使接收站点周围的站点监听到该帧，从而在一定时间内避免数据发送</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>PPP</li>
<li>RARP</li>
<li>ICMP</li>
<li>HTML</li>
<li>CIDR</li>
<li>CHAP</li>
<li>ISP</li>
</ul>
</blockquote>
<p><strong>简答</strong></p>
<ol>
<li><p>RIP</p>
</li>
<li><p>DTBATF</p>
</li>
<li><p>Briefly describe the process of displaying the home page after entering the url address in the browser for the first time. </p>
<ul>
<li>浏览器将URL地址发送到DNS服务器，以获取与该域名对应的IP地址。</li>
<li>DNS服务器返回域名对应的IP地址给浏览器。</li>
<li>浏览器使用获取到的IP地址建立与Web服务器的TCP连接。</li>
<li>浏览器向Web服务器发送HTTP请求，请求获取主页的内容。</li>
<li>Web服务器接收到请求后，将主页文件作为HTTP响应发送回浏览器。</li>
<li>浏览器接收到HTTP响应后，开始解析响应的内容，将主页显示在用户的浏览器窗口中。</li>
</ul>
</li>
<li><p>划分子网</p>
</li>
<li><p>001101101010，NRZ, 曼，差分</p>
</li>
<li><p>Given that the hexadecimal number of UDP header is 06 32 00 35 00 1C E2 17. </p>
<p>Answer the following questions. (8 marks)</p>
<p>(1) The source port number and the destination port number？</p>
<ul>
<li>1586，53</li>
</ul>
<p>(2) The length of the user datagram？</p>
<ul>
<li>28</li>
</ul>
<p>(3) Is the message sent by a client or a server?</p>
<ul>
<li>客户端</li>
</ul>
<p>(4) Which kind of network service does the message involve?</p>
<ul>
<li>DNS</li>
</ul>
</li>
</ol>
<h2 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h2><ul>
<li><p>无线LAN标准</p>
<ul>
<li>802.11a是5Ghz，802.11b是2.4GHz</li>
<li>802.11a最大 54Mbps，5GHz 工作频段。</li>
<li>802.11b最大 11Mbps，2.4GHz</li>
</ul>
</li>
<li><p>路由器</p>
<ul>
<li>RAM存储路由表啥的</li>
<li>NVRAM配置文件</li>
<li>FLASH存储IOS</li>
<li>ROM存储POST，引导程序，微型IOS</li>
</ul>
</li>
<li><p>首部格式</p>
<ul>
<li>TCP</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625115457283.png" alt="image-20220625115457283"></p>
<ul>
<li>UDP</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625162534854.png" alt="image-20220625162534854"></p>
<ul>
<li>IP</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625193904948.png" alt="image-20220625193904948"></p>
<ul>
<li>MAC帧</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220625195527702.png" alt="image-20220625195527702"></p>
</li>
<li><p>RIPV1与V2的区别</p>
<ul>
<li>V1是有类路由，V2是无类路由</li>
<li>V1不支持VLSM</li>
<li>V1是广播更新，V2是组播更新</li>
<li>V1是定时更新，V2是触发更新</li>
<li>V1不发送子网掩码，V2发送</li>
<li>V2具有较低的默认管理距离</li>
</ul>
</li>
<li><p>TCP拥塞控制</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220404205056363.png" alt="image-20220404205056363"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/互联网计算/">互联网计算</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/计网/">计网</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/06/12/软件系统设计-架构-7-微服务架构/"><span>软件系统设计-架构(7) 微服务架构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/06/12/软件系统设计-架构-7-微服务架构/" rel="bookmark">
        <time class="entry-date published" datetime="2023-06-12T11:52:54.000Z">
          2023-06-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="1-微服务架构基础知识"><a href="#1-微服务架构基础知识" class="headerlink" title="1. 微服务架构基础知识"></a>1. 微服务架构基础知识</h1><p>考其中某一个或某几个特性</p>
<h2 id="1-1-微服务架构"><a href="#1-1-微服务架构" class="headerlink" title="1.1 微服务架构"></a>1.1 微服务架构</h2><p><strong>概括性描述</strong></p>
<p>微服务架构是把应用程序<strong>功能性分解</strong>为一组服务的架构风格，每一个服务都是由一组<strong>专注、内聚</strong>的功能职责组成。</p>
<p><strong>定义</strong></p>
<p>微服务架构是一种将单体应用拆分为<strong>细粒度</strong>的服务，并使其运行在<strong>独立进程</strong>中，服务之间采用<strong>轻量级通信机制</strong>(如HTTP RESTful API）进行交互的架构风格。这些服务<strong>围绕系统的业务能力构建</strong>，且可以通过全自动的部署机制进行<strong>独立部署</strong>。服务可以进行<strong>分布式管理</strong>，从而支持<strong>不同的编程语言</strong>进行开发和<strong>不同的数据存储技术</strong>进行存储</p>
<h2 id="1-2-主要特性"><a href="#1-2-主要特性" class="headerlink" title="1.2 主要特性"></a>1.2 主要特性</h2><h3 id="1-2-1-通过服务组件化"><a href="#1-2-1-通过服务组件化" class="headerlink" title="1.2.1 通过服务组件化"></a>1.2.1 通过服务组件化</h3><ul>
<li>组件：可以独立替换和升级的软件单元</li>
<li>进程内组件<ul>
<li>类、对象或库的形式</li>
<li>一般直接调用、以内存方式进行功能调用(共享内存）</li>
</ul>
</li>
<li>进程外组件<ul>
<li>微服务架构中的独立服务</li>
<li>实现组件化的方式是分解成服务</li>
<li>通过Web服务请求或RPC机制通信</li>
<li>轻量级消息传递机制(如RabbitMQ）</li>
<li>产生明确的组件发布接口，封装(区别于文档）</li>
<li>耦合度低，隔离性好、独立开发、部署</li>
<li>远程调用性能损耗、合适的API粒度</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-围绕业务能力组织"><a href="#1-2-2-围绕业务能力组织" class="headerlink" title="1.2.2 围绕业务能力组织"></a>1.2.2 围绕业务能力组织</h3><ul>
<li><strong>传统软件系统开发管理通常聚焦在技术层面</strong><ul>
<li>UI团队、服务逻辑团队、数据库团队…</li>
<li>跨团队的沟通、交接和预算审批等</li>
</ul>
</li>
<li><strong>采用围绕业务能力的划分方法</strong><ul>
<li>服务业务领域内的宽栈实现</li>
<li>团队跨职能、全方位开发技能</li>
<li>如用户体验、数据库、项目管理…</li>
</ul>
</li>
<li><strong>采用产品开发模式</strong><ul>
<li>传统：项目模式, 开发-维护，开发完解散</li>
<li>开发团队负责软件的整个产品周期</li>
<li>持续关注软件如何帮助用户提升业务能力，实现价值交付</li>
</ul>
</li>
</ul>
<h3 id="1-2-3-内聚和解耦"><a href="#1-2-3-内聚和解耦" class="headerlink" title="1.2.3 内聚和解耦"></a>1.2.3 内聚和解耦</h3><ul>
<li><strong>内聚：单一职责，有各自的领域逻辑</strong></li>
<li><strong>解耦：微服务间尽量减少直接依赖，独立自治</strong><ul>
<li>服务边界的确定(划分）有助于澄清和强化分离</li>
<li>业务功能分解：每个微服务负责独立的业务能力</li>
<li>领域驱动设计：通用领域划分为多个子域，识别限界上下文(Bounded Context）- 服务边界</li>
</ul>
</li>
</ul>
<h3 id="1-2-4-去中心化"><a href="#1-2-4-去中心化" class="headerlink" title="1.2.4 去中心化"></a>1.2.4 去中心化</h3><ul>
<li><strong>去中心化治理</strong><ul>
<li>构建微服务时可以有服务自己的技术栈选择</li>
<li>服务之间只需约定接口，无需关注内部实现</li>
<li>运维只需了解服务部署规范</li>
</ul>
</li>
<li><strong>去中心化数据存储</strong><ul>
<li>让每个微服务管理自己的数据库</li>
<li>或同一数据库技术的不同实例</li>
<li>或完全不同的数据库系统</li>
</ul>
</li>
<li><strong>去中心化数据管理</strong><ul>
<li>传统架构采用事务保证数据一致性，分布式微服务架构中数据管理困难</li>
<li>强调服务间的无事务协作，最终一致性和补偿策略</li>
<li>需权衡更大一致性的业务损失与修复错误的代价</li>
</ul>
</li>
</ul>
<h3 id="1-2-5-基础设施自动化"><a href="#1-2-5-基础设施自动化" class="headerlink" title="1.2.5 基础设施自动化"></a>1.2.5 基础设施自动化</h3><ul>
<li>依赖自动化的基础设施，降低开发和运维微服务的操作复杂度</li>
<li>持续部署和交付：编码、管理代码库、集成(构建、测试、打包）、部署、监控和运维</li>
<li>测试：单元测试、集成测试、组件化测试、契约测试和端到端测试等</li>
</ul>
<h3 id="1-2-6-服务设计与演进"><a href="#1-2-6-服务设计与演进" class="headerlink" title="1.2.6 服务设计与演进"></a>1.2.6 服务设计与演进</h3><ul>
<li><strong>高可用设计</strong><ul>
<li>容忍服务失败，客户端须尽可能有效地做出响应</li>
<li>完善的监控和日志记录，架构元素或业务指标、链路追踪</li>
<li>快速发现不良突发行为并尽早修复</li>
</ul>
</li>
<li><strong>演进式设计</strong><ul>
<li>传统架构软件变更难以预测且改造成本高昂</li>
<li>合理设计实现频繁、快速且控制良好的增量变更和演化</li>
<li>合适的服务解耦，只需重新部署修改的服务</li>
<li>变更频率不同，拆分(相同，合并）</li>
<li>架构适应度函数(Architectural fitness function）</li>
</ul>
</li>
</ul>
<h1 id="2-微服务架构核心设计模式"><a href="#2-微服务架构核心设计模式" class="headerlink" title="2. 微服务架构核心设计模式"></a>2. 微服务架构核心设计模式</h1><p>对某一个问题的理解：上下文，需求约束，模式，模式间的关系…</p>
<h2 id="2-1-微服务架构拆分模式"><a href="#2-1-微服务架构拆分模式" class="headerlink" title="2.1 微服务架构拆分模式"></a>2.1 微服务架构拆分模式</h2><h3 id="2-1-1-问题：如何将应用拆分为微服务"><a href="#2-1-1-问题：如何将应用拆分为微服务" class="headerlink" title="2.1.1 问题：如何将应用拆分为微服务?"></a>2.1.1 问题：如何将应用拆分为微服务?</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul>
<li>高内聚：实现一组密切相关的功能</li>
<li>松耦合：封装内部细节，API交互</li>
<li>单一职责原则(SRP）</li>
<li>共同封闭原则(CCP）</li>
<li>双披萨团队开发</li>
<li>团队自治</li>
</ul>
<h4 id="模式1：根据业务能力进行服务拆分"><a href="#模式1：根据业务能力进行服务拆分" class="headerlink" title="模式1：根据业务能力进行服务拆分"></a>模式1：根据业务能力进行服务拆分</h4><ul>
<li>为企业产生价值的商业活动<ul>
<li>保险：承保、理赔管理、账务管理等</li>
<li>FTGO：供应商、消费者、订单获取和执行、记账管理</li>
</ul>
</li>
<li>业务能力可分解：顶级能力和子能力</li>
<li>能力层次结构中各级别能力映射到服务中</li>
</ul>
<p>结果：</p>
<ul>
<li>内聚和解耦</li>
<li>能力与服务的映射具有主观性</li>
<li>过多的进程间通信导致重新分解或组合</li>
</ul>
<p>相关模式：</p>
<ul>
<li>根据子域进行服务拆分</li>
</ul>
<h4 id="模式2：根据子域进行服务拆分"><a href="#模式2：根据子域进行服务拆分" class="headerlink" title="模式2：根据子域进行服务拆分"></a>模式2：根据子域进行服务拆分</h4><ul>
<li>领域驱动设计DDD核心：子域和限界上下文</li>
<li>领域：描述应用程序问题域的术语(包含子领域）</li>
<li>拆分过程：<ul>
<li>分析业务</li>
<li>识别子领域(领域模型）</li>
<li>子领域模型边界(限界上下文、微服务边界）</li>
<li>订单获取、餐馆管理、配送、记账等</li>
</ul>
</li>
</ul>
<p>结果：</p>
<ul>
<li>高内聚和松耦合</li>
<li>单独的领域模型来消除上帝类</li>
<li>领域模型由团队独立开发、支持团队自治</li>
</ul>
<p>相关模式：</p>
<ul>
<li>根据业务能力进行服务拆分</li>
</ul>
<h2 id="2-2-微服务架构通信模式"><a href="#2-2-微服务架构通信模式" class="headerlink" title="2.2 微服务架构通信模式"></a>2.2 微服务架构通信模式</h2><h3 id="2-2-1-问题：同步通信中如何避免由于服务故障或网络中断所引起的故障蔓延到其他服务？"><a href="#2-2-1-问题：同步通信中如何避免由于服务故障或网络中断所引起的故障蔓延到其他服务？" class="headerlink" title="2.2.1 问题：同步通信中如何避免由于服务故障或网络中断所引起的故障蔓延到其他服务？"></a>2.2.1 问题：同步通信中如何避免由于服务故障或网络中断所引起的故障蔓延到其他服务？</h3><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><ul>
<li>微服务，分布式，进程间调用</li>
<li>服务请求可能面临局部故障(故障/停机/过载）</li>
<li>同步通信客户端等待响应被阻塞，蔓延</li>
</ul>
<h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><ul>
<li>处理网络超时/无响应服务的能力</li>
<li>限制客户端向服务器发出请求的数量</li>
<li>决定如何从失败的远程服务中恢复</li>
</ul>
<h4 id="模式：断路器-Circuit-Breaker"><a href="#模式：断路器-Circuit-Breaker" class="headerlink" title="模式：断路器(Circuit Breaker)"></a>模式：断路器(Circuit Breaker)</h4><ul>
<li>服务客户端应通过代理调用远程服务(类似于电路断路器)</li>
<li>闭合状态：对程序的请求的直接引起方法调用</li>
<li>断开状态：对程序的请求会立即返回错误响应</li>
<li>半断开状态：当连续失败的次数超过阈值时<ul>
<li>超时期限内，所有调用远程服务的尝试都将立即失败</li>
<li>超时到期后，断路器允许有限数量的测试请求通过</li>
<li>如果这些请求成功，断路器将恢复正常运行</li>
<li>否则，如果出现故障，超时期限将重新开始</li>
</ul>
</li>
</ul>
<p>结果</p>
<ul>
<li>防止不断地尝试执行可能会失败的操作</li>
<li>使程序能够诊断错误是否已经修正，进而再次尝试调用操作</li>
</ul>
<p>相关模式</p>
<ul>
<li>API网关模式、服务器端服务发现模式</li>
</ul>
<h3 id="2-2-2-问题：服务的客户端-包括API网关或者其它服务）如何在网络上发现服务实例的位置？"><a href="#2-2-2-问题：服务的客户端-包括API网关或者其它服务）如何在网络上发现服务实例的位置？" class="headerlink" title="2.2.2 问题：服务的客户端(包括API网关或者其它服务）如何在网络上发现服务实例的位置？"></a>2.2.2 问题：服务的客户端(包括API网关或者其它服务）如何在网络上发现服务实例的位置？</h3><h4 id="上下文-1"><a href="#上下文-1" class="headerlink" title="上下文"></a>上下文</h4><ul>
<li>不同微服务之间通常需要进程间调用</li>
<li>在传统的分布式系统部署下，服务在固定且已知的位置(主机与端口）运行，从而确保各服务可利用 REST 或 RPC 机制进行相互调用</li>
<li>微服务通常在虚拟化或者容器化环境中运行，服务实例数量和位置动态变化</li>
</ul>
<h4 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h4><ul>
<li>每一服务实例的特定位置(主机与端口）信息</li>
<li>服务端实例的具体数量及位置动态变化信息</li>
<li>虚拟机与容器分配的动态IP地址信息</li>
<li>服务实例的数量信息的(EC自动伸缩组会根据负载情况随时调整实例数量）</li>
</ul>
<h4 id="模式1：应用层服务发现模式"><a href="#模式1：应用层服务发现模式" class="headerlink" title="模式1：应用层服务发现模式"></a>模式1：应用层服务发现模式</h4><ul>
<li>自注册：服务实例调用服务注册表的注册 API 来注册其网络位置的(服务注册表定期调用心跳 API）</li>
<li>客户端发现：客户端查询服务注册表以获取服务实例的列表(缓存+负载均衡，提高性能）</li>
</ul>
<p>结果：</p>
<ul>
<li>相较于服务器端服务发现，其活动部件与网络中转数量更少</li>
<li>需要为应用中使用的每种编程语言/框架建立客户端服务发现逻辑，例如Netflix Prana 为非 JVM 客户端提供了一套基于 HTTP 代理的服务发现方案</li>
<li>客户端与服务注册表相耦合</li>
<li>开发者负责设置和管理服务注册表，分散精力</li>
</ul>
<p>相关模式：</p>
<ul>
<li>替代模式：平台层服务发现模式</li>
</ul>
<h4 id="模式2：平台层服务发现模式"><a href="#模式2：平台层服务发现模式" class="headerlink" title="模式2：平台层服务发现模式"></a>模式2：平台层服务发现模式</h4><ul>
<li>第三方注册：由第三方负责(注册服务器，通常是部署平台的一部分）处理注册，而不是服务本身向服务注册表注册自己。</li>
<li>服务端发现：客户端无需查询服务注册表，而是向 DNS 名称发出请求，对该 DNS 名称的请求被解析到路由器，路由器查询服务注册表并对请求进行负载均衡。</li>
</ul>
<p>结果：</p>
<ul>
<li>完全交给部署平台，服务端、客户端代码减负</li>
<li>多语言支持度较高</li>
<li>存在平台约束</li>
<li>相较于客户端服务发现，需要更多的网络跳转</li>
</ul>
<p>相关模式：</p>
<ul>
<li>替代模式：应用层服务发现模式</li>
</ul>
<h3 id="2-2-3-问题：如何处理外部客户端与服务之间的通讯？"><a href="#2-2-3-问题：如何处理外部客户端与服务之间的通讯？" class="headerlink" title="2.2.3 问题：如何处理外部客户端与服务之间的通讯？"></a>2.2.3 问题：如何处理外部客户端与服务之间的通讯？</h3><h4 id="上下文-2"><a href="#上下文-2" class="headerlink" title="上下文"></a>上下文</h4><ul>
<li>多个版本客户端需要开发多个适配的用户界面</li>
<li>产品信息通过API访问</li>
<li>数据分布在多项服务之间</li>
</ul>
<h4 id="需求-3"><a href="#需求-3" class="headerlink" title="需求"></a>需求</h4><ul>
<li>微服务通常提供的是细粒度API，客户端需要同多项服务进行交互</li>
<li>不同客户端需要不同的数据(桌面浏览器版本通常较复杂）</li>
<li>不同客户端的网络性能亦有所区别(移动网络速度更慢）。服务器端 Web 应用能够向后端服务发送多条请求，不会影响用户体验，但移动客户端则只能发送少量请求</li>
<li>服务实例数量与其位置(主机与端口）会发生动态变化</li>
<li>服务的划分方式会随时间的推移而改变，且不应被客户端所感知</li>
</ul>
<h4 id="模式1：API-Gateway模式"><a href="#模式1：API-Gateway模式" class="headerlink" title="模式1：API Gateway模式"></a>模式1：API Gateway模式</h4><ul>
<li>实现一个服务，外部 API 客户端进入基于微服务应用的入口点(类似于外观模式）</li>
<li>部分请求会被直接代理/路由至对应的服务</li>
<li>部分请求则需要接入多项服务</li>
<li>针对不同客户端提供不同的 API</li>
</ul>
<p>结果：</p>
<ul>
<li>确保客户端无法察觉应用程序是如何被拆分为多项微服务的</li>
<li>确保客户端不受服务实例的位置的影响</li>
<li>为每套客户端提供最优API</li>
<li>降低请求/往返次数</li>
<li>将从客户端调用多项服务的逻辑转换为从API网关处调用，从而简化整个客户端</li>
<li>API组合、协议转换和边缘功能，身份验证等</li>
<li>问题：复杂性、性能和可扩展性、局部故障等</li>
</ul>
<p>相关模式：</p>
<ul>
<li>后续模式：断路器模式、服务发现模式</li>
</ul>
<h4 id="模式2：后端前置模式"><a href="#模式2：后端前置模式" class="headerlink" title="模式2：后端前置模式"></a>模式2：后端前置模式</h4><ul>
<li>为每种类型的客户端实现单独的API Gateway</li>
<li>针对不同客户端提供不同的API</li>
<li>现成产品或服务、自研</li>
</ul>
<p>结果：</p>
<ul>
<li>封装应用程序内部结构，减少交互次数</li>
<li>API组合、协议转换和边缘功能，身份验证等</li>
<li>解决API Gateway职责不明确问题</li>
<li>API模块彼此隔离、可独立扩展、减少启动时间</li>
</ul>
<p>相关模式：</p>
<ul>
<li>替代模式：API Gateway模式</li>
</ul>
<h2 id="2-3-微服务架构部署模式"><a href="#2-3-微服务架构部署模式" class="headerlink" title="2.3 微服务架构部署模式"></a>2.3 微服务架构部署模式</h2><h3 id="2-3-1-问题：如何部署？"><a href="#2-3-1-问题：如何部署？" class="headerlink" title="2.3.1 问题：如何部署？"></a>2.3.1 问题：如何部署？</h3><h4 id="上下文-3"><a href="#上下文-3" class="headerlink" title="上下文"></a>上下文</h4><ul>
<li>微服务架构包含一组服务</li>
<li>每个服务都部署为一组服务实例，以实现吞吐量和可用性</li>
</ul>
<h4 id="需求-4"><a href="#需求-4" class="headerlink" title="需求"></a>需求</h4><ul>
<li>服务使用各种语言、框架和框架版本编写</li>
<li>需要快速构建、独立部署和扩展服务</li>
<li>服务实例需相互隔离</li>
<li>需要监控每个服务实例的行为、部署可靠</li>
<li>需限制服务消耗的资源(CPU和内存）</li>
<li>尽可能经济高效地部署应用程序</li>
</ul>
<h4 id="模式1：单主机部署多个服务实例"><a href="#模式1：单主机部署多个服务实例" class="headerlink" title="模式1：单主机部署多个服务实例"></a>模式1：单主机部署多个服务实例</h4><ul>
<li>资源需求冲突的风险</li>
<li>在主机(物理机或虚拟机）上运行不同服务的多个实例。</li>
<li>有多种方法可以在共享主机上部署服务实例，包括：<ul>
<li>将每个服务实例部署为一个 JVM 进程。例如，每个服务实例一个 Tomcat 或 Jetty 实例。</li>
<li>在同一个 JVM 中部署多个服务实例。例如，作为 Web 应用程序或 OSGI 包。</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>资源利用率相对较高</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源需求冲突的风险</li>
<li>依赖版本冲突的风险</li>
<li>难以限制服务实例消耗的资源</li>
<li>在同一个进程中部署多个服务实例，很难监控每个服务实例的资源消耗，也不可能隔离每个实例</li>
</ul>
<p>相关模式：</p>
<ul>
<li>替代模式：单主机部署单个服务实例</li>
</ul>
<h4 id="模式2：单主机部署多个服务实例"><a href="#模式2：单主机部署多个服务实例" class="headerlink" title="模式2：单主机部署多个服务实例"></a>模式2：单主机部署多个服务实例</h4><ul>
<li>在自己的主机上部署单个服务实例</li>
</ul>
<p>优点：</p>
<ul>
<li>服务实例彼此隔离</li>
<li>不存在资源需求或依赖版本冲突的可能性</li>
<li>一个服务实例最多只能消耗单个主机的资源</li>
<li>监控、管理和重新部署每个服务实例非常简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>与单主机部署多个服务实例模式相比，资源利用效率可能较低，因为主机更多</li>
</ul>
<p>相关模式：</p>
<ul>
<li>替代模式：单主机部署多个服务实例、无服务器部署</li>
<li>特化模式：将服务部署到虚拟机、将服务部署到容器</li>
</ul>
<h4 id="模式3：将服务部署到虚拟机"><a href="#模式3：将服务部署到虚拟机" class="headerlink" title="模式3：将服务部署到虚拟机"></a>模式3：将服务部署到虚拟机</h4><ul>
<li>将服务打包为虚拟机镜像，并将每个服务实例部署为单独的 VM</li>
<li>比如 Netflix 部署流水线将每个服务打包为一个 EC2 AMI(包含服务运行所需要的所有内容）</li>
<li>运行时每个服务实例是该镜像实例化的虚拟机，如 EC2 实例</li>
<li>EC2 弹性负栽均衡器(Elastic Load Balancer)将请求路由到对应的实例</li>
</ul>
<p>优点：</p>
<ul>
<li>通过增加实例数量来扩展服务很简单。Amazon Autoscaling Groups 可以根据负载自动执行此操作</li>
<li>VM 封装了用于构建服务的技术细节，例如所有服务都以完全相同的方式启动和停止</li>
<li>每个服务实例都是隔离的</li>
<li>VM 对服务实例消耗的 CPU 和内存施加限制</li>
<li>AWS 等 IaaS 解决方案为部署和管理虚拟机提供了成熟且功能丰富的基础设施，如弹性负载均衡器、自动缩放组</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源利用效率较低(整台虚拟机）</li>
<li>部署速度相对较慢(分钟级）</li>
<li>系统管理的额外开销(操作系统、运行补丁）</li>
</ul>
<p>相关模式：</p>
<ul>
<li>替代模式：将服务部署到容器</li>
<li>泛化模式：单主机部署单个服务实例</li>
</ul>
<h4 id="模式4：将服务部署到容器"><a href="#模式4：将服务部署到容器" class="headerlink" title="模式4：将服务部署到容器"></a>模式4：将服务部署到容器</h4><ul>
<li>将服务打包为 (Docker) 容器镜像并将每个服务实例部署到容器<ul>
<li>容器是一种更现代、更轻量级的部署机制，操作系统级的虚拟化机制</li>
<li>容器由在隔离的沙箱中运行的一个或多个进程组成，多个容器通常在一台机器上运行，容器共享操作系统</li>
<li>从在容器中运行的进程的角度来看，它就好像在自己的机器上运行一样，有独立IP、可消除端口冲突</li>
<li>使用 Docker 编排框架指定并协调容器资源，如 Kubernetes、Marathon/Mesos、Amazon EC2 Container Service</li>
</ul>
</li>
<li>部署过程：<ul>
<li>构建Docker镜像：在构建时，部署流水线使用容器镜像构建工具，该工具读取服务代码和镜像描述，以创建容器镜像并将其存储在镜像仓库中。</li>
<li>运行Docker镜像：在运行时，从镜像仓库中拉取容器镜像，并用于创建容器。</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>通过更改容器实例的数量可以直接扩展和缩减服务</li>
<li>容器封装了用于构建服务的技术细节，所有服务都以完全相同的方式启动和停止</li>
<li>每个服务实例都是隔离的</li>
<li>容器对服务实例消耗的 CPU 和内存施加限制</li>
<li>容器的构建和启动速度非常快<ul>
<li>将应用程序打包为 Docker 容器比将其打包为 AMI 快 100 倍</li>
<li>Docker 容器启动速度明显快于 VM(仅启动应用程序进程而非整个操作系统）</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>大量的容器镜像管理工作(操作系统补丁、基础设施）</li>
<li>部署容器的基础设施不如部署虚拟机的基础设施丰富</li>
</ul>
<p>相关模式：</p>
<ul>
<li>替代模式：将服务部署到虚拟机</li>
<li>泛化模式：单主机部署单个服务实例</li>
</ul>
<blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230613000504170.png" alt="image-20230613000504170"></p>
</blockquote>
<h4 id="模式5：服务部署平台"><a href="#模式5：服务部署平台" class="headerlink" title="模式5：服务部署平台"></a>模式5：服务部署平台</h4><ul>
<li>使用部署平台作为应用程序部署的自动化基础设施</li>
<li>提供服务抽象(一组命名的、高度可用的服务实例）<ul>
<li>Docker 编排框架，包括 Docker swarm 模式和 Kubernetes</li>
<li>无服务器平台，例如 AWS Lambda</li>
<li>PaaS，包括 Cloud Foundry 和 AWS Elastic Beanstalk</li>
</ul>
</li>
<li>Docker编排框架将运行Docker的一组计算机转变为资源集群，将容器分配给机器，提供<strong>资源管理、调度、服务管理</strong>功能</li>
</ul>
<p>相关模式：</p>
<ul>
<li>后续模式：将服务部署到虚拟机、将服务部署容器、无服务器部署</li>
</ul>
<blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230613000421999.png" alt="image-20230613000421999"></p>
</blockquote>
<h4 id="模式6：无服务器部署"><a href="#模式6：无服务器部署" class="headerlink" title="模式6：无服务器部署"></a>模式6：无服务器部署</h4><ul>
<li>使用公有云提供的 serverless 部署机制部署服务</li>
<li>部署细节对用户隐藏，用户和其组织不负责管理低级基础设施(无服务器概念）</li>
<li>基础设施获取服务代码并运行，根据消耗的资源为每个请求付费</li>
<li>需打包代码(例如ZIP），将其上传到部署基础设施</li>
<li>公有云serverless平台：AWS Lambda、Google Cloud Functions、Azure Functions</li>
<li>开源serverless框架：Apache Openwhisk、Fission on Kubernetes</li>
</ul>
<p>优点：</p>
<ul>
<li>AWS服务集成简单：AWS服务生成事件、AWS API Gateway处理HTTP请求的Lambda函数</li>
<li>消除系统管理任务：底层系统管理、操作系统或运行时打补丁，专注于开发应用程序</li>
<li>弹性伸缩：AWS Lambda运行应用程序所需的多个实例以动态处理负载</li>
<li>基于使用情况的定价：与典型的laaS云不同，AWS Lambda按请求所消耗的资源收费</li>
</ul>
<p>缺点：</p>
<ul>
<li>长尾延迟：AWS Lambda动态运行代码，需花费时间配置和启动应用，某些请求具有高延迟(Java服务通常需要至少几秒钟，不适合对延迟敏感的服务）</li>
<li>基于有限事件与请求的编程模型：不用于长时间运行的服务(使用第三方消息代理的消息服务）</li>
</ul>
<p>相关模式：</p>
<ul>
<li>替代模式：单主机部署单个服务实例</li>
</ul>
<blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230613000438644.png" alt="image-20230613000438644"></p>
</blockquote>
<h2 id="2-4-微服务架构可观测性模式"><a href="#2-4-微服务架构可观测性模式" class="headerlink" title="2.4 微服务架构可观测性模式"></a>2.4 微服务架构可观测性模式</h2><h3 id="2-4-0-上下文"><a href="#2-4-0-上下文" class="headerlink" title="2.4.0 上下文"></a>2.4.0 上下文</h3><ul>
<li>多台机器上、多个服务和服务实例</li>
<li>请求跨越多服务实例，每个服务通过执行一个或多个操作来处理请求</li>
<li>以标准化格式将操作信息写入日志文件，跟踪用户行为和代码异常</li>
<li>服务实例可能无法处理请求但仍在运行</li>
</ul>
<h3 id="2-4-1-问题：如何理解用户和应用程序的行为并解决问题？"><a href="#2-4-1-问题：如何理解用户和应用程序的行为并解决问题？" class="headerlink" title="2.4.1 问题：如何理解用户和应用程序的行为并解决问题？"></a>2.4.1 问题：如何理解用户和应用程序的行为并解决问题？</h3><h4 id="模式1：日志聚合模式"><a href="#模式1：日志聚合模式" class="headerlink" title="模式1：日志聚合模式"></a>模式1：日志聚合模式</h4><ul>
<li>使用集中式日志记录服务聚合来自每个服务实例的日志</li>
<li>用户可搜索和分析日志</li>
<li>可配置当某些消息出现在日志中时触发的警报</li>
<li>实例：AWS Cloud Watch, Logstash (ELK)</li>
</ul>
<p>需求：</p>
<ul>
<li>任何解决方案都应该具有最小的运行时开销</li>
</ul>
<p>缺点：</p>
<ul>
<li>处理大量日志需要大量的基础设施</li>
</ul>
<p>相关模式：</p>
<ul>
<li>分布式追踪、异常跟踪</li>
</ul>
<blockquote>
<p>日志记录的基础设施：</p>
<ul>
<li>ELK<ul>
<li>Elasticsearch：面向文本搜索的NoSQL数据库，用作日志记录服务器</li>
<li>Logstash：聚合服务日志并将其写入 Elasticsearch 的日志流水线</li>
<li>Kibana: Elasticsearch的可视化工具</li>
</ul>
</li>
<li>开源日志流水线包括 Fluentd 和 Apache Flume</li>
<li>商用如 AWS Cloud Watch Logs 等</li>
</ul>
</blockquote>
<h4 id="模式2：审计日志模式"><a href="#模式2：审计日志模式" class="headerlink" title="模式2：审计日志模式"></a>模式2：审计日志模式</h4><ul>
<li>向业务逻辑中添加审计日志代码</li>
<li>创建审核日志条目并保存在数据库中</li>
</ul>
<p>需求：</p>
<ul>
<li>了解用户最近执行了哪些操作，帮助支持、确保合规性、安全性和可疑行为等</li>
</ul>
<p>优点: </p>
<ul>
<li>提供用户操作的记录</li>
</ul>
<p>缺点：</p>
<ul>
<li>审计代码与业务逻辑交织，使业务逻辑复杂化</li>
</ul>
<p>相关模式：</p>
<ul>
<li>后续模式：事件溯源(实施审计的可靠方式）</li>
</ul>
<h4 id="模式3：应用程序指标模式"><a href="#模式3：应用程序指标模式" class="headerlink" title="模式3：应用程序指标模式"></a>模式3：应用程序指标模式</h4><ul>
<li>检测服务以收集有关各个操作的统计信息，在集中式指标服务中聚合指标，提供报告和警报。聚合指标两种模型：<ul>
<li>push - 服务将指标推送到指标服务</li>
<li>pull - 指标服务从服务中提取指标</li>
</ul>
</li>
<li>实例：Coda Hale/Yammer Java 指标库、Prometheus(普罗米修斯）、AWS Cloud Watch等</li>
</ul>
<p>需求：</p>
<ul>
<li>任何解决方案都应该具有最小的运行时开销</li>
</ul>
<p>优点: </p>
<ul>
<li>提供对应用程序行为的深入洞察</li>
</ul>
<p>缺点：</p>
<ul>
<li>指标代码与业务逻辑交织在一起，使其更加复杂</li>
<li>聚合指标可能需要大量的基础设施</li>
</ul>
<p>相关模式：其他可观测性模式</p>
<h4 id="模式4：分布式追踪模式"><a href="#模式4：分布式追踪模式" class="headerlink" title="模式4：分布式追踪模式"></a>模式4：分布式追踪模式</h4><ul>
<li>记录单次请求范围以内的信息</li>
<li>为每个外部请求分配一个唯一的外部请求 ID</li>
<li>并在提供可视化和分析的集中式服务器中记录请求如何从一个服务流向下一个服务</li>
<li>在所有日志消息中包含外部请求 ID</li>
<li>记录在集中服务中处理外部请求时执行的请求和操作的信息(例如开始时间、结束时间）</li>
</ul>
<p>需求：</p>
<ul>
<li>外部监控只报告总体响应时间和调用次数，无法深入了解各个操作</li>
<li>任何解决方案都应该具有最小的运行时开销</li>
<li>请求的日志条目分散在许多日志中</li>
</ul>
<p>实例</p>
<ul>
<li>Spring Cloud Sleuth - Spring Cloud 应用程序的分布式跟踪</li>
<li>Open Zipkin - 用于记录和显示跟踪信息的服务</li>
<li>Open Tracing - 用于分布式跟踪的标准化 API</li>
</ul>
<p>优点:</p>
<ul>
<li>提供了对系统行为的有用洞察，包括延迟的来源</li>
<li>使开发人员能够通过在聚合日志中搜索其外部请求 ID 来查看单个请求是如何处理的</li>
</ul>
<p>缺点：</p>
<ul>
<li>聚合和存储追踪数据可能需要大量的基础设施</li>
</ul>
<p>相关模式：</p>
<ul>
<li>日志聚合 - 外部请求 ID 包含在每个日志消息中</li>
</ul>
<h4 id="模式5：异常跟踪模式"><a href="#模式5：异常跟踪模式" class="headerlink" title="模式5：异常跟踪模式"></a>模式5：异常跟踪模式</h4><ul>
<li>向集中式异常跟踪服务报告所有异常，该服务聚合和跟踪异常并通知开发人员。</li>
<li>实例：Sentry Datadog、PagerDuty</li>
</ul>
<p>上下文：</p>
<ul>
<li>处理请求时有时会发生错误。发生错误时，服务实例会抛出异常，其中包含错误消息和堆栈跟踪</li>
</ul>
<p>需求：</p>
<ul>
<li>异常必须由开发人员去重、记录、调查并解决潜在问题</li>
<li>任何解决方案都应该具有最小的运行时开销</li>
</ul>
<p>优点：</p>
<ul>
<li>更容易查看异常并跟踪其解决方案</li>
</ul>
<p>缺点：</p>
<ul>
<li>异常跟踪服务是额外的基础设施</li>
</ul>
<p>相关模式：</p>
<ul>
<li>日志聚合 - 应记录异常并报告给跟踪服务</li>
</ul>
<h3 id="2-4-2-问题：如何检测正在运行的服务实例无法处理请求？"><a href="#2-4-2-问题：如何检测正在运行的服务实例无法处理请求？" class="headerlink" title="2.4.2 问题：如何检测正在运行的服务实例无法处理请求？"></a>2.4.2 问题：如何检测正在运行的服务实例无法处理请求？</h3><h4 id="需求-5"><a href="#需求-5" class="headerlink" title="需求"></a>需求</h4><ul>
<li>当服务实例失败时应生成警报，请求应该被路由到正常工作的服务实例</li>
</ul>
<h4 id="模式：健康检查API模式"><a href="#模式：健康检查API模式" class="headerlink" title="模式：健康检查API模式"></a>模式：健康检查API模式</h4><ul>
<li>服务具有 /health 返回服务健康状况的健康检查 API 端点(实例Spring Boot Actuator），执行检查：<ul>
<li>服务实例使用的基础设施服务的连接状态</li>
<li>主机的状态，例如磁盘空间</li>
<li>应用程序特定逻辑</li>
</ul>
</li>
<li>监控服务、服务注册表或负载均衡可以定期 “ping” 调用端点来检查服务实例的健康状况</li>
<li>使用 Spring Boot 和 Spring Cloud 作为微服务框架</li>
<li>提供健康检查端点，由 Spring Boot Actuator 模块实现</li>
<li>配置调用 /health 可扩展健康检查逻辑的 HTTP 端点。</li>
</ul>
<p>优点：</p>
<ul>
<li>定期测试服务实例的健康状况</li>
</ul>
<p>缺点：</p>
<ul>
<li>不够全面</li>
<li>服务实例可能在健康检查之间失败</li>
</ul>
<p>相关模式：</p>
<ul>
<li>前置模式：服务注册与发现模式、部署相关模式</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/软件系统设计/">软件系统设计</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件架构/">软件架构</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/06/12/软件系统设计-架构-6-评估架构/"><span>软件系统设计-架构(6) 评估架构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/06/12/软件系统设计-架构-6-评估架构/" rel="bookmark">
        <time class="entry-date published" datetime="2023-06-12T11:25:04.000Z">
          2023-06-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-架构流程-Architecture-Process"><a href="#1-架构流程-Architecture-Process" class="headerlink" title="1. 架构流程 Architecture Process"></a>1. 架构流程 Architecture Process</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192726697.png" alt="image-20230612192726697"></p>
<h3 id="1-1-为什么要评估架构-Why-to-evaluate-architecture"><a href="#1-1-为什么要评估架构-Why-to-evaluate-architecture" class="headerlink" title="1.1 为什么要评估架构 Why to evaluate architecture?"></a>1.1 为什么要评估架构 Why to evaluate architecture?</h3><ol>
<li>大型项目经常延迟交付和超出预算 Large projects often delivered late and over-budget<ol>
<li>由于设计失败而无法及时交付 Don’t function as promised due to design failures</li>
<li>商业组件不能按照预期运行 COTS components don’t work as expected</li>
</ol>
</li>
<li>项目后期需要大量的返工 Considerable rework often required late in project<ol>
<li>团队成员没有讨论这个问题 Team members not communicated the issues?</li>
<li>团队成员中缺少可以尽早发现问题的专家 Team members lacking expertise to detect problems early?</li>
<li>有代价 Costly</li>
</ol>
</li>
<li>架构评估有助于缓解这些问题 Architecture evaluations help alleviate these problems<ol>
<li>彻底评估商业组件的稳定性 Thoroughly assess COTS component suitability</li>
<li>在问题变的需要一定代价去修复前识别发现问题 Identify problems before they become costly to fix</li>
<li>通知管理层，以方便他们做出更好的决策 Inform management so they can make better decisions</li>
</ol>
</li>
<li>在问题修复代价还比较低时尽早定位问题 Locate problems early when they are cheap to fix<ol>
<li>设计缺陷 Design faults</li>
<li>没有考虑到的商业组件行为 Unexpected COTS components behavior</li>
<li>商业组件对整体系统架构不匹配 Mismatch of COTS components to overall architecture</li>
</ol>
</li>
<li>传播架构/设计最佳实践 Disseminate architecture/design best practices<ol>
<li>评估者是可以发现最佳实践的专家 Reviewers are experts, can capture best practices</li>
<li>评估者拥有不同项目的广阔视野 Reviewers have broad perspective across many projects</li>
</ol>
</li>
<li>提供更好的技术和项目信息给管理层 Provide management with better technical and project information</li>
<li>确定通过培训可以对常见问题领域产生广泛影响的领域 Identify areas where training could provide broad impact on commonly recurring problem areas</li>
<li>改善与商业组件供应商的互动 Improve interactions with COTS component suppliers</li>
</ol>
<h3 id="1-2-什么时候需要评估架构呢？When-to-evaluate-an-architecture"><a href="#1-2-什么时候需要评估架构呢？When-to-evaluate-an-architecture" class="headerlink" title="1.2 什么时候需要评估架构呢？When to evaluate an architecture?"></a>1.2 什么时候需要评估架构呢？When to evaluate an architecture?</h3><ol>
<li>期望获得 Acquisition<ol>
<li>选择不合适的商业组件时的最小风险 Minimize risks of choosing inappropriate COTS components</li>
<li>涉及收购方和供应商(有明显的警告) Involve acquirers and vendors (with obvious caveats:-})</li>
</ol>
</li>
<li>演化/升级 Evolution/Upgrade<ol>
<li>评估变化的影响 Assess impact of changes</li>
</ol>
</li>
<li>设计 Design<ol>
<li>新架构适合需求的早期”验证” Early ‘validation’ that the new architecture is suitable for requirements</li>
</ol>
</li>
<li>构建 Build<ol>
<li>实际架构是否按预期构建 Is actual architecture built as intended</li>
<li>它是否被很好的构建 Is it built ‘well?</li>
</ol>
</li>
<li>总是尽早地进行评估 Always evaluate early!!!</li>
</ol>
<h3 id="1-3-为什么要尽早评估架构-Why-evaluate-architecture-early"><a href="#1-3-为什么要尽早评估架构-Why-evaluate-architecture-early" class="headerlink" title="1.3 为什么要尽早评估架构 Why evaluate architecture early?"></a>1.3 为什么要尽早评估架构 Why evaluate architecture early?</h3><ol>
<li>架构评估需要尽早完成因为 Architecture evaluation should be done early because:<ol>
<li>还有时间来修复 there is time for correction</li>
<li>修复错误的决定的成本相对比较小 correcting wrong decision is relatively inexpensive</li>
<li>它是最有效的质量保证和风险缓解技术之一 it is one of the most effective quality assurance and risk mitigation techniques</li>
<li>这被认为是一种良好的商业惯例 it is considered a good commercial practice</li>
</ol>
</li>
<li>早期质量评估具有成本效益（AT&amp;T：生产力提高 10%/1991 年项目）- 最近，通过及早发现和解决问题，在 100,000 行(不含注释)的系统上节省了 100 万美元 Early quality evaluation is cost effective (AT&amp;T: 10% productivity increase/project 1991) - Lately, $1 million savings on systems of 100,000 non-commentary LOC by detecting and resolving problems early</li>
<li>存在相互竞争的要求；必须根据业务目标及早做出决定 There are competing requirements; decisions must be made early according to business goals</li>
<li>架构设计决策的基本原理应该被捕获和推理 Rationale for architecture design decisions should be captured and reasoned about</li>
</ol>
<h3 id="1-4-如何评估软件架构-How-to-evaluate-software-architecture"><a href="#1-4-如何评估软件架构-How-to-evaluate-software-architecture" class="headerlink" title="1.4 如何评估软件架构 How to evaluate software architecture?"></a>1.4 如何评估软件架构 How to evaluate software architecture?</h3><ol>
<li>评估架构的系统方法需要一种有助于提出正确问题的方法 A systematic approach to evaluate architecture needs a method that helps ask right questions<ol>
<li>来发现风险 to discover risks</li>
<li>来识别错误的架构决定 to identify wrong architectural choices</li>
<li>确保质量问题得到解决 to ensure quality issues have been addressed</li>
</ol>
</li>
<li>这里有很多用来评估软件架构的方法 There are a number of methods to evaluate software architecture:<ol>
<li>Software Architecture Analysis Method (SAAM)</li>
<li>Architecture Level Modifiability Analysis (ALMA)</li>
<li>Performance Assessment of Software Architecture (PASA)</li>
<li>Architecture Trade-off Analysis Method (ATAM)</li>
</ol>
</li>
<li>所有这些方法都是基于场景的方法，因为质量属性是使用场景定义的 All these methods are scenario-based approaches as quality attributes are defined using scenarios</li>
<li>场景被映射到架构组件上，以评估架构能力，以满足所需的质量属性 Scenarios are mapped on architectural components to evaluate architectural capability to fulfill desired quality attributes</li>
</ol>
<h3 id="1-5-一个方法为什么会有用？How-can-a-method-be-helpful"><a href="#1-5-一个方法为什么会有用？How-can-a-method-be-helpful" class="headerlink" title="1.5 一个方法为什么会有用？How can a method be helpful!?"></a>1.5 一个方法为什么会有用？How can a method be helpful!?</h3><ol>
<li>它可以帮助涉众尽早问正确的问题来：It helps stakeholders ask right questions early to:<ol>
<li>识别风险：可能对所需质量属性产生负面影响的架构决策<br>Identify risks: Architectural decisions that may negatively affect desired quality attributes</li>
<li>发现敏感点：特定质量属性对其敏感的架构决策<br>Find sensitivity points: Architecture decisions to which a particular quality attribute is sensitive to</li>
<li>发现<strong>权衡</strong>：影响多个质量属性的架构决策<br>Discover tradeoffs: Architecture decision that affect more than one quality attribute</li>
</ol>
</li>
<li>发现趋势：架构决策与系统属性预测之间的相关性 Find trends: correlation between architectural decisions and predictions of system properties</li>
<li>可以通过进一步分析、设计或原型制作来减轻风险 Efforts can be directed to mitigate the found risks by further analysis, design or prototyping</li>
<li>所做的权衡和支持它们的理由可以适当地记录下来以备将来参考 Tradeoffs made and rationale underpinning them can appropriately be documented for future reference</li>
</ol>
<h3 id="1-6-评价分析方法-Analysis-Methods-for-Evaluation"><a href="#1-6-评价分析方法-Analysis-Methods-for-Evaluation" class="headerlink" title="1.6 评价分析方法 Analysis Methods for Evaluation"></a>1.6 评价分析方法 Analysis Methods for Evaluation</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612193355339.png" alt="image-20230612193355339"></p>
<h3 id="1-7-评估格式-Evaluate-Forms"><a href="#1-7-评估格式-Evaluate-Forms" class="headerlink" title="1.7 评估格式 Evaluate Forms"></a>1.7 评估格式 Evaluate Forms</h3><ol>
<li>由<strong>设计师</strong>在设计过程中评估 Evaluation by designers within the design process<ol>
<li>“生成-测试”方法 “generate-and-test” approach</li>
</ol>
</li>
<li>由<strong>同行</strong>在设计过程中评估 Evaluation by peers within the design process<ol>
<li>审查者确定许多质量属性方案来推动审查。The reviewers determine a number of quality attribute scenarios to drive the review.</li>
<li>架构师介绍要评估的架构部分 The architect presents the portion of the architecture to be evaluated.</li>
<li>对于每个场景，设计人员都会遍历架构并解释如何满足场景。For each scenario, the designer walks through the architecture and explains how the scenario is satisfied.</li>
<li>潜在的问题被捕获。Potential problems are captured.</li>
</ol>
</li>
<li>架构设计完成后由<strong>外部人员</strong>进行评估 Evaluation by outsiders once the architecture has been designed</li>
</ol>
<h2 id="2-ATAM：架构权衡分析方法-ATAM：Architecture-Tradeoff-Analysis-Method"><a href="#2-ATAM：架构权衡分析方法-ATAM：Architecture-Tradeoff-Analysis-Method" class="headerlink" title="2. ATAM：架构权衡分析方法 ATAM：Architecture Tradeoff Analysis Method"></a>2. ATAM：架构权衡分析方法 ATAM：Architecture Tradeoff Analysis Method</h2><p>ATAM方法分为4个阶段完成</p>
<h3 id="2-1-阶段0：伙伴与准备-Phase-0-Partnership-amp-Preparation"><a href="#2-1-阶段0：伙伴与准备-Phase-0-Partnership-amp-Preparation" class="headerlink" title="2.1 阶段0：伙伴与准备 Phase-0: Partnership &amp; Preparation"></a>2.1 阶段0：伙伴与准备 Phase-0: Partnership &amp; Preparation</h3><ol>
<li>参与者：评估团队领导和关键项目决策者 Participants: evaluation team leadership and key project decision makers</li>
<li>输入：架构文档 Inputs: the architecture documentation</li>
<li>输出：评估计划 Outputs: the evaluation plan<ol>
<li><strong>谁？</strong>涉众的初步名单 Who? a preliminary list of stakeholders</li>
<li>逻辑：<strong>什么时候？什么地点和如何？</strong> Logistics: When? Where? and How?</li>
<li>什么时候评估报告被送给<strong>谁</strong>？When the evaluation report is to be delivered to whom?</li>
<li>评估报告中应该包含<strong>什么</strong>信息？What information to be included in the evaluation report?</li>
</ol>
</li>
</ol>
<h3 id="2-2-阶段1：评估-1-Phase-1-Evaluation-1"><a href="#2-2-阶段1：评估-1-Phase-1-Evaluation-1" class="headerlink" title="2.2 阶段1：评估(1) Phase-1: Evaluation (1)"></a>2.2 阶段1：评估(1) Phase-1: Evaluation (1)</h3><ol>
<li>参与者：评估团队和项目决策者 Participants: evaluation team and project decision makers</li>
<li>步骤1-6 Step 1-6</li>
<li>输出 Outputs:<ol>
<li>架构的简明介绍 a concise presentation of the architecture</li>
<li>业务目标（驱动因素）的阐述 articulation of the business goals (drivers)</li>
<li>作为场景实现的特定质量属性要求的优先列表 a prioritized list of specific quality attribute requlrements realized as scenarios</li>
<li>效用树 utility tree</li>
<li>风险和无风险 risks and nonrisks</li>
<li>敏感点和权衡点 sensitivity points and tradeoff points</li>
</ol>
</li>
</ol>
<h4 id="2-2-1-第一步：介绍ATAM-Step1-Present-the-ATAM"><a href="#2-2-1-第一步：介绍ATAM-Step1-Present-the-ATAM" class="headerlink" title="2.2.1 第一步：介绍ATAM Step1 - Present the ATAM"></a>2.2.1 第一步：介绍ATAM Step1 - Present the ATAM</h4><p>评估负责人向集合的项目代表（”决策者”）简要介绍 ATAM，让他们了解评估的过程和输出<br>The evaluation leader presents the ATAM in brief to assembled project representatives (‘decision makers’) for their understanding of the process and outputs of the evaluation</p>
<h4 id="2-2-2-第二步：介绍业务驱动因素-Step2-Present-the-Business-Drivers"><a href="#2-2-2-第二步：介绍业务驱动因素-Step2-Present-the-Business-Drivers" class="headerlink" title="2.2.2 第二步：介绍业务驱动因素 Step2 - Present the Business Drivers"></a>2.2.2 第二步：介绍业务驱动因素 Step2 - Present the Business Drivers</h4><p>项目经理或系统的客户从业务角度呈现系统概览，描述<br>Project manager or system’s customer presents a system overview from a business perspective, describing:</p>
<ol>
<li>它最重要的功能需求 its most important functional requirements</li>
<li>其技术、管理、经济或政治限制 its technical, managerial, economic, or political constraints</li>
<li>其商业目标和上下文 its business goals and context</li>
<li>其主要涉众 its major stakeholders</li>
<li>架构驱动因素（塑造架构的主要质量属性目标）the architectural drivers (major quality attribute goals that shape the architecture)</li>
</ol>
<h4 id="2-2-3-第三步：展示架构-Step3-Present-the-architecture"><a href="#2-2-3-第三步：展示架构-Step3-Present-the-architecture" class="headerlink" title="2.2.3 第三步：展示架构 Step3 - Present the architecture"></a>2.2.3 第三步：展示架构 Step3 - Present the architecture</h4><ol>
<li>首席架构师在适当的细节级别上进行了描述架构的演示：<br>The lead architect makes a presentation describing the architecture at an appropriate level of detail:<ol>
<li>技术限制，例如规定使用的操作系统、硬件或中间件 technical constraints such as an OS, hardware, or middleware prescribed for use</li>
<li>系统必须与之交互的其他系统 other systems with which the system must interact</li>
<li>用于满足质量属性要求的架构方法 architectural approaches used to meet quality attribute requirements</li>
</ol>
</li>
</ol>
<blockquote>
<p>架构演示（大约 20 张幻灯片；60 分钟）Architecture Presentation (Approximately 20 slides; 60 Minutes)</p>
<p>驱动架构需求、与这些需求相关的可测量数量，以及满足这些需求的任何现有标准/模型/方法（2-3 张幻灯片）Driving architectural requirements, the measurable quantities you associate with these requirements, and any existing standards/ models/ approaches for meeting these (2-3 slides)</p>
<p>重要的架构信息（4-8 张幻灯片）：Important architectural information (4-8 slides):</p>
<ol>
<li>语境图 - 系统在其存在的语境中。系统将与之交互的人类或其他系统。 Context diagram-the system within the context in which it will exist. Humans or other systems with which the system will interact.</li>
<li>模块或层视图 - 描述系统功能分解的模块（可以是子系统或层），以及填充这些的对象、过程、函数以及它们之间的关系（例如，过程调用、方法调用、回调，遏制）。Module or layer view- the modules (which may be subsystems or layers) that describe the system s decomposition of functionality, along with the objects, procedures, functions that populate these, and the relations among them (e.g, procedure call, method invocation, callback, containment).</li>
<li>组件和连接器视图进程、线程以及连接它们的同步、数据流和事件。Component-and-connector view-processes, threads along with the synchronization, data flow, and events that connect them.</li>
<li>部署视图 - CPU、存储、外部设备/传感器以及连接它们的网络和通信设备。 还显示了在各种处理器上执行的进程。Deployment view- CPUs, storage, external devices/ sensors along with the networks and communication devices that connect them. Also shown are the processes that execute on the various processors.</li>
</ol>
<p>采用的架构方法、模式或策略，包括它们解决的质量属性以及这些方法如何解决这些属性的描述（3-6 张幻灯片）：Architectural approaches, patterns, or tactics employed, including what quality attributes they address and a description of how the approaches address those attributes (3-6 slides):</p>
<ol>
<li>商业现货 (COTS) 产品的使用以及它们的选择/集成方式（1-2 张幻灯片）。Use of commercial off-the-shelf (COTS) products and how they are chosen/integrated (1-2 slides).</li>
<li>跟踪 1 到 3 个最重要的用例场景。 如果可能，包括每个场景消耗的运行时资源（1-3 张幻灯片）。Trace of 1 to 3 of the most important use case scenarios. If possible, include the runtime resources consumed for each scenario (1-3 slides).</li>
<li>跟踪 1 到 3 个最重要的变化场景。 如果可能，根据更改的模块或界面（1-3 张幻灯片）描述更改影响（更改的估计大小/难度） Trace of1 to 3 of the most important change scenarios. If possible, describe the change impact (estimated size/ difficulty of the change) in terms of the changed modules or interfaces (1-3 slides).</li>
<li>与满足驱动架构要求相关的架构问题/风险（2-3 张幻灯片）。Architectural issues/risks with respect to meeting the driving architectural requirements (2-3 slides).</li>
<li>词汇表（1张PPT）Glossary (1 slide).</li>
</ol>
</blockquote>
<h4 id="2-2-4-第四步：确定架构方法-Step4-Identify-Architectural-Approaches"><a href="#2-2-4-第四步：确定架构方法-Step4-Identify-Architectural-Approaches" class="headerlink" title="2.2.4 第四步：确定架构方法 Step4 - Identify Architectural Approaches"></a>2.2.4 第四步：确定架构方法 Step4 - Identify Architectural Approaches</h4><ol>
<li>ATAM 专注于通过理解架构方法来分析架构。ATAM focuses on analyzing an architecture by understanding its architectural approaches.</li>
<li>在这一步，评估团队：By this step, the evaluation team<ol>
<li>研究了架构文档 have studied the architecture documentation</li>
<li>听取了架构师的展示 have heard the architect’s presentation</li>
<li>向架构师询问了设计系统时使用的模式和策略 have asked the architect about patterns and tactics used in designing the system</li>
</ol>
</li>
<li>评估团队对已确定的架构方法（风格、模式和策略）进行编目。The evaluation team catalogs the architectural approaches (styles, patterns and tactics) that have been identified.</li>
</ol>
<h4 id="2-2-5-第五步：生成质量属性效用树-Step5-Generate-Quality-Attribute-Utility-Tree"><a href="#2-2-5-第五步：生成质量属性效用树-Step5-Generate-Quality-Attribute-Utility-Tree" class="headerlink" title="2.2.5 第五步：生成质量属性效用树 Step5 - Generate Quality Attribute Utility Tree"></a>2.2.5 第五步：生成质量属性效用树 Step5 - Generate Quality Attribute Utility Tree</h4><ol>
<li>这是指导其余分析的关键步骤。 This is a crucial step that guides the remainder of the analysis.</li>
<li>评估团队与项目决策者合作，确定、确定和优化系统最重要的质量属性目标。The evaluation team works with the project decision makers to identify, prioritize and refine the system’s most important quality attribute goals.</li>
<li>质量属性目标通过质量属性效用树详细阐述，该树通过精确定义相关质量属性需求使需求具体化。The quality attribute goals are articulated in detail via quality attribute utility tree that makes the requirements concrete by defining precisely the relevant quality attribute requirements.</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612194332541.png" alt="image-20230612194332541" style="zoom:80%;" /></p>
<h4 id="2-2-6-第六步：分析架构方法-Step6-Analyze-Architectural-Approaches"><a href="#2-2-6-第六步：分析架构方法-Step6-Analyze-Architectural-Approaches" class="headerlink" title="2.2.6 第六步：分析架构方法 Step6 - Analyze Architectural Approaches"></a>2.2.6 第六步：分析架构方法 Step6 - Analyze Architectural Approaches</h4><ol>
<li>目标是让评估团队确信该方法的实例化适合满足特定于属性的要求。The goal is for the evaluation team to be convinced that the instantiation of the approach is appropriate for meeting the attribute-specific requirements.</li>
<li>评估团队通过要求架构师解释架构如何相互支持，一次检查排名最高的场景（来自效用树）。The evaluation team examines that the highest-ranked scenarios(from the utility tree) one at a time by asking the architect to explain how the architecture supports each other.</li>
<li>评估团队记录相关的架构决策，并通过讨论识别和分类其风险、非风险、敏感点和权衡。The evaluation team documents the relevant architectural decisions and identifies and catalogs their risks, nonrisks, sensitivity points, and tradeoffs through a discussion.</li>
<li>分析是为了引出足够的架构信息，以在已经做出的架构决策和需要满足的质量属性之间建立某种联系。The analysis is to elicit sufficient architectural information to establish some link between the architectural decisions that have been made and quality attributes that need to be satisfied.</li>
<li>在这一步结束时，评估团队应该清楚地了解整个架构的最重要方面、关键设计决策的基本原理以及风险、非风险、敏感点和权衡点的列表。At the end of this step, the evaluation team should have a clear picture of the most important aspects of the entire architecture, the rationale for key design decisions, and a list of risks, nonrisks, sensitivity points, and tradeoff points.</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612194526912.png" alt="image-20230612194526912"></p>
<h4 id="2-2-7-ATAM-第-1-天的示例议程-Example-Agenda-for-Day-1-for-ATAM"><a href="#2-2-7-ATAM-第-1-天的示例议程-Example-Agenda-for-Day-1-for-ATAM" class="headerlink" title="2.2.7 ATAM 第 1 天的示例议程 Example Agenda for Day 1 for ATAM"></a>2.2.7 ATAM 第 1 天的示例议程 Example Agenda for Day 1 for ATAM</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612194601380.png" alt="image-20230612194601380"></p>
<h3 id="2-3-阶段2：评估-2-Phase-2-Evaluation-2"><a href="#2-3-阶段2：评估-2-Phase-2-Evaluation-2" class="headerlink" title="2.3 阶段2：评估(2) Phase-2: Evaluation (2)"></a>2.3 阶段2：评估(2) Phase-2: Evaluation (2)</h3><ol>
<li>参与者：评估团队，项目决策者和架构涉众 Participants: evaluation team, project decision makers, and architecture stakeholders</li>
<li>步骤(1) 7-9 Step (1) 7~9</li>
<li>输出：Outputs:<ol>
<li>涉众社区的优先场景列表 a list of prioritized scenarios from the stakeholder community</li>
<li>风险主题和业务驱动因素各自受到的威胁 risk themes and business drivers threatened by each one</li>
</ol>
</li>
</ol>
<h4 id="2-3-1-第一步：展示ATAM和之前的结果-Step-1-Present-the-ATAM-amp-Previous-Results"><a href="#2-3-1-第一步：展示ATAM和之前的结果-Step-1-Present-the-ATAM-amp-Previous-Results" class="headerlink" title="2.3.1 第一步：展示ATAM和之前的结果 Step-1: Present the ATAM &amp; Previous Results"></a>2.3.1 第一步：展示ATAM和之前的结果 Step-1: Present the ATAM &amp; Previous Results</h4><ol>
<li>重复步骤 1，以便涉众了解方法和他们将扮演的角色。 Step 1 is repeated so that the stakeholders understand the method and the roles they are to play.</li>
<li>评估负责人总结第 2 步到第 6 步的结果，并分享输出（效用树除外）。The evaluation leader recaps the results of steps 2 through 6, and shares the outputs (except the utility tree).</li>
</ol>
<h4 id="2-3-2-第七步：头脑风暴并确定场景的优先级-Step-7-Brainstorm-amp-Prioritize-Scenarios"><a href="#2-3-2-第七步：头脑风暴并确定场景的优先级-Step-7-Brainstorm-amp-Prioritize-Scenarios" class="headerlink" title="2.3.2 第七步：头脑风暴并确定场景的优先级 Step-7: Brainstorm &amp; Prioritize Scenarios"></a>2.3.2 第七步：头脑风暴并确定场景的优先级 Step-7: Brainstorm &amp; Prioritize Scenarios</h4><ol>
<li>此步骤的目的是把握更大的涉众社区的脉搏，以了解系统成功对他们意味着什么。The purpose of this step is to take the pulse of the larger stakeholder community to understand what system success means to them.</li>
<li>评估团队要求涉众集思广益，就其个人角色而言，在操作上有意义的场景。The evaluation team asks the stakeholders to brainstorm scenarios that are operationally meaningful with respect to their individual roles.</li>
<li>一旦收集了场景，就会要求涉众对他们认为代表行为或质量问题的场景进行优先级排序和合并。Once the scenarios have been collected, stakeholders are asked to prioritize and merge scenarios they feel represent the behavior or quality concern.</li>
<li>将优先场景列表与效用树中的场景进行比较。The list of prioritized scenarios is compared with those from the utility tree.</li>
<li>如果差异很大，则额外的情景可能被识别为风险。If the discrepancy is significant, the additional scenario may be identified as a risk.</li>
</ol>
<h4 id="2-3-3-第八步：分析架构方法-Step-8-Analyze-Architectual-Approaches"><a href="#2-3-3-第八步：分析架构方法-Step-8-Analyze-Architectual-Approaches" class="headerlink" title="2.3.3 第八步：分析架构方法 Step-8: Analyze Architectual Approaches"></a>2.3.3 第八步：分析架构方法 Step-8: Analyze Architectual Approaches</h4><ol>
<li>在此步骤中，评估团队执行与步骤 6 中相同的活动，使用排名最高的（例如前 5 到 10）但新生成的场景。In this step, the evaluation team performs the same activities as in Step 6, using the highest ranked (e.g. top 5 to 10), but newly generated scenarios.</li>
<li>架构师解释了相关的架构决策如何有助于实现每个决策。The architect explains how relevant architectural decisions contribute to realizing each one.</li>
</ol>
<h4 id="2-3-4-第九步：展示结果-Step-9-Present-Results"><a href="#2-3-4-第九步：展示结果-Step-9-Present-Results" class="headerlink" title="2.3.4 第九步：展示结果 Step-9: Present Results"></a>2.3.4 第九步：展示结果 Step-9: Present Results</h4><ol>
<li>评估团队根据共同的潜在问题或系统性缺陷将风险分组为风险主题。The evaluation team groups the risks into risk themes, based on common underlying concern or systemic deficiency.</li>
<li>然后，确定的风险主题与步骤 2 中列出的特定业务驱动因素相关。The identified risk themes are then related to specific business drivers listed in Step 2.</li>
<li>从评估中收集的信息被总结并呈现给所有涉众：The collected information from evaluation is summarized and presented to all stakeholders:<ol>
<li>记录的架构方法 The architectural approaches documented</li>
<li>集思广益的场景集及其优先级 The set of scenarios and their prioritization from brainstorming</li>
<li>实用树 The utility tree</li>
<li>发现的风险和记录的非风险 The risks discovered and nonrisks documented</li>
<li>发现的敏感因素和权衡因素 The sensitivity points and tradeoff points found</li>
<li>风险主题和受威胁的业务驱动因素 Risk themes and the business drivers threatened by each one</li>
</ol>
</li>
</ol>
<h3 id="2-4-阶段3：后续-Phase-3-Follow-up"><a href="#2-4-阶段3：后续-Phase-3-Follow-up" class="headerlink" title="2.4 阶段3：后续 Phase-3: Follow-up"></a>2.4 阶段3：后续 Phase-3: Follow-up</h3><ol>
<li>参与者：评估团队和主要涉众(评估客户) Participants: evaluation team and key stakeholders (evaluation clients)</li>
<li>输出：最终评估报告 Outputs: the final evaluation report</li>
<li>评估团队制作一份书面最终报告，分发给主要涉众以供审核。The evaluation team produces a written final report that is circulated to key stakeholders for revlew.</li>
<li>审查结束后，将报告提交给委托评估的人。After the review, the report is delivered to whom commissioned the evaluation.</li>
</ol>
<h3 id="2-5-ATAM阶段总结-Summary-of-ATAM-phases"><a href="#2-5-ATAM阶段总结-Summary-of-ATAM-phases" class="headerlink" title="2.5 ATAM阶段总结 Summary of ATAM phases"></a>2.5 ATAM阶段总结 Summary of ATAM phases</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612195042921.png" alt="image-20230612195042921"></p>
<h3 id="2-6-ATAM输出总结-Summary-of-ATAM-Outputs"><a href="#2-6-ATAM输出总结-Summary-of-ATAM-Outputs" class="headerlink" title="2.6 ATAM输出总结 Summary of ATAM Outputs"></a>2.6 ATAM输出总结 Summary of ATAM Outputs</h3><ol>
<li>架构的简明展示 A concise presentation of the architecture</li>
<li>业务目标的阐述 Articulation of the business goals</li>
<li>表示为质量属性场景的优先质量属性要求 Prioritized quality attribute requirements expressed as quality attribute scenarios</li>
<li>效用树 A utility tree</li>
<li>一组风险和非风险 A set of risks and nonrisks</li>
<li>一组风险主题 A set of riskthemes</li>
<li>将架构决策映射到质量要求 Mapping of architectural decisions to quality requirements</li>
<li>一组确定的敏感度和权衡点 A set of identified sensitivity and tradeoff points</li>
<li>最终的评估报告 Final evaluation report</li>
</ol>
<h3 id="2-7-轻量级架构评估-Lightweight-Architecture-Evaluation"><a href="#2-7-轻量级架构评估-Lightweight-Architecture-Evaluation" class="headerlink" title="2.7 轻量级架构评估 Lightweight Architecture Evaluation"></a>2.7 轻量级架构评估 Lightweight Architecture Evaluation</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612195204456.png" alt="image-20230612195204456"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/软件系统设计/">软件系统设计</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件架构/">软件架构</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/06/12/软件系统设计-架构-5-记录架构/"><span>软件系统设计-架构(5) 架构文档化</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/06/12/软件系统设计-架构-5-记录架构/" rel="bookmark">
        <time class="entry-date published" datetime="2023-06-12T08:38:00.000Z">
          2023-06-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-架构文档化-Documenting-Architecture"><a href="#1-架构文档化-Documenting-Architecture" class="headerlink" title="1. 架构文档化 Documenting Architecture"></a>1. 架构文档化 Documenting Architecture</h2><h3 id="1-1-为什么要记录软件架构？-Why-to-document-software-architecture"><a href="#1-1-为什么要记录软件架构？-Why-to-document-software-architecture" class="headerlink" title="1.1 为什么要记录软件架构？ Why to document software architecture?"></a>1.1 为什么要记录软件架构？ Why to document software architecture?</h3><ol>
<li>这是记录软件架构的几个很好的理由，例如：There are several good reasons for documenting software architecture such as:<ol>
<li>交流和社交化架构设计决策 Communicating and socialising architecture design decisions</li>
<li>帮助理解和评估架构设计决策 Helping understand and assess architecture designdecisions</li>
<li>刷新设计师对某些决策的记忆 Refreshing designers’ memories about certain decisions</li>
<li>培训架构设计人员 Training people in designing architecture</li>
<li>支持地理位置分散的团队 Supporting geographically ditributed teams</li>
</ol>
</li>
<li>架构文档用于以下活动：Architecture documentation is used for several activities:<ol>
<li>架构设计分析 Architecture design analysis.</li>
<li>工作分解和分配 Work breakdown and assignment.</li>
<li>部署后维护 Post-deployment maintenance.</li>
</ol>
</li>
<li>软件架构文档提供了维护和修改决策的框架 Software architecture documentation provides a framework for maintenance and modification decisions.</li>
</ol>
<h3 id="1-2-记录架构的挑战-Challenges-in-documenting-architecture"><a href="#1-2-记录架构的挑战-Challenges-in-documenting-architecture" class="headerlink" title="1.2 记录架构的挑战 Challenges in documenting architecture"></a>1.2 记录架构的挑战 Challenges in documenting architecture</h3><ol>
<li><strong>没有</strong>普遍接受的记录软件架构的<strong>标准</strong>或方法。No universally accepted standard or method of documenting software architecture.</li>
<li>记录大型系统的架构可能是一项<strong>耗时</strong>且重要的任务。 Documenting architecture of large-scale system can be time consuming and non-trivial task.</li>
<li>对用于记录架构的视图的<strong>数量和性质没有达成共识</strong> - 资源密集型活动。No consensus on the number and nature ofviews used to document architecture - resource intensive activity.</li>
<li>迫在眉睫的最后期限和不断发展的架构性质不利于架构文档的流通。Looming deadlines and evolving nature of architecture are detrimental to the currency of architecture documentation.</li>
<li>缺乏全面的<strong>符号和工具</strong>。Absence of a comprehensive notation and tooling.</li>
</ol>
<h3 id="1-3-记录什么-What-to-document"><a href="#1-3-记录什么-What-to-document" class="headerlink" title="1.3 记录什么? What to document?"></a>1.3 记录什么? What to document?</h3><ol>
<li>许多值得记录的事情，例如：Many things worth of documenting such as:<ol>
<li>组件<strong>接口</strong>和<strong>依赖项</strong> Component interfaces and dependencies</li>
<li>子系统<strong>约束</strong> Subsystems constraints</li>
<li><strong>测试场景</strong> Test scenarios</li>
<li>围绕设计决策的<strong>上下文</strong>信息 Contextual information surrounding design decisions</li>
</ol>
</li>
<li>有几个因素会影响对记录内容的决定 Several factors affect the decision of what to document:<ol>
<li>被记录的架构的<strong>复杂性</strong> Complexity of the architecture being documented</li>
<li>应用程序的<strong>寿命</strong> Longevity of an application</li>
<li>基于<strong>涉众</strong>对文档的预期使用 Based on the expected use of documentation by stakeholders</li>
</ol>
</li>
</ol>
<h3 id="1-4-架构文档的-7-条规则-7-Rules-for-Architecture-Documentation"><a href="#1-4-架构文档的-7-条规则-7-Rules-for-Architecture-Documentation" class="headerlink" title="1.4 架构文档的 7 条规则 7 Rules for Architecture Documentation"></a>1.4 架构文档的 7 条规则 7 Rules for Architecture Documentation</h3><ol>
<li>从<strong>读者的角度</strong>撰写文档 Write documentation from the reader’s point of view</li>
<li>避免没有意义的<strong>重复</strong> Avoid unnecessary repetition.</li>
<li>避免<strong>模糊性</strong> Avoid ambiguity.</li>
<li>使用<strong>标准</strong>的文档组织方式 Use a standard organization.</li>
<li>记录<strong>理由</strong> Record rationale.</li>
<li>保持文档<strong>最新</strong>但不要太最新 Keep documentation current but not too current</li>
<li><strong>审查</strong>文件是否适合<strong>用途</strong> Review documentation for fitness of purpose</li>
</ol>
<h2 id="2-视图-Views"><a href="#2-视图-Views" class="headerlink" title="2. 视图 Views"></a>2. 视图 Views</h2><h3 id="2-1-Styles-and-Views-样式和视图"><a href="#2-1-Styles-and-Views-样式和视图" class="headerlink" title="2.1 Styles and Views 样式和视图"></a>2.1 Styles and Views 样式和视图</h3><h4 id="2-1-1-三类风格-Three-Categories-of-Styles"><a href="#2-1-1-三类风格-Three-Categories-of-Styles" class="headerlink" title="2.1.1 三类风格 Three Categories of Styles"></a>2.1.1 三类风格 Three Categories of Styles</h4><ol>
<li>模块风格: 它是如何构建为一组实现单元的？How it is structured as a set of implementation units? Module styles</li>
<li>组件连接器 (C&amp;C) 风格: 它是如何构建为一组具有运行时行为和交互的元素的？How it is structured as a set of elements that have runtime behavior and interactions? Component-connector(C&amp;C) styles</li>
<li>分配风格: 它与环境中的非软件结构有何关系？How it relates to non-software structures in its environment? Allocation style</li>
</ol>
<h4 id="2-1-2-架构风格-和-架构模式-Styles-Vs-Patterns"><a href="#2-1-2-架构风格-和-架构模式-Styles-Vs-Patterns" class="headerlink" title="2.1.2 架构风格 和 架构模式 Styles Vs. Patterns"></a>2.1.2 架构风格 和 架构模式 Styles Vs. Patterns</h4><ol>
<li><strong>架构风格</strong>是元素和关系类型的特殊化，以及关于如何使用它们的一组约束 An architecture style is a <em>“specialization of element and relation types, together with a set of constraints on how they can be used”</em> (Bass, Clements, and Kazman 2003)</li>
<li><strong>架构模式</strong>表达了软件系统的基本结构组织模式 An architecture pattern <em>“expresses a fundamental structural organization schema for software systems”</em> (Buschmann et al. 1996)</li>
<li>架构模式的一个重要部分是关注问题和上下文，以及如何在该上下文中解决问题。An essential part of an architecture pattern is its focus on the problem and context as well as how to solve the problem in that context.</li>
<li>架构风格侧重于架构方法，对特定风格何时有用或无用提供更轻量级的指导。An architecture style focuses on the architecture approach, with more lightweight guidance on when a particular style may or may not be useful.</li>
<li>架构模式：{问题，上下文} —&gt; 架构方法<br>Architecture pattern: {problem, context} —&gt; architecture approach</li>
<li>架构风格：架构方式 Architecture style: architecture approach</li>
<li>风格描述通常不包括详细的问题/上下文信息；架构模式可以。A style description does not generally include detailed problem/context information; architecture patterns do.</li>
<li>微服务知识定义了element，和element通过什么方式进行交互。</li>
</ol>
<h4 id="2-1-3-架构视图-Architectural-Views"><a href="#2-1-3-架构视图-Architectural-Views" class="headerlink" title="2.1.3 架构视图 Architectural Views"></a>2.1.3 架构视图 Architectural Views</h4><ol>
<li>视图是一组系统元素和它们之间关系的表示——不是所有的系统元素，而是特定类型的那些元素 A view is a representation of a set of system elements and relations among them - not all system elements, but those of a particular type.</li>
<li>视图让我们将系统的实体划分为有趣且易于管理的系统表示 Views let us divide the system’s entity into interesting and manageable representations of the system.</li>
<li>不同的视图支持不同的目标和用户，突出不同的系统元素和关系 Different views support different goals and users, and highlight different system elements and relations</li>
<li>不同的视图在不同程度上暴露了不同的质量属性。Different views expose different quality attributes to different degrees.</li>
</ol>
<h3 id="2-2-结构视图-Structural-Views"><a href="#2-2-结构视图-Structural-Views" class="headerlink" title="2.2 结构视图 Structural Views"></a>2.2 结构视图 Structural Views</h3><h4 id="2-2-1-模块视图-Module-Views"><a href="#2-2-1-模块视图-Module-Views" class="headerlink" title="2.2.1 模块视图 Module Views"></a>2.2.1 模块视图 Module Views</h4><ol>
<li>模块是提供一组连贯职责的实现单元 A module is an implementation unit that provides a coherent set of responsibility.</li>
<li>没有至少一个模块视图，任何软件架构的文档都不可能是完整的 It is unlikely that the documentation of any software architecture can be complete without at least one module view.</li>
<li><p>视图示例</p>
<ol>
<li>分解视图 Decomposition view</li>
<li>使用视图 Uses view</li>
<li>泛化视图 Generalization view</li>
<li>分层视图 Layered view</li>
<li>领域视图 Aspects View</li>
<li>数据模型视图 Data model view</li>
</ol>
</li>
<li><p>Summary of Module Views</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612185439945.png" alt="image-20230612185439945"></p>
<h4 id="2-2-2-组件连接器视图-Component-Connector-Views"><a href="#2-2-2-组件连接器视图-Component-Connector-Views" class="headerlink" title="2.2.2 组件连接器视图 Component-Connector Views"></a>2.2.2 组件连接器视图 Component-Connector Views</h4><ol>
<li>组件和连接器视图显示具有某些<strong>运行时存在</strong>的元素，例如进程、对象、客户端、服务器和数据存储（称为”组件”）。<br> Component-and-connector views show elements that have some runtime presence, e.g, processes, objects, clients, servers, and data stores (being termed ‘components).</li>
<li>附件指示哪些连接器连接到哪些组件 Attachments indicate which connectors are attached to which components.</li>
<li>通过将连接器的端点连接到组件的端口来显示附件。Attachment is shown by connecting the endpoints of the connector to the ports of components.</li>
<li><p>视图示例</p>
<ol>
<li>管道和过滤器视图 Pipe-and-filter view</li>
<li>客户端-服务器视图 Client-server view</li>
<li>点对点视图 Peer-to-peer view</li>
<li>面向服务的架构 (SOA) 视图 Service-oriented architecture (SOA) view</li>
<li>发布订阅视图 Publish-subscribe view</li>
<li>共享数据视图 Shared-data view</li>
<li>多层视图 Multi-tier view</li>
</ol>
</li>
<li><p>Summary of C&amp;C Views</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612185747350.png" alt="image-20230612185747350"></p>
<h4 id="2-2-3-分配视图-Allocation-Views"><a href="#2-2-3-分配视图-Allocation-Views" class="headerlink" title="2.2.3 分配视图 Allocation Views"></a>2.2.3 分配视图 Allocation Views</h4><ol>
<li>分配视图描述了软件单元到软件开发或执行环境元素的映射 Allocation views describe the mapping of software units to elements of an environment in which the software is developed or in which it executes.</li>
<li>分配视图的通常目标是将软件元素所需的属性与环境元素提供的属性进行比较，以确定分配是否成功 The usual goal of an allocation view is to compare the properties required by the software element with the properties provided by the environmental elements to determine whether the allocation will be successful or not.</li>
<li>分配视图可以描绘静态或动态视图 Allocation views can depict static or dynamic views</li>
<li>视图实例<ol>
<li>部署视图 Deployment view</li>
<li>安装视图 Install view</li>
<li>工作分配视图 Work assignment view</li>
<li>其他分配视图 Other allocation views</li>
</ol>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612190702523.png" alt="image-20230612190702523" style="zoom:80%;" /></p>
<ol>
<li>Summary of Allocation Views</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612190315504.png" alt="image-20230612190315504"></p>
<h3 id="2-3-质量视图-Quality-Views"><a href="#2-3-质量视图-Quality-Views" class="headerlink" title="2.3 质量视图 Quality Views"></a>2.3 质量视图 Quality Views</h3><ol>
<li>安全视图 Security view</li>
<li>性能视图 Performance view</li>
<li>可靠性视图 Reliability view</li>
<li>沟通视图 Communication View</li>
<li>异常(错误处理)视图 Exception view (error-handling) view</li>
</ol>
<h3 id="2-4-文档化视图-Documenting-Views"><a href="#2-4-文档化视图-Documenting-Views" class="headerlink" title="2.4 文档化视图 Documenting Views"></a>2.4 文档化视图 Documenting Views</h3><h4 id="2-4-1-使用-3-步选择视图-3-Step-for-Choosing-Views"><a href="#2-4-1-使用-3-步选择视图-3-Step-for-Choosing-Views" class="headerlink" title="2.4.1 使用 3 步选择视图 3-Step for Choosing Views"></a>2.4.1 使用 3 步选择视图 3-Step for Choosing Views</h4><p>步骤 1：构建<strong>涉众/视图表</strong> Step-1: Build a stakeholder/view table</p>
<p>步骤 2：<strong>合并视图</strong> Step-2: Combine views</p>
<ul>
<li><p>2.1: 识别上表中的边缘视图<br>2.1: Identify marginal views in the above table</p>
</li>
<li><p>2.2: 通过关联一个视图中的元素和另一个视图中的元素，将每个边缘视图与另一个具有更强选区的视图相结合<br>2.2: Combine each marginal views with another view with stronger constituency by associating between elements in one view and elements in the other</p>
</li>
</ul>
<p>步骤 3：确定优先级和阶段 Step-3: Prioritize and stage</p>
<ul>
<li>分解视图 decomposition view</li>
<li>80/20原则 80/20 principle</li>
<li>按顺序完成所有视图？complete all views in sequence?</li>
</ul>
<h4 id="2-4-2-涉众和文档-Stakeholder-and-Documentation"><a href="#2-4-2-涉众和文档-Stakeholder-and-Documentation" class="headerlink" title="2.4.2 涉众和文档 Stakeholder and Documentation"></a>2.4.2 涉众和文档 Stakeholder and Documentation</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191431955.png" alt="image-20230612191431955"></p>
<h4 id="2-4-3-涉众视图表-Stackholder-View-Table"><a href="#2-4-3-涉众视图表-Stackholder-View-Table" class="headerlink" title="2.4.3 涉众视图表 Stackholder-View Table"></a>2.4.3 涉众视图表 Stackholder-View Table</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191448333.png" alt="image-20230612191448333"></p>
<ul>
<li>上图中每一个格子是指涉众对某一个部分的细节了解程度。</li>
</ul>
<h3 id="2-5-组合视图-Combining-Views"><a href="#2-5-组合视图-Combining-Views" class="headerlink" title="2.5 组合视图 Combining Views"></a>2.5 组合视图 Combining Views</h3><ol>
<li>各种 C&amp;C 视图 Various C&amp;C view</li>
<li>带有 SOA 或通信进程视图的部署视图 Deployment view with either SOA or communicating- process Views</li>
<li>分解视图和任何工作分配、实施、使用或分层视图 Decomposition view and any of work assignment, implementation, uses, or layered views</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191540749.png" alt="image-20230612191540749"></p>
<ul>
<li>使用一张视图说明整个系统的部署信息</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191553295.png" alt="image-20230612191553295"></p>
<ul>
<li>描述了component之间的关系</li>
</ul>
<h3 id="2-6-视图模板-View-Template"><a href="#2-6-视图模板-View-Template" class="headerlink" title="2.6 视图模板 View Template"></a>2.6 视图模板 View Template</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191632502.png" alt="image-20230612191632502"></p>
<ol>
<li>第1部分：主要介绍 Section-1: The Primary Presentation<ol>
<li>显示视图的元素和关系 shows the elements and relations of the view</li>
<li>通常是带有键的图形 often graphical with a key</li>
</ol>
</li>
<li>第2部分：<strong>元素目录</strong> Section-2: The <strong>Element Catalog</strong><ol>
<li>详细介绍了第1节中描述的元素。details the elements depicted in Sect.1</li>
<li>元素及其属性 Elements and their properties</li>
<li>关系及其属性 Relations and their properties</li>
<li>元素接口和行为 Element interfaces and behavior</li>
</ol>
</li>
<li>第3部分：<strong>上下文图</strong> Section-3: <strong>Context Diagram</strong><ol>
<li>系统或其部分如何与其环境相关 how the system or its portion relates to its envlronment</li>
</ol>
</li>
<li>第4部分：<strong>可变性</strong>指南 Section-4: <strong>Variability</strong> Guide<ol>
<li>如何在此视图中练习架构的任何变化点 how to exercise any variation points of the architecture in this view</li>
</ol>
</li>
<li>第5部分：<strong>解释</strong> Section-5: <strong>Rationale</strong><ol>
<li>为什么设计反映在视图中 why the design reflected in the view</li>
<li>提供了一个令人信服的论据，证明它是合理的。 provides a convincing argument that it is sound.</li>
</ol>
</li>
</ol>
<h4 id="2-6-1-上下文图-Context-Diagram"><a href="#2-6-1-上下文图-Context-Diagram" class="headerlink" title="2.6.1 上下文图 Context Diagram"></a>2.6.1 上下文图 Context Diagram</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191909970.png" alt="image-20230612191909970"></p>
<h2 id="3-超越（超越视图的信息）Beyond-Information-Beyond-Views"><a href="#3-超越（超越视图的信息）Beyond-Information-Beyond-Views" class="headerlink" title="3. 超越（超越视图的信息）Beyond(Information Beyond Views)"></a>3. 超越（超越视图的信息）Beyond(Information Beyond Views)</h2><h3 id="3-1-视图之外的文档-Documentation-Beyond-Views"><a href="#3-1-视图之外的文档-Documentation-Beyond-Views" class="headerlink" title="3.1 视图之外的文档 Documentation Beyond Views"></a>3.1 视图之外的文档 Documentation Beyond Views</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192030553.png" alt="image-20230612192030553"></p>
<p>第1部分：文档路线图说明文档中的信息以及在哪里可以找到它 Section-1: Documentation Roadmap tells what in formation is in the documentation and where to find it</p>
<ol>
<li>范围和总结 Scope and summary</li>
<li>文档的组织方式 How the documentation is organized<ol>
<li>简短的概要 short synopsis</li>
<li>带注释的目录 annotated table of contents</li>
</ol>
</li>
<li>查看概览 View overview</li>
<li>利益相关者如何使用文档 How stakeholders can use the documentation</li>
</ol>
<h3 id="3-2-文档控制信息-Document-Control-information"><a href="#3-2-文档控制信息-Document-Control-information" class="headerlink" title="3.2 文档控制信息 Document Control information"></a>3.2 文档控制信息 Document Control information</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192054456.png" alt="image-20230612192054456"></p>
<h3 id="3-3-Mapping-between-Views"><a href="#3-3-Mapping-between-Views" class="headerlink" title="3.3 Mapping between Views"></a>3.3 Mapping between Views</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192257861.png" alt="image-20230612192257861"></p>
<h3 id="3-4-Documentation-Package"><a href="#3-4-Documentation-Package" class="headerlink" title="3.4 Documentation Package"></a>3.4 Documentation Package</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192317391.png" alt="image-20230612192317391"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/软件系统设计/">软件系统设计</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件架构/">软件架构</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/05/25/Java-8函数式编程/"><span>Java 8函数式编程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/05/25/Java-8函数式编程/" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-25T02:55:49.000Z">
          2023-05-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>内容来自《Java 8函数式编程》</p>
</blockquote>
<h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><h3 id="1-1-匿名内部类与Lambda表达式"><a href="#1-1-匿名内部类与Lambda表达式" class="headerlink" title="1.1 匿名内部类与Lambda表达式"></a>1.1 匿名内部类与Lambda表达式</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匿名内部类</span><br>button.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActionListener</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent event)</span> &#123;<br>    	System.out.println(<span class="hljs-string">&quot;button clicked&quot;</span>);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// Lambda表达式</span><br>button.addActionListener(event -&gt; System.out.println(<span class="hljs-string">&quot;button clicked&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>匿名内部类：</p>
<ul>
<li><p>实现了 ActionListener 接口。这个接口只有一个方法 <code>actionPerformed</code>。匿名内部类实现了该方法。</p>
</li>
<li><p>但是匿名内部类不够简便，样板代码，可读性很差，我们<strong>不想传入对象，只想传入行为</strong>。</p>
</li>
</ul>
<p>Lambda 表达式：</p>
<ul>
<li><p>上述代码也可以改写为 Lambda 表达式</p>
</li>
<li><p>event 是参数名，和上面匿名内部类示例中的是同一个参数。-&gt; 将参数和 Lambda 表达式的主体分开，而主体是用户点击按钮时会运行的一些代码</p>
</li>
<li><p>Lambda 表达式中无需指定类型，程序依然可以编译。这是因为 javac 根据程序的上下文(<code>addActionListener</code> 方法的签名)在后台推断出了参数 event 的类型。这意味着如果参数类型不言而明，则无需显式指定。</p>
</li>
</ul>
<blockquote>
<p>为了增加可读性并迁就我们的习惯，声明参数时也可以包括类型信息，而且有时编译器不一定能根据上下文推断出参数的类型！</p>
</blockquote>
<h3 id="1-2-几种Lambda表达式的变体"><a href="#1-2-几种Lambda表达式的变体" class="headerlink" title="1.2 几种Lambda表达式的变体"></a>1.2 几种Lambda表达式的变体</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">noArguments</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-comment">// 2</span><br><span class="hljs-type">ActionListener</span> <span class="hljs-variable">oneArgument</span> <span class="hljs-operator">=</span> event -&gt; System.out.println(<span class="hljs-string">&quot;button clicked&quot;</span>);<br><span class="hljs-comment">// 3</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">multiStatement</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    System.out.print(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;World&quot;</span>);<br>&#125;;<br><span class="hljs-comment">// 4</span><br>BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;<br><span class="hljs-comment">// 5</span><br>BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;<br></code></pre></td></tr></table></figure>
<ol>
<li>使用空括号 () 表示没有参数，实现了 Runnable 接口，该接口也只有一个 run 方法，返回类型为 void</li>
<li>只包含一个参数，可省略参数的括号</li>
<li>主体可以是一段代码块，可以用返回或抛出异常来退出，只有一行代码的 Lambda 表达式也可使用大括号</li>
<li>Lambda 表达式也可以表示包含多个参数的方法，这行代码创建了一个函数，用来计算两个数字相加的结果。变量 add 的类型是 <code>BinaryOperator</code>，它不是两个数字的和，而是将两个数字相加的那行代码</li>
<li>可以显式声明参数类型，需要使用小括号将参数括起来</li>
</ol>
<blockquote>
<p>目标类型是指 Lambda 表达式所在上下文环境的类型。比如，将 Lambda 表达式赋值给一个局部变量，或传递给一个方法作为参数，局部变量或方法参数的类型就是 Lambda 表达式的目标类型。</p>
</blockquote>
<h3 id="1-3-引用值，而不是变量"><a href="#1-3-引用值，而不是变量" class="headerlink" title="1.3 引用值，而不是变量"></a>1.3 引用值，而不是变量</h3><p>在使用匿名内部类时，当你需要引用它所在方法里的变量，需要将变量声明为 final</p>
<p>Java 8 虽然放松了这一限制，可以引用非 final 变量，但是该变量<strong>在既成事实上必须是 final</strong>。如果坚持用作非终态变量，编译器就会报错。</p>
<ul>
<li>既成事实上的 final 是指<strong>只能给该变量赋值一次</strong>。</li>
<li>换句话说，Lambda 表达式引用的是值，而不是变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getUserName();<br>button.addActionListener(event -&gt; System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + name));<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果你试图给该变量多次赋值，然后在 Lambda 表达式中引用它，编译器就会报错：</p>
<p>local variables referenced from a Lambda expression must be final or effectively final</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getUserName();<br>name = formatUserName(name);<br>button.addActionListener(event -&gt; System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + name));<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-4-函数接口"><a href="#1-4-函数接口" class="headerlink" title="1.4 函数接口"></a>1.4 函数接口</h3><p>函数接口是<strong>只有一个抽象方法的接口</strong>，用作 Lambda 表达式的类型</p>
<p>例如 Swing 中的 <code>ActionListener</code>, 只有一个抽象方法：<code>actionPerformed</code>，被用来表示行为。该接口也继承自一个不具有任何方法的父接口：<code>EventListener</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ActionListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent event)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接口中单一方法的命名并不重要，只要<strong>方法签名和 Lambda 表达式的类型匹配</strong>即可。</p>
<ul>
<li>这里的函数接口接受一个 <code>ActionEvent</code> 类型的参数，返回空（void）</li>
</ul>
<p>JDK 提供了一组核心函数接口会频繁出现，以下罗列一部分</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>参数</th>
<th>返回类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td>T</td>
<td>boolean</td>
<td>这张唱片已经发行了吗</td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td>T</td>
<td>void</td>
<td>输出一个值</td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;</code></td>
<td>T</td>
<td>R</td>
<td>获得 Artist 对象的名字</td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td>None</td>
<td>T</td>
<td>工厂方法</td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td>T</td>
<td>T</td>
<td>逻辑非（!）</td>
</tr>
<tr>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td>(T, T)</td>
<td>T</td>
<td>求两个数的乘积（*）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-5-类型推断"><a href="#1-5-类型推断" class="headerlink" title="1.5 类型推断"></a>1.5 类型推断</h3><p>Lambda 表达式中的类型推断，实际上是 Java 7 就引入的目标类型推断的扩展，例如 Java 7 中的菱形操作符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; diamondWordCounts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();<br>Map&lt;String, Integer&gt; diamondWordCounts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p>如果将构造函数直接传递给一个方法，也可根据方法签名来推断类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要java8</span><br>useHashmap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useHashmap</span><span class="hljs-params">(Map&lt;String, String&gt; values)</span>;<br></code></pre></td></tr></table></figure>
<p>Java 8 更进一步，可省略 Lambda 表达式中的所有参数类型, javac 根据 Lambda 表达式上下文信息就能推断出参数的正确类型。</p>
<p>程序依然要经过类型检查来保证运行的安全性，但不用再显式声明类型罢了。这就是所谓的<strong>类型推断</strong>。</p>
<h4 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h4><p>使用 Lambda 表达式检测一个 Integer 是否大于 5。这实际上是一个 Predicate (用来判断真假的函数接口)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Predicate&lt;Integer&gt; atLeast5 = x -&gt; x &gt; <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>Predicate 只有一个泛型类型的参数，Integer 用于其中。</li>
<li>Lambda 表达式实现了 Predicate 接口，因此它的单一参数被推断为 Integer 类型。</li>
<li>javac 还可检查 Lambda 表达式的返回值是不是 boolean，这正是 Predicate 方法的返回类型</li>
</ul>
<blockquote>
<p>Predicate 接口的源码，接受一个对象，返回一个布尔值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br>	<span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>BinaryOperator：该接口接受两个参数，返回一个值，参数和值的类型均相同。实例中所用的类型是 Long</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BinaryOperator&lt;Long&gt; addLongs = (x, y) -&gt; x + y;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>没有泛型，代码则通不过编译</p>
<p><code>BinaryOperator add = (x, y) -&gt; x + y;</code></p>
<p>编译器给出的报错信息如下：</p>
<p><code>Operator &#39;&amp; #x002B;&#39; cannot be applied to java.lang.Object, java.lang.Object.</code></p>
<p>上面的例子中并没有给出变量 add 的任何泛型信息，给出的正是<strong>原始类型</strong>的定义。因此，编译器认为参数和返回值都是 java.lang.Object 实例。</p>
</blockquote>
<h3 id="1-6-练习"><a href="#1-6-练习" class="headerlink" title="1.6 练习"></a>1.6 练习</h3><p>练习答案可在 <a target="_blank" rel="noopener" href="https://github.com/RichardWarburton/java-8-Lambdas-exercises">GitHub</a> 上本书所对应的代码仓库中找到</p>
<ol>
<li><p>Java 有一个 ThreadLocal 类，作为容器保存了当前线程里局部变量的值。Java 8 为该类新加了一个工厂方法，接受一个 Lambda 表达式，并产生一个新的 ThreadLocal 对象，而不用使用继承，语法上更加简洁</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zebe1989/article/details/82692551">方法为 <code>withInitial(Supplier&lt;? extends S&gt; supplier)</code></a></p>
</li>
<li><p><code>public final static ThreadLocal&lt;DateFormat&gt; formatter = withInitial(() -&gt; new SimpleDateFormat(&quot;dd-MMM-yyyy&quot;));</code></p>
</li>
</ul>
</li>
<li><p>以如下方式重载 check 方法后，还能正确推断出 check(x -&gt; x &gt; 5) 的类型吗？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IntPred</span> &#123;<br>	<span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Integer value)</span>;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(Predicate&lt;Integer&gt; predicate)</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(IntPred predicate)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>不能，只能二选一，或者更改 Predicate 泛型类型，并且声明 x 的类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(check((Integer x) -&gt; x &gt; <span class="hljs-number">5</span>));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(IntPred predicate)</span> &#123;<br>    <span class="hljs-keyword">return</span> predicate.test(<span class="hljs-number">8</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(Predicate&lt;Long&gt; predicate)</span> &#123;<br>    <span class="hljs-keyword">return</span> predicate.test(<span class="hljs-number">3L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-流"><a href="#2-流" class="headerlink" title="2. 流"></a>2. 流</h2><p>Java 8 对核心类库的改进主要包括集合类的 API 和新引入的流（Stream）。流使程序员得以站在更高的抽象层次上对集合进行操作。</p>
<h3 id="2-1-从外部迭代到内部迭代"><a href="#2-1-从外部迭代到内部迭代" class="headerlink" title="2.1 从外部迭代到内部迭代"></a>2.1 从外部迭代到内部迭代</h3><h4 id="外部迭代"><a href="#外部迭代" class="headerlink" title="外部迭代"></a>外部迭代</h4><p>在使用集合类时，一个通用的模式是在集合上进行迭代，然后处理返回的每一个元素，一个常用的方式是使用 for 循环，但样板代码模糊了代码的本意，无法流畅传达意图</p>
<p>就原理来看，for 循环其实是一个封装了迭代的语法糖：</p>
<ul>
<li>首先调用 <code>iterator()</code> 方法，产生一个新的 Iterator 对象，进而控制整个迭代过程，这就是<strong>外部迭代</strong>。</li>
<li>迭代过程通过显式调用 Iterator 对象的 <code>hasNext()</code> 和 <code>next()</code> 方法完成迭代</li>
<li>然而，外部迭代也有问题，首先，它很难抽象出后面提及的不同操作；此外，它从本质上来讲是一种串行化操作。总体来看，使用 for 循环会将行为和方法混为一谈。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用迭代器计算来自伦敦的艺术家人数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Iterator&lt;Artist&gt; iterator = allArtists.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>	<span class="hljs-type">Artist</span> <span class="hljs-variable">artist</span> <span class="hljs-operator">=</span> iterator.next();<br>    <span class="hljs-keyword">if</span> (artist.isFrom(<span class="hljs-string">&quot;London&quot;</span>)) &#123;<br>    	count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230528171811358.png" alt="image-20230528171811358" style="zoom: 67%;" /></p>
<h4 id="内部迭代"><a href="#内部迭代" class="headerlink" title="内部迭代"></a>内部迭代</h4><p>另一种方法就是<strong>内部迭代</strong>。首先要注意 <code>stream()</code> 方法的调用，它和 <code>iterator()</code> 的作用一样, 返回内部迭代中的相应接口：Stream。</p>
<blockquote>
<p>Stream 是用函数式编程方式在集合类上进行复杂操作的工具</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> allArtists.stream()<br>    				   .filter(artist -&gt; artist.isFrom(<span class="hljs-string">&quot;London&quot;</span>))<br>    				   .count()<br></code></pre></td></tr></table></figure>
<ul>
<li><code>filter</code>: 过滤在这里是指“只保留通过某项测试的对象”。测试由一个函数完成，该函数返回 true 或者 false。<ul>
<li>由于 Stream API 的函数式编程风格，我们并没有改变集合的内容，而是描述出 Stream 里的内容。</li>
</ul>
</li>
<li><code>count()</code>: 计算给定 Stream 里包含多少个对象。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230528172558102.png" alt="image-20230528172558102" style="zoom: 67%;" /></p>
<h3 id="2-2-实现机制"><a href="#2-2-实现机制" class="headerlink" title="2.2 实现机制"></a>2.2 实现机制</h3><p>即使代码被分解为两步操作，但实际上只对列表迭代了一次</p>
<p>通常，在 Java 中调用一个方法，计算机会随即执行操作。但 Stream 里的一些方法却略有不同，它们虽是普通的 Java 方法，但返回的 Stream 对象却不是一个新集合，而是<strong>创建新集合的配方</strong>。</p>
<ul>
<li>对于像 <code>filter</code> 这种只描述 Stream，最终不产生新集合的方法叫作<strong>惰性求值</strong>方法<ul>
<li>返回值是 Stream</li>
</ul>
</li>
<li>像 <code>count</code> 这样最终会从 Stream 产生值的方法叫作<strong>及早求值</strong>方法<ul>
<li>返回值是另一个值或为空</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">allArtists.stream()<br>          .filter(artist -&gt; &#123;<br>              System.out.println(artist.getName());<br>              <span class="hljs-keyword">return</span> artist.isFrom(<span class="hljs-string">&quot;London&quot;</span>);<br>          &#125;);<br>		<span class="hljs-comment">//.count()  取消注释就会输出艺术家的名字</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>这段代码并未做什么实际性的工作，filter 只刻画出了 Stream，但没有产生新的集合。</p>
<ul>
<li>由于使用了惰性求值，没有输出艺术家的名字</li>
<li>加入一个拥有终止操作的流，如 <code>count()</code> ，艺术家的名字就会被输出</li>
</ul>
</li>
<li><p>使用这些操作的理想方式就是形成一个<strong>惰性求值的链</strong>，最后用<strong>一个及早求值</strong>的操作返回想要的结果</p>
</li>
</ul>
<blockquote>
<p>整个过程和建造者模式有共通之处。建造者模式使用一系列操作设置属性和配置，最后调用一个 build 方法，这时，对象才被真正创建。</p>
</blockquote>
<h3 id="2-3-常用的流操作"><a href="#2-3-常用的流操作" class="headerlink" title="2.3 常用的流操作"></a>2.3 常用的流操作</h3><h4 id="collect-toList"><a href="#collect-toList" class="headerlink" title="collect(toList())"></a>collect(toList())</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; collected = Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br>							   .collect(Collectors.toList());<br>assertEquals(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>), collected);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>of</code>方法使用一组初始值生成新的 Stream</li>
<li><code>collect(toList())</code>方法由 Stream 里的值生成一个列表，是一个及早求值操作</li>
</ul>
<blockquote>
<p>这个例子也展示了本节中所有示例代码的通用格式。首先由列表生成一个 Stream，然后进行一些 Stream 上的操作，继而是 collect 操作，由 Stream 生成列表，最后使用断言判断结果是否和预期一致</p>
</blockquote>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; collected = Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br>							   .map(string -&gt; string.toUpperCase())<br>							   .collect(toList());<br>assertEquals(asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;HELLO&quot;</span>), collected);<br></code></pre></td></tr></table></figure>
<ul>
<li>如果有一个函数可以将一种类型的值转换成另外一种类型，map 操作就可以使用该函数，将一个流中的值转换成一个新的流<ul>
<li><strong>参数和返回值不必属于同一种类型</strong></li>
<li>但是 Lambda 表达式必须是 Function 接口的一个实例，Function 接口是只包含一个参数的普通函数接口</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230529204931993.png" alt="image-20230529204931993" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230529202907182.png" alt="image-20230529202907182"></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; beginningWithNumbers<br>    = Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;1abc&quot;</span>, <span class="hljs-string">&quot;abc1&quot;</span>)<br>			.filter(value -&gt; isDigit(value.charAt(<span class="hljs-number">0</span>)))<br>			.collect(toList());<br>assertEquals(asList(<span class="hljs-string">&quot;1abc&quot;</span>), beginningWithNumbers);<br></code></pre></td></tr></table></figure>
<ul>
<li>filter 接受一个函数作为参数，该函数用 Lambda 表达式表示</li>
<li>经过过滤，Stream 中符合条件的，即 Lambda 表达式值为 true 的元素被保留下来</li>
<li>该 Lambda 表达式的函数接口正是前面章节中介绍过的 Predicate</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230529205054570.png" alt="image-20230529205054570"></p>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>假设有一个包含多个列表的流，现在希望得到所有数字的序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; together = Stream.of(asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), asList(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br>                               .flatMap(numbers -&gt; numbers.stream())<br>                               .collect(toList());<br>assertEquals(asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), together);<br></code></pre></td></tr></table></figure>
<ul>
<li>flatMap 方法可用 Stream 替换值，然后将多个 Stream 连接成一个 Stream</li>
<li>调用 stream 方法，将每个列表转换成 Stream 对象，其余部分由 flatMap 方法处理。<ul>
<li>flatMap 方法的相关函数接口为 Function 接口，只是方法的返回值限定为 Stream 类型</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230529205319762.png" alt="image-20230529205319762"></p>
<h4 id="max和min"><a href="#max和min" class="headerlink" title="max和min"></a>max和min</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Track&gt; tracks = asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Track</span>(<span class="hljs-string">&quot;Bakai&quot;</span>, <span class="hljs-number">524</span>),<br>							<span class="hljs-keyword">new</span> <span class="hljs-title class_">Track</span>(<span class="hljs-string">&quot;Violets for Your Furs&quot;</span>, <span class="hljs-number">378</span>),<br>							<span class="hljs-keyword">new</span> <span class="hljs-title class_">Track</span>(<span class="hljs-string">&quot;Time Was&quot;</span>, <span class="hljs-number">451</span>));<br><span class="hljs-type">Track</span> <span class="hljs-variable">shortestTrack</span><br>    <span class="hljs-operator">=</span> tracks.stream()<br>			.min(Comparator.comparing(track -&gt; track.getLength()))<br>			.get();<br>assertEquals(tracks.get(<span class="hljs-number">1</span>), shortestTrack);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>为了让 Stream 对象按照曲目长度进行排序，需要传给它一个 Comparator 对象。Java 8 提 供了一个新的静态方法 comparing，使用它可以方便地实现一个比较器</p>
<ul>
<li>comparing 方法接受一个函数并返回另一个函数</li>
</ul>
</li>
<li><p>此外，还可以调用空 Stream 的 max 方法，返回 Optional 对象</p>
<ul>
<li>Optional 对象代表一个可能存在也可能不存在的值。如果 Stream 为空，那么该值不存在，如果不为空，则该值存在</li>
<li>通过调用 get 方法可以取出 Optional 对象中的值</li>
</ul>
</li>
</ul>
<blockquote>
<p>max 和 min 方法都属于更通用的一种编程模式: reduce 模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">accumulator</span> <span class="hljs-operator">=</span> initialValue;<br><span class="hljs-keyword">for</span>(Object element : collection) &#123;<br>	accumulator = combine(accumulator, element);<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><blockquote>
<p>reduce 操作可以实现从一组值中生成一个值。在上述例子中用到的 count、min 和 max 方 法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>				  .reduce(<span class="hljs-number">0</span>, (acc, element) -&gt; acc + element);<br>assertEquals(<span class="hljs-number">10</span>, count);<br></code></pre></td></tr></table></figure>
<ul>
<li>以 0 作为起点: 一个空 Stream 的求和结果，每一步都将 Stream 中的元素累加至 accumulator，遍历至 Stream 中的最后一个元素时，accumulator 的值就是所有元素的和。</li>
<li>Lambda 表达式就是 reducer，它执行求和操作<ul>
<li>有两个参数：传入 Stream 中的当前元素和 acc，acc 是累加器，保存着当前的累加结果。</li>
<li>返回值是最新的 acc</li>
<li>reducer 的类型是 BinaryOperator</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230530215003705.png" alt="image-20230530215003705"></p>
<p>也可以将 reduce 操作展开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BinaryOperator&lt;Integer&gt; accumulator = (acc, element) -&gt; acc + element;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> accumulator.apply(<br>				accumulator.apply(<br>					accumulator.apply(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>				<span class="hljs-number">2</span>),<br>			<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<p><code>reduce</code>方法还有一种形式，它接受三个参数：初始值<code>identity</code>、累加器<code>accumulator</code>和组合器<code>combiner</code>。这种形式的<code>reduce</code>方法用于并行处理流时，可以在多个部分上并行累积结果，然后再将这些部分的结果合并为一个最终结果。</p>
<h3 id="2-4-高阶函数"><a href="#2-4-高阶函数" class="headerlink" title="2.4 高阶函数"></a>2.4 高阶函数</h3><p>高阶函数是指接受另外一个函数作为参数，或返回一个函数的函数</p>
<ul>
<li>可以通过函数签名辨认：函数的<strong>参数列表里包含函数接口</strong>或者该函数<strong>返回一个函数接口</strong></li>
</ul>
<p>map 是一个高阶函数，因为它的 mapper 参数是一个函数。事实上，本章介绍的 Stream 接口中几乎所有的函数都是高阶函数。</p>
<p>之前的排序例子中还用到了 comparing 函数，它接受一个函数作为参数，获取相应的值，同时返回一个 Comparator。Comparator 可能会被误认为是一个对象，但它有且只有一个抽象方法，所以实际上是一个函数接口</p>
<h3 id="2-5-正确使用Lambda表达式"><a href="#2-5-正确使用Lambda表达式" class="headerlink" title="2.5 正确使用Lambda表达式"></a>2.5 正确使用Lambda表达式</h3><p>本章介绍的概念能够帮助用户写出更简单的代码，因为这些概念描述了数据上的操作，明确了要达成<strong>什么转化</strong>，而不是说明<strong>如何转化</strong>。这种方式写出的代码，潜在的缺陷更少，更直接地表达了程序员的意图。</p>
<p>明确要达成什么转化，而不是说明如何转化的另外一层含义在于<strong>写出的函数没有副作用</strong>。这一点非常重要，这样<strong>只通过函数的返回值就能充分理解函数的全部作用</strong></p>
<p>没有副作用的函数不会改变程序或外界的状态</p>
<ul>
<li>向控制台输出信息、给变量赋值都是副作用</li>
</ul>
<p>鼓励用户使用 Lambda 表达式获取值而不是变量。获取值使用户更容易写出没有副作用的代码。</p>
<p>无论何时，将 Lambda 表达式传给 Stream 上的高阶函数，都应该尽量避免副作用。唯一的例外是 forEach 方法，它是一个终结方法。</p>
<h3 id="2-6-要点回顾"><a href="#2-6-要点回顾" class="headerlink" title="2.6 要点回顾"></a>2.6 要点回顾</h3><ul>
<li>内部迭代将更多控制权交给了集合类。</li>
<li>和 Iterator 类似，Stream 是一种内部迭代方式。</li>
<li>将 Lambda 表达式和 Stream 上的方法结合起来，可以完成很多常见的集合操作。</li>
</ul>
<h3 id="2-7-练习"><a href="#2-7-练习" class="headerlink" title="2.7 练习"></a>2.7 练习</h3><ol>
<li>编写一个函数，接受艺术家列表作为参数，返回一个字符串列表，其中包含艺术家的姓名和国籍；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getNamesAndOrigins</span><span class="hljs-params">(List&lt;Artist&gt; artists)</span> &#123;<br>    <span class="hljs-keyword">return</span> artists.stream()<br>                  .flatMap(artist -&gt; Stream.of(artist.getName(), artist.getNationality()))<br>                  .collect(toList());<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>在一个字符串列表中，找出包含最多小写字母的字符串。对于空列表，返回 <code>Optional&lt;String&gt;</code> 对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countLowercaseLetters</span><span class="hljs-params">(String string)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) string<br>            .chars()<br>            .filter(Character::isLowerCase)<br>            .count();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Optional&lt;String&gt; <span class="hljs-title function_">mostLowercaseString</span><span class="hljs-params">(List&lt;String&gt; strings)</span> &#123;<br>    <span class="hljs-keyword">return</span> strings<br>            .stream()<br>            .max(Comparator.comparing(StringExercises::countLowercaseLetters));<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>只用 reduce 和 Lambda 表达式写出实现 Stream 上的 map 操作的代码，如果不想返回 Stream，可以返回一个 List。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;I, O&gt; List&lt;O&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Stream&lt;I&gt; stream, Function&lt;I, O&gt; mapper)</span> &#123;<br>    <span class="hljs-keyword">return</span> stream.reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;O&gt;(), (acc, x) -&gt; &#123;<br>        List&lt;O&gt; newAcc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(acc);<br>        newAcc.add(mapper.apply(x));<br>        <span class="hljs-keyword">return</span> newAcc;<br>    &#125;, (List&lt;O&gt; left, List&lt;O&gt; right) -&gt; &#123;<br>        List&lt;O&gt; newLeft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(left);<br>        newLeft.addAll(right);<br>        <span class="hljs-keyword">return</span> newLeft;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>只用 reduce 和 Lambda 表达式写出实现 Stream 上的 filter 操作的代码，如果不想返回 Stream，可以返回一个 List。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;I&gt; List&lt;I&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Stream&lt;I&gt; stream, Predicate&lt;I&gt; predicate)</span> &#123;<br>    <span class="hljs-keyword">return</span> stream.reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;I&gt;(), (acc, x) -&gt; &#123;<br>        List&lt;I&gt; newAcc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(acc);<br>        <span class="hljs-keyword">if</span> (predicate.test(x)) &#123;<br>            newAcc.add(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> newAcc;<br>    &#125;, (List&lt;I&gt; left, List&lt;I&gt; right) -&gt; &#123;<br>        List&lt;I&gt; newLeft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(left);<br>        newLeft.addAll(right);<br>        <span class="hljs-keyword">return</span> newLeft;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-类库"><a href="#3-类库" class="headerlink" title="3. 类库"></a>3. 类库</h2><h3 id="3-1-在代码中使用Lambda表达式"><a href="#3-1-在代码中使用Lambda表达式" class="headerlink" title="3.1 在代码中使用Lambda表达式"></a>3.1 在代码中使用Lambda表达式</h3><p>在 slf4j 和 log4j 等几种常用的日志系统中，有一些记录日志的方法，当日志级别不低于某个固定级别时就会开始记录日志。</p>
<ul>
<li>例如<code>void debug(String message)</code>，当级别为 debug 时，就开始记录日志消息</li>
</ul>
<p>但频繁计算消息是否应该记录日志会对系统性能产生影响：可以通过 if 语句预先判断</p>
<ul>
<li><code>if (logger.isDebugEnabled()) &#123;...&#125;</code></li>
</ul>
<p>但使用 Lambda 表达式可以进一步简化日志代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>logger.debug(() -&gt; <span class="hljs-string">&quot;Look at this: &quot;</span> + expensiveOperation());<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(Supplier&lt;String&gt; message)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isDebugEnabled()) &#123;<br>    	debug(message.get()); <span class="hljs-comment">// 调用 get() 方法，相当于调用传入的 Lambda 表达式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2-基本类型"><a href="#3-2-基本类型" class="headerlink" title="3.2 基本类型"></a>3.2 基本类型</h3><p>装箱类型是对象，在内存中存在额外开销。</p>
<ul>
<li>比如整型在内存中占用 4 字节，整型对象却要占用 16 字节，这一情况在数组上更加严重。</li>
<li>将基本类型转换为装箱类型，称为装箱，反之则称为拆箱，两者都需要额外的计算开销。</li>
</ul>
<p>为了减小这些性能开销，Stream 类的某些方法对基本类型和装箱类型做了区分，在 Java 8 中，仅对整型、长整型和双浮点型做了特殊处理</p>
<p>对基本类型做特殊处理的方法在命名上有明确的规范</p>
<ol>
<li>如果方法返回类型为基本类型，则在基本类型前加 To，如<code>ToLongFunction</code></li>
<li>如果参数是基本类型，则不加前缀只需类型名即可，如<code>LongFunction</code></li>
<li>如果高阶函数使用基本类型，则在操作后加后缀 To 再加基本类型，如<code>mapToLong</code></li>
</ol>
<p>这些基本类型都有与之对应的 Stream，以基本类型名为前缀，如 LongStream</p>
<blockquote>
<p>事实上，<code>mapToLong</code>方法返回的不是一个一般的 Stream，而是一个特殊处理的 Stream。</p>
<p>在这个特殊的 Stream 中，map 方法的实现方式也不同，它接受一个 <code>LongUnaryOperator</code> 函数，将一个长整型值映射成另一个长整型值。通过一些高阶函数装箱方法，如<code>mapToObj</code>，也可以从一个基本类型的 Stream 得到一个装箱后的 Stream，如<code>Stream&lt;Long&gt;</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTrackLengthStatistics</span><span class="hljs-params">(Album album)</span> &#123;<br>    <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">trackLengthStats</span><br>            <span class="hljs-operator">=</span> album.getTracks()<br>                   .mapToInt(track -&gt; track.getLength())<br>                   .summaryStatistics();<br><br>    System.out.printf(<span class="hljs-string">&quot;Max: %d, Min: %d, Ave: %f, Sum: %d&quot;</span>,<br>                      trackLengthStats.getMax(),<br>                      trackLengthStats.getMin(),<br>                      trackLengthStats.getAverage(),<br>                      trackLengthStats.getSum());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-重载解析"><a href="#3-3-重载解析" class="headerlink" title="3.3 重载解析"></a>3.3 重载解析</h3><p>Lambda 表达式作为参数时，其类型由它的目标类型推导得出，推导过程遵循如下规则：</p>
<ul>
<li>如果只有一个可能的目标类型，由相应函数接口里的参数类型推导得出</li>
<li>如果有多个可能的目标类型，由<strong>最具体</strong>的类型推导得出</li>
<li>如果有多个可能的目标类型且<strong>最具体的类型不明确</strong>，则需<strong>人为指定</strong>类型<ul>
<li>可以对 Lambda 表达式进行强转</li>
</ul>
</li>
</ul>
<h3 id="3-4-FunctionalInterface"><a href="#3-4-FunctionalInterface" class="headerlink" title="3.4 @FunctionalInterface"></a>3.4 @FunctionalInterface</h3><p>Java 中有一些接口，虽然只含一个方法，但并不是为了使用 Lambda 表达式来实现的。有些对象内部可能保存着某种状态，使用带有一个方法的接口纯属巧合。例如 java.lang.Comparable 和 java.io.Closeable。</p>
<p>和<code>Closeable</code>和<code>Comparable</code>接口不同，为了提高 Stream 对象可操作性而引入的各种新接口，都需要有 Lambda 表达式可以实现它。它们存在的意义在于将代码块作为数据打包起来。因此，它们都添加了<code>@FunctionalInterface</code>注解。</p>
<p>该注释会强制 javac 检查一个接口是否符合函数接口的标准。如果该注释添加给一个枚举类型、类或另一个注释，或者接口包含不止一个抽象方法，javac 就会报错。重构代码时，使用它能很容易发现问题。</p>
<h3 id="3-5-二进制接口的兼容性"><a href="#3-5-二进制接口的兼容性" class="headerlink" title="3.5 二进制接口的兼容性"></a>3.5 二进制接口的兼容性</h3>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Language/">Language</a>, <a href="/categories/Language/Java/">Java</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/05/09/软件系统设计-架构-4-设计架构/"><span>软件系统设计-架构(4) 设计架构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/05/09/软件系统设计-架构-4-设计架构/" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-09T02:23:38.000Z">
          2023-05-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-架构重要需求-Architecturally-Significant-Requirements"><a href="#1-架构重要需求-Architecturally-Significant-Requirements" class="headerlink" title="1. 架构重要需求 Architecturally Significant Requirements"></a>1. 架构重要需求 Architecturally Significant Requirements</h2><ul>
<li><p>架构重要需求 (ASR) 是一种将对架构产生深远影响的需求 - 如果没有这样的需求，架构可能会大不相同<br>An <strong>Architecturally Significant Requirements(ASR)</strong> is a requirement that will have a profound effect on the architecture - the architecture might well be dramatically different in the absence of such a requirement</p>
</li>
<li><p>QA 需求越困难、越重要，就越有可能显着影响架构，因此成为 ASR<br>The more difficult and important the QA requirement,the more likely it is to significantly affect the architecture, and hence to be an ASR.</p>
</li>
<li>如何系统地识别 ASR 和其他影响架构的因素？<br>How to systematically identify the ASRs and other factors that will shape the architecture?<ul>
<li>从需求文档中收集ASR Gathering ASRs from requirements documents</li>
<li>通过采访涉众收集ASR Gathering ASRs by interviewing stakeholders</li>
<li>通过了解业务目标来收集ASR Gathering ASRs by understanding the business goals</li>
<li>在效用树中捕获ASR Capturing ASRs in a utility tree</li>
</ul>
</li>
</ul>
<h3 id="1-1-从需求文档中收集ASR-Gathering-ASRs-from-Requirements-Documents"><a href="#1-1-从需求文档中收集ASR-Gathering-ASRs-from-Requirements-Documents" class="headerlink" title="1.1 从需求文档中收集ASR Gathering ASRs from Requirements Documents"></a>1.1 从需求文档中收集ASR Gathering ASRs from Requirements Documents</h3><ul>
<li><p>无论需求是使用 “MoSCoW” 风格还是作为”用户故事”的集合来指定，这些都无助于确定质量属性。<br>Whether requirements are specified using the “MoSCoW” style or as a collection of “user stories”, neither of these is much help in nailing down quality attributes.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cheny_com/article/details/6358456">MoSCoW 风格</a>：使用四个级别来定义一个需求的优先级程度</li>
</ul>
</li>
<li><p>需求文档通常会以两种方式让架构师失望 Requirements documents often fail an architect in two ways:</p>
<ul>
<li>需求规范中的大部分内容不会影响架构 Most of what is in a requirements specification does not affect the architecture.<ul>
<li>“系统应该是模块化的” “The system shall be modular”</li>
<li>“系统应具有高可用性” “The system shall exhibit high usability”</li>
<li>“系统应满足用户的性能期望” “The system shall meet users’ performance expectations”</li>
</ul>
</li>
<li>很多对架构师有用的东西甚至都不在最好的需求文档中 Much of what is useful to an architect is not in even the best requirements document.<ul>
<li>在收购的背景下，需求文档代表的是收购方的利益，而不是开发者的利益<br>In an acquisition context, the requirements document represents the interests of the acquirer, not that of the developer.</li>
</ul>
</li>
</ul>
</li>
<li>如果一个需求影响关键架构设计决策的制定，那么根据定义，它就是 ASR<br>if a requirement affects the making of a critical architectural design decision, it is by definition an ASR.</li>
</ul>
<h3 id="1-2-通过采访涉众收集ASR-Gathering-ASRs-by-interviewing-stakeholders"><a href="#1-2-通过采访涉众收集ASR-Gathering-ASRs-by-interviewing-stakeholders" class="headerlink" title="1.2 通过采访涉众收集ASR Gathering ASRs by interviewing stakeholders"></a>1.2 通过采访涉众收集ASR Gathering ASRs by interviewing stakeholders</h3><ul>
<li>质量属性研讨会 Quality Attribute Workshop (QAW)<ol>
<li>QAW 演示和介绍 QAW presentation and introductions</li>
<li>业务任务介绍 Business mission presentation</li>
<li>架构计划介绍 Architectual plan presentation</li>
<li>确定架构驱动因素：就包含总体需求、业务驱动因素、约束和质量属性的架构驱动因素的精简列表达成共识。<br>Identification of architectural drivers: to reach a consensus on a distilled list of architectural drivers that includes overall requirements, business drivers, constraints, and quality attributes.</li>
<li>场景头脑风暴：每个涉众都表达一个场景，表示他/她对系统的关注。<br>Scenario brainstorming: each stakeholder expresses a scenario representing his/ her concerns with respect to the system.</li>
<li>场景合并（合并类似方案） Scenario consolidation (merging similar scenarios)</li>
<li>场景优先级（通过投票） Scenario prioritization(by voting)</li>
<li>场景细化：对最重要的场景进行细化和阐述。<br>Scenario refinement: the top scenarios are refined and elaborated.</li>
</ol>
</li>
<li>QAW的结果包括一份架构驱动因素列表和一组QA场景，利益相关者（作为一个组）对其进行了优先排序。<br>The results of QAW include a list of architectural drivers and a set of QA scenarios that the stakeholders (as a group prioritized).</li>
</ul>
<h3 id="1-3-在效用树中捕获ASR-Capturing-ASRs-in-a-Utility-Tree"><a href="#1-3-在效用树中捕获ASR-Capturing-ASRs-in-a-Utility-Tree" class="headerlink" title="1.3 在效用树中捕获ASR Capturing ASRs in a Utility Tree"></a>1.3 在效用树中捕获ASR Capturing ASRs in a Utility Tree</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605165136398.png" alt="image-20230605165136398"></p>
<ul>
<li>将 scenario 使用量化的方式来描述，之后才可以使用测试等方式来确定是否实现了要求。</li>
<li>逐渐对质量需求进行分解，分解到含有量化指标为止。</li>
<li>然后将分解的结果进行细化</li>
</ul>
<h3 id="1-4-基于角色的方法探索-ASR-Persona-Based-Approach-to-exploring-ASRs"><a href="#1-4-基于角色的方法探索-ASR-Persona-Based-Approach-to-exploring-ASRs" class="headerlink" title="1.4 基于角色的方法探索 ASR Persona-Based Approach to exploring ASRs"></a>1.4 基于角色的方法探索 ASR Persona-Based Approach to exploring ASRs</h3><h4 id="1-4-1-Working-with-ASRs"><a href="#1-4-1-Working-with-ASRs" class="headerlink" title="1.4.1 Working with ASRs"></a>1.4.1 Working with ASRs</h4><ul>
<li><p>在实践中，ASR（尤其是 NFR）通常不会被引出并且没有明确指定。<br>In practice ASRS (especially NFRs) are often not elicited and are not clearly specified.</p>
<ul>
<li><p>许多软件需求规范根本不包含 NFR。<br>Many Software Requirements Specifications simply don’t include NFRs.</p>
</li>
<li><p>同样，许多敏捷项目都没有包含与 ASR 相关的用户案例。</p>
<p>Similarly, many agile projects fail to include ASR-related user stories.</p>
</li>
</ul>
</li>
<li><p>有没有更好的办法？Is there a better way?</p>
</li>
<li><p>在我们的 TraceLab 项目中，我们采用了角色驱动的方法，使我们能够在项目早期发现 ASR，并利用我们的知识对架构设计和实施做出明智的决策。<br>In our TraceLab project we adopted a persona-driven approach which enabled us to discover architecturally significant requirements early in the project and to use our knowledge to make informed decisions about architectural design and implementation.</p>
</li>
</ul>
<h4 id="1-4-2-ASRs-in-TraceLab"><a href="#1-4-2-ASRs-in-TraceLab" class="headerlink" title="1.4.2 ASRs in TraceLab"></a>1.4.2 ASRs in TraceLab</h4><ul>
<li>TraceLab 是一项由国家科学基金会资助的 200 万美元的项目<br>TraceLab is a US $2 Million Project funded by the National Science Foundation</li>
<li>由 DePaul 大学、威廉玛丽学院、肯特州立大学和肯塔基大学的合作者开发。<br>Developed by collaborators at DePaul University, College of William and Mary, Kent State Univ, and Univ. of Kentucky.</li>
<li>旨在通过促进创新和创造力，增强可追溯性研究人员之间的协作，降低新可追溯性研究项目的启动成本和工作量以及促进技术转让来授权未来的可追溯性研究。<br>Intended to empower future traceability research through facilitating innovation and creativity, increasing collaboration between traceability researchers, decreasing the startup costs and effort of new traceability research projects, and fostering technology transfer.</li>
<li>提供了一个环境，研究人员可以在此环境中设计和执行实验，共享组件和数据集，并在受控的环境中比较评估结果。<br>Provides an environment in which researchers can design and execute experiments, share components and datasets, and comparatively evaluate results in a controlled setting.</li>
</ul>
<h4 id="1-4-3-Competing-Tradeoffs"><a href="#1-4-3-Competing-Tradeoffs" class="headerlink" title="1.4.3 Competing Tradeoffs"></a>1.4.3 Competing Tradeoffs</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170527201.png" alt=""></p>
<h4 id="1-4-4-Traditional-HCI-Personas"><a href="#1-4-4-Traditional-HCI-Personas" class="headerlink" title="1.4.4 Traditional HCI Personas"></a>1.4.4 Traditional HCI Personas</h4><ul>
<li>我们决定通过开发一组精通架构的角色来表示冲突的需求。<br>We decided to represent the conflicting needs through developing a set of architecturally-savvy personas.</li>
<li>传统上，角色构建涉及对用户进行调查，对其进行分类，制定使用假设，进行验证，创建场景以及最终设计角色。<br>Traditionally persona construction involves surveying users, classifying them, formulating hypotheses of use, validating, creating scenarios, and finally designing personas.</li>
<li>我们的项目太耗时，即过多的前期工作会阻碍我们实现目标。<br>Too time consuming for our project i.e. too much upfront effort that would retard the achievement of our goals.</li>
<li>解决方案：角色草图。Solution: Persona sketches.</li>
</ul>
<h4 id="1-4-5-Architecturally-Savvy-Personas-Lite"><a href="#1-4-5-Architecturally-Savvy-Personas-Lite" class="headerlink" title="1.4.5 Architecturally-Savvy Personas(Lite)"></a>1.4.5 Architecturally-Savvy Personas(Lite)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170759188.png" alt="image-20230605170759188" style="zoom:80%;" /></p>
<h4 id="1-4-6-一些例子"><a href="#1-4-6-一些例子" class="headerlink" title="1.4.6 一些例子"></a>1.4.6 一些例子</h4><div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170905058.png" alt="image-20230605170905058"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170913374.png" alt="image-20230605170913374"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170922072.png" alt="image-20230605170922072"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170928431.png" alt="image-20230605170928431"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170936169.png" alt="image-20230605170936169"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170943682.png" alt="image-20230605170943682"></td>
</tr>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170950817.png" alt="image-20230605170950817"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605170955965.png" alt="image-20230605170955965"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605171005323.png" alt="image-20230605171005323"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-设计策略-Design-Strategies"><a href="#2-设计策略-Design-Strategies" class="headerlink" title="2. 设计策略 Design Strategies"></a>2. 设计策略 Design Strategies</h2><ol>
<li>Abstraction</li>
<li>Generate &amp; Test</li>
<li>Decomposition</li>
<li>Reusable Elements</li>
<li>Iteration &amp; Refinement</li>
<li>Divide &amp; Conquer</li>
</ol>
<h3 id="2-1-分解-Decomposition"><a href="#2-1-分解-Decomposition" class="headerlink" title="2.1 分解 Decomposition"></a>2.1 分解 Decomposition</h3><ul>
<li>质量属性需求可以<strong>分解</strong>，并<strong>分配</strong>给分解<strong>元素</strong>。<br>Quality attribute requirements can be decomposed and assigned to the elements of the decomposition.</li>
<li>请记住给定的约束，并安排分解，使其能够<strong>适应</strong>这些<strong>约束</strong>。<br>Keep in mind the constraints given and arrange the decomposition so that it will accommodate those constraints.</li>
<li>设计活动的目标是生成一个适应约束并<strong>达到</strong>系统<strong>质量</strong>和<strong>业务目标</strong>的设计。<br>The goal of the design activity is to generate a design that accommodates the constraints and achieves the quality and business goals for the system.</li>
</ul>
<h3 id="2-2-根据ASR进行设计-Designing-to-ASRs"><a href="#2-2-根据ASR进行设计-Designing-to-ASRs" class="headerlink" title="2.2 根据ASR进行设计 Designing to ASRs"></a>2.2 根据ASR进行设计 Designing to ASRs</h3><ul>
<li><strong>非ASR</strong>需求如何进行设计？ What about the non-ASR requirements?<ul>
<li>ASR的选择意味着需求的<strong>优先级</strong> The choice of ASRs implies a prioritization of the requirements.<ul>
<li>您<strong>仍然可以满足</strong>其他需求 You can still meet the other requirements.</li>
<li>您可以<strong>稍加调整</strong>现有<strong>设计</strong>来满足其他需求 You can meet the others with a slight adjustment of the existing design.</li>
<li>您无法在当前设计下满足其他需求 You cannot meet the others under the current design.<ul>
<li>您<strong>即将</strong>满足需求 you are close to meeting the requirements.</li>
<li>重新确定需求的<strong>优先级</strong>并<strong>重新设计</strong> reprioritize the requirements and revisit the design.</li>
<li>您<strong>不能满足</strong>需求 you cannot meet requirements.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>是一次性设计<strong>所有</strong>的ASR还是一次设计<strong>一个</strong>ASR？Design for all of ASRs or one at a time?<ul>
<li>答案是经验问题。The answer is a matter of experience.</li>
<li>通过经验和教育，您将培养设计直觉，并采用模式/策略来帮助您针对多个 ASR 进行设计。<br>Through experience and education, you will develop an intuition for designing, and employ patterns/tactics to aid you in designing for multiple ASRs.</li>
</ul>
</li>
</ul>
<h3 id="2-3-生成并测试-Generate-and-Test"><a href="#2-3-生成并测试-Generate-and-Test" class="headerlink" title="2.3 生成并测试 Generate and Test"></a>2.3 生成并测试 Generate and Test</h3><ul>
<li>将特定设计视为假设：当前设计假设的<strong>错误</strong>在<strong>下一设计假设中得到解决</strong>，而正确的事情得到保留。<br>View a particular design as a hypothesis: the things wrong with the current design hypothesis are fixed in the next design hypothesis, and the things right are kept.</li>
<li><strong>最初的假设</strong>从何而来？Where does the initial hypothesis come from?<ul>
<li>现有系统 Existing systems</li>
<li>框架(部分设计) Frameworks (partial designs)</li>
<li>模式与策略 Patterns and tactics</li>
<li>设计清单(提供指导和信心) Design checklists (providing guidance and confidence)</li>
</ul>
</li>
<li>有哪些<strong>测试</strong>？What are the tests that are applied?<ul>
<li>根据分析技术 Analysis techniques</li>
<li>根据设计清单 Design checklists<ul>
<li>Allocation of Responsibility</li>
<li>Coordination Model</li>
<li>Data Model</li>
<li>Mapping among Architecture Elements</li>
<li>Resource Management</li>
<li>Binding Time</li>
<li>Choice of Technology</li>
</ul>
</li>
</ul>
</li>
<li><strong>下一个假设</strong>是如何产生的？How is the next hypothesis generated?<ul>
<li>基于目前的假设，和系统实现的具体情况与质量属性之间的差距</li>
<li>然后结合新的tactics生成下一个假设</li>
</ul>
</li>
<li>你什么时候<strong>做完</strong> When are you done?<ul>
<li>要么具有满足ASR的设计，要么在您用尽设计预算时。<br>Either have a design that satisfies the ASRs or when you exhaust you budget for design.</li>
<li>实施您做出的最佳假设 Implement the best hypothesis you made</li>
</ul>
</li>
</ul>
<h2 id="3-属性驱动设计-Attribute-Driven-Design，ADD"><a href="#3-属性驱动设计-Attribute-Driven-Design，ADD" class="headerlink" title="3. 属性驱动设计 Attribute-Driven Design，ADD"></a>3. 属性驱动设计 Attribute-Driven Design，ADD</h2><h3 id="3-1-ADD的步骤概述"><a href="#3-1-ADD的步骤概述" class="headerlink" title="3.1 ADD的步骤概述"></a>3.1 ADD的步骤概述</h3><ol>
<li>确认有足够的需求信息<br>Step 1: Confirm there is sufficient requirements information</li>
<li>选择要分解的系统元素<br>Step 2: Choose an element of the system to decompose</li>
<li>确定所选元素的ASR<br>Step 3: ldentify the ASRs for the chosen element</li>
<li>选择符合ASR的设计概念<br>Step 4:Choose a design concept that satisfies the ASRs</li>
<li>实例化架构元素并分配职责<br>Step 5: Instantiate architectural elements and allocate responsibilities</li>
<li>为实例化元素定义接口<br>Step6: Define interfaces for instantiated elements</li>
<li>验证和完善需求，并使其成为实例化元素的约束<br>Step 7: Verify and refine requirements and make them constraints for instantiated elements</li>
<li>重复进行，直到满足所有ASR<br>Step 8: Repeat until all the ASRs have been satisfied</li>
</ol>
<h3 id="3-2-ADD的输入：需求？-Inputs-to-ADD：Requirements"><a href="#3-2-ADD的输入：需求？-Inputs-to-ADD：Requirements" class="headerlink" title="3.2 ADD的输入：需求？ Inputs to ADD：Requirements?"></a>3.2 ADD的输入：需求？ Inputs to ADD：Requirements?</h3><p>文档提供的信息是不充分的。</p>
<h3 id="步骤1：确认有足够的需求信息-Step-1-Confirm-there-is-sufficient-requirements-information"><a href="#步骤1：确认有足够的需求信息-Step-1-Confirm-there-is-sufficient-requirements-information" class="headerlink" title="步骤1：确认有足够的需求信息 Step 1: Confirm there is sufficient requirements information"></a>步骤1：确认有足够的需求信息 Step 1: Confirm there is sufficient requirements information</h3><ul>
<li>系统的涉众已根据业务和任务目标确定了<strong>需求</strong>的<strong>优先级</strong>。The system’s stakeholders have prioritized the requirements according to business and mission goals.</li>
<li>您可以确定设计期间要重点关注的<strong>系统元素</strong>。You determine which system elements to focus on during the design.</li>
<li>您确定是否有关于系统质量属性要求的<strong>足够信息</strong>：”<strong>刺激反应</strong>“形式(图)。You determine if there is sufficient information about the quality attribute requirements of the system:stimulus-response form.</li>
</ul>
<h3 id="步骤2：选择要分解的系统元素-Step-2-Choose-an-element-of-the-system-to-decompose"><a href="#步骤2：选择要分解的系统元素-Step-2-Choose-an-element-of-the-system-to-decompose" class="headerlink" title="步骤2：选择要分解的系统元素 Step 2: Choose an element of the system to decompose"></a>步骤2：选择要分解的系统元素 Step 2: Choose an element of the system to decompose</h3><ul>
<li>如果是第一次作为”<strong>未开发</strong>“开发的一部分，则将<strong>所有需求</strong>分配给系统。<br>If the first time as part of a “greenfield” development, all requirements are assigned to the system.</li>
<li><strong>完善</strong>部分设计的系统时，系统已划分为多个元素，并为其分配了需求。从这些元素中选择<strong>一个</strong>作为聚焦点。<br>When refining a partially designed system, the system has been partitioned into elements with requirements assigned to them. Choose one of these elements as the focus.</li>
</ul>
<blockquote>
<p>Ploughed field：耕种过的地，已有一些处理</p>
</blockquote>
<h3 id="步骤3：确定所选元素的ASR-Step-3-Identify-the-ASRs-for-the-chosen-element"><a href="#步骤3：确定所选元素的ASR-Step-3-Identify-the-ASRs-for-the-chosen-element" class="headerlink" title="步骤3：确定所选元素的ASR Step 3: Identify the ASRs for the chosen element"></a>步骤3：确定所选元素的ASR Step 3: Identify the ASRs for the chosen element</h3><ul>
<li>根据对架构的<strong>相对影响</strong>对这些相同的需求进行第二次<strong>排名</strong>，将高影响、中等影响或低影响分配给每个需求。<br>Rank these same requirements a second time based on their relative impact on the architecture as assigning “high impact”, “medium impact” or “low impact” to each requirement.</li>
<li>(H，H) (H，M) (H，L) (M，H) (M，M) (M，L) (L，H) (L，M) (L，L)<ul>
<li>第一个字母表示要求对涉众的重要性 The first letter indicates the importance of requirements to stakeholders</li>
<li>第二个字母表示需求对架构的潜在影响 The second letter indicates the potential impact of requirements on the architecture</li>
</ul>
</li>
</ul>
<h3 id="步骤4：选择满足ASR的设计概念-Step-4-Choose-a-design-concept-that-satisfies-the-ASRs"><a href="#步骤4：选择满足ASR的设计概念-Step-4-Choose-a-design-concept-that-satisfies-the-ASRs" class="headerlink" title="步骤4：选择满足ASR的设计概念 Step 4: Choose a design concept that satisfies the ASRs"></a>步骤4：选择满足ASR的设计概念 Step 4: Choose a design concept that satisfies the ASRs</h3><h4 id="步骤4-1：找出设计问题-Step-4-1-Identify-design-concerns"><a href="#步骤4-1：找出设计问题-Step-4-1-Identify-design-concerns" class="headerlink" title="步骤4.1：找出设计问题 Step 4.1: Identify design concerns"></a>步骤4.1：找出设计问题 Step 4.1: Identify design concerns</h4><ul>
<li>如何解决设计中的ASR？How to address ASRs in your design?</li>
<li>如何将问题划分成几个子问题。</li>
</ul>
<h4 id="步骤4-2：列出从属问题的替代模式-策略-Step-4-2-List-alternative-patterns-tactics-for-subordinate-concerns"><a href="#步骤4-2：列出从属问题的替代模式-策略-Step-4-2-List-alternative-patterns-tactics-for-subordinate-concerns" class="headerlink" title="步骤4.2：列出从属问题的替代模式/策略 Step 4.2: List alternative patterns/tactics for subordinate concerns"></a>步骤4.2：列出从属问题的替代模式/策略 Step 4.2: List alternative patterns/tactics for subordinate concerns</h4><p>对于列表中的每个模式，您应该 For each pattern on your list, you should</p>
<ul>
<li><strong>识别</strong>每个模式的区分<strong>参数</strong>，以帮助您在模式和策略中进行选择<br>identify each pattern‘s discriminating parameters to help you choose among the patterns and tactics</li>
<li><strong>估计</strong>区分参数的<strong>值</strong><br>estimate the values of the discriminating parameters</li>
</ul>
<h4 id="步骤4-3：从清单中选择模式-策略-Step-4-3-Select-patterns-tactics-from-the-list"><a href="#步骤4-3：从清单中选择模式-策略-Step-4-3-Select-patterns-tactics-from-the-list" class="headerlink" title="步骤4.3：从清单中选择模式/策略 Step 4.3: Select patterns/tactics from the list"></a>步骤4.3：从清单中选择模式/策略 Step 4.3: Select patterns/tactics from the list</h4><ul>
<li>使用每种模式时需要进行哪些<strong>权衡</strong>？ What tradeoffs are expected when using each pattern?</li>
<li>模式之间的<strong>结合</strong>程度如何？ How well do the patterns combine with each other?</li>
<li>是否有任何模式<strong>互斥</strong>？ Are any patterns mutually exclusive?</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230605215318191.png" alt="image-20230605215318191"></p>
<h4 id="步骤4-4：确定模式-策略与-ASR-之间的关系-Step-4-4-Determine-relationship-between-patterns-tactics-and-ASRs"><a href="#步骤4-4：确定模式-策略与-ASR-之间的关系-Step-4-4-Determine-relationship-between-patterns-tactics-and-ASRs" class="headerlink" title="步骤4.4：确定模式/策略与 ASR 之间的关系 Step 4.4: Determine relationship between patterns/tactics and ASRs"></a>步骤4.4：确定模式/策略与 ASR 之间的关系 Step 4.4: Determine relationship between patterns/tactics and ASRs</h4><ul>
<li>考虑到目前为止确定的<strong>模式/策略</strong>，并决定它们<strong>之间的关系</strong>。所选模式的组合可以产生新的模式。<br>Consider the patterns/ tactics identified so far and decide how they relate to each other. The combination of the selected patterns may result in a new pattern.</li>
</ul>
<h4 id="步骤4-5：捕获初步的架构视图-Step-4-5-Capture-preliminary-architectural-views"><a href="#步骤4-5：捕获初步的架构视图-Step-4-5-Capture-preliminary-architectural-views" class="headerlink" title="步骤4.5：捕获初步的架构视图 Step 4.5: Capture preliminary architectural views"></a>步骤4.5：捕获初步的架构视图 Step 4.5: Capture preliminary architectural views</h4><ul>
<li>通过开始捕获不同的<strong>架构视图</strong>来描述您选择的<strong>模式</strong>。Describe the patterns you have selected by starting to capture different architectural views.</li>
<li>在此阶段，您无需创建完整记录的架构视图(You don’t need to create fully documented architectural views at this stage)</li>
</ul>
<h4 id="步骤4-6：评估并解决不一致问题-Step-4-6-Evaluate-and-resolve-inconsistencies"><a href="#步骤4-6：评估并解决不一致问题-Step-4-6-Evaluate-and-resolve-inconsistencies" class="headerlink" title="步骤4.6：评估并解决不一致问题 Step 4.6: Evaluate and resolve inconsistencies"></a>步骤4.6：评估并解决不一致问题 Step 4.6: Evaluate and resolve inconsistencies</h4><ul>
<li>根据架构<strong>驱动</strong>程序评估<strong>设计</strong>。Evaluate the design against the architectural drivers.</li>
<li>确定<strong>是否有未考虑</strong>的体系结构驱动程序。Determine if there are any architectural drivers that were not considered.</li>
<li>评估<strong>替代模式</strong>或应用其他<strong>策略</strong>。Evaluate alternative patterns or apply additional tactics.</li>
<li>将<strong>当前元素的设计</strong>与体系结构中<strong>其他</strong>元素的设计进行评估，并解决所有<strong>不一致</strong>之处。Evaluate the design of the current element against the design of other elements in the architecture and resolve any inconsistencies.</li>
</ul>
<h3 id="步骤5：实例化架构元素并分配职责-Step-5-Instantiate-architectural-elements-and-allocate-responsibilities"><a href="#步骤5：实例化架构元素并分配职责-Step-5-Instantiate-architectural-elements-and-allocate-responsibilities" class="headerlink" title="步骤5：实例化架构元素并分配职责 Step 5: Instantiate architectural elements and allocate responsibilities"></a>步骤5：实例化架构元素并分配职责 Step 5: Instantiate architectural elements and allocate responsibilities</h3><ul>
<li>实例化您选择的<strong>每种元素</strong>的一个<strong>实例</strong>。Instantiate one instance of every type of element you chose.</li>
<li>根据<strong>子元素</strong>的类型<strong>分配职责</strong>。Assign responsibilities to child elements according to their type.</li>
<li>在其子元素中<strong>分配</strong>与父元素相关联的责任。Allocate responsibilities associated with the parent element among its children.</li>
<li>分析并<strong>记录</strong>您所做的设计决策。Analyze and document the design decisions you have made.</li>
</ul>
<h3 id="步骤6：为实例化元素定义接口-Step6-Define-interfaces-for-instantiated-elements"><a href="#步骤6：为实例化元素定义接口-Step6-Define-interfaces-for-instantiated-elements" class="headerlink" title="步骤6：为实例化元素定义接口 Step6: Define interfaces for instantiated elements"></a>步骤6：为实例化元素定义接口 Step6: Define interfaces for instantiated elements</h3><ul>
<li>接口描述了软件元素对彼此所做的 PROVIDES 和 REQUIRES 假设。<br>Interfaces describe the PROVIDES and REQUIRES assumptions that software elements make about one another.<ul>
<li>练习涉及您实例化的元素的<strong>功能要求</strong>。Exercise the functional requirements that involve the elements you instantiated.</li>
<li>观察由一个元素<strong>产生</strong>并由另一元素<strong>消耗</strong>的<strong>任何信息</strong>。Observe any information that is produced by one element and consumed by another.</li>
</ul>
</li>
</ul>
<h3 id="步骤7：验证和完善需求，并使其成为实例化元素的约束-Step-7-Verify-and-refine-requirements-and-make-them-constraints-for-instantiated-elements"><a href="#步骤7：验证和完善需求，并使其成为实例化元素的约束-Step-7-Verify-and-refine-requirements-and-make-them-constraints-for-instantiated-elements" class="headerlink" title="步骤7：验证和完善需求，并使其成为实例化元素的约束 Step 7: Verify and refine requirements and make them constraints for instantiated elements"></a>步骤7：验证和完善需求，并使其成为实例化元素的约束 Step 7: Verify and refine requirements and make them constraints for instantiated elements</h3><ul>
<li><strong>验证</strong>分配给<strong>父元素</strong>的所有需求是否已分配给一个或多个<strong>子元素</strong>。<br>Verify that all requirements assigned to the parent element have been allocated to one or more child elements.</li>
<li>将分配给子元素的所有<strong>职责转换</strong>为各个元素的<strong>功能需求</strong>。<br>Translate any responsibilities assigned to child elements into functional requirements for the individual elements.</li>
</ul>
<h3 id="步骤8：重复进行，直到满足所有ASR-Step-8-Repeat-until-all-the-ASRs-have-been-satisfied"><a href="#步骤8：重复进行，直到满足所有ASR-Step-8-Repeat-until-all-the-ASRs-have-been-satisfied" class="headerlink" title="步骤8：重复进行，直到满足所有ASR Step 8: Repeat until all the ASRs have been satisfied"></a>步骤8：重复进行，直到满足所有ASR Step 8: Repeat until all the ASRs have been satisfied</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230606205656100.png" alt="image-20230606205656100"></p>
<h3 id="3-3-ADD的输出-Outputs-of-ADD"><a href="#3-3-ADD的输出-Outputs-of-ADD" class="headerlink" title="3.3 ADD的输出 Outputs of ADD"></a>3.3 ADD的输出 Outputs of ADD</h3><ul>
<li><strong>软件元素</strong>：履行各种角色和<strong>职责</strong>的计算或开发工件，具有预定<strong>属性</strong>并与其他软件元素相关以组成系统架构<br>software element: a computational or developmental artifact that fulills various roles and responsibilities, has defined properties, and relates to other software elements to compose the architecture of a system</li>
<li><strong>角色</strong>：一组相关职责<br>role: a set of related responsibilities</li>
<li><strong>责任</strong>：软件元素提供的<strong>功能，数据或信息</strong><br>responsibility: the functionality, data, or information that a software element provides</li>
<li><strong>属性</strong>：有关软件元素的附加信息<br>property: additional information about a software element</li>
<li><strong>关系</strong>：两个软件元素如何相互<strong>关联或交互</strong>的定义<br>relationship: a definition of how two software elements are associated with or interact with one another</li>
</ul>
<h2 id="4-基于ADD进行系统架构设计的实例"><a href="#4-基于ADD进行系统架构设计的实例" class="headerlink" title="4. 基于ADD进行系统架构设计的实例"></a>4. 基于ADD进行系统架构设计的实例</h2><h3 id="4-1-系统的功能视角-System-Functional-Overview"><a href="#4-1-系统的功能视角-System-Functional-Overview" class="headerlink" title="4.1 系统的功能视角 System Functional Overview"></a>4.1 系统的功能视角 System Functional Overview</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230606210648277.png" alt="image-20230606210648277" style="zoom:80%;" /></p>
<h3 id="4-2-系统的功能需求、约束和质量属性需求"><a href="#4-2-系统的功能需求、约束和质量属性需求" class="headerlink" title="4.2 系统的功能需求、约束和质量属性需求"></a>4.2 系统的功能需求、约束和质量属性需求</h3><h4 id="实例的功能需求"><a href="#实例的功能需求" class="headerlink" title="实例的功能需求"></a>实例的功能需求</h4><p>轨迹管理器为两种类型的客户端提供跟踪服务<br>The Track Manager provides a tracking service for two types of clients:</p>
<ol>
<li><strong>更新客户端</strong>：这些客户端会<strong>定期</strong>向 Track Manager 发送轨迹更新。轨迹管理器可以<strong>容忍</strong>某些偶然的更新丢失，尤其是在设备故障导致的瞬态情况下。所有更新客户端<strong>每秒都会进行一次更新</strong>，当轨迹管理器收到第三个信号时，它可以从<strong>两个丢失的更新信号中恢复</strong>。如果错过了两个以上的信号，则操作员可能必须在恢复过程中协助轨迹管理器。换句话说，如果发生故障，则<strong>必须在两秒钟之前重新开始处理</strong>，以避免操作员的干预。<br>update clients: These clients send track updates to the Track Manager periodically. The Track Manager can tolerate some occasional loss of updates, especially during transient conditions caused by equipment failure. All update clients perform an update every second, and thel rack Manager can recover from two missed update signals when it receives the third signal. If more than two signals are missed, the operator may have to assist the Track Manager in the recovery process. In other words, if a failure occurs, the processing must restart before two seconds have elapsed in order to avoid operator intervention.</li>
<li><strong>查询客户端</strong>：这些客户端<strong>偶尔</strong>运行，并且必须准确收到一个对其查询的回复。查询客户端可能与某些经常请求小块数据的客户端(例如，单个客户端在五秒内查询几千字节的数据)和其他客户端<strong>偶尔</strong>请求<strong>大块数据</strong>(例如，单个客户端在几分钟内查询几兆字节的数据)不同。查询的响应时间应少于特定查询正常响应时间的两倍。<br>query clients: These clients operate sporadically and must receive exactly one reply to their query. Query clients can be dissimilar with some clients requesting small chunks of data often (e.g., several kilobytes with five seconds between queries from a single client) and others requesting large chunks of data occasionally (e.g., several megabytes with minutes between queries). The response time for queries should be less than double the normal response time for a particular query.</li>
</ol>
<h4 id="实例的设计约束-Design-Constraints"><a href="#实例的设计约束-Design-Constraints" class="headerlink" title="实例的设计约束 Design Constraints"></a>实例的设计约束 Design Constraints</h4><ol>
<li><strong>容量限制</strong>：提供的处理器在交付时应具有<strong>50%的备用处理器</strong>和<strong>内存</strong>容量，而局域网(LAN)具有<strong>50%的备用吞吐</strong>能力。有<strong>100个更新</strong>客户端和<strong>25个查询</strong>客户端。为了进行时序估算，假设每秒有<strong>100个更新和5个查询</strong>。<br>capacity restrictions: The provided processors shall have 50% spare processor and memory capacity on delivery, and the local area network (L AN) has 50% spare throughput capability. There are 100 update clients and 25 query clients. For the purposes of timing estimates, assume that there are 100 updates and 5 queries per second.</li>
<li><strong>持久性存储服务</strong>：该服务将<strong>维护状态</strong>副本，该副本至少由Track Manager<strong>每分钟检查一次</strong>。如果Track Manager的所有副本均失败，则可以从检查点文件开始<strong>重新启动</strong>。<br>persistent storage service: This service will maintain a copy of state that is checked at least once per minute by the Track Manager. If all replicas of the Track Manager fail, a restart can begin from the checkpoint file.</li>
<li><strong>两个副本</strong>：为了满足可用性和可靠性要求，已经进行了可靠性，可用性和可维护性(RMA)研究，Track Manager和持久存储元素在正常情况下都应有两个副本运行。<br>two replicas: To satisfy the availability and reliability requirements, a Reliability, Availability, and Maintainability (RMA) study has been conducted, and the Track Manager and persistent storage elements shall all have two replicas operating during normal circumstances.</li>
</ol>
<h4 id="实例的质量属性需求-Quality-Attribute-Requirements"><a href="#实例的质量属性需求-Quality-Attribute-Requirements" class="headerlink" title="实例的质量属性需求 Quality Attribute Requirements"></a>实例的质量属性需求 Quality Attribute Requirements</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230606214440899.png" alt="image-20230606214440899"></p>
<h3 id="4-3-步骤-1：Confirm-there-is-sufficient-requirements-information"><a href="#4-3-步骤-1：Confirm-there-is-sufficient-requirements-information" class="headerlink" title="4.3 步骤 1：Confirm there is sufficient requirements information"></a>4.3 步骤 1：Confirm there is sufficient requirements information</h3><ul>
<li>系统的涉众已根据业务和任务目标确定了<strong>需求</strong>的<strong>优先级</strong>。The system’s stakeholders have prioritized the requirements according to business and mission goals.</li>
<li>您可以确定设计期间要重点关注的<strong>系统元素</strong>。You determine which system elements to focus on during the design.</li>
<li>您确定是否有关于系统质量属性要求的<strong>足够信息</strong>：”<strong>刺激反应</strong>“形式(图)。You determine if there is sufficient information about the quality attribute requirements of the system:stimulus-response form.</li>
</ul>
<h4 id="第一次迭代的元素视图-View-with-Elements-from-First-Iteration"><a href="#第一次迭代的元素视图-View-with-Elements-from-First-Iteration" class="headerlink" title="第一次迭代的元素视图 View with Elements from First Iteration"></a>第一次迭代的元素视图 View with Elements from First Iteration</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230606214712183.png" alt="image-20230606214712183" style="zoom:80%;" /></p>
<h4 id="第一次迭代的结果-Results-from-Iteration1"><a href="#第一次迭代的结果-Results-from-Iteration1" class="headerlink" title="第一次迭代的结果 Results from Iteration1"></a>第一次迭代的结果 Results from Iteration1</h4><ul>
<li>该设计使用客户端-服务器模型，其中Track Manager为更新和查询客户端提供服务。The design uses a client-server model where the Track Manager provides services to the update and query clients.</li>
<li>Track Manager分为两个元素：A 和 B。此分解允许两种部署策略：<br>The Track Manager has been broken into two elements: A and B. This decomposition allows two deployment strategies:</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230606215143839.png" alt="image-20230606215143839"></p>
<ul>
<li>更新客户端和查询客户端与Track Manager之间的<strong>通信机制</strong>不同：The communication mechanisms between the update and query clients and the Track Manager differ:<ul>
<li><strong>更新</strong>客户端使用<strong>异步通信</strong>机制。Update clients use an asynchronous communication mechanism.</li>
<li><strong>查询</strong>客户端使用<strong>同步通信</strong>机制。Query clients use a synchronous communication mechanism.</li>
</ul>
</li>
<li>元素 A 和 B 都包含状态数据，必须将其保存为永久存储中的检查点。Elements A and B both contain state data that must be saved as a checkpoint in persistent storage.</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230607004537032.png" alt="image-20230607004537032"></p>
<ul>
<li>中间件<strong>Naming Service</strong>接受<strong>请求的服务</strong>的名称，并返回该服务的访问代码。A middleware naming service accepts the name of a requested service and returns an access code tor the service.</li>
<li>如果提供中间件<strong>注册服务</strong>会导致<strong>持久存储超出</strong>其备用<strong>容量</strong>限制，则该中间件注册服务将拒绝为新客户端提供服务。A middleware registration service refuses service to new clients if providing it would cause persistent storage to exceed its spare capacity limit.</li>
<li>分配了一个<strong>单独的团队</strong>来考虑Track Manager元素的启动。A separate team is assigned to consider the start-up of the Track Manager elements.</li>
<li>A 和 B 都在命名服务中注册其接口。Both A and B register their interfaces with the naming service.</li>
<li>当<strong>更新客户端</strong>发出<strong>请求</strong>时，该请求直接从 A 或 B 到达<strong>异步</strong>通信服务，然后再到达<strong>命名服务</strong>以获取该服务的<strong>句柄</strong>。When an update client is making the request, the request goes directly from A or B to the asynchronous communication service and then to the naming service to get the handle for the service.</li>
<li>当<strong>查询客户端</strong>发出<strong>请求</strong>时，该请求直接从 A 或 B 到达<strong>同步</strong>通信服务，然后再到达<strong>命名服务</strong>以获取该服务的<strong>句柄</strong>。When a query client is making the request, the request goes directly from A or B to the synchronous communication service and then to the naming service to get the handle for the service.</li>
<li>团队决定由一位容错专家来完善容错占位符。The team decides to have a fault-tolerance expert refine the fault-tolerance placeholder.</li>
</ul>
<h4 id="第一次迭代后的元素-Elements-after-Iteration1"><a href="#第一次迭代后的元素-Elements-after-Iteration1" class="headerlink" title="第一次迭代后的元素 Elements after Iteration1"></a>第一次迭代后的元素 Elements after Iteration1</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230607005407656.png" alt="image-20230607005407656"></p>
<h3 id="4-4-步骤-2：Choose-an-Element-of-system-to-decompose"><a href="#4-4-步骤-2：Choose-an-Element-of-system-to-decompose" class="headerlink" title="4.4 步骤 2：Choose an Element of system to decompose"></a>4.4 步骤 2：Choose an Element of system to decompose</h3><ul>
<li>如果是第一次作为”<strong>未开发</strong>“开发的一部分，则将<strong>所有需求</strong>分配给系统。<br>If the first time as part of a “greenfield” development, all requirements are assigned to the system.</li>
<li><strong>完善</strong>部分设计的系统时，系统已划分为多个元素，并为其分配了需求。从这些元素中选择<strong>一个</strong>作为聚焦点。<br>When refining a partially designed system, the system has been partitioned into elements with requirements assigned to them. Choose one of these elements as the focus.</li>
</ul>
<h4 id="第一次迭代的系统元素-System-Elements-from-the-First-Iteration"><a href="#第一次迭代的系统元素-System-Elements-from-the-First-Iteration" class="headerlink" title="第一次迭代的系统元素 System Elements from the First Iteration"></a>第一次迭代的系统元素 System Elements from the First Iteration</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230607204126165.png" alt="image-20230607204126165"></p>
<ul>
<li>我们选择Fault-Tolerance Service作为设计焦点</li>
</ul>
<h3 id="4-5-步骤-3：Identify-the-ASRs-for-the-chosen-element"><a href="#4-5-步骤-3：Identify-the-ASRs-for-the-chosen-element" class="headerlink" title="4.5 步骤 3：Identify the ASRs for the chosen element"></a>4.5 步骤 3：Identify the ASRs for the chosen element</h3><ul>
<li>根据对架构的<strong>相对影响</strong>对这些相同的需求进行第二次<strong>排名</strong>，将高影响、中等影响或低影响分配给每个需求。<br>Rank these same requirements a second time based on their relative impact on the architecture as assigning “high impact”, “medium impact” or “low impact” to each requirement.</li>
<li>(H，H) (H，M) (H，L) (M，H) (M，M) (M，L) (L，H) (L，M) (L，L)<ul>
<li>第一个字母表示要求对涉众的重要性 The first letter indicates the importance of requirements to stakeholders</li>
<li>第二个字母表示需求对架构的潜在影响 The second letter indicates the potential impact of requirements on the architecture</li>
</ul>
</li>
</ul>
<h4 id="Architectually-Significant-Requirements"><a href="#Architectually-Significant-Requirements" class="headerlink" title="Architectually Significant Requirements"></a>Architectually Significant Requirements</h4><p>识别出架构上重要的要求，如下图所示 </p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230607204321941.png" alt="image-20230607204321941"></p>
<ul>
<li>从初始<strong>架构需求</strong>中识别出<strong>7</strong>个ASR。7 ASRs are identified from the initial architecture requirements.</li>
<li>从ADD的第一次迭代产生的<strong>设计约束</strong>中识别出<strong>3</strong>个ASR。3 ASRs are identified from the design constraints resulting from the first iteration of ADD.</li>
<li>标记为(<strong>高，高</strong>)的ASR直接取决于方案1(<strong>最难满足</strong>且具有<strong>最高优先级</strong>驱动程序)中<strong>2秒</strong>的端到端定时要求。ASRs labeled (high, high) bear directly on the end-to-end timing requirement of 2 seconds in Scenario 1 (the most difficult to satisfy and has the highest priority drivers</li>
<li>标有(<strong>中，中</strong>)的ASR与运行追踪管理器的单个副本的时间相关联，并且恢复应在<strong>2</strong>分钟内发生。ASRs labeled (medium, medium) are associated with the timing when a single copy of the Track Manager is operating, and restoration should occur within 2 minutes.</li>
<li>重新启动场景最不重要，因此单独的启动设计工作正在考虑其细节。The restart scenario is least important, and a separate “start-up” design effort is considering its details.</li>
</ul>
<h3 id="4-6-步骤-4：Choose-a-design-concept-that-satisfies-the-ASRs"><a href="#4-6-步骤-4：Choose-a-design-concept-that-satisfies-the-ASRs" class="headerlink" title="4.6 步骤 4：Choose a design concept that satisfies the ASRs"></a>4.6 步骤 4：Choose a design concept that satisfies the ASRs</h3><h4 id="步骤-4-1：Identify-design-concerns"><a href="#步骤-4-1：Identify-design-concerns" class="headerlink" title="步骤 4.1：Identify design concerns"></a>步骤 4.1：Identify design concerns</h4><ol>
<li>How to address ASRs in your design?</li>
</ol>
<h5 id="容错服务的设计问题-Design-concerns-with-Fault-Tolerance-Services"><a href="#容错服务的设计问题-Design-concerns-with-Fault-Tolerance-Services" class="headerlink" title="容错服务的设计问题 Design concerns with Fault-Tolerance Services"></a>容错服务的设计问题 Design concerns with Fault-Tolerance Services</h5><ol>
<li><strong>故障准备</strong>：此问题包括在正常操作过程中<strong>定期执行的策略</strong>，以确保发生故障时可以进行恢复。<br>fault preparation: This concern consists of those tactics performed routinely during normal operation to ensure that when a failure occurs, a recovery can take place.</li>
<li><strong>故障检测</strong>：此问题包括与<strong>检测</strong>故障并<strong>通知</strong>要处理该故障的元素有关的策略。<br>fault detection: This concern consists of the tactics associated with detecting the fault and notifying an element to deal with the fault.</li>
<li><strong>故障恢复</strong>：此问题涉及<strong>瞬态</strong>情况下的操作，在故障<strong>发生</strong>和<strong>恢复</strong>正常操作之间的时间段。<br>fault recovery: This concern addresses operations during a transient condition —— the time period between the fault occurrence and the restoration ot normal operation.</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612155000754.png" alt="image-20230612155000754" style="zoom:80%;" /></p>
<ol>
<li>4个分支是4个关注点，我们选择Detect Faults作为关注点</li>
</ol>
<h5 id="设计考量-可能的策略-Design-Concerns-Alternative-Tactics"><a href="#设计考量-可能的策略-Design-Concerns-Alternative-Tactics" class="headerlink" title="设计考量(可能的策略) Design Concerns(Alternative Tactics)"></a>设计考量(可能的策略) Design Concerns(Alternative Tactics)</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612155117873.png" alt="image-20230612155117873" style="zoom:80%;" /></p>
<h4 id="步骤-4-2-amp-步骤-4-3-List-alternative-patterns-tactics-for-subordinate-concerns-amp-Select-patterns-tactics-from-the-list"><a href="#步骤-4-2-amp-步骤-4-3-List-alternative-patterns-tactics-for-subordinate-concerns-amp-Select-patterns-tactics-from-the-list" class="headerlink" title="步骤 4.2 &amp; 步骤 4.3: List alternative patterns/tactics for subordinate concerns &amp; Select patterns/tactics from the list"></a>步骤 4.2 &amp; 步骤 4.3: List alternative patterns/tactics for subordinate concerns &amp; Select patterns/tactics from the list</h4><p>对于列表中的每个模式，您应该 For each pattern on your list, you should</p>
<ul>
<li><strong>识别</strong>每个模式的区分<strong>参数</strong>，以帮助您在模式和策略中进行选择<br>identify each pattern‘s discriminating parameters to help you choose among the patterns and tactics</li>
<li><strong>估计</strong>区分参数的<strong>值</strong><br>estimate the values of the discriminating parameters</li>
</ul>
<p>使用每种模式时需要进行哪些<strong>权衡</strong>？ What tradeoffs are expected when using each pattern?</p>
<p>模式之间的<strong>结合</strong>程度如何？ How well do the patterns combine with each other?</p>
<p>是否有任何模式<strong>互斥</strong>？ Are any patterns mutually exclusive?</p>
<h5 id="可替代的重启策略-Alternative-Restart-Tactics"><a href="#可替代的重启策略-Alternative-Restart-Tactics" class="headerlink" title="可替代的重启策略 Alternative Restart Tactics"></a>可替代的重启策略 Alternative Restart Tactics</h5><p>区分参数：Discriminating parameters:</p>
<ol>
<li>故障后可以忍受的停机时间(方案1)<br>the downtime that can be tolerated after failure (scenario 1)</li>
<li>系统在故障时间附近处理服务请求的方式；例如，它是否接受请求但响应时间变慢，或者直接丢弃这些请求（场景1）。<br>the manner in which the system treats requests for services in the time interval around the failure time; for example, if it honors them and degrades the response time or it drops them (scenario 1)</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612155636561.png" alt="image-20230612155636561"></p>
<p>推理 Reasoning</p>
<ol>
<li>方案1和要求1都指示<strong>重新启动时间</strong>必须<strong>少于2秒</strong>；因此，冷重启策略是不合适的。<br>Both Scenario1 and Requirement 1 indicate that the restart time must be less than two seconds; thus, Cold Restart tactic is inappropriate.</li>
<li>“热备份”策略比”主/主”或”负载共享”策略更<strong>易于实施</strong>；并且似乎可以轻松满足场景1中描述的时序要求。<br>The Warm Standby tactic is simpler to implement than the Master/ Master or Load Sharing tactics; and it seems to easily satisfy the timing requirement described in scenario 1.</li>
</ol>
<p>决策：使用<strong>热备份</strong>策略。Decision: Use the Warm Standby tactic.</p>
<p>实现 Implications</p>
<ol>
<li>每个组件(A和B)的<strong>主要</strong>轨迹管理器都会接收所有请求并做出响应。<br>A primary Track Manager for each component (A and B) receives all requests and responds to them.</li>
<li>每个组件(A和B)的<strong>辅助</strong>(备用)轨迹管理器都加载在另一个处理器上，并占用内存。<br>A secondary (standby) Track Manager for each component (A’ and B”) is loaded on another processor and takes up memory.</li>
</ol>
<h5 id="可选的部署策略-Alternative-Deployment-Tactics"><a href="#可选的部署策略-Alternative-Deployment-Tactics" class="headerlink" title="可选的部署策略 Alternative Deployment Tactics"></a>可选的部署策略 Alternative Deployment Tactics</h5><p>区分参数：Discriminating parameters:</p>
<ol>
<li>故障后可以忍受的停机时间（方案1） the downtime that can be tolerated after failure(scenario 1)</li>
<li>支持100个更新客户端和25个查询客户端（需求2）the support of 100 update clients and 25 query clients (requirement 2)</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612160259489.png" alt="image-20230612160259489"></p>
<p>推理 Reasoning</p>
<ol>
<li>尽管具有较慢的恢复时间，架构师熟悉使用<strong>单一的故障切换方案</strong>（Together策略）来从软件或硬件故障中恢复。<br>The architect is familiar with having a single failover scheme for recovery from a software or hardware failure (Together tactic), even though it has a slower recovery time.</li>
<li>该策略可以满足处理要求，尽管可以减少处理次数。<br>This tactic meets the processing requirements, although it can perform less processing.</li>
</ol>
<p>决策：使用<strong>共同</strong>战术。Decision: Use the Together tactic.</p>
<p>实现 Implications</p>
<ol>
<li><strong>主要</strong>组件(A和B)<strong>共享一个处理器</strong>，次要组件(A和B)也共享一个处理器。<br>The primary components (A and B) share a processor, as do the secondary components (A and B ).</li>
<li>该系统将永远无法与不同处理器中的主要组件一起运行。<br>The system will never be operational with the primary components in different processors.</li>
</ol>
<h5 id="可选的数据集成策略-Alternative-Data-Integrity-Tactics"><a href="#可选的数据集成策略-Alternative-Data-Integrity-Tactics" class="headerlink" title="可选的数据集成策略 Alternative Data Integrity Tactics"></a>可选的数据集成策略 Alternative Data Integrity Tactics</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612160540775.png" alt="image-20230612160540775" style="zoom:80%;" /></p>
<p>推理 Reasoning</p>
<ol>
<li>显然，需要每分钟有一个状态检查点才能满足方案2。但是，<strong>一分钟前</strong>的状态不能满足方案1。策略1被拒绝。<br>Clearly a checkpoint of state every minute is needed to satisfy Scenario 2. However, a state that is one minute old cannot satisfy Scenario 1. Tactic 1 is rejected.</li>
<li>策略2满足方案1和2的升级要求；但是，这会带来不可接受的<strong>通信负载</strong>。策略2被拒绝。<br>Tactic 2 would satisfy the upgrade requirements of Scenarios 1 and 2; however, it places an unacceptable communication load. Tactic 2 is rejected.</li>
<li>策略3将满足方案1和2，但是(如策略2一样)它给通信系统带来了沉重的负担。策略3被拒绝。<br>Tactic 3 would satisfy Scenarios1 and 2, but like Tactic 2) it places a significant burden on the communication system. Tactic 3 is rejected.</li>
<li><strong>如果x小于2秒</strong>，则策略4满足方案1和2。这也带来了更合理的通信负载。捆绑升级周期为2秒似乎令人满意。选择了策略4。<br>Tactic 4 satisfies Scenarios 1 and 2 if x is less than 2 seconds. It also puts a more reasonable communication load. Having a bundled upgrade periodicity of 2 seconds appears to be satisfactory. Tactic 4 is selected.</li>
<li>策略5也可以满足这种情况，但<strong>更为复杂</strong>，因为辅助服务器必须每隔x秒执行一次以更新其状态副本。策略5被拒绝。<br>Tactic 5 also satisfies the scenarios but is more complex, since the secondary must execute every x seconds to update its state copy. Tactic 5 is rejected.</li>
</ol>
<p>决策：</p>
<ol>
<li>使用<strong>检查点+捆绑日志更改</strong>策略。Use the Checkpoint + Bundled Log Changes tactic.</li>
<li>x小于2：此时策略满足了方案1和方案2</li>
</ol>
<p>实现 Implications</p>
<ol>
<li>主副本每分钟将状态保存到一个<strong>持久性检查点文件</strong>中。The primary replica saves the state to a persistent CheckpointFile every minute.</li>
<li>主数据库将所有状态更改的本地捆绑文件保留2秒，然后<strong>每2秒</strong>将其作为<strong>日志文件</strong>发送一次。The primary keeps a local bundled file of all state changes for 2 seconds, and sends it as a LogFile every 2 seconds.</li>
<li>升级后的主数据库在升级后会先读取检查点文件，然后读取日志文件并在读取时更新每个状态更改 The promoted primary reads in the CheckpointFile after it is promoted, then reads the LogFile and updates each state change as it is read…</li>
</ol>
<h5 id="可选的健康监控策略-Alternative-Health-Monitoring-Tactics"><a href="#可选的健康监控策略-Alternative-Health-Monitoring-Tactics" class="headerlink" title="可选的健康监控策略 Alternative Health Monitoring Tactics"></a>可选的健康监控策略 Alternative Health Monitoring Tactics</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612160646497.png" alt="image-20230612160646497"></p>
<p>推理 Reasoning：</p>
<ol>
<li><strong>ping/echo</strong>故障检测比<strong>心跳</strong>检测<strong>更为复杂</strong>，并且需要<strong>两倍的带宽</strong>。The ping/echo fault detection is more complex than the heartbeat detection and requires twice the bandwidth.</li>
<li>不选择3和4的原因是如果使用客户端来检查，可能没有办法在2s之内完成，从而导致更严重的问题。</li>
</ol>
<p>决策：使用<strong>心跳</strong>策略。Decision: Use the Heartbeat tactic.</p>
<p>实现 Implications</p>
<ol>
<li>心跳必须足够快，以允许辅助节点<strong>初始化</strong>并在<strong>发生故障后2秒钟内开始</strong>处理。初始化两个检查点文件需要1.2秒。心跳会额外增加0.25秒，剩下0.55秒的备用时间，这似乎是合理的。The heartbeat must be fast enough to allow the secondary to become initialized and start processing within 2 seconds after a failure occurs. Initializing the two checkpoint files takes 1.2 seconds. The heartbeat adds an additional 0.25 second, leaving 0.55 second spare, which seems reasonable.</li>
<li>运行状况<strong>监视</strong>元素<strong>每0.25秒检查一次心跳</strong>。如果未检测到心跳，则健康监视器会<strong>通知</strong>所有<strong>必要的元素</strong>。A health monitoring element checks for the heartbeat every 0.25 second. When a heartbeat is not detected, the health monitor informs all the necessary elements.</li>
<li>如果主要轨迹管理器组件检测到内部故障，则用于传达故障的机制是不发出心跳。<br>If a primary Track Manager component detects an internal failure, the mechanism for communicating the failure is to not issue the heartbeat.</li>
</ol>
<h5 id="可选的透明策略-Alternative-Transparency-Tactics"><a href="#可选的透明策略-Alternative-Transparency-Tactics" class="headerlink" title="可选的透明策略 Alternative Transparency Tactics"></a>可选的透明策略 Alternative Transparency Tactics</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612160711166.png" alt="image-20230612160711166"></p>
<p>推理 Reasoning</p>
<ol>
<li>客户端处理故障是不希望的，故障转移很容易被误解并使它变得不那么健壮。It is undesirable to have the clients handle failure, the failover could be misinterpreted easily and render it less than robust.</li>
<li>该基础结构<strong>没有内置的多播</strong>功能，因此添加此功能将很昂贵。The infrastructure has no built-in multicast capability, and adding this feature would be expensive.</li>
</ol>
<p>决策：使用<strong>代理处理失败</strong>策略。Decision: Use the Proxy Handles Failure tactic.</p>
<p>含义 Implications</p>
<ol>
<li>代理服务将服务方法注册到名称服务器。The proxy service registers the service methods with the name server.</li>
<li>代理服务会启动第一个组件，并以不同的名称(AA.a，AA.b，BB.c和BB.d)注册它们，并同样对第二个组件(AA.a，AA’.b，BB’.c 和 BB’.d)进行注册。<br>The proxy service starts the first components, registering them under different names (AA.a, AA.b, BB.c, and BB.d) and does likewise for the secondary components (AA.c, AA’.b, BB’.c, and BB’d).</li>
<li>客户端请求服务(A.a)。此请求将导致命名服务被调用并返回A.a的访问代码，该代码被指定为access(A.a)。接下来，客户端调用访问权限(A.a)。<br>The client requests a service (A.a). This request causes the naming service to be invoked and to return the access code for A.a, designated as access(A.a). Next, the client invokes access(A.a).</li>
<li>代理服务(A.a)确定AA是主要副本，并将访问(AA.a)作为”转发请求”返回给客户端。<br>The proxy service (A.a) determines that AA is the primary replica and returns access (AA.a) to the client as a forward request to</li>
<li>客户端调用访问(AA.a)并继续执行直到AA失败。<br>The client invokes access(AA.a) and continues to do so until AA fails.</li>
<li>当运行状况监视器在AA中检测到心跳失败时，它将通知代理服务…<br>When the health monitor detects heartbeat failure in AA, it informs the proxy service…</li>
</ol>
<h4 id="步骤-4-4-Determine-relationship-between-patterns-tactics-and-ASRs"><a href="#步骤-4-4-Determine-relationship-between-patterns-tactics-and-ASRs" class="headerlink" title="步骤 4.4: Determine relationship between patterns/ tactics and ASRs"></a>步骤 4.4: Determine relationship between patterns/ tactics and ASRs</h4><ul>
<li>考虑到目前为止确定的<strong>模式/策略</strong>，并决定它们<strong>之间的关系</strong>。所选模式的组合可以产生新的模式。<br>Consider the patterns/ tactics identified so far and decide how they relate to each other. The combination of the selected patterns may result in a new pattern.</li>
</ul>
<h5 id="策略和ASR之间的映射-Mapping-between-Patterns-Tactics-and-ASRs"><a href="#策略和ASR之间的映射-Mapping-between-Patterns-Tactics-and-ASRs" class="headerlink" title="策略和ASR之间的映射 Mapping between Patterns/Tactics and ASRs"></a>策略和ASR之间的映射 Mapping between Patterns/Tactics and ASRs</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612161458813.png" alt="image-20230612161458813"></p>
<h4 id="步骤-4-5-捕获初步的架构视图-Capture-preliminary-architectural-view"><a href="#步骤-4-5-捕获初步的架构视图-Capture-preliminary-architectural-view" class="headerlink" title="步骤 4.5: 捕获初步的架构视图 Capture preliminary architectural view"></a>步骤 4.5: 捕获初步的架构视图 Capture preliminary architectural view</h4><ul>
<li>通过开始捕获不同的<strong>架构视图</strong>来描述您选择的<strong>模式</strong>。Describe the patterns you have selected by starting to capture different architectural views.</li>
<li>在此阶段，您无需创建完整记录的架构视图(You don’t need to create fully documented architectural views at this stage)</li>
</ul>
<h5 id="元素表-Element-Table"><a href="#元素表-Element-Table" class="headerlink" title="元素表 Element Table"></a>元素表 Element Table</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612161536183.png" alt="image-20230612161536183" style="zoom:80%;" /></p>
<h5 id="架构元素视图-Architectual-Element-View"><a href="#架构元素视图-Architectual-Element-View" class="headerlink" title="架构元素视图 Architectual Element View"></a>架构元素视图 Architectual Element View</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612161554321.png" alt="image-20230612161554321" style="zoom:80%;" /></p>
<h5 id="顺序图-Sequence-Diagram"><a href="#顺序图-Sequence-Diagram" class="headerlink" title="顺序图 Sequence Diagram"></a>顺序图 Sequence Diagram</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612161605616.png" alt="image-20230612161605616" style="zoom:80%;" /></p>
<h4 id="步骤-4-6-Evaluate-and-resolve-inconsistencies"><a href="#步骤-4-6-Evaluate-and-resolve-inconsistencies" class="headerlink" title="步骤 4.6: Evaluate and resolve inconsistencies"></a>步骤 4.6: Evaluate and resolve inconsistencies</h4><ul>
<li>根据架构<strong>驱动</strong>程序评估<strong>设计</strong>。Evaluate the design against the architectural drivers.</li>
<li>确定<strong>是否有未考虑</strong>的体系结构驱动程序。Determine if there are any architectural drivers that were not considered.</li>
<li>评估<strong>替代模式</strong>或应用其他<strong>策略</strong>。Evaluate alternative patterns or apply additional tactics.</li>
<li>将<strong>当前元素的设计</strong>与体系结构中<strong>其他</strong>元素的设计进行评估，并解决所有<strong>不一致</strong>之处。Evaluate the design of the current element against the design of other elements in the architecture and resolve any inconsistencies.</li>
</ul>
<h5 id="时间模型-Timing-Model"><a href="#时间模型-Timing-Model" class="headerlink" title="时间模型 Timing Model"></a>时间模型 Timing Model</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612161629678.png" alt="image-20230612161629678"></p>
<h5 id="顺序发生的事件Events-Occuring-in-Sequence"><a href="#顺序发生的事件Events-Occuring-in-Sequence" class="headerlink" title="顺序发生的事件Events Occuring in Sequence"></a>顺序发生的事件Events Occuring in Sequence</h5><ol>
<li>保存对持久性日志文件的状态更新。A save is made of state updates to the persistent LogFile.</li>
<li>保存状态后，多次检测到心跳。A heartbeat is detected a number of times after the state save.</li>
<li>轨迹管理器中发生崩溃故障。A crash failure occurs in the Track Manager.</li>
<li>当心跳之前发生超时时，运行状况监视器将检测到故障。The health monitor detects the failure when a timeout occurs before the heartbeat</li>
<li>辅助跟踪管理器提升为主要。The secondary Track Manager is promoted to primary</li>
<li>辅助服务开始响应客户端请求，以减少请求的积压并缩短响应时间。The secondary service starts to respond to client requests, working off the backlog of requests and giving slower response times.</li>
<li>响应缓慢的过渡时间结束后，服务将恢复正常。The service returns to normal when the transient period of slow responses ends.</li>
<li>新副本完成初始化，并准备与当前主副本同步并成为辅助副本。A new replica completes initialization and is ready to synchronize with the current primary and become the secondary.</li>
<li>新副本已完成所有需要的状态更新，并且还原服务的过程已完成。The new replica has completed any needed state updates, and the process of restoring the service is completed.</li>
</ol>
<h5 id="时间衡量-Timing-Evaluation"><a href="#时间衡量-Timing-Evaluation" class="headerlink" title="时间衡量 Timing Evaluation"></a>时间衡量 Timing Evaluation</h5><ol>
<li>Tps：状态ogFile保存的周期(2秒)Tps: periodicity of the state LogFile save (2 seconds)</li>
<li>Th：心跳周期(0.25秒)Th: periodicity of the heartbeat (0.25 second)</li>
<li>TrA：从持久性存储中恢复A状态所花费的时间(0.8秒)TrA: elapsed time taken to recover the state of A from persistent storage (0.8 second)</li>
<li>TrB：从持久性存储中恢复B状态所花费的时间(0.6秒)TrB: elapsed time taken to recover the state of B from persistent storage (0.6 second)</li>
<li>TrL：从持久性存储中恢复LogFile所花费的时间(估计为0.2秒)TrL: elapsed time to recover the LogFile from persistent storage (estimated at 0.2 second)</li>
<li>Tus：从日志文件更新A和B的状态所花费的时间(估计为0.1秒)Tus: elapsed time to update the state of A and B from the LogFile (estimated at 0.1 second)</li>
<li>T1 = Tps + Th + TrA + TrB + TrL + Tus</li>
<li>T1 = 2 + 0.25 + 0.8 + 0.6 + 0.2 + 0.1 = 3.95&gt; 2.0</li>
</ol>
<h5 id="可能的时序解决方案-Possible-Timing-Resolutions"><a href="#可能的时序解决方案-Possible-Timing-Resolutions" class="headerlink" title="可能的时序解决方案 Possible Timing Resolutions"></a>可能的时序解决方案 Possible Timing Resolutions</h5><ol>
<li>减少日志文件保存到永久性存储的周期。同步日志文件和心跳，以便在启动保存后立即发生心跳。Reduce the periodicity of the LogFile save to persistent storage. Synchronize the LogFile save and the heartbeat such that the heartbeat occurs just after a save is initiated.</li>
<li>将日志文件保存到永久性存储中相当于心跳。每0.5秒发送一次日志。扩展持久性存储元素，以便它识别出未能接收到日志文件更新会触发一个请求，以通知其他必要的元素失败(即代理，备用，客户端)。Have the LogFile save to persistent storage serve as the heartbeat equivalent. Send the log every 0.5 seconds. Extend the persistent storage element so that it recognizes that a failure to receive the LogFile update triggers a request to intorm the other necessary elements of a failure (i.e., proxy, standby, clients).</li>
<li>使持久存储并发访问，而不是顺序访问。Make the 3 persistent storage accesses concurrent instead of sequential.</li>
<li>将部署决策更改为第二种模式，其中A和B的主节点位于不同的处理器中；因此，带有组件A的处理器的故障将是最坏的情况。Change the deployment decision to the second pattern, in which the primaries of A and B are in different processors; hence, the failure of the processor with component A will be the worst case.</li>
<li>更改状态更新的样式，其中辅助数据库通过在启动期间与主数据库同步来维护状态模型。它还定期接收一堆状态更新，从而消除了从持久性存储中读取数据的需求。Change the style of the state update, in which the secondary maintains a model of the state by synchronizing with the primary during start-up. It also receives a bundle of state updates periodically, thus obviating the need to read from persistent storage.</li>
<li>通过在重新启动时重新计算一些状态数据来减少要为组件A和B保存的状态的大小。Reduce the size of the state to be saved for components A and B by recomputing some state data on restart.</li>
</ol>
<h5 id="时间决策-Timing-Decisions"><a href="#时间决策-Timing-Decisions" class="headerlink" title="时间决策 Timing Decisions"></a>时间决策 Timing Decisions</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612161754771.png" alt="image-20230612161754771"></p>
<h3 id="4-7-步骤-5-Instantiate-architectural-elements-and-allocate-responsibilities"><a href="#4-7-步骤-5-Instantiate-architectural-elements-and-allocate-responsibilities" class="headerlink" title="4.7 步骤 5: Instantiate architectural elements and allocate responsibilities"></a>4.7 步骤 5: Instantiate architectural elements and allocate responsibilities</h3><ul>
<li>实例化您选择的<strong>每种元素</strong>的一个<strong>实例</strong>。Instantiate one instance of every type of element you chose.</li>
<li>根据<strong>子元素</strong>的类型<strong>分配职责</strong>。Assign responsibilities to child elements according to their type.</li>
<li>在其子元素中<strong>分配</strong>与父元素相关联的责任。Allocate responsibilities associated with the parent element among its children.</li>
<li>分析并<strong>记录</strong>您所做的设计决策。Analyze and document the design decisions you have made.</li>
</ul>
<h4 id="4-7-1-分配职责给每一个元素"><a href="#4-7-1-分配职责给每一个元素" class="headerlink" title="4.7.1 分配职责给每一个元素"></a>4.7.1 分配职责给每一个元素</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612161839702.png" alt="image-20230612161839702"></p>
<h4 id="4-7-2-解释"><a href="#4-7-2-解释" class="headerlink" title="4.7.2 解释"></a>4.7.2 解释</h4><ul>
<li>A接收来自查询和更新客户端的消息。 它根据更新客户端消息更新其状态，并回复查询客户端的查询。A receives messages from both query and update clients. It updates its state based on the update client messages and replies to queries from the query clients.</li>
<li>通常，A与元素B的备份副本B’部署在同一处理器上。在B发生故障之后，B’被提升，并且A和B都占用相同的处理器，直到启动新版本的B。 未定义将主节点B切换到刚启动的元素B的过程。A is normally deployed on the same processor as the backup copy B’ of the element B. Just after a failure occurs to B, B’ is promoted, and both A and B occupy the same processor until a new version of B is started. The process of switching the primary B to the just- started element B is not defined.</li>
<li>A每0.25秒向健康监视器发送一次心跳 A sends a heartbeat to the health monitor every 0.25 seconds.</li>
<li>A每分钟将其状态复制到检查点文件A。A copies its state to CheckpointFileA every minute.</li>
<li>A会累积由于更新客户端消息而导致的状态更改，并每1.0秒将其写入LogFileA。A accumulates the state changes made due to update client messages and writes them to LogFileA every 1.0 seconds. This write is synchronized with sending the check- point.</li>
<li>此写入与发送检查点同步。 A和A’的启动未解决(另一个团队)。 The start-up of A and A’ was not addressed (by another team).</li>
<li>proxy元素将收到一个请求，要求元素A的两个副本都失败，将停止发送更新，并通知必要的参与者。The proxy element will receive a request that both copies of the element A have failed, will stop sending updates, and will notify the necessary actors.</li>
<li>它使用命名服务注册与A和B关联的所有方法It registers all the methods associated with both A and B with the naming service.</li>
<li>它启动AA，AA’，BB和BB’，并在命名服务中注册其所有方法。 它通过映射客户端使用的名称(例如A.a)和元素创建的名称(例如AA.a和AA’.a)来创建缓存。 它确定哪个元素是主要元素，哪个是次要元素。It starts AA, AA’, BB, and BB’and registers all their methods with the naming service. It creates a cache by mapping the names used by the clients (e.g,, A.a) and the names created by the elements (e.g., AA.a and AA’ .a). It determines which element is primary and which is secondary.</li>
<li>当客户端请求服务时，它由同步或异步通信元素调用； 例如A.a. 如果AA是主要服务器，它会向AA.a发出”转发请求”。当运行状况监视器向代理发出信号通知主服务器(例如AA)发生故障时，它将向同步和异步通信元素发送转发请求，以访问所有备用方法(例如AA’.a)，从而提升AA’到主要位置。It is called by either the synchronous or asynchronous communication element when a client requests a service; e.g., A.a. It replies with a “forward request” to AA.a if AA is the primary.</li>
<li>When the health monitor signals the proxy that the primary (e.g, AA) has failed, it sends a forward request to both the synchronous and asynchronous communication elements to access all the standby methods (e.g., AA’ .a), thus promoting AA’ to be primary.</li>
<li>它接收来自更新客户端的对方法(例如A.a)的请求，并将该请求定向到适当的元素。It receives a request from the update clients to a method (e.g., A.a), and directs the request to the appropriate element.</li>
<li>它向名称服务器发送方法A.a，并接收对A.a代理元素的访问代码。It sends the name server the method A.a and receives the access code to the proxy element for A.a.</li>
<li>它将更新消息发送到代理元素A.a。It sends the update message to the proxy element A.a.</li>
<li>当收到转发给A.a的转发请求以将消息发送到A.a时，它将请求发送给A.a并缓存A.a的句柄。When receives the forward request for A.a to send the message to AA.a, it sends the request to AA.a and caches the handle for AA.a.</li>
<li>任何后续请求均直接向AA.a句柄发出。Any subsequent requests are made directly to the AA.a handle.</li>
<li>发生故障时，它将接收到AA’.a的转发请求，并将该句柄用于后续请求。When a failure occurs, it receives the forward request to AA’.a and uses that handle for subsequent requests.</li>
<li>如果Aa.a失败并且没有备用，它将通知更新客户端停止发送更新。If AA.a fails and there is no standby, it informs the update client to stop sending updates.</li>
</ul>
<h3 id="4-8-步骤-6-Define-interfaces-for-instantiated-elements"><a href="#4-8-步骤-6-Define-interfaces-for-instantiated-elements" class="headerlink" title="4.8 步骤 6: Define interfaces for instantiated elements"></a>4.8 步骤 6: Define interfaces for instantiated elements</h3><ul>
<li><p>接口描述了软件元素对彼此所做的 PROVIDES 和 REQUIRES 假设。</p>
<p>Interfaces describe the PROVIDES and REQUIRES assumptions that software elements make about one another.</p>
<ul>
<li>练习涉及您实例化的元素的<strong>功能要求</strong>。Exercise the functional requirements that involve the elements you instantiated.</li>
<li>观察由一个元素<strong>产生</strong>并由另一元素<strong>消耗</strong>的<strong>任何信息</strong>。Observe any information that is produced by one element and consumed by another.</li>
</ul>
</li>
</ul>
<h4 id="4-8-1-接口总结-Summary-of-Interfaces"><a href="#4-8-1-接口总结-Summary-of-Interfaces" class="headerlink" title="4.8.1 接口总结 Summary of Interfaces"></a>4.8.1 接口总结 Summary of Interfaces</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612162152424.png" alt="image-20230612162152424" style="zoom:80%;" /></p>
<h3 id="4-9-步骤-7：Verify-and-refine-requirements-and-make-them-constraints-for-instantiated-elements"><a href="#4-9-步骤-7：Verify-and-refine-requirements-and-make-them-constraints-for-instantiated-elements" class="headerlink" title="4.9 步骤 7：Verify and refine requirements and make them constraints for instantiated elements"></a>4.9 步骤 7：Verify and refine requirements and make them constraints for instantiated elements</h3><ul>
<li><strong>验证</strong>分配给<strong>父元素</strong>的所有需求是否已分配给一个或多个<strong>子元素</strong>。<br>Verify that all requirements assigned to the parent element have been allocated to one or more child elements.</li>
<li>将分配给子元素的所有<strong>职责转换</strong>为各个元素的<strong>功能需求</strong>。<br>Translate any responsibilities assigned to child elements into functional requirements for the individual elements.</li>
</ul>
<h4 id="4-9-1-架构上重要的要求-Architectually-Significant-Requirements"><a href="#4-9-1-架构上重要的要求-Architectually-Significant-Requirements" class="headerlink" title="4.9.1 架构上重要的要求 Architectually Significant Requirements"></a>4.9.1 架构上重要的要求 Architectually Significant Requirements</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612162215577.png" alt="image-20230612162215577"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/软件系统设计/">软件系统设计</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件架构/">软件架构</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/05/08/软件系统设计-架构-3-架构模式/"><span>软件系统设计-架构(3) 架构模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/05/08/软件系统设计-架构-3-架构模式/" rel="bookmark">
        <time class="entry-date published" datetime="2023-05-08T06:07:58.000Z">
          2023-05-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>架构模式是一组架构设计决策，适用于重复出现的设计问题，并进行了参数化处理以解决出现该问题的不同软件开发环境。<br>An architectural pattern is a set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears.</p>
<p>架构模式与DSSA相似，但适用于较低级别，范围更窄。<br>Architectural patterns are similar to DSSAs but applied at a lower level” and within a much narrower scope.</p>
<p>课本227页</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508141625196.png" alt="image-20230508141625196" style="zoom:80%;" /></p>
<h2 id="1-领域特定的软件架构-Domain-Specific-Software-Architecture"><a href="#1-领域特定的软件架构-Domain-Specific-Software-Architecture" class="headerlink" title="1. 领域特定的软件架构 Domain-Specific Software Architecture"></a>1. 领域特定的软件架构 Domain-Specific Software Architecture</h2><ul>
<li>领域特定的软件架构(DSSA)是软件组件的组合<br>Domain- Specific Software Architectures (DSSA) is an assemblage of software components<ul>
<li>专用于特定类型的任务(域)<br>specialized for a particular type of task (domain)</li>
<li>泛化以在该领域有效使用<br>generalized for effective use across that domain</li>
<li>由标准化结构（拓扑）组成，可有效构建成功的应用程序<br>composed in a standardized structure (topology) effective for building successful applications.</li>
</ul>
</li>
<li>DSSA是最大限度地<strong>重用</strong>知识和进行先期开发并因此开发新的架构设计的卓越手段<br>DSSAs are the pre-eminent means for maximal reuse of knowledge and prior development and hence for developing a new architectural design.</li>
</ul>
<h2 id="2-程序-设计模式-Program-Design-Patterns"><a href="#2-程序-设计模式-Program-Design-Patterns" class="headerlink" title="2. (程序)设计模式 (Program) Design Patterns"></a>2. (程序)设计模式 (Program) Design Patterns</h2><h2 id="3-架构模式-Architectural-Patterns"><a href="#3-架构模式-Architectural-Patterns" class="headerlink" title="3. 架构模式 Architectural Patterns"></a>3. 架构模式 Architectural Patterns</h2><ul>
<li>架构模式 Architecture pattern<ul>
<li>是在实践中<strong>反复</strong>发现的一套设计决策<br>is a package of design decisions that is found repeatedly in practice,</li>
<li>具有允许<strong>重复使用</strong>的已知属性，并且描述了<strong>一类</strong>架构<br>has known properties that permit reuse, and describes a class of architectures.</li>
</ul>
</li>
<li>架构模式建立了以下之间的<strong>关系</strong>：Architecture pattern establishes a relationship between:<ul>
<li><strong>上下文</strong>：一个世界上经常发生的普遍情况，会引起一个问题<br>A context: A recurring, common situation in the world that gives rise to a problem.</li>
<li>一个<strong>问题</strong>：在给定的上下文中出现的问题，经过适当概括<br>A problem: The problem, appropriately generalized, that arises in the given context.</li>
<li><strong>解决方案</strong>：针对问题的成功架构解决方案，并进行了适当抽象<br>A solution: A successful architecture resolution to the problem, appropriately abstracted. </li>
</ul>
</li>
<li>在实践中找到模式 Patterns are found in practice<ul>
<li>模式不是发明的，而是发现的 One does not invent patterns, one discovers them</li>
<li>永远不会有一个<strong>完整的模式列表</strong> There will never be a complete list of patterns</li>
</ul>
</li>
</ul>
<h3 id="3-1-分层模式-Layered-Pattern"><a href="#3-1-分层模式-Layered-Pattern" class="headerlink" title="3.1 分层模式 Layered Pattern"></a>3.1 分层模式 Layered Pattern</h3><p>对应4+1视图中的逻辑视图</p>
<h4 id="3-1-1-解决方案-Layered-Pattern-Solution"><a href="#3-1-1-解决方案-Layered-Pattern-Solution" class="headerlink" title="3.1.1 解决方案 Layered Pattern Solution"></a>3.1.1 解决方案 Layered Pattern Solution</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508172855333.png" alt="image-20230508172855333" style="zoom:80%;" /></p>
<p>层间的访问必须按照逐层进行访问</p>
<h4 id="3-1-2-堆叠盒表示法-Stack-of-boxes-Notation"><a href="#3-1-2-堆叠盒表示法-Stack-of-boxes-Notation" class="headerlink" title="3.1.2 堆叠盒表示法 Stack-of-boxes Notation"></a>3.1.2 堆叠盒表示法 Stack-of-boxes Notation</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508173032102.png" alt="image-20230508173032102" style="zoom:80%;" /></p>
<h4 id="3-1-3-基于分层模式的系统-Layered-Pattern-Based-System"><a href="#3-1-3-基于分层模式的系统-Layered-Pattern-Based-System" class="headerlink" title="3.1.3 基于分层模式的系统 Layered Pattern Based System"></a>3.1.3 基于分层模式的系统 Layered Pattern Based System</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508173041863.png" alt="image-20230508173041863" style="zoom:80%;" /></p>
<h4 id="3-1-4-分层模式变体-Layered-Pattern-Variants"><a href="#3-1-4-分层模式变体-Layered-Pattern-Variants" class="headerlink" title="3.1.4 分层模式变体 Layered Pattern Variants"></a>3.1.4 分层模式变体 Layered Pattern Variants</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508181748878.png" alt="image-20230508181748878" style="zoom:80%;" /></p>
<ul>
<li>上面的A、B、C：不是一种分层模式<ul>
<li>分层的核心是为了实现关注点分离</li>
<li>不是分层模式：<ul>
<li>形成了环状依赖</li>
<li>没有实现关注点分离，一个的修改可能有多个原因</li>
<li>是一种软件的坏味道</li>
</ul>
</li>
</ul>
</li>
<li>下面的A、B、C、D：是一种分层模式<ul>
<li>也可以是一种分层模式，D不期待A的结果且D不期待B的结果</li>
<li>而严格意义和其他场景中，不认为是一种分层模式</li>
</ul>
</li>
</ul>
<h4 id="3-1-5-分层模式对质量属性的影响"><a href="#3-1-5-分层模式对质量属性的影响" class="headerlink" title="3.1.5 分层模式对质量属性的影响"></a>3.1.5 分层模式对质量属性的影响</h4><ol>
<li>可修改性</li>
<li>可模块化</li>
<li>可维护性</li>
<li>可复用性</li>
</ol>
<h3 id="3-2-代理模式-Broker-Pattern"><a href="#3-2-代理模式-Broker-Pattern" class="headerlink" title="3.2 代理模式 Broker Pattern"></a>3.2 代理模式 Broker Pattern</h3><p>Broker可以理解为中间人，撮合双方达成交易。</p>
<h4 id="3-2-1-解决方案-Broker-Pattern-Solution"><a href="#3-2-1-解决方案-Broker-Pattern-Solution" class="headerlink" title="3.2.1 解决方案 Broker Pattern Solution"></a>3.2.1 解决方案 Broker Pattern Solution</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508182146084.png" alt="image-20230508182146084" style="zoom:80%;" /></p>
<h4 id="3-2-2-概述图"><a href="#3-2-2-概述图" class="headerlink" title="3.2.2 概述图"></a>3.2.2 概述图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508182335938.png" alt="image-20230508182335938" style="zoom:80%;" /></p>
<h4 id="3-2-3-质量属性体现模式的优缺点"><a href="#3-2-3-质量属性体现模式的优缺点" class="headerlink" title="3.2.3 质量属性体现模式的优缺点"></a>3.2.3 质量属性体现模式的优缺点</h4><blockquote>
<ul>
<li>优点<ul>
<li>Interoperability：根本目的，提高Server-Client之间的交互性</li>
<li>Scaliability：可伸缩和扩展</li>
<li>Modifiabiliy：</li>
<li>两面性：<ul>
<li>Security：代理对象屏蔽了系统内部的具体实现</li>
<li>Reliability：服务降级和实例重启</li>
<li>Availability：</li>
</ul>
</li>
</ul>
</li>
<li>缺点<ul>
<li>Security：成为被攻击的对象</li>
<li>Reliabiliy：可靠性会降低</li>
</ul>
</li>
<li>两面性：<ul>
<li>Performance：整体大集群的性能可能会提高(QPS等提高)，但是局部单点性能会下降，多次网络请求、多次匹配，有可能会抵消。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-3-模型-视图-控制器模式-Model-View-Controller-Pattern-MVC"><a href="#3-3-模型-视图-控制器模式-Model-View-Controller-Pattern-MVC" class="headerlink" title="3.3 模型-视图-控制器模式 Model-View-Controller Pattern(MVC)"></a>3.3 模型-视图-控制器模式 Model-View-Controller Pattern(MVC)</h3><ul>
<li>使用运行时、动态、相互之间的关系来审视，集成到了开发框架中，也是分层架构的变种(会强调各模块之间的约束关系，model不可以直接返回到controller)<ul>
<li>model 业务逻辑</li>
<li>view 处理用户展示，接收用户操作</li>
<li>controller 对用户操作进行处理，将信息通知给model</li>
</ul>
</li>
<li>model -&gt; controller 不会产生通信</li>
</ul>
<h4 id="3-3-1-解决方案"><a href="#3-3-1-解决方案" class="headerlink" title="3.3.1 解决方案"></a>3.3.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508182557555.png" alt="image-20230508182557555" style="zoom:80%;" /></p>
<h4 id="3-3-2-概述图"><a href="#3-3-2-概述图" class="headerlink" title="3.3.2 概述图"></a>3.3.2 概述图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230508182734832.png" alt="image-20230508182734832"  /></p>
<h3 id="3-4-管道和过滤器模式-Pipe-and-Filter-Pattern"><a href="#3-4-管道和过滤器模式-Pipe-and-Filter-Pattern" class="headerlink" title="3.4 管道和过滤器模式 Pipe-and-Filter Pattern"></a>3.4 管道和过滤器模式 Pipe-and-Filter Pattern</h3><ul>
<li>filter：相当于component，起到数据处理、计算作用，每个filter有input和多个output，数据处理后传递给后续的部分。</li>
<li>pipe：连接filter，相当于connector，将output导入到其他的filter的input中去，不会孤立存在。</li>
<li>管道和过滤模式不会孤立存在，应用在顺序处理结构，有一系列的数据结构filter，体现依赖关系。</li>
<li>场景应用在科学计算的场景中，需要避免出现环形的filter，不适用于有很多交互产生的场景。</li>
</ul>
<h4 id="3-4-1-解决方案"><a href="#3-4-1-解决方案" class="headerlink" title="3.4.1 解决方案"></a>3.4.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509101001324.png" alt="image-20230509101001324" style="zoom:80%;" /></p>
<h4 id="3-4-2-基于管道和过滤器模式的系统"><a href="#3-4-2-基于管道和过滤器模式的系统" class="headerlink" title="3.4.2 基于管道和过滤器模式的系统"></a>3.4.2 基于管道和过滤器模式的系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509101156013.png" alt="image-20230509101156013" style="zoom:80%;" /></p>
<ul>
<li>每一组件表示filter，连接两个组件的部分是pipe(类似于queue交易任务的排队等待处理)</li>
<li>任何一个filter都依赖于前一个filter的输出，中间没有机会接收外部的交互来改变严格定义好的流程。</li>
<li>不适用于一些可以引入变形的场景(相互独立、不依赖前面的产出，会带来损耗)</li>
</ul>
<h3 id="3-5-客户端-服务端模式-Client-Server-Pattern"><a href="#3-5-客户端-服务端模式-Client-Server-Pattern" class="headerlink" title="3.5 客户端-服务端模式 Client-Server Pattern"></a>3.5 客户端-服务端模式 Client-Server Pattern</h3><ul>
<li>包含两类不同的component</li>
<li>请求发起client、server接收请求，这里没有broker，不能动态改变client和server的关系，相对更固定，但是一个client可以连接多个server</li>
<li>一个component在一个关系中可以是client，也可能是server，非绝对，但是成对的关系相对固定。</li>
<li>会受到负载的限制。</li>
<li>Server可能有性能瓶颈，但是可以通过事先规划避免。</li>
<li>Server可能单点失效，但是broker可以控制</li>
</ul>
<h4 id="3-5-1-解决方案"><a href="#3-5-1-解决方案" class="headerlink" title="3.5.1 解决方案"></a>3.5.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509131852683.png" alt="image-20230509131852683" style="zoom:80%;" /></p>
<h4 id="3-5-2-基于客户端-服务端模式的系统"><a href="#3-5-2-基于客户端-服务端模式的系统" class="headerlink" title="3.5.2 基于客户端-服务端模式的系统"></a>3.5.2 基于客户端-服务端模式的系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509131935722.png" alt="image-20230509131935722" style="zoom:80%;" /></p>
<ul>
<li>ATM 验证身份，某一个server会给很多设备提供服务。</li>
<li>ATM 操作安全监控、盗刷之类，通过 monitoring 发现问题找到记录</li>
<li>对银行工作人员而言，需要新的业务，policy发生变化，银行工作人员定义ATM上的操作</li>
<li>银行负责安全金融的根据ATM、对照用户操作行为是否有安全隐患，多对多。</li>
<li>问题：broker也存在client和server之间的关系，对质量属性的影响，做一下比较，broker是之前，c/s是90年代流行广泛应用<ol>
<li>互操作性：可能导致变弱？没有broker，需要人为连接</li>
<li>安全性：Client、Server不采用broker 可能被拦截</li>
<li>伸缩性</li>
<li>性能</li>
<li>可修改性</li>
</ol>
</li>
<li>小型局域网、互联网还没有普及，规模有限，直接联系，性能上安全性可能带来更大收益</li>
<li>broker的一些负面影响就不必承担了，c/s会比broker投入更少，收益可能更大</li>
</ul>
<h3 id="3-6-Peer-to-Peer-Pattern-点对点模式"><a href="#3-6-Peer-to-Peer-Pattern-点对点模式" class="headerlink" title="3.6 Peer-to-Peer Pattern 点对点模式"></a>3.6 Peer-to-Peer Pattern 点对点模式</h3><ul>
<li>这一刻是提供者，下一刻就是消费者，是对等的。</li>
<li>不单单提供服务，还能提供物流(对于整个网络)</li>
<li>对每一个peer可能会给他一个规定对的连接数</li>
</ul>
<h4 id="3-6-1-解决方案"><a href="#3-6-1-解决方案" class="headerlink" title="3.6.1 解决方案"></a>3.6.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509132055841.png" alt="image-20230509132055841" style="zoom:80%;" /></p>
<h4 id="3-6-2-基于点对点模式的系统"><a href="#3-6-2-基于点对点模式的系统" class="headerlink" title="3.6.2 基于点对点模式的系统"></a>3.6.2 基于点对点模式的系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509132519307.png" alt="image-20230509132519307" style="zoom:80%;" /></p>
<ul>
<li>可能安全性不受保障，因为节点既是Client又是Server，被攻击可能性提高了，attack、surface受攻击面变大</li>
<li>数据分布在不同的节点上，相同数据多处拷贝，如果要的话，可能会导致数据不一致(数据一致性难度更大)，不能保证数据一定可用，数据可用性不能百分之百保证。</li>
<li>可用性 availability，同一个数据多个副本，所以个别数据出问题不影响整体。</li>
<li>但又不能保证availability，不会以后任何一个节点有权限。</li>
<li>Performance：多个节点同时提供服务，性能快(多个渠道获取数据，并行能力提高)</li>
</ul>
<h3 id="3-7-Service-Oriented-Pattern-面向服务的模式"><a href="#3-7-Service-Oriented-Pattern-面向服务的模式" class="headerlink" title="3.7 Service-Oriented Pattern 面向服务的模式"></a>3.7 Service-Oriented Pattern 面向服务的模式</h3><ul>
<li>broker架构的延续。</li>
<li>component包含服务提供者、服务消费者。</li>
<li>除了这些component还有ESB、企业服务组件、连接处理，包括发现、注册。</li>
<li>Registry of Services</li>
<li>Orchestration Server 不同的Service按照一定的顺序进行编排，提供更高级的(申请贷款流程)</li>
<li>Connectors：<ul>
<li>SOAP：</li>
<li>REST：</li>
<li>Asynchronous messaging connector</li>
</ul>
</li>
</ul>
<h4 id="3-7-1-解决方案"><a href="#3-7-1-解决方案" class="headerlink" title="3.7.1 解决方案"></a>3.7.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509132900563.png" alt="image-20230509132900563" style="zoom:80%;" /></p>
<h4 id="3-7-2-基于SOA的系统"><a href="#3-7-2-基于SOA的系统" class="headerlink" title="3.7.2 基于SOA的系统"></a>3.7.2 基于SOA的系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509133010845.png" alt="image-20230509133010845" style="zoom:80%;" /></p>
<ul>
<li>旅行社有一系列需求</li>
<li>真正提供服务的是酒店、导游之类的，系统需要通过Web Service Broker连接到不同的真正提供者。下单：商家发货。</li>
</ul>
<h4 id="3-7-3-SOA中的连接器-Connectors-in-SOA"><a href="#3-7-3-SOA中的连接器-Connectors-in-SOA" class="headerlink" title="3.7.3 SOA中的连接器 Connectors in SOA"></a>3.7.3 SOA中的连接器 Connectors in SOA</h4><ul>
<li><strong>SOAP</strong>(简单对象访问协议)：服务使用者和提供者通过通常在<strong>HTTP之上</strong>交换请求/答复<strong>XML消息</strong>进行交互<br>SOAP (Simple Object Access Protocol): Service consumers and providers interact by exchanging request/reply XML messages typically on top of HTTP</li>
<li><strong>REST</strong>(表征状态转移)：服务使用者发送依赖于<strong>四个</strong>基本<strong>HTTP命令(POST，GET，PUT，DELETE)</strong>的HTTP请求<br>REST (Representational State Transfer) : A service consumer sends HTTP requests that rely on four basic HTTP commands (POST, GET, PUT, DELETE)</li>
<li><strong>异步消息传递</strong>(“<strong>即发即忘</strong>”)：参与者不必等待接受确认<br>Asynchronous messaging (“fire-and-forget”): Participants do not have to wait for an acknowledgment of receipt.</li>
</ul>
<h4 id="3-7-4-SOA和其他架构的区别"><a href="#3-7-4-SOA和其他架构的区别" class="headerlink" title="3.7.4 SOA和其他架构的区别"></a>3.7.4 SOA和其他架构的区别</h4><ul>
<li>具备broker的优势，这里又不想继承broker，所以broker消失了</li>
<li>出现类似集基础设施的组件，代替单一节点broker，单点失效的问题消失了</li>
<li>商业模式的变化、看技术可用性</li>
<li>基础条件——互联网普及范围参与者人数规模比以往大这样一个背景下打破broker c-s</li>
<li>追求更高互操作性更高伸缩性</li>
<li>技术条件下提供的服务越来越多现在可以分得更细更大差异化更细粒度的组合可以实现出来社会分工越来越细（不同航空公司不同酒店细粒度体现如果固定就很难实现差异化）微服务也是这样的体现服务粒度越来越小是有很多技术条件支持的（单体系统内部复杂度外化外面复杂度可以进行动态绑定可以提供多样化服务）</li>
</ul>
<h3 id="3-8-发布-订阅模式-Publish-Subscribe-Pattern"><a href="#3-8-发布-订阅模式-Publish-Subscribe-Pattern" class="headerlink" title="3.8 发布-订阅模式 Publish-Subscribe Pattern"></a>3.8 发布-订阅模式 Publish-Subscribe Pattern</h3><ul>
<li>subscribe注册对于publiser进行注册</li>
<li>某一个publiser发布自己的消息可能订阅其他消息（朋友圈微博）</li>
</ul>
<h4 id="3-8-1-解决方案"><a href="#3-8-1-解决方案" class="headerlink" title="3.8.1 解决方案"></a>3.8.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509135114614.png" alt="image-20230509135114614" style="zoom:80%;" /></p>
<ul>
<li>传统操作系统也是通过事件驱动方式来管理的</li>
<li>IDE环境注册后就行结构发布的事件</li>
<li>数据发生变化会反映到环境中去</li>
<li>性能上的延迟（可限制subscriber数量订阅越多性能下降）</li>
<li>scalability publisher数量不会变多</li>
<li>发布者不关心每个订阅者都收到不是guarantee</li>
</ul>
<h4 id="3-8-2-基于发布-订阅模式的系统"><a href="#3-8-2-基于发布-订阅模式的系统" class="headerlink" title="3.8.2 基于发布-订阅模式的系统"></a>3.8.2 基于发布-订阅模式的系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509135230707.png" alt="image-20230509135230707" style="zoom:80%;" /></p>
<h3 id="3-9-共享数据模式-Shared-Data-Pattern"><a href="#3-9-共享数据模式-Shared-Data-Pattern" class="headerlink" title="3.9 共享数据模式 Shared-Data Pattern"></a>3.9 共享数据模式 Shared-Data Pattern</h3><p>中间安全数据会被很多人共享登录访问</p>
<h4 id="3-9-1-解决方案"><a href="#3-9-1-解决方案" class="headerlink" title="3.9.1 解决方案"></a>3.9.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509135326701.png" alt="image-20230509135326701" style="zoom:80%;" /></p>
<ul>
<li>这样一个系统模式有什么问题嘛？</li>
<li>单点失效性能瓶颈问题（都要对它操作） 安全性（攻击中心点有风险）对安全性数据来说强调强一致性如果有副本有一段时间才能到其他副本上更（可能成为漏洞任何时刻访问数据都必须一致）</li>
<li>一致性<ul>
<li>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）</li>
<li>看哪个更重要只能同时实现两者</li>
<li>其他实现一致性方式：最终一致性（不保证任何时候访问数据都一致但是可以保证最终结果要一致） 互联网不可能牺牲可用性也必须是分布式结构（面对分布在很多地方保证信号要求） 一致性设计难度非常大</li>
</ul>
</li>
</ul>
<h4 id="3-9-2-基于共享数据模式的系统"><a href="#3-9-2-基于共享数据模式的系统" class="headerlink" title="3.9.2 基于共享数据模式的系统"></a>3.9.2 基于共享数据模式的系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509135413329.png" alt="image-20230509135413329" style="zoom:80%;" /></p>
<p>既有读又有写</p>
<h3 id="3-10-Map-Reduce-Pattern"><a href="#3-10-Map-Reduce-Pattern" class="headerlink" title="3.10 Map-Reduce Pattern"></a>3.10 Map-Reduce Pattern</h3><ul>
<li>软件和外部环境的关系 部署</li>
<li>map对数据进行抽取所需要的信息信息转换</li>
<li>可以有多个map 处理数据工作内容不一样</li>
<li>相互独立可以运行</li>
<li>reduce进行合并产出想要的答案</li>
</ul>
<h4 id="3-10-1-解决方案"><a href="#3-10-1-解决方案" class="headerlink" title="3.10.1 解决方案"></a>3.10.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509135538285.png" alt="image-20230509135538285" style="zoom:80%;" /></p>
<ul>
<li>map reduce部署在不同的地方</li>
<li>词频分析案例大量数据</li>
<li>Map-Reduce Based System</li>
<li>每一个partition对应一个map 每一个map任务一样不同实例</li>
<li>所有词汇使用频率标注出来</li>
<li>通过reduce进行合并</li>
<li>最后进行排序</li>
</ul>
<h4 id="3-10-2-基于Map-Reduce模式的系统"><a href="#3-10-2-基于Map-Reduce模式的系统" class="headerlink" title="3.10.2 基于Map-Reduce模式的系统"></a>3.10.2 基于Map-Reduce模式的系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509135604677.png" alt="image-20230509135604677" style="zoom:80%;" /></p>
<h3 id="3-11-Multi-Tier-Pattern-多层模式"><a href="#3-11-Multi-Tier-Pattern-多层模式" class="headerlink" title="3.11 Multi-Tier Pattern 多层模式"></a>3.11 Multi-Tier Pattern 多层模式</h3><ul>
<li>部署的环境划分</li>
<li>layer是真实存在的</li>
<li>这里是逻辑的组合没有和层的强依赖关系</li>
<li>不同的部署环境里面分层不同但是软件完成内容一样</li>
</ul>
<h4 id="3-11-1-解决方案"><a href="#3-11-1-解决方案" class="headerlink" title="3.11.1 解决方案"></a>3.11.1 解决方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509135626778.png" alt="image-20230509135626778" style="zoom:80%;" /></p>
<ul>
<li>旅行社例子</li>
<li>tier只是部署方案决定并没有改变代码本身</li>
</ul>
<h4 id="3-11-2-基于多层模式的系统"><a href="#3-11-2-基于多层模式的系统" class="headerlink" title="3.11.2 基于多层模式的系统"></a>3.11.2 基于多层模式的系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509135718648.png" alt="image-20230509135718648" style="zoom:80%;" /></p>
<p>三大类：modular类、runtime process动态类、软件和非软件环境关系（部署关系）11个架构模式</p>
<h3 id="3-12-不同的模式对于质量属性不同的影响"><a href="#3-12-不同的模式对于质量属性不同的影响" class="headerlink" title="3.12 不同的模式对于质量属性不同的影响"></a>3.12 不同的模式对于质量属性不同的影响</h3><p>某一个Pattern会对一些质量属性产生积极影响，但是也会对其他属性产生不好的影响</p>
<h2 id="4-模式与策略-Architecture-Patterns-and-Tactics"><a href="#4-模式与策略-Architecture-Patterns-and-Tactics" class="headerlink" title="4. 模式与策略 Architecture Patterns and Tactics"></a>4. 模式与策略 Architecture Patterns and Tactics</h2><ul>
<li>策略比模式简单。他们使用<strong>单一的结构或机制</strong>来应对<strong>单一的架构力量</strong><br>Tactics are simpler than patterns; they use a single structure or mechanism to address a single architectural force.</li>
<li>模式通常将多个设计决策组合到一个包中<br>Patterns typically combine multiple design decisions into a package.</li>
<li>模式和策略共同构成了软件设计师的主要工具<br>Patterns and tactics together constitute the software architect’s primary tools.</li>
<li><strong>策略是设计的“构建块”</strong>，从中创建架构模式。<br>Tactics are “building blocks” of design from which architectural patterns are created.</li>
<li>大多数模式包含几种不同的策略 Most patterns consist of several different tactics that may:<ul>
<li>都有共同的目的 all serve a common purpose,</li>
<li>经常被选择来承诺不同的质量属性 be often chosen to promise different quality attributes</li>
</ul>
</li>
<li>示例：分层模式 Example: layered pattern<ul>
<li>提高语义连贯性 Increase semantic coherence</li>
<li>限制依赖 Restrict dependencies</li>
</ul>
</li>
<li>tactic是设计最小粒度tactic进行组合一个tactic是为了某一个质量属性也会影响其他属性（正面、负面）</li>
<li>针对某一个质量属性Modifiablity 相关的 tactic 和 pattern 之间的关系是否涉及到</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509141058889.png" alt="image-20230509141058889" style="zoom:80%;" /></p>
<ol>
<li>设计深度问题</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230509141138497.png" alt="image-20230509141138497"  /></p>
<p>图一：</p>
<ul>
<li>椭圆形——某一个 tactic 如ping/Echo</li>
<li>可用性有贡献但是可能会产生其他影响（系统复杂度、资源影响、性能）</li>
<li>如果性能很在意就对它单独进行设计成本、增加资源利用率问题</li>
</ul>
<p>图三：</p>
<ul>
<li>为了提高利用率需要引入调度机制</li>
<li>最终判断是ASR<ul>
<li>负面影响系统可以容忍对最在意的 ASR 可以忽略就可以停止，每一个 tactic 都会增加系统复杂度和规模</li>
<li>没有足够人力物力实现也可以停止</li>
<li>整个过程不断迭代最后达成妥协</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/软件系统设计/">软件系统设计</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件架构/">软件架构</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/2/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/4/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Whale
    
  </p>
</footer>
    
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>