<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="码农预备役">
<meta property="og:type" content="website">
<meta property="og:title" content="Whale&#39;s Blog">
<meta property="og:url" content="https://whale-lyi.github.io/page/6/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="码农预备役">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Whale">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://whale-lyi.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-6-LLVM-IR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-6-LLVM-IR/" class="post-title-link" itemprop="url">编译原理(6) LLVM IR</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-19 16:02:03" itemprop="dateCreated datePublished" datetime="2022-12-19T16:02:03+08:00">2022-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h1><h2 id="一、LLVM-IR-简介"><a href="#一、LLVM-IR-简介" class="headerlink" title="一、LLVM IR 简介"></a>一、LLVM IR 简介</h2><h3 id="1-LLVM"><a href="#1-LLVM" class="headerlink" title="1. LLVM"></a>1. LLVM</h3><blockquote>
<p>基础设施而非编译器</p>
<p>目标: 模块化，可重用</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221222200423196.png" alt="image-20221222200423196" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221222200437641.png" alt="image-20221222200437641" style="zoom:80%;" /></p>
<ul>
<li>包含范围(黄色)</li>
<li>Clang 为 LLVM 子项目，狭义上的 LLVM 并不包含 Clang</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223001148768.png" alt="image-20221223001148768" style="zoom:80%;" /></p>
<h3 id="2-Clang"><a href="#2-Clang" class="headerlink" title="2. Clang"></a>2. Clang</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223001849775.png" alt="image-20221223001849775" style="zoom:80%;" /></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 和 GCC 类似，直接编译为可执行文件</span><br>clang .\hello.c -o hello<br><span class="hljs-comment"># -ast-dump 得到抽象语法树</span><br>clang -Xclang -ast-dump -c hello.c<br></code></pre></td></tr></table></figure>
<h3 id="3-IR"><a href="#3-IR" class="headerlink" title="3. IR"></a>3. IR</h3><h4 id="3-1-IR"><a href="#3-1-IR" class="headerlink" title="3.1 IR"></a>3.1 IR</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219162837400.png" alt="image-20221219162837400" style="zoom:80%;" /></p>
<p>IR: Intermediate Representation(中间表示)</p>
<p>LLVM IR: <strong>带有类型的</strong>、介于高级程序设计语言与汇编语言之间</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组成</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>IR 的基本单位，每个 Module 对应一个 .c 文件</td>
</tr>
<tr>
<td>Function / Global variables</td>
<td>每个 Module 中有若干函数与全局变量</td>
</tr>
<tr>
<td>Basic Block</td>
<td>基本块，由若干指令构成。但是<strong>除了最后一条指令</strong>(返回或跳转到其他基本块)，全部都是<strong>顺序执行指令</strong>，不能是分支或跳转</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-2-LLVM-IR"><a href="#3-2-LLVM-IR" class="headerlink" title="3.2 LLVM IR"></a>3.2 LLVM IR</h4><p><strong>示例</strong></p>
<h5 id="opt0"><a href="#opt0" class="headerlink" title="opt0"></a>opt0</h5><ul>
<li><code>factorial0.c</code></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223164427023.png" alt="image-20221223164427023" style="zoom:80%;" /></p>
<ul>
<li><p><code>clang -S -emit-llvm factorial0.c -o f0-opt0.ll</code></p>
<blockquote>
<p>-S: 生成的中间表示是人类可阅读的</p>
<p>-emit-llvm: 生成中间代码就可以停止</p>
</blockquote>
</li>
<li><p>f0-opt0.ll</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223164448062.png" alt="image-20221223164448062" style="zoom:80%;" /></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>;</td>
<td>注释 <code>;xxx</code></td>
</tr>
<tr>
<td>optnone</td>
<td>没有优化</td>
</tr>
<tr>
<td>declare</td>
<td>声明函数</td>
</tr>
<tr>
<td>define</td>
<td>定义函数</td>
</tr>
<tr>
<td>@</td>
<td>全局符号(全局变量/函数名) <code>@main</code></td>
</tr>
<tr>
<td>%</td>
<td>局部变量 <code>%</code></td>
</tr>
<tr>
<td>i32/i8</td>
<td>32位/8位整型, 类型信息, llvm是强类型</td>
</tr>
<tr>
<td>*</td>
<td>指针, <code>i32*</code></td>
</tr>
<tr>
<td>icmp</td>
<td>整数间的比较</td>
</tr>
<tr>
<td>alloca</td>
<td>分配空间，返回的是指针, 如 i32*</td>
</tr>
<tr>
<td>align n</td>
<td>n字节对齐, <code>align 4</code></td>
</tr>
<tr>
<td>store</td>
<td>存储数据</td>
</tr>
<tr>
<td>call</td>
<td>调用函数</td>
</tr>
<tr>
<td>zext</td>
<td>扩展</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>三地址码(TAC: Three-Address Code, 也称三地址指令)</p>
<ul>
<li>LLVM 所有指令操作数都小于等于3</li>
<li><code>mul</code>: 两个操作数 + 一个存结果的虚拟寄存器</li>
</ul>
<p>静态单赋值(SSA: Static Single Assignment)</p>
<ul>
<li>每一个变量都只允许定义一次</li>
</ul>
</blockquote>
<h5 id="opt1"><a href="#opt1" class="headerlink" title="opt1"></a>opt1</h5><ul>
<li><p><code>clang -S -emit-llvm factorial0.c -o f0-opt1.ll -O1 -g0</code></p>
<blockquote>
<p>-o1: 进行优化</p>
<p>-g0: 去掉 debug 相关信息</p>
</blockquote>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223180457115.png" alt="image-20221223180457115" style="zoom:80%;" /></p>
<ul>
<li>可以看到 <code>alloca, store</code> 部分代码被删去<ul>
<li>解释一: 函数参数没有用到</li>
<li><strong>解释二</strong>: <code>alloca, store</code> 是内存操作(memory), 其他则是虚拟寄存器操作(register), 使用 <code>-o1</code> 往往会<strong>将内存操作优化掉</strong></li>
</ul>
</li>
</ul>
<h3 id="4-SSA"><a href="#4-SSA" class="headerlink" title="4. SSA"></a>4. SSA</h3><h4 id="4-1-phi-函数"><a href="#4-1-phi-函数" class="headerlink" title="4.1 $\phi$ 函数"></a>4.1 $\phi$ 函数</h4><blockquote>
<p>上面的例子都是顺序执行代码，如果遇到分支语句如何满足 SSA</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223181451471.png" alt="image-20221223181451471" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223211226055.png" alt="image-20221223211226055" style="zoom:80%;" /></p>
<blockquote>
<p>$\phi$ 函数在 LLVM IR 中是一种高级的指令(抽象的), 不对应于具体的机器指令(没有机器指令可以实现)</p>
<p>通常通过分配给一个寄存器或存储到一个公共堆栈内存位置来完成</p>
</blockquote>
<h4 id="4-2-CFG"><a href="#4-2-CFG" class="headerlink" title="4.2 CFG"></a>4.2 CFG</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223211527170.png" alt="image-20221223211527170" style="zoom:80%;" /></p>
<blockquote>
<p>系统调用图只显示了函数间的调用关系, 我们也想了解函数内部的控制流信息</p>
<ul>
<li>使用控制流图</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223211912503.png" alt="image-20221223211912503" style="zoom:80%;" /></p>
<h4 id="4-3-举例-递归"><a href="#4-3-举例-递归" class="headerlink" title="4.3 举例(递归)"></a>4.3 举例(递归)</h4><h5 id="opt0-1"><a href="#opt0-1" class="headerlink" title="opt0"></a>opt0</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223212142241.png" alt="image-20221223212142241" style="zoom:80%;" /></p>
<blockquote>
<p>factorial 函数翻译后被分为 4 段(基本块)</p>
<p>即, 每个<strong>函数</strong>被分为若干<strong>基本块</strong></p>
</blockquote>
<p>上方代码之所以没有用到 $\phi$ 函数, 是因为使用了 <code>store load</code> 指令</p>
<ul>
<li>基本块最后一条指令(结束指令)</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223212902324.png" alt="image-20221223212902324" style="zoom:80%;" /></p>
<h5 id="opt1-1"><a href="#opt1-1" class="headerlink" title="opt1"></a>opt1</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223213036680.png" alt="image-20221223213036680" style="zoom:80%;" /></p>
<p>优化后不使用 <code>store load</code> 内存操作, 需要使用 $\phi$ 函数</p>
<p><a target="_blank" rel="noopener" href="https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/control-structures/ssa-phi.html">Single-Static Assignment Form and PHI(How to implement it?)</a></p>
<h5 id="opt3"><a href="#opt3" class="headerlink" title="opt3"></a>opt3</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223214428140.png" alt="image-20221223214428140" style="zoom:80%;" /></p>
<h4 id="4-4-举例-循环"><a href="#4-4-举例-循环" class="headerlink" title="4.4 举例(循环)"></a>4.4 举例(循环)</h4><h5 id="opt0-2"><a href="#opt0-2" class="headerlink" title="opt0"></a>opt0</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223214627570.png" alt="image-20221223214627570" style="zoom:80%;" /></p>
<h5 id="opt1-2"><a href="#opt1-2" class="headerlink" title="opt1"></a>opt1</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223214917187.png" alt="image-20221223214917187" style="zoom:80%;" /></p>
<blockquote>
<p>这里做了一个优化, 将判断条件取反, 即判断 val 是否小于 2</p>
<p>为了符合 SSA, 需要对 i 与 temp 进行选择, 分别对应 %6 %7 </p>
</blockquote>
<h5 id="opt3-1"><a href="#opt3-1" class="headerlink" title="opt3"></a>opt3</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221223215450428.png" alt="image-20221223215450428" style="zoom:80%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/09/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-7-Node-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/09/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-7-Node-js/" class="post-title-link" itemprop="url">Web前端开发(7) Node.js</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-09 14:06:01" itemprop="dateCreated datePublished" datetime="2022-12-09T14:06:01+08:00">2022-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="9-Node-js"><a href="#9-Node-js" class="headerlink" title="9-Node.js"></a>9-Node.js</h1><h2 id="1-服务端编程"><a href="#1-服务端编程" class="headerlink" title="1. 服务端编程"></a>1. 服务端编程</h2><h4 id="静态网页与动态网页"><a href="#静态网页与动态网页" class="headerlink" title="静态网页与动态网页"></a>静态网页与动态网页</h4><p>静态页面</p>
<ul>
<li>客户/消费者的观点: 一个url指向同一个html文件</li>
<li>服务器/生产者的观点: 存储在Web服务器根文件夹内或子文件夹内的文件</li>
<li>HTML文件: 无论何时当一个特定资源被请求的时候都返回相同的被硬编码的内容</li>
<li>可以直接在浏览器上显示</li>
</ul>
<p>动态页面</p>
<ul>
<li>客户/消费者的观点: url指的是动态html(可能每次请求都不同)</li>
<li>服务器/生产者的观点: 程序/脚本生成html</li>
<li>它不是一个html, 而是一个程序产生的html(s), 页面通常是通过将数据库的数据植入到HTML模板中的占位符中而产生的。</li>
<li>不能直接在浏览器中显示</li>
</ul>
<h4 id="服务端编程"><a href="#服务端编程" class="headerlink" title="服务端编程"></a>服务端编程</h4><ul>
<li>服务器端页面是使用多种web编程语言/框架之一编写的程序<ul>
<li>例如: PHP, Java/JSP, Ruby on Rails, ASP.NET, Python, Perl</li>
</ul>
</li>
<li>每种语言/框架都有其优点和缺点</li>
</ul>
<h4 id="服务端编程的优势"><a href="#服务端编程的优势" class="headerlink" title="服务端编程的优势"></a>服务端编程的优势</h4><ul>
<li>信息的高效存储和传输、定制用户体验、控制对内容的访问、存储会话和状态信息、通知和通讯、数据分析</li>
</ul>
<h2 id="2-Node-js"><a href="#2-Node-js" class="headerlink" title="2. Node.js"></a>2. Node.js</h2><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><ul>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/">Node</a>(正式名称 Node.js)是一个开源的、跨平台的运行时环境</li>
<li>服务端Javascript: 开发人员可以使用 JavaScript 创建各种服务器端工具和应用程序</li>
<li>事件驱动, 异步I/O框架</li>
<li>性能: 在v8之上的c++内核</li>
<li>在单一进程中可以最小的开销(cpu/内存)处理成千上万的并发连接</li>
<li>模块系统</li>
<li>不是一个web框架, 也不是一种语言</li>
</ul>
<blockquote>
<p>Node.js is a platform built on <a target="_blank" rel="noopener" href="http://code.google.com/p/v8/">Chrome’s JavaScript runtime</a> for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices. — from nodejs.org</p>
</blockquote>
<h4 id="Node-js-的诞生"><a href="#Node-js-的诞生" class="headerlink" title="Node.js 的诞生"></a>Node.js 的诞生</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126145036774.png" alt="image-20230126145036774" style="zoom:80%;" /></p>
<h4 id="Node-js-现状"><a href="#Node-js-现状" class="headerlink" title="Node.js 现状"></a>Node.js 现状</h4><ul>
<li>2018 年 5 月 31 日, Node.js 基⾦会发布的用户调查报告, 显示学习 Node.js 看起来更容易了, 少于 2 年 node 经验的用户中, 有 43% 的觉得”容易”。绝大多数(85%)Node.js 用户用于网页开发, 43% 参与一些企业级开发, 13% 用于大数据分析, 8% 用于嵌入式系统。</li>
</ul>
<h4 id="Node-js-应用场景"><a href="#Node-js-应用场景" class="headerlink" title="Node.js 应用场景"></a>Node.js 应用场景</h4><ul>
<li>网站(如express/koa等)</li>
<li>im即时聊天(socket.io)</li>
<li>api(移动端, pc, h5)</li>
<li>HTTP Proxy(淘宝、Qunar、腾讯、百度都有)</li>
<li>前端构建工具(grunt/gulp/bower/webpack/fis3…)</li>
<li>写操作系统(NodeOS)</li>
<li>跨平台打包工具(PC端的electron、nw.js, 比如钉钉PC客户端、微信小程序IDE、微信客户端, 移动的cordova, 即老的 Phonegap, 还有更加有名的一站式开发框架ionicframework)</li>
<li>命令行工具(比如cordova、shell.js)</li>
<li>反向代理(比如anyproxy, node-http-proxy)</li>
</ul>
<h4 id="Node-优势"><a href="#Node-优势" class="headerlink" title="Node 优势"></a>Node 优势</h4><p>从 web 服务器开发的⻆度来看, Node 有很多好处: </p>
<ul>
<li>卓越的性能表现！Node 为优化 web 应用的吞吐量和扩展度而生, 对常见的 web 开发问题是一套绝佳方案(比如实时 web 应用)</li>
<li>代码还是熟悉的老伙伴 JavaScript, 这意味着在客户端和服务器端”上下文切换”的时间成本更低</li>
<li>与传统的 web 服务器语言(例如 Python、PHP 等)相比, JavaScript 理念更新, 语言设计的改进带来了诸多好处。许多其它新近流行的语言也可编译/转换成 JavaScript, 所以 TypeScript、CoffeeScript、ClojureScript、Scala、LiveScript 等等也可以使用</li>
<li>Node 包管理工具(node package manager, NPM)提供了数十万个可重用的工具包。它还提供了一流的依赖解决方案, 可实现自动化工具链构建</li>
<li>Node.js 是可移植的, 可运行于 Microsoft Windows、macOS、Linux、Solaris、FreeBSD、OpenBSD、WebOS 和 NonStop OS。此外, 许多 web 主机供应商对其提供了良好支持(包括专用的基础框架和构建 Node 站点的文档)</li>
<li>它有一个非常活跃的第三方生态系统和开发者社区, 很多人愿意提供帮助</li>
</ul>
<h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><ul>
<li>Node所针对的应用程序有一个专门的简称: DIRT, 表示数据密集型实时(data-intensive real-time)程序</li>
<li>性能和I/O负载: Nodejs非常好的解决了IO密集的问题, 通过异步IO来实现</li>
<li>大前端的基石</li>
<li>从脚⼿架、辅助前端开发(比如 SSR、PWA 等)的快速开发实践, 到 API 中间层、代理层, 到专业的后端开发都有非常成熟的经验</li>
<li>全栈</li>
</ul>
<h4 id="Node-js-不适合的领域"><a href="#Node-js-不适合的领域" class="headerlink" title="Node.js 不适合的领域"></a>Node.js 不适合的领域</h4><ul>
<li>计算密集型应用</li>
<li>内存控制</li>
<li>大内存的应用, 由于V8引擎有内存设计的限制, 32位环境中最大堆是 1G, 64位环境中最大堆也不到2G, 如果要一次读入 10G 数据, 对于 Nodejs来说也无法实现</li>
<li>静态服务器, 虽然Nodejs的优势在IO密集集应用, 但是和 Nginx 的处理静态资源还是有很大的差距</li>
<li>不需要异步的应用: 比如系统管理, 自行化脚本等, Nodejs的异步调用可能会给编程带来一些麻烦。</li>
</ul>
<h2 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3. 事件循环"></a>3. 事件循环</h2><h4 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903999506923528">事件循环</a></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126155638013.png" alt="image-20230126155638013" style="zoom:80%;" /></p>
<blockquote>
<p>There are a couple of implications of this apparently very simple and basic model Avoid synchronous code at all costs because it blocks the event loop Which means: callbacks, callbacks, and more callbacks</p>
</blockquote>
<h4 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h4><ul>
<li>由一个事件收集器、一个事件发送器和一个事件处理器组成</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160013635.png" alt="image-20230126160013635" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160035582.png" alt="image-20230126160035582"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160042277.png" alt="image-20230126160042277" style="zoom:80%;" /></p>
<h4 id="Node-js-支持-JS"><a href="#Node-js-支持-JS" class="headerlink" title="Node.js 支持 JS"></a>Node.js 支持 JS</h4><p>这是 Node.js 能够发展壮大的一个非常重要的间接原因</p>
<ul>
<li>首先, Javascript 作为前端工程师的主⼒语言, 在技术社区中有相当的号召⼒。而且, 随着 Web 技术的不断发展, 特别是前端的重要性增加, 不少前端工程师开始试水”后台应用”, 在许多采用 Node.js 的企业中, 工程师都表示因为习惯了 Javascript, 所以选择 Node.js</li>
<li>其次, Javascript 的匿名函数和闭包特性非常适合事件驱动、异步编程</li>
<li>有 Google V8 引擎的加持, Node.js 的性能也是受益其中。</li>
</ul>
<h2 id="4-阻塞"><a href="#4-阻塞" class="headerlink" title="4. 阻塞"></a>4. 阻塞</h2><h4 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h4><div class="table-container">
<table>
<thead>
<tr>
<th>同步</th>
<th>异步</th>
</tr>
</thead>
<tbody>
<tr>
<td>等待每个操作完成, 然后执行下一个操作。</td>
<td>从不等待每个操作完成, 一次执行所有操作。</td>
</tr>
<tr>
<td>一步一步执行</td>
<td>回调, 用于处理结果</td>
</tr>
</tbody>
</table>
</div>
<h4 id="同步式-I-O-和异步式-I-O-的特点"><a href="#同步式-I-O-和异步式-I-O-的特点" class="headerlink" title="同步式 I/O 和异步式 I/O 的特点"></a>同步式 I/O 和异步式 I/O 的特点</h4><ul>
<li>阻塞方法同步执行, 非阻塞方法异步执行</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>同步式 I/O(阻塞式)</th>
<th>异步式 I/O(非阻塞式)</th>
</tr>
</thead>
<tbody>
<tr>
<td>利用多线程提供吞吐量</td>
<td>单线程即可实现高吞吐量</td>
</tr>
<tr>
<td>通过事件片分割和线程调度利用多核CPU</td>
<td>通过功能划分利用多核CPU</td>
</tr>
<tr>
<td>需要由操作系统调度多线程使用多核 CPU</td>
<td>可以将单进程绑定到单核 CPU</td>
</tr>
<tr>
<td>难以充分利用 CPU 资源</td>
<td>可以充分利用 CPU 资源</td>
</tr>
<tr>
<td>内存轨迹大, 数据局部性弱</td>
<td>内存轨迹小, 数据局部性强</td>
</tr>
<tr>
<td>符合线性的编程思维</td>
<td>不符合传统编程思维</td>
</tr>
</tbody>
</table>
</div>
<h4 id="阻塞-vs-非阻塞"><a href="#阻塞-vs-非阻塞" class="headerlink" title="阻塞 vs 非阻塞"></a>阻塞 vs 非阻塞</h4><ul>
<li>阻塞 是指在 Node.js 程序中, 其它 JavaScript 语句的执行, 必须等待一个非 JavaScript 操作完成。这是因为当阻塞发生时, 事件循环无法继续运行 JavaScript</li>
<li>在 Node.js 中, JavaScript 由于执行 CPU 密集型操作, 而不是等待一个非 JavaScript 操作(例如 I/O)而表现不佳, 通常不被称为阻塞。在 Node.js 标准库中使用 libuv 的同步方法是最常用的阻塞操作。原生模块中也有阻塞方法</li>
<li><p>在Node.js标准库中的所有I/O方法都提供异步版本, 非阻塞, 并且接受回调函数。某些方法也有对应的阻塞版本, 名字以 Sync 结尾</p>
</li>
<li><p>示例: 从文件中读取数据并显示数据</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126162814121.png" alt="image-20230126162814121"></p>
</li>
</ul>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>同步</li>
<li>文件读取<ul>
<li>从文件读取数据</li>
<li>显示数据</li>
<li>完成其他任务</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Do other tasks&quot;</span>);<br></code></pre></td></tr></table></figure>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>异步</li>
<li>从文件中读取数据<ul>
<li>当读取数据完成时, 显示数据</li>
</ul>
</li>
<li>完成其他任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// callback</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<h2 id="5-实践"><a href="#5-实践" class="headerlink" title="5. 实践"></a>5. 实践</h2><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>项目信息</p>
<ul>
<li>name 项目名称</li>
<li>version 项目的版本号</li>
<li>description 项目的描述信息</li>
<li>entry point 项目的入口文件</li>
<li>test command 项目启动时脚本命令</li>
<li>git repository 如果你有 Git 地址, 可以将这个项目放到你的 Git 仓库⾥</li>
<li>keywords 关键词</li>
<li>author 作者</li>
<li>license 项目要发行的时候需要的证书, 平时可以忽略它</li>
</ul>
<h4 id="Node-js-API"><a href="#Node-js-API" class="headerlink" title="Node.js API"></a>Node.js API</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126210438297.png" alt="image-20230126210438297" style="zoom:80%;" /></p>
<h4 id="Node-js流行模块"><a href="#Node-js流行模块" class="headerlink" title="Node.js流行模块"></a>Node.js流行模块</h4><ul>
<li>Express.js 由核⼼ Node 项目团队的成员之一 TJ Holowaychuk 构建。大型社区支持此框架, 因此具有不断更新和改⾰所有核⼼功能的优势。这是一个极简主义的框架, 用于构建 mobile 应用程序和 API</li>
<li>Koa 由创建 Express.js 的同一团队开发, 通常被称为下一代 NodeJS 框架。 Koa 的独特之处在于它使用了一些非常酷的 ECMAScript (ES6)方法, 使你无需回调即可工作, 同时极大地扩展了错误处理</li>
<li>Hapi 是一个强大且健壮的框架, 用于开发API。完善的插件系统和各种关键功能(例如输入验证、基于配置的功能、实现缓存、错误处理、日志记录等)使 Hapi 成为最受欢迎的框架之一。它用于构建有用的应用, 并通为 PayPal, Disney 等多个大型网站提供技术解决方案。Hapi 以最小的开销构建安全、强大、可扩展的开箱即用的功能</li>
<li>Socket.io用于构建实时 Web 应用。这是一个 Javascript 库, 可在 Web 客户端和服务器之间进行双向数据通信。异步数据 I/O、⼆进制流和即时消息传递是此框架最重要的功能</li>
<li>Meteor.JS 是最常用的 NodeJS 框架之一。 NodeJS 的全栈框架, 允许用户构建实时应用程序。它用于创建基于移动和基于 Web 的 JavaScript 应用。</li>
</ul>
<h2 id="6-模块"><a href="#6-模块" class="headerlink" title="6. 模块"></a>6. 模块</h2><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>两种模块, 不兼容</p>
<ul>
<li>ES6 模块, 简称 ESM</li>
<li>Node.js 专用的 CommonJS 模块, 简称 CJS</li>
</ul>
<h4 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h4><p>语法</p>
<ul>
<li>CommonJS 模块使用 <code>require()</code> 加载和 <code>module.exports</code> 输出</li>
<li>ES6 模块使用 <code>import</code> 和 <code>export</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><span class="hljs-keyword">export</span> &#123;firstName, lastName, year&#125;;<br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123;firstName, lastName, year&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstName, lastName) <span class="hljs-comment">// Michael Jackson</span><br></code></pre></td></tr></table></figure>
<p>CommonJS 模块输出的是一个值的拷贝, ES6 模块输出的是值的引用</p>
<p>CommonJS 模块是运行时加载, ES6 模块是编译时输出接口</p>
<ul>
<li>CommonJS 加载的是一个对象(即module.exports属性), 该对象只有在脚本运行完才会生成</li>
<li>ES6 模块不是对象, 它的对外接口只是一种静态定义, 在代码静态解析阶段就会生成</li>
</ul>
<h4 id="模块加载的实质"><a href="#模块加载的实质" class="headerlink" title="模块加载的实质"></a>模块加载的实质</h4><p>cjs</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// lib.js</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">incCounter</span>(<span class="hljs-params"></span>) &#123;<br>	counter++;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">counter</span>: counter,<br>    <span class="hljs-attr">incCounter</span>: incCounter,<br>&#125;;<br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">var</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod.<span class="hljs-property">counter</span>); <span class="hljs-comment">// 3</span><br>mod.<span class="hljs-title function_">incCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod.<span class="hljs-property">counter</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<p>es6</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// lib.mjs</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> counter = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">incCounter</span>(<span class="hljs-params"></span>) &#123;<br>	counter++;<br>&#125;<br><span class="hljs-comment">// main.mjs</span><br><span class="hljs-keyword">import</span> &#123; counter, incCounter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lib.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter); <span class="hljs-comment">// 3</span><br><span class="hljs-title function_">incCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>
<h4 id="Node-js-的区分"><a href="#Node-js-的区分" class="headerlink" title="Node.js 的区分"></a>Node.js 的区分</h4><ul>
<li>Node.js 要求 ES6 模块采用 .mjs 后缀文件名<ul>
<li>只要脚本文件⾥面使用 import 或者 export 命令, 那么就必须采用.mjs后缀名</li>
<li>Node.js 遇到.mjs文件, 就认为是 ES6 模块, <strong>默认启用严格模式</strong>, 不必在每个模块文件顶部指定”use strict”</li>
<li>如果不希望将后缀名改成.mjs, 可以在项目的package.json文件中, 指定 type 字段为 module</li>
</ul>
</li>
<li>.cjs 文件总是以 CommonJS 模块加载<ul>
<li>如果没有 type 字段, 或者 type 字段为 commonjs, 则 .js 脚本会被解释成 CommonJS 模块</li>
</ul>
</li>
<li>.js 文件的加载取决于 package.json ⾥面 type 字段的设置</li>
<li>注意, ES6 模块与 CommonJS 模块尽量不要混用！！！<ul>
<li>require 命令不能加载 .mjs 文件, 会报错, 只有 import 命令才可以加载 .mjs 文件</li>
<li>反之, .mjs 文件⾥面也不能使用 require 命令, 必须使用 import</li>
</ul>
</li>
</ul>
<h4 id="同时支持两种格式的模块-了解"><a href="#同时支持两种格式的模块-了解" class="headerlink" title="同时支持两种格式的模块(了解)"></a>同时支持两种格式的模块(了解)</h4><ul>
<li><p>如果原始模块是 ES6 格式, 那么需要给出一个整体输出接口, 比如 export default obj, 使得 CommonJS 可以用 import() 进行加载</p>
</li>
<li><p>如果原始模块是 CommonJS 格式, 那么可以加一个包装层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> cjsModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../index.js&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = cjsModule.<span class="hljs-property">foo</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以把这个文件的后缀名改为 .mjs, 或者放在一个子目录, 再在这个子目录⾥面放一个单独的 package.json 文件, 指明{ type: “module” }</p>
</li>
<li><p>另一种做法是在 package.json 文件的 exports 字段, 指明两种格式模块各自的加载入口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.js&quot;</span>, <br>    <span class="hljs-string">&quot;import&quot;</span>: <span class="hljs-string">&quot;./esm/wrapper.js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="require-方法查找策略"><a href="#require-方法查找策略" class="headerlink" title="require 方法查找策略"></a>require 方法查找策略</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230127150018532.png" alt="image-20230127150018532" style="zoom:80%;" /></p>
<h4 id="A-simple-file-server"><a href="#A-simple-file-server" class="headerlink" title="A simple file server"></a>A simple file server</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)&#123;<br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>)<br>&#125;);<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running at http://localhost:3000/&#x27;</span>);<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">node server.js<br>sudo npm install -g supervisor<br>supervisor server.js<br></code></pre></td></tr></table></figure>
<h4 id="as"><a href="#as" class="headerlink" title="as"></a>as</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> &#123; lastName <span class="hljs-keyword">as</span> surname &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(surname); <span class="hljs-comment">// Jackson</span><br><br><span class="hljs-comment">//profile.js</span><br><span class="hljs-keyword">export</span> &#123;firstName <span class="hljs-keyword">as</span> name&#125;<br></code></pre></td></tr></table></figure>
<h4 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//default.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>)&#123;<br>	<span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> add;<br><span class="hljs-comment">// 实际上</span><br><span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> add <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./default&#x27;</span><br><span class="hljs-comment">//实际上 add 名字可以随便起</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> add&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./default&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="7-循环加载"><a href="#7-循环加载" class="headerlink" title="7. 循环加载"></a>7. <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">循环加载</a></h2><h4 id="CommonJS-循环加载"><a href="#CommonJS-循环加载" class="headerlink" title="CommonJS 循环加载"></a>CommonJS 循环加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在 a.js 之中, b.done = %j&#x27;</span>, b.<span class="hljs-property">done</span>);<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a.js 执行完毕&#x27;</span>);<br><br><span class="hljs-comment">//b.js</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在 b.js 之中, a.done = %j&#x27;</span>, a.<span class="hljs-property">done</span>);<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b.js 执行完毕&#x27;</span>);<br><br><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.<span class="hljs-property">done</span>, b.<span class="hljs-property">done</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在 b.js 之中, a.done = false</span><br><span class="hljs-comment">b.js 执行完毕</span><br><span class="hljs-comment">在 a.js 之中, b.done = true</span><br><span class="hljs-comment">a.js 执行完毕</span><br><span class="hljs-comment">在 main.js 之中, a.done=true, b.done=true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>CommonJS模块的重要特性是加载时执行, 即脚本代码在<code>require</code>的时候, 就会全部执行。<strong>CommonJS的做法是, 一旦出现某个模块被”循环加载”, 就只输出已经执行的部分, 还未执行的部分不会输出。</strong></p>
</blockquote>
<h4 id="ES6-循环加载"><a href="#ES6-循环加载" class="headerlink" title="ES6 循环加载"></a>ES6 循环加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.mjs如下</span><br><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a.mjs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><br><span class="hljs-comment">// b.mjs</span><br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b.mjs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> bar = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$ node --experimental-modules a.mjs</span><br><span class="hljs-comment">b.mjs</span><br><span class="hljs-comment">ReferenceError: Cannot access &#x27;foo&#x27; before initialization</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>借助函数提升解决, 改为函数表达式也会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.mjs</span><br><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a.mjs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bar</span>());<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span> &#125;<br><span class="hljs-keyword">export</span> &#123;foo&#125;;<br><span class="hljs-comment">// b.mjs</span><br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b.mjs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>());<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;bar&#x27;</span> &#125;<br><span class="hljs-keyword">export</span> &#123;bar&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$ node --experimental-modules a.mjs</span><br><span class="hljs-comment">b.mjs</span><br><span class="hljs-comment">foo</span><br><span class="hljs-comment">a.mjs</span><br><span class="hljs-comment">bar</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><h4 id="Node-js-版本"><a href="#Node-js-版本" class="headerlink" title="Node.js 版本"></a>Node.js 版本</h4><ul>
<li>LTS 和 Current 其实并不是版本, 而是同一个主版本号的不同阶段<ul>
<li>LTS: Long Term Support。该版本进入了漫长的维护期。它又分为两个阶段: Active LTS 和 Maintenance LTS。从以往的发布历史看, LTS 至少会被跟进 2 年时间, 按照最新的官方网站的说法, Active LTS 持续 12 个月, Maintenance LTS 将会被持续维护 18 个月的时间。Node.js 12 之前, active 阶段持续18个月, maintenance 阶段持续 12 个月。</li>
<li>Current: 一个新主版本号 release 后, 先进入 Current 阶段, 该阶段持续 6 个月, 目的是给各个库(library)的作者时间来支持新版。偶数版本在 Current 阶段后进入 LTS 阶段, 而奇数版本则终结不再维护</li>
</ul>
</li>
<li>奇偶版本号<ul>
<li>Nodejs主版本号(semver-major)奇数版本和偶数版本有不同的生命周期</li>
<li>每隔6个月, 社区会从 Nodejs master 分支拉出一个分支作为主版本的release。偶数版本在4月发版, 奇数版本则在10月</li>
<li>奇数版本发版时, 上一个偶数版本会进入LTS阶段, 而奇数版本则只持续6个月的时间, 终结不再维护</li>
</ul>
</li>
</ul>
<h4 id="已无性能优势"><a href="#已无性能优势" class="headerlink" title="已无性能优势?"></a>已无性能优势?</h4><ul>
<li>实现成本、调优成本、学习成本</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113254724.png" alt="image-20230128113254724" style="zoom:80%;" /></p>
<h4 id="MEAN"><a href="#MEAN" class="headerlink" title="MEAN"></a>MEAN</h4><p>MEAN 是一个 Javascript 平台的现代 Web 开发框架总称</p>
<ul>
<li>MongoDB 是一个使用 JSON 风格存储的数据库, 非常适合 JavaScript (JSON是JS数据格式)</li>
<li>ExpressJS 是一个 Web 应用框架, 提供有帮助的组件和模块帮助建立一个网站应用。</li>
<li>AngularJS 是一个前端 MVC 框架。</li>
<li>Node.js 是一个并发、异步、事件驱动的Javascript服务器后端开发平台。</li>
</ul>
<h4 id="MEAN-架构原理"><a href="#MEAN-架构原理" class="headerlink" title="MEAN 架构原理"></a>MEAN 架构原理</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113438817.png" alt="image-20230128113438817" style="zoom:80%;" /></p>
<h4 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113515334.png" alt="image-20230128113515334" style="zoom:80%;" /></p>
<h4 id="Node-js-框架的优势"><a href="#Node-js-框架的优势" class="headerlink" title="Node.js 框架的优势"></a>Node.js 框架的优势</h4><p>现在 NodeJS 框架正在成为最常用的构建 Web 应用前后端的开发框架。这是自定义 Web 开发的首选环境。让我们检查一些主要的 NodeJS 框架的优点</p>
<ul>
<li>实时工作环境、简单的编码经验、无缝数据流、在整个开发过程中使用相同的代码模式、方便易用</li>
</ul>
<h4 id="框架选型"><a href="#框架选型" class="headerlink" title="框架选型"></a>框架选型</h4><ul>
<li>业务场景、特点</li>
<li>自身团队能⼒、喜好, 有时候技术选型决定团队氛围的, 需要平衡激进与稳定</li>
<li>熟悉程度</li>
<li>个人学习求新, 企业架构求稳, 无非喜好与场景而已</li>
</ul>
<h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113646359.png" alt="image-20230128113646359" style="zoom:80%;" /></p>
<h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128140941232.png" alt="image-20230128140941232" style="zoom:80%;" /></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128141012898.png" alt="image-20230128141012898" style="zoom:80%;" /></p>
<h1 id="10-Express"><a href="#10-Express" class="headerlink" title="10-Express"></a>10-Express</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h4 id="什么是-Express"><a href="#什么是-Express" class="headerlink" title="什么是 Express ?"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs/Introduction#Is_Express_opinionated">什么是 Express ?</a></h4><ul>
<li>Express是最流行的node web框架, 它是许多其他流行的节点 web 框架的底层库。它提供了机制:<ul>
<li>在不同的URL路径(路由)中使用不同HTTP动词的请求编写处理程序</li>
<li>与”视图”呈现引擎集成, 以便通过将数据插入模板来生成响应</li>
<li>设置常见的web应用程序设置, 比如用于连接的端口, 以及用于呈现响应的模板的位置</li>
<li>在请求处理管道的任何位置添加额外的请求处理”中间件”</li>
</ul>
</li>
<li>虽然Express本身是非常简单的, 但是开发人员已经创建了兼容的中间件包来解决几乎所有的 web 开发问题<ul>
<li>cookie、会话、用户登录、URL参数、POST数据、安全标头等等。</li>
</ul>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>精简、灵活、web 程序框架、单页 web 程序、多页和混合的 web 程序</li>
</ul>
<h4 id="Is-Express-opinionated"><a href="#Is-Express-opinionated" class="headerlink" title="Is Express opinionated?"></a>Is Express opinionated?</h4><ul>
<li>Web框架通常将自己称为”固执己见”或”不固执己见”</li>
<li>固执的框架认为应该有一套”标准答案”来解决各类具体任务。通常支持特定领域的快速开发(解决特定类型的问题)。因为标准答案通常易于理解且文档丰富。然而在解决主领域之外的问题时, 就会显得不那么灵活, 可用的组件和方法也更少</li>
<li>Express是不固执己见的,是高度包容的<ul>
<li>几乎可以将任何您喜欢的任何兼容的中间件插入到请求处理链中</li>
<li>可以在一个文件或多个文件中构造该应用程序, 并使用任何目录结构</li>
<li>有太多的选择！</li>
</ul>
</li>
</ul>
<h4 id="Express-开发环境概述"><a href="#Express-开发环境概述" class="headerlink" title="Express 开发环境概述"></a>Express 开发环境概述</h4><p>完整的 Express 本地开发环境包括</p>
<ul>
<li>Nodejs</li>
<li>NPM 包管理器</li>
<li>Express 应用生成器(可选)</li>
</ul>
<h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// npm init</span><br><span class="hljs-comment">// npm install express —save</span><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Example app listening on port 3000!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="应用生成器工具"><a href="#应用生成器工具" class="headerlink" title="应用生成器工具"></a>应用生成器工具</h4><p>通过应用生成器工具 express-generator 可以快速创建一个应用的⻣架</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002408387.png" alt="image-20230129002408387" style="zoom:80%;" /></p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002447793.png" alt="image-20230129002447793" style="zoom:80%;" /></p>
<h2 id="2-路由"><a href="#2-路由" class="headerlink" title="2. 路由"></a>2. 路由</h2><h4 id="处理数据流"><a href="#处理数据流" class="headerlink" title="处理数据流"></a>处理数据流</h4><ul>
<li>下图展示了 HTTP 请求/响应处理的主数据流和需要实现的行为</li>
<li>路由: 把需要支持的请求(以及请求 URL 中包含的任何信息)转发到适当的控制器函数</li>
<li>控制器: 从模型中获取请求的数据, 创建一个 HTML 页面显示出数据, 并将页面返回给用户, 以便在浏览器中查看</li>
<li>视图(模板): 供控制器用来渲染数据。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002557988.png" alt="image-20230129002557988" style="zoom:80%;" /></p>
<h4 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h4><ul>
<li>路由用于确定应用程序如何响应对特定端点的客户机请求, 包含一个 URI(或路径)和一个特定的 HTTP 请求方法(GET、POST 等)</li>
<li>每个路由可以具有一个或多个处理程序函数, 这些函数在路由匹配时执行</li>
<li>路由定义采用以下结构: <ul>
<li><code>app.METHOD(PATH, HANDLER)</code></li>
<li>其中: <ul>
<li>app 是 express 的实例</li>
<li>METHOD 是 HTTP 请求方法</li>
<li>PATH 是服务器上的路径</li>
<li>HANDLER 是在路由匹配时执行的函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="路由示例"><a href="#路由示例" class="headerlink" title="路由示例"></a>路由示例</h4><p>以主页上的 Hello World! 进行响应: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>在根路由 (/) 上(应用程序的主页)对 POST 请求进行响应: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Got a POST request&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>对 /user 路由的 PUT 请求进行响应: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Got a PUT request at /user&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由方法"><a href="#路由方法" class="headerlink" title="路由方法"></a>路由方法</h4><p>路由方法派生自 HTTP 方法之一, 附加到 express 类的实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// GET method route</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;GET request to the homepage&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// POST method route</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;POST request to the homepage&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="特殊路由方法-app-all"><a href="#特殊路由方法-app-all" class="headerlink" title="特殊路由方法: app.all()"></a>特殊路由方法: app.all()</h4><ul>
<li>有一种特殊路由方法: <code>app.all()</code>, 它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数</li>
<li>在以下示例中, 无论使用 GET、POST、PUT、DELETE 还是在 http 模块中支持的其他任何 HTTP 请求方法, 都将为针对”/ secret”的请求执行处理程序</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;/secret&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Accessing the secret section ...&#x27;</span>);<br>	<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// pass control to the next handler</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由路径"><a href="#路由路径" class="headerlink" title="路由路径"></a>路由路径</h4><ul>
<li><p>路由路径与请求方法相结合, 用于定义可以在其中提出请求的端点。路由路径可以是字符串、字符串模式或正则表达式</p>
</li>
<li><p>路由路径用于定义可请求的端点。之前示例中路径都是字符串, 并且必须精确写为: ‘/‘、’/about’、’/book’等等</p>
</li>
<li><p>路由路径也可以是字符串模式(String Pattern)。可用部分正则表达式语法来定义端点的模式。以下是所涉及的正则表达式(注意, 连字符(-)和点(.)在字符串路径中解释为字面量, 不能作为正则表达式): </p>
<ul>
<li>?: 问号之前的一个字符只能出现零次或一次。<ul>
<li>例如, 路由路径 ‘/ab?cd’ 路径匹配端点 acd 或 abcd</li>
</ul>
</li>
<li>+: 加号之前的一个字符至少出现一次<ul>
<li>例如, 路径路径 ‘/ab+cd’ 匹配端点 abcd、abbcd、abbbcd 等</li>
</ul>
</li>
<li>*: 星号可以替换为任意字符串<ul>
<li>例如, 路由路径 ‘/ab*cd’ 匹配端点 abcd、abXcd、abSOMErandomTEXTcd 等</li>
</ul>
</li>
<li>(): 将一个字符串视为一体以执行 ?、+、 * 操作<ul>
<li>例如。 ‘/ab(cd)?e’ 将对 (cd) 进行匹配, 将匹配到 abe 和 abcde</li>
</ul>
</li>
</ul>
</li>
<li><p>路由路径也可以是 JavaScript 正则表达式。</p>
<ul>
<li><p>例如, 下面的路由路径将匹配 catfish 和 dogfish, 但不会匹配 catflap、catfishhead 等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-regexp">/.*fish$/</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br> ...<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意, 正则表达式路径不再用引号 “…” 括起来, 而是正则表达式语法 /…/</p>
</li>
</ul>
</li>
<li><p>Express 使用 path-to-regexp 来匹配路由路径</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 此路由路径将请求与根路由 / 匹配。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;root&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 此路由路径将请求与 /about 匹配。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;about&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 此路由路径将请求与 /random.text 匹配。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/random.text&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;random.text&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 基于字符串模式的路由路径的示例。此路由路径将匹配 acd 和 abcd。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/ab?cd&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ab?cd&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><ul>
<li>路径参数是命名的 URL 段, 用于捕获在 URL 中的位置指定的值。命名段以冒号为前缀, 然后是名称<ul>
<li>例如 /:your_parameter_name/。捕获的值保存在 req.params 对象中, 键即参数名<ul>
<li>例如 req.params.your_parameter_name</li>
</ul>
</li>
</ul>
</li>
<li>路由参数名必须由”单词字符”(<code>/[A-Za-z0-9_]/</code>)组成</li>
<li>举例说, 一个包含用户和藏书信息的 URL: <a target="_blank" rel="noopener" href="http://localhost:3000/users/34/books/8989">http://localhost:3000/users/34/books/8989</a>, 可以这样提取信息(使用 userId 和 bookId 路径参数): </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users/:userId/books/:bookId&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br> <span class="hljs-comment">// 通过 req.params.userId 访问 userId</span><br> <span class="hljs-comment">// 通过 req.params.bookId 访问 bookId</span><br> res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由处理程序"><a href="#路由处理程序" class="headerlink" title="路由处理程序"></a>路由处理程序</h4><ul>
<li>可以提供多个回调函数, 以类似于中间件的行为方式来处理请求。唯一例外是这些回调函数可能调用 next(‘route’)来绕过剩余的路由回调。可以使用此机制对路由施加先决条件, 在没有理由继续执行当前路由的情况下, 可将控制权传递给后续路由</li>
<li>路由处理程序的形式可以是一个函数、一组函数或者两者的结合, 如以下示例中所示</li>
<li>单个回调函数可以处理一个路由。例如: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单个回调函数可以处理一个路由。例如: </span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/example/a&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from A!&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 多个回调函数可以处理一个路由(确保您指定 next 对象)。例如: </span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/example/b&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the response will be sent by the next function ...&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br> 	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from B!&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 一组回调函数可以处理一个路由。例如: </span><br><span class="hljs-keyword">var</span> cb0 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CB0&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;<br><span class="hljs-keyword">var</span> cb1 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CB1&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;<br><span class="hljs-keyword">var</span> cb2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from C!&#x27;</span>);<br>&#125;<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/example/c&#x27;</span>, [cb0, cb1, cb2]);<br><br><span class="hljs-comment">// 独立函数与一组函数的组合可以处理一个路由。例如: </span><br><span class="hljs-keyword">var</span> cb0 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CB0&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;<br><span class="hljs-keyword">var</span> cb1 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CB1&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/example/d&#x27;</span>, [cb0, cb1], <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the response will be sent by the next function ...&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from D!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="响应方法"><a href="#响应方法" class="headerlink" title="响应方法"></a>响应方法</h4><p>下表中响应对象 (res) 的方法可以向客户机发送响应, 并终止请求/响应循环。如果没有从路由处理程序调用其中任何方法, 客户机请求将保持挂起状态。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="http://expressjs.com/zh-cn/4x/api.html#res.download">方法</a></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>res.download()</td>
<td>提示将要下载文件</td>
</tr>
<tr>
<td>res.end()</td>
<td>结束响应进程</td>
</tr>
<tr>
<td>res.json()</td>
<td>发送 JSON 响应</td>
</tr>
<tr>
<td>res.jsonp()</td>
<td>在 JSONP 的支持下发送 JSON 响应</td>
</tr>
<tr>
<td>res.redirect()</td>
<td>重定向请求</td>
</tr>
<tr>
<td>res.render()</td>
<td>呈现视图模板</td>
</tr>
<tr>
<td>res.send()</td>
<td>发送各种类型的响应</td>
</tr>
<tr>
<td>res.sendFile()</td>
<td>以⼋位元流形式发送文件</td>
</tr>
<tr>
<td>res.sendStatus()</td>
<td>设置响应状态码并以响应主体形式发送其字符串表示</td>
</tr>
</tbody>
</table>
</div>
<h4 id="app-route"><a href="#app-route" class="headerlink" title="app.route()"></a>app.route()</h4><ul>
<li>可以使用 <code>app.route()</code> 为路由路径创建链式路由处理程序。因为在单一位置指定路径, 所以可以减少冗余和输入错误。有关路由的更多信息, 请参阅 <a target="_blank" rel="noopener" href="http://expressjs.com/zh-cn/4x/api.html#router">Router()文档</a>。 以下是使用 <code>app.route()</code> 定义的链式路由处理程序的示例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/book&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get a random book&#x27;</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add a book&#x27;</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">put</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Update the book&#x27;</span>);<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h4 id="express-Router"><a href="#express-Router" class="headerlink" title="express.Router"></a>express.Router</h4><ul>
<li>使用 express.Router 类来创建可安装的模块化路由处理程序</li>
<li>Router 实例是完整的中间件和路由系统；因此, 常常将其称为”微型应用程序”</li>
<li>以下示例将路由器创建为模块, 在其中装入中间件, 定义一些路由, 然后安装在主应用程序的路径中</li>
<li>在应用程序目录中创建名为 birds.js 的路由器文件, 其中包含以下内容: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><span class="hljs-comment">// middleware that is specific to this router</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeLog</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time: &#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>    <span class="hljs-title function_">next</span>();<br>&#125;);<br><span class="hljs-comment">// define the home page route</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Birds home page&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// define the about route</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;About birds&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure>
<ul>
<li>接着, 在应用程序中装入路由器模块: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> birds = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./birds&#x27;</span>);<br>...<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/birds&#x27;</span>, birds);<br></code></pre></td></tr></table></figure>
<h2 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3. 中间件"></a>3. 中间件</h2><h4 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h4><ul>
<li>Connect 创造了”中间件”(middleware)这个术语来描述插入式的 Node 模块</li>
<li>从概念上讲, 中间件是一种功能的封装方式, 具体来说就是封装在程序中处理 HTTP 请求的功能</li>
<li>中间件是在管道中执行的。<ul>
<li>在 Express 程序中, 通过调用 app.use() 向管道中插入中间件。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129145316636.png" alt="image-20230129145316636" style="zoom:80%;" /></p>
<h4 id="Express工作重点"><a href="#Express工作重点" class="headerlink" title="Express工作重点"></a>Express工作重点</h4><ul>
<li>路由处理器(app.get、app.post 等, 经常被统称为app.VERB)可以被看作只处理特定 HTTP动词 (GET、POST等)的中间件。同样, 也可以将中间件看作可以处理全部 HTTP动词 的路由处理器(基本上等同于app.all, 可以处理任何HTTP动词; 对于 PURGE 之类特别的动词会有细微的差别, 但对于普通的动词而言, 效果是一样的)</li>
<li>路由处理器的第一个参数必须是路径。如果你想让某个路由匹配所有路径, 只需用<code>/*</code> 。中间件也可以将路径作为第一个参数, 但它是可选的(如果忽略这个参数, 它会匹配所有路径, 就像指定了 <code>/*</code> 一样)</li>
<li>路由处理器和中间件的参数中都有回调函数, 这个函数有2个、3个或4个参数(从技术上讲也可以有 0 或 1 个参数, 但这些形式没有意义)<ul>
<li>如果有 2 个或 3 个参数, 头两个参数是请求和响应对象, 第三个参数是 next 函数</li>
<li>如果有 4 个参数, 它就变成了<strong>错误处理中间件, 第一个参数变成了错误对象, 然后依次是请求、响应和 next 对象</strong></li>
</ul>
</li>
<li>如果不调用 next(), 管道就会被终止, 也不会再有处理器或中间件做后续处理。如果不调用 next(), 则应该发送一个响应到客户端(res.send、res.json、res.render 等); 如果你不这样做, 客户端会被挂起并最终导致超时</li>
<li>如果调用了 next(), 一般不宜再发送响应到客户端。如果你发送了, 管道中后续的中间件或路由处理器还会执行, 但它们发送的<strong>任何响应都会被忽略</strong></li>
</ul>
<h4 id="中间件函数的简单示例"><a href="#中间件函数的简单示例" class="headerlink" title="中间件函数的简单示例"></a>中间件函数的简单示例</h4><ul>
<li>此函数仅在应用程序的请求通过它时显示”LOGGED”。中间件函数会分配给名为 myLogger 的变量</li>
<li>请注意以上对 next() 的调用<ul>
<li>调用此函数时, 将调用应用程序中的下一个中间件函数</li>
<li>next() 函数不是 Node.js 或 Express API 的一部分, 而是传递给中间件函数的第三自变量</li>
<li>next() 函数可以命名为任何名称, 但是按约定, 始终命名为”next”</li>
<li>为了避免混淆, 请始终使用此约定。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myLogger = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LOGGED&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>要装入中间件函数, 请调用 <code>app.use()</code> 并指定中间件函数。例如, 以下代码在根路径 (/) 的路由之前装入 myLogger 中间件函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">var</span> myLogger = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LOGGED&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;;<br>app.<span class="hljs-title function_">use</span>(myLogger);<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>中间件装入顺序很重要<ul>
<li><strong>首先装入的中间件函数也首先被执行</strong></li>
</ul>
</li>
<li>如果在根路径的路由之后装入 myLogger, 那么请求永远都不会到达该函数, 应用程序也不会显示”LOGGED”, 因为根路径的路由处理程序终止了请求/响应循环</li>
<li>中间件函数 myLogger 只是显示消息, 然后通过调用 next() 函数将请求传递到堆栈中的下一个中间件函数</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>名为 requestTime 的属性添加到请求对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> requestTime = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	req.<span class="hljs-property">requestTime</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>	<span class="hljs-title function_">next</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>现在, 该应用程序使用 requestTime 中间件函数。此外, 根路径路由的回调函数使用由中间件函数添加到 req(请求对象)的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(requestTime);<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	<span class="hljs-keyword">var</span> responseText = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br>	responseText += <span class="hljs-string">&#x27;Requested at: &#x27;</span> + req.<span class="hljs-property">requestTime</span> + <span class="hljs-string">&#x27;&#x27;</span>;<br>	res.<span class="hljs-title function_">send</span>(responseText);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>
<h4 id="使用中间件"><a href="#使用中间件" class="headerlink" title="使用中间件"></a>使用中间件</h4><ul>
<li>Express 是一个路由和中间件 Web 框架, 其自身只具有最低程度的功能: <ul>
<li>Express 应用程序基本上是一系列中间件函数调用</li>
</ul>
</li>
<li>中间件函数能够访问请求对象 (req)、响应对象 (res) 以及应用程序的请求/响应循环中的下一个中间件函数。下一个中间件函数通常由名为 next 的变量来表示</li>
<li>中间件函数可以执行以下任务: <ul>
<li>执行任何代码</li>
<li>对请求和响应对象进行更改</li>
<li>结束请求/响应循环</li>
<li>调用堆栈中的下一个中间件函数</li>
</ul>
</li>
<li><p>如果当前中间件函数没有结束请求/响应循环, 那么它必须调用 next(), 以将控制权传递给下一个中间件函数。否则, 请求将保持挂起状态。</p>
</li>
<li><p>Express 应用程序可以使用以下类型的中间件: </p>
<ul>
<li>应用层中间件</li>
<li>路由器层中间件</li>
<li>错误处理中间件</li>
<li>内置中间件</li>
<li>第三方中间件</li>
</ul>
</li>
<li>可以使用可选安装路径来装入应用层和路由器层中间件。还可以将一系列中间件函数一起装入, 这样会在安装点创建中间件系统的子堆栈。</li>
</ul>
<h4 id="应用层中间件"><a href="#应用层中间件" class="headerlink" title="应用层中间件"></a>应用层中间件</h4><ul>
<li>使用 <code>app.use()</code> 和 <code>app.METHOD()</code> 函数将应用层中间件绑定到<a target="_blank" rel="noopener" href="http://expressjs.com/zh-cn/4x/api.html#app">应用程序对象</a>的实例, 其中 METHOD 是中间件函数处理的请求的小写 HTTP 方法(例如 GET、PUT 或 POST)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 此示例显示没有安装路径的中间件函数。应用程序每次收到请求时执行该函数。</span><br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time:&#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>	<span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// 此示例显示安装在 /user/:id 路径中的中间件函数。在 /user/:id 路径中为任何类型的 HTTP 请求执行此函数。</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request Type:&#x27;</span>, req.<span class="hljs-property">method</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// 此示例显示一个路由及其处理程序函数(中间件系统)。此函数处理针对 /user/:id 路径的 GET 请求。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;USER&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 在安装点使用安装路径装入一系列中间件函数的示例。演示一个中间件子堆栈, 用于显示针对 /user/:id 路径的任何类型 HTTP 请求的信息。</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request URL:&#x27;</span>, req.<span class="hljs-property">originalUrl</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request Type:&#x27;</span>, req.<span class="hljs-property">method</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>路由处理程序可以为一个路径定义多个路由。以下示例为针对 /user/:id 路径的 GET 请求定义两个路由。第⼆个路由不会导致任何问题, 但是永远都不会被调用, 因为第一个路由结束了请求/响应循环。</p>
</li>
<li><p>此示例显示一个中间件子堆栈, 用于处理针对 /user/:id 路径的 GET 请求。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ID:&#x27;</span>, req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br> 	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User Info&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// handler for the /user/:id path, which prints the user ID</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	res.<span class="hljs-title function_">end</span>(req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>要跳过路由器中间件堆栈中剩余的中间件函数, 请调用 <code>next(&#39;route&#39;)</code> 将控制权传递给下一个路由</p>
</li>
<li><p>next(‘route’) 仅在使用 <code>app.METHOD()</code> 或 <code>router.METHOD()</code> 函数装入的中间件函数中有效</p>
</li>
<li><p>此示例显示一个中间件子堆栈, 用于处理针对 /user/:id 路径的 GET 请求</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-comment">// if the user ID is 0, skip to the next route</span><br> 	<span class="hljs-keyword">if</span> (req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> == <span class="hljs-number">0</span>) <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;route&#x27;</span>);<br> 	<span class="hljs-comment">// otherwise pass the control to the next middleware function in this stack</span><br> 	<span class="hljs-keyword">else</span> <span class="hljs-title function_">next</span>(); <span class="hljs-comment">//</span><br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-comment">// render a regular page</span><br> 	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;regular&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// handler for the /user/:id path, which renders a special page</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;special&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由器层中间件"><a href="#路由器层中间件" class="headerlink" title="路由器层中间件"></a>路由器层中间件</h4><ul>
<li>路由器层中间件的工作方式与应用层中间件基本相同, 差异之处在于它绑定到 <code>express.Router()</code> 的实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>使用 <code>router.use()</code> 和 <code>router.METHOD()</code> 函数装入路由器层中间件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">// a middleware function with no mount path. This code is executed for every request to the router</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time:&#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br> 	<span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request URL:&#x27;</span>, req.<span class="hljs-property">originalUrl</span>);<br> 	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request Type:&#x27;</span>, req.<span class="hljs-property">method</span>);<br> 	<span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// a middleware sub-stack that handles GET requests to the /user/:id path</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-comment">// if the user ID is 0, skip to the next router</span><br> 	<span class="hljs-keyword">if</span> (req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> == <span class="hljs-number">0</span>) <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;route&#x27;</span>);<br> 	<span class="hljs-comment">// otherwise pass control to the next middleware function in this stack</span><br> 	<span class="hljs-keyword">else</span> <span class="hljs-title function_">next</span>(); <span class="hljs-comment">//</span><br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-comment">// render a regular page</span><br> 	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;regular&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// handler for the /user/:id path, which renders a special page</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br> 	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;special&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// mount the router on the app</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, router);<br></code></pre></td></tr></table></figure>
<h4 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h4><ul>
<li>错误处理中间件始终采用四个自变量。必须提供四个自变量, 以将函数标识为错误处理中间件函数。即使无需使用 next 对象, 也必须指定该对象以保持特征符的有效性。否则, next 对象将被解释为常规中间件, 从而无法处理错误</li>
<li>错误处理中间件函数的定义方式与其他中间件函数基本相同, 差别在于错误处理函数有四个自变量而不是三个, 专门具有特征符 <code>(err, req, res, next)</code>: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">stack</span>);<br> 	res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h4><ul>
<li>自 V4.x 起, Express 不再依赖于 Connect。除 <code>express.static</code> 外, 先前 Express 随附的所有中间件函数现在以单独模块的形式提供。请查看中间件函数的列表。</li>
<li><code>express.static(root, [options])</code><ul>
<li>Express 中唯一内置的中间件函数是 <code>express.static</code>。此函数基于 serve-static, 负责提供 Express 应用程序的静态资源</li>
<li>root 自变量指定从其中提供静态资源的根目录</li>
<li>可选的 options 对象可以具有以下属性: </li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129172729202.png" alt="image-20230129172729202" style="zoom:80%;" /></p>
<ul>
<li>以下示例将使用了 <code>express.static</code> 中间件, 并且提供了一个详细的 ‘options’ 对象(作为示例): </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> options = &#123;<br>    <span class="hljs-attr">dotfiles</span>: <span class="hljs-string">&#x27;ignore&#x27;</span>,<br>    <span class="hljs-attr">etag</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;htm&#x27;</span>, <span class="hljs-string">&#x27;html&#x27;</span>],<br>    <span class="hljs-attr">index</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">maxAge</span>: <span class="hljs-string">&#x27;1d&#x27;</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">setHeaders</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res, path, stat</span>) &#123;<br>    	res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;x-timestamp&#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>    &#125;<br>&#125;<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>, options));<br></code></pre></td></tr></table></figure>
<ul>
<li>对于每个应用程序, 可以有多个静态目录</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;uploads&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>));<br></code></pre></td></tr></table></figure>
<h4 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h4><ul>
<li>使用第三方中间件向 Express 应用程序添加功能</li>
<li>安装具有所需功能的 Node.js 模块, 然后在应用层或路由器层的应用程序中将其加装入</li>
<li>以下示例演示如何安装和装入 cookie 解析中间件函数 cookie-parser</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$ npm install cookie-parser<br><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">var</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cookie-parser&#x27;</span>);<br><span class="hljs-comment">// load the cookie-parsing middleware</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cookieParser</span>());<br></code></pre></td></tr></table></figure>
<h2 id="4-模板引擎"><a href="#4-模板引擎" class="headerlink" title="4. 模板引擎"></a>4. 模板引擎</h2><h4 id="将模板引擎用于-Express"><a href="#将模板引擎用于-Express" class="headerlink" title="将模板引擎用于 Express"></a>将模板引擎用于 Express</h4><ul>
<li>Express 应用生成器支持多款流行的视图/模板引擎, 包括 EJS、Hbs、Pug (Jade)、Twig 和 Vash, 缺省选项是 Jade。Express 本身也支持大量其他模板语言, 开箱即用</li>
<li>在 Express 可以呈现模板文件之前, 必须设置以下应用程序设置: <ul>
<li>views: 模板文件所在目录。例如: <code>app.set(&#39;views&#39;, &#39;./views&#39;)</code></li>
<li>view engine: 要使用的模板引擎。例如: <code>app.set(&#39;view engine&#39;, &#39;pug&#39;)</code></li>
</ul>
</li>
<li>然后安装对应的模板引擎 npm 包: <ul>
<li>$ npm install pug —save</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在设置视图引擎之后, 不必指定该引擎或者在应用程序中装入模板引擎模块；Express 在内部装入此模块, 如下所示(针对以上示例)</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;pug&#x27;</span>);<br><br><span class="hljs-comment">// 在 views 目录中创建名为 index.pug 的 Pug 模板文件, 其中包含以下内容: </span><br>html<br>  head<br>    title= title<br>  body<br>	h1= message<br><br><span class="hljs-comment">// 随后创建路由以呈现 index.pug 文件。如果未设置 view engine 属性, 必须指定 view 文件的扩展名。否则, 可以将其忽略。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hey&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello there!&#x27;</span>&#125;);<br>&#125;);<br><br><span class="hljs-comment">// 向主页发出请求时, index.pug 文件将呈现为 HTML。</span><br></code></pre></td></tr></table></figure>
<h4 id="选用模板引擎需要考虑的因素"><a href="#选用模板引擎需要考虑的因素" class="headerlink" title="选用模板引擎需要考虑的因素"></a>选用模板引擎需要考虑的因素</h4><p>一般来说, 你应该选择一个大而全的模板引擎, 可以尽快进入生产状态。就像你选择其他组件一样！选用模板引擎需要考虑以下因素: </p>
<ul>
<li>进入生产状态的时间 —— 如果你的团队已经有某个模板语言的经验, 那么用它可能更快进入生产状态。否则你应该考虑所选模板引擎的学习曲线</li>
<li>流行度和活跃度 —— 要评估所选引擎的流行程度, 以及它是否拥有活跃的社区。在网站的生命周期中遇到问题时, 是否能够获得相关支持非常重要</li>
<li>风格 —— 某些模板引擎使用特定标记, 来标识插入”普通”HTML 中的内容, 而另一些模板引擎使用不同的语法(例如使用缩进和块名称)构造 HTML</li>
<li>性能/渲染时间</li>
<li>功能——你应该考虑所选引擎是否具有以下功能: <ul>
<li>布局继承: 可以定义基本模板, 然后”继承”它的一部分, 使不同页面可以有不同的呈现。这通常比包含大量所需组件, 或每次从头开始构建模板更好</li>
<li>“包含”支持: 可以通过包含其他模板来构建新模板</li>
<li>简明的变量和循环控制语法</li>
<li>能够在模板级别过滤变量值(例如, 将变量设置为大写, 或格式化日期值)</li>
<li>能够生成 HTML 以外的输出格式(例如 JSON 或 XML)</li>
<li>支持异步操作和流</li>
<li>可以同时在客户端和服务器上使用。如果一款模板引擎可以在客户端使用, 那么就使在客户端托管数据并完成所有(或大多数)渲染成为可能。</li>
</ul>
</li>
</ul>
<h4 id="为-Express-开发模板引擎"><a href="#为-Express-开发模板引擎" class="headerlink" title="为 Express 开发模板引擎"></a>为 Express 开发模板引擎</h4><ul>
<li>可以使用 <code>app.engine(ext, callback)</code> 方法创建自己的模板引擎<ul>
<li><code>ext</code> 表示文件扩展名</li>
<li><code>callback</code> 表示模板引擎函数, 它接受以下项作为参数: 文件位置、选项对象和回调函数</li>
</ul>
</li>
<li>以下代码示例实现非常简单的模板引擎以呈现 <code>.ntl</code> 文件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// this engine requires the fs module</span><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>); <br><span class="hljs-comment">// define the template engine</span><br>app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;ntl&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">filePath, options, callback</span>) &#123; <br>	fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, content</span>) &#123;<br>		<span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(err));<br> 		<span class="hljs-comment">// this is an extremely simple template engine</span><br> 		<span class="hljs-keyword">var</span> rendered = content.<span class="hljs-title function_">toString</span>()<br>        	.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#title#&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>+ options.<span class="hljs-property">title</span> +<span class="hljs-string">&#x27;&#x27;</span>)<br> 			.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#message#&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>+ options.<span class="hljs-property">message</span> +<span class="hljs-string">&#x27;&#x27;</span>);<br> 		<span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, rendered);<br> 	&#125;);<br>&#125;);<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, <span class="hljs-string">&#x27;./views&#x27;</span>); <span class="hljs-comment">// specify the views directory</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ntl&#x27;</span>); <span class="hljs-comment">// register the template engine</span><br><br><span class="hljs-comment">// 应用程序现在能够呈现 .ntl 文件。在 views 目录中创建名为 index.ntl 且包含以下内容的文件: </span><br>#title#<br>#message#<br><span class="hljs-comment">// 然后, 在应用程序中创建以下路径: </span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hey&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello there!&#x27;</span>&#125;);<br>&#125;);<br><span class="hljs-comment">// 您向主页发出请求时, index.ntl 将呈现为 HTML。</span><br></code></pre></td></tr></table></figure>
<h4 id="调试-Express"><a href="#调试-Express" class="headerlink" title="调试 Express"></a>调试 Express</h4><ul>
<li>Express 在内部使用调试模块来记录关于路由匹配、使用的中间件函数、应用程序模式以及请求/响应循环流程的信息</li>
<li>debug 就像是扩充版的 console.log, 但是与 console.log 不同, 不必注释掉生产代码中的 debug 日志。缺省情况下, 日志记录功能已关闭, 可以使用 DEBUG 环境变量有条件地开启日志记录</li>
<li>要查看 Express 中使用的所有内部日志, 在启动应用程序时, 请将 DEBUG 环境变量设置为 express:*<ul>
<li>$ DEBUG=express:* node index.js</li>
</ul>
</li>
<li>在 Windows 上, 使用对应的命令<ul>
<li>> set DEBUG=express:* &amp; node index.js</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222224055948.png" alt="image-20230222224055948" style="zoom:80%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-5-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-5-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理(5) 语义分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-07 13:33:47" itemprop="dateCreated datePublished" datetime="2022-12-07T13:33:47+08:00">2022-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><p>本节课代码见<a target="_blank" rel="noopener" href="https://github.com/courses-at-nju-by-hfwei/2022-compilers-coding">https://github.com/courses-at-nju-by-hfwei/2022-compilers-coding</a></p>
<h2 id="一、类型系统与类型检查"><a href="#一、类型系统与类型检查" class="headerlink" title="一、类型系统与类型检查"></a>一、类型系统与类型检查</h2><h3 id="1-类型系统"><a href="#1-类型系统" class="headerlink" title="1. 类型系统"></a>1. 类型系统</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207151819743.png" alt="image-20221207151819743" style="zoom:80%;" /></p>
<h4 id="1-1-JS-糟糕的类型系统"><a href="#1-1-JS-糟糕的类型系统" class="headerlink" title="1.1 JS 糟糕的类型系统"></a>1.1 JS 糟糕的类型系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207151842025.png" alt="image-20221207151842025" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207151856769.png" alt="image-20221207151856769" style="zoom:80%;" /></p>
<h3 id="2-类型检查"><a href="#2-类型检查" class="headerlink" title="2. 类型检查"></a>2. 类型检查</h3><h4 id="2-1-类型检查"><a href="#2-1-类型检查" class="headerlink" title="2.1 类型检查"></a>2.1 类型检查</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207152018144.png" alt="image-20221207152018144" style="zoom:80%;" /></p>
<h4 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2 类型转换"></a>2.2 类型转换</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207152042825.png" alt="image-20221207152042825" style="zoom:80%;" /></p>
<blockquote>
<p><strong>不要写这样的代码!!!</strong></p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207152141192.png" alt="image-20221207152141192" style="zoom:80%;" /></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/conversion">Conversion @ cppreference.com</a></li>
</ul>
<h4 id="2-3-类型综合"><a href="#2-3-类型综合" class="headerlink" title="2.3 类型综合"></a>2.3 类型综合</h4><p>根据子表达式的类型确定表达式的类型</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207152444442.png" alt="image-20221207152444442" style="zoom:80%;" /></p>
<h4 id="2-4-类型推导"><a href="#2-4-类型推导" class="headerlink" title="2.4 类型推导"></a>2.4 类型推导</h4><p>根据某语言结构的使用方式确定表达式的类型</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207152504821.png" alt="image-20221207152504821" style="zoom:80%;" /></p>
<h3 id="3-数组类型文法"><a href="#3-数组类型文法" class="headerlink" title="3. 数组类型文法"></a>3. 数组类型文法</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207152709599.png" alt="image-20221207152709599" style="zoom:80%;" /></p>
<h4 id="3-1-语法分析树"><a href="#3-1-语法分析树" class="headerlink" title="3.1 语法分析树"></a>3.1 语法分析树</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207152729596.png" alt="image-20221207152729596" style="zoom:80%;" /></p>
<h4 id="3-2-Listener"><a href="#3-2-Listener" class="headerlink" title="3.2 Listener"></a>3.2 Listener</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212160736411.png" alt="image-20221212160736411" style="zoom:80%;" /></p>
<h4 id="3-3-ParseTreeProperty"><a href="#3-3-ParseTreeProperty" class="headerlink" title="3.3 ParseTreeProperty"></a>3.3 ParseTreeProperty</h4><ul>
<li>通过 ANTLR4 提供的 <code>ParseTreeProperty&lt;&gt;</code> 来存储 <code>basicType</code> 与 <code>arrayType</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ParseTreeProperty&lt;Type&gt; arrayTypeProperty = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParseTreeProperty</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ParseTreeProperty&lt;Type&gt; basicTypeProperty = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParseTreeProperty</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212160750687.png" alt="image-20221212160750687" style="zoom:80%;" /></p>
<ul>
<li>赋值语句类型检查，详见代码</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212162801953.png" alt="image-20221212162801953" style="zoom:80%;" /></p>
<h3 id="4-类型声明文法"><a href="#4-类型声明文法" class="headerlink" title="4. 类型声明文法"></a>4. 类型声明文法</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212160914001.png" alt="image-20221212160914001" style="zoom:80%;" /></p>
<ul>
<li>与数组类似，需要保存最左侧的类型</li>
</ul>
<h3 id="5-类型系统"><a href="#5-类型系统" class="headerlink" title="5. 类型系统"></a>5. 类型系统</h3><p><a target="_blank" rel="noopener" href="https://youtu.be/SWTWkYbcWU0">https://youtu.be/SWTWkYbcWU0</a></p>
<h2 id="二、属性文法"><a href="#二、属性文法" class="headerlink" title="二、属性文法"></a>二、属性文法</h2><h3 id="1-属性文法"><a href="#1-属性文法" class="headerlink" title="1. 属性文法"></a>1. 属性文法</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212165143201.png" alt="image-20221212165143201" style="zoom:80%;" /></p>
<p>$\textcolor{red}{\textbf{属性文法}\text{(Attribute Grammar)}:} 为上下文无关文法赋予\textcolor{blue}{\textbf{语义}}$</p>
<blockquote>
<p>终结符或非终结符上的属性就可以看作语义</p>
<p>属性分为两类:</p>
<ul>
<li>综合属性</li>
<li>继承属性</li>
</ul>
</blockquote>
<h4 id="1-1-关键问题"><a href="#1-1-关键问题" class="headerlink" title="1.1 关键问题"></a>1.1 关键问题</h4><p><strong>如何基于上下文无关文法做上下文相关分析?</strong></p>
<blockquote>
<p>上下文相关文法分析复杂度太高</p>
</blockquote>
<p>关键: <strong>语法分析树</strong>上的<strong>有序</strong>信息流动</p>
<ul>
<li>通过 DFS 来遍历</li>
</ul>
<h3 id="2-计算属性值"><a href="#2-计算属性值" class="headerlink" title="2. 计算属性值"></a>2. 计算属性值</h3><h4 id="2-1-Offline-方式"><a href="#2-1-Offline-方式" class="headerlink" title="2.1 Offline 方式"></a>2.1 Offline 方式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212170016385.png" alt="image-20221212170016385" style="zoom:80%;" /></p>
<blockquote>
<p>但因为要先建立语法分析树，实际上遍历了两遍，效率并不高</p>
</blockquote>
<h4 id="2-2-语法分析过程中"><a href="#2-2-语法分析过程中" class="headerlink" title="2.2 语法分析过程中"></a>2.2 语法分析过程中</h4><p>在<strong>语法分析过程中</strong>实现属性文法</p>
<p><strong>基本思想: </strong>一个动作在它<strong>左边的</strong>所有文法符号都<strong>处理</strong>过之后立刻执行</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212170232773.png" alt="image-20221212170232773" style="zoom:80%;" /></p>
<p><strong>时机(Timing)</strong></p>
<p>语义动作嵌入在什么地方? 这决定了何时执行语义动作。</p>
<h4 id="2-3-实现迷你计算器"><a href="#2-3-实现迷你计算器" class="headerlink" title="2.3 实现迷你计算器"></a>2.3 实现迷你计算器</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212172137328.png" alt="image-20221212172137328" style="zoom:80%;" /></p>
<blockquote>
<p>expr 的 value 只依赖于子节点的 value</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs antlr4">@header &#123;<br>package ag;<br>import java.util.*;<br>&#125;<br><br>@parser::members &#123;<br>  Map&lt;String, Integer&gt; memory = new HashMap&lt;&gt;();<br><br>  int eval(int left, int right, int op) &#123;<br>    switch (op) &#123;<br>      case ADD : return left + right;<br>      case SUB : return left - right;<br>      case MUL : return left * right;<br>      case DIV : return left / right;<br>      default : return 0;<br>    &#125;<br>  &#125;<br>&#125;<br><br>prog : stat* EOF ;<br><br>stat : expr         &#123; System.out.println($expr.val); &#125;<br>     | ID &#x27;=&#x27; expr  &#123; memory.put($ID.text, $expr.val); &#125;  // $ID.text -&gt; ID.getText()<br>     ;<br><br>expr returns [int val]<br>    : left = expr op = (&#x27;*&#x27; | &#x27;/&#x27;) right = expr     &#123; $val = eval($left.val, $right.val, $op.type); &#125;<br>    | left = expr op = (&#x27;+&#x27; | &#x27;-&#x27;) right = expr     &#123; $val = eval($left.val, $right.val, $op.type); &#125;<br>    | &#x27;(&#x27; expr &#x27;)&#x27;                                  &#123; $val = $expr.val; &#125;<br>    | ID                                            &#123; String id = $ID.text; $val = memory.getOrDefault(id, 0); &#125;<br>    | INT                                           &#123; $val = $INT.int; &#125;<br>    ;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-输出表格文件"><a href="#2-4-输出表格文件" class="headerlink" title="2.4 输出表格文件"></a>2.4 输出表格文件</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221212174143821.png" alt="image-20221212174143821" style="zoom:80%;" /></p>
<h3 id="3-SDD"><a href="#3-SDD" class="headerlink" title="3. SDD"></a>3. SDD</h3><h4 id="3-1-SDD"><a href="#3-1-SDD" class="headerlink" title="3.1 SDD"></a>3.1 SDD</h4><p><strong>Definition (语法制导定义 (Syntax-Directed Definition; SDD))</strong></p>
<p>SDD 是一个上下文无关文法和<strong>属性</strong>及<strong>规则</strong>的结合</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221214141005939.png" alt="image-20221214141005939" style="zoom:80%;" /></p>
<p>要点:</p>
<ul>
<li>SDD <strong>唯一确定</strong>了语法分析树上每个<strong>非终结符</strong>节点的属性值</li>
<li>SDD <strong>没有</strong>规定以什么方式、什么顺序计算这些属性值</li>
</ul>
<h4 id="3-2-注释语法分析树"><a href="#3-2-注释语法分析树" class="headerlink" title="3.2 注释语法分析树"></a>3.2 注释语法分析树</h4><p><strong>注释(annotated)语法分析树: </strong>显示了各个属性值的语法分析树</p>
<p>ANTLR4 中使用 ParseTreeProperty 存放属性值</p>
<ul>
<li><code>ParseTreeProperty&lt;Integer&gt;   put(ctx, ...)  get(ctx, ...)</code></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219144009716.png" alt="image-20221219144009716" style="zoom:80%;" /></p>
<h4 id="3-3-综合属性"><a href="#3-3-综合属性" class="headerlink" title="3.3 综合属性"></a>3.3 综合属性</h4><h5 id="Definition-综合属性-Synthesized-Attribute"><a href="#Definition-综合属性-Synthesized-Attribute" class="headerlink" title="Definition (综合属性 (Synthesized Attribute))"></a>Definition (综合属性 (Synthesized Attribute))</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219144328213.png" alt="image-20221219144328213" style="zoom:80%;" /></p>
<h5 id="Definition-S-属性定义-S-Attributed-Definition"><a href="#Definition-S-属性定义-S-Attributed-Definition" class="headerlink" title="Definition ($S$ 属性定义 ($S$-Attributed Definition))"></a>Definition ($S$ 属性定义 ($S$-Attributed Definition))</h5><p>如果一个 SDD 的每个属性都是综合属性, 则它是 $S$ 属性定义</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219144737275.png" alt="image-20221219144737275" style="zoom:80%;" /></p>
<ul>
<li>此类属性值的计算可以在 <em>自顶向下</em> 的 $LL$ 语法分析<strong>过程中</strong>实现</li>
<li>在 $LL$ 语法分析器中, 递归下降函数 A <strong>返回</strong> 时, 计算相应节点 A 的综合属性值</li>
</ul>
<h4 id="3-4-继承属性"><a href="#3-4-继承属性" class="headerlink" title="3.4 继承属性"></a>3.4 继承属性</h4><h5 id="Definition-继承属性-Inherited-Attribute"><a href="#Definition-继承属性-Inherited-Attribute" class="headerlink" title="Definition (继承属性 (Inherited Attribute))"></a>Definition (继承属性 (Inherited Attribute))</h5><p>节点 $N$ 上的<strong>继承属性</strong>只能通过 <strong>$N$ 的父节点、$N$ 本身和 $N$ 的兄弟节点</strong>上的属性来定义。</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>$T$′ 有一个综合属性 $syn$ 与一个继承属性 $inh$</p>
<ul>
<li>继承属性 $T$′.$inh$ 用于在表达式中从左向右传递中间计算结果</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219145400168.png" alt="image-20221219145400168" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219145643816.png" alt="image-20221219145643816" style="zoom:80%;" /></p>
<h4 id="3-5-L-属性定义"><a href="#3-5-L-属性定义" class="headerlink" title="3.5 $L$ 属性定义"></a>3.5 $L$ 属性定义</h4><h5 id="Definition-L-属性定义-textcolor-red-L-Attributed-Definition"><a href="#Definition-L-属性定义-textcolor-red-L-Attributed-Definition" class="headerlink" title="Definition ($L$ 属性定义 ($\textcolor{red}{L}$-Attributed Definition))"></a>Definition ($L$ 属性定义 ($\textcolor{red}{L}$-Attributed Definition))</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219145937914.png" alt="image-20221219145937914" style="zoom:80%;" /></p>
<h5 id="例1：非-L-属性定义举例"><a href="#例1：非-L-属性定义举例" class="headerlink" title="例1：非 $L$ 属性定义举例"></a>例1：非 $L$ 属性定义举例</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219150215536.png" alt="image-20221219150215536" style="zoom:80%;" /></p>
<ul>
<li>$B.i$ 依赖了右兄弟节点的 $C.c$ 属性</li>
</ul>
<h5 id="例2：数组类型文法举例"><a href="#例2：数组类型文法举例" class="headerlink" title="例2：数组类型文法举例"></a>例2：数组类型文法举例</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219150436131.png" alt="image-20221219150436131" style="zoom:80%;" /></p>
<ul>
<li><p>继承属性 $C.b$ 将一个基本类型沿着树向下传播</p>
</li>
<li><p>综合属性 $C.t$ 收集最终得到的类型表达式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219150516491.png" alt="image-20221219150516491" style="zoom:80%;" /></p>
</li>
</ul>
<h5 id="例3：后缀表示"><a href="#例3：后缀表示" class="headerlink" title="例3：后缀表示"></a>例3：后缀表示</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219151655273.png" alt="image-20221219151655273" style="zoom:80%;" /></p>
<ul>
<li>(9 − 5) + 2 $\Rightarrow$ 95 − 2 +</li>
<li>9 − (5 + 2) $\Rightarrow$ 952 + −</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219151759248.png" alt="image-20221219151759248" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219151812012.png" alt="image-20221219151812012" style="zoom:80%;" /></p>
<h5 id="例4：有符号二进制数文法"><a href="#例4：有符号二进制数文法" class="headerlink" title="例4：有符号二进制数文法"></a>例4：有符号二进制数文法</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219152055063.png" alt="image-20221219152055063" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219152127179.png" alt="image-20221219152127179" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219152316587.png" alt="image-20221219152316587" style="zoom:80%;" /></p>
<h3 id="4-SDT"><a href="#4-SDT" class="headerlink" title="4. SDT"></a>4. SDT</h3><h4 id="4-1-语法制导的翻译方案-SDT"><a href="#4-1-语法制导的翻译方案-SDT" class="headerlink" title="4.1 语法制导的翻译方案(SDT)"></a>4.1 语法制导的翻译方案(SDT)</h4><p>Definition (语法制导的翻译方案 (Syntax-Directed Translation Scheme; SDT))</p>
<p><strong>SDT</strong> 是在其产生式体中嵌入<strong>语义动作</strong>的上下文无关文法。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219152659177.png" alt="image-20221219152659177" style="zoom:80%;" /></p>
<blockquote>
<p>$Q$ : 如何将带有<strong>语义规则</strong>的 SDD 转换为带有<strong>语义动作</strong>的 SDT</p>
</blockquote>
<h4 id="4-2-后缀翻译方案"><a href="#4-2-后缀翻译方案" class="headerlink" title="4.2 后缀翻译方案"></a>4.2 后缀翻译方案</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219152852152.png" alt="image-20221219152852152" style="zoom:80%;" /></p>
<h4 id="4-3-L-属性定义-与-LL-语法分析"><a href="#4-3-L-属性定义-与-LL-语法分析" class="headerlink" title="4.3 $L$ 属性定义 与 $LL$ 语法分析"></a>4.3 $L$ 属性定义 与 $LL$ 语法分析</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219153015846.png" alt="image-20221219153015846" style="zoom:80%;" /></p>
<p><strong>原则:</strong></p>
<ol>
<li><strong>从左到右</strong>处理各个 $X_i$ 符号</li>
<li>对每个 $X_i$ , 先计算<strong>继承属性</strong>, 后计算<strong>综合属性</strong></li>
</ol>
<p>具体如下图所示</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219153132204.png" alt="image-20221219153132204" style="zoom:80%;" /></p>
<p><strong>举例</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219153410001.png" alt="image-20221219153410001" style="zoom:80%;" /></p>
<h4 id="4-4-左递归问题"><a href="#4-4-左递归问题" class="headerlink" title="4.4 左递归问题"></a>4.4 左递归问题</h4><blockquote>
<p>许多工具是不支持左递归的，会转化为右递归，这会带来一些问题</p>
<ul>
<li>因为 ANTLR4 支持直接左递归，暂不考虑</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219153929953.png" alt="image-20221219153929953" style="zoom:80%;" /></p>
<ul>
<li><p>继承属性 $\textcolor{blue}{R.i}$ 用于计算并传递中间结果</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219154145315.png" alt="image-20221219154145315" style="zoom:80%;" /></p>
</li>
<li><p>右递归翻译方案</p>
<ul>
<li><p><strong>原则: 继承属性在处理文法符号之前, 综合属性在处理文法符号之后</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219154523447.png" alt="image-20221219154523447" style="zoom:80%;" /></p>
</li>
<li><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219154606283.png" alt="image-20221219154606283" style="zoom:80%;" /></p>
</li>
<li><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219154556836.png" alt="image-20221219154556836" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/antlr/antlr4/blob/master/doc/faq/general.md#what-is-the-difference-between-antlr-3-and-4">What is the difference between ANTLR 3 and 4?</a></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221219155751002.png" alt="image-20221219155751002" style="zoom:80%;" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/07/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-6-JS%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/07/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-6-JS%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Web前端开发(6) JS最佳实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-07 10:29:49" itemprop="dateCreated datePublished" datetime="2022-12-07T10:29:49+08:00">2022-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="8-JavaScript最佳实践"><a href="#8-JavaScript最佳实践" class="headerlink" title="8-JavaScript最佳实践"></a>8-JavaScript最佳实践</h1><h2 id="1-最佳实践"><a href="#1-最佳实践" class="headerlink" title="1. 最佳实践"></a>1. 最佳实践</h2><h4 id="避免全局变量"><a href="#避免全局变量" class="headerlink" title="避免全局变量"></a>避免全局变量</h4><ul>
<li>请尽量少地使用全局变量</li>
<li>它包括所有的数据类型、对象和函数</li>
<li>全局变量和函数可被其他脚本覆盖</li>
<li>请使用局部变量替代, 并学习如何使用闭包</li>
</ul>
<h4 id="始终声明局部变量"><a href="#始终声明局部变量" class="headerlink" title="始终声明局部变量"></a>始终声明局部变量</h4><ul>
<li>所有在函数中使用的变量应该被声明为局部变量</li>
<li>局部变量必须通过 var 关键词来声明, 否则它们将变成全局变量</li>
<li>严格模式不允许未声明的变量<ul>
<li><code>&quot;use strict&quot;;</code></li>
</ul>
</li>
</ul>
<h4 id="为什么使用严格模式"><a href="#为什么使用严格模式" class="headerlink" title="为什么使用严格模式"></a>为什么使用严格模式</h4><ul>
<li>消除Javascript语法的一些不合理、不严谨之处, 减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处, 保证代码运行的安全</li>
<li>提高编译器效率, 增加运行速度</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ul>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><ul>
<li>ES6的模块自动采用严格模式, 不管模块头部有没有use strict</li>
<li>严格模式有以下限制<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性, 否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值, 否则报错</li>
<li>不能使用前缀0表示⼋进制数, 否则报错</li>
<li>不能删除不可删除的属性, 否则报错</li>
<li>不能使用<code>delete prop</code>删除变量, 会报错, 只能删除属性<code>delete global[prop]</code></li>
<li>eval不会在它的外层作用域引入变量</li>
<li>eval和arguments不能被重新赋值</li>
<li>arguments不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止this指向全局对象</li>
<li>不能使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 获取函数调用的堆栈</li>
<li>增加了保留字(比如protected, static 和 interface)</li>
</ul>
</li>
</ul>
<h4 id="在顶部声明"><a href="#在顶部声明" class="headerlink" title="在顶部声明"></a>在顶部声明</h4><ul>
<li>一项好的编码习惯是把所有声明放在每段脚本或函数的顶部。</li>
<li>这么做的好处是：<ul>
<li>获得更整洁的代码</li>
<li>提供了查找局部变量的好位置</li>
<li>更容易避免不需要的全局变量</li>
<li>减少不需要的重新声明的可能性</li>
</ul>
</li>
</ul>
<h4 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h4><ul>
<li>在您声明变量时对其进行初始化是个好习惯</li>
<li>这么做的好处是：<ul>
<li>更整洁的代码</li>
<li>在单独的位置来初始化变量</li>
<li>避免未定义值</li>
</ul>
</li>
</ul>
<h4 id="请不要声明数值、字符串或布尔对象"><a href="#请不要声明数值、字符串或布尔对象" class="headerlink" title="请不要声明数值、字符串或布尔对象"></a>请不要声明数值、字符串或布尔对象</h4><ul>
<li>请始终将数值、字符串或布尔值视作原始值。而非对象。</li>
<li>如果把这些类型声明为对象, 会拖慢执行速度, 并产生讨厌的副作用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Example</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;John&quot;</span>;             <br><span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>(x === y) <span class="hljs-comment">// is false because x is a string and y is an object.</span><br><br><span class="hljs-comment">//Or even worse:</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;John&quot;</span>);             <br><span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>(x == y) <span class="hljs-comment">// is false because you cannot compare objects.</span><br></code></pre></td></tr></table></figure>
<h4 id="请勿使用-new-Object"><a href="#请勿使用-new-Object" class="headerlink" title="请勿使用 new Object()"></a>请勿使用 <code>new Object()</code></h4><ul>
<li>请使用 <code>&#123;&#125;</code> 来代替 <code>new Object()</code></li>
<li>请使用 <code>&quot;&quot;</code> 来代替 <code>new String()</code></li>
<li>请使用 <code>0</code> 来代替 <code>new Number()</code></li>
<li>请使用 <code>false</code> 来代替 <code>new Boolean()</code></li>
<li>请使用 <code>[]</code> 来代替 <code>new Array()</code></li>
<li>请使用 <code>/()/</code> 来代替 <code>new RegExp()</code></li>
<li>请使用 <code>function ()&#123;&#125;</code> 来代替 <code>new Function()</code></li>
</ul>
<h4 id="意识到自动类型转换"><a href="#意识到自动类型转换" class="headerlink" title="意识到自动类型转换"></a>意识到自动类型转换</h4><ul>
<li>请意识到数值会被意外转换为字符串或 NaN(Not a Number)</li>
<li>JavaScript 属于松散类型。变量可包含不同的数据类型, 并且变量能够改变其数据类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Example</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;Hello&quot;</span>;     <span class="hljs-comment">// typeof x is a string</span><br>x = <span class="hljs-number">5</span>;               <span class="hljs-comment">// changes typeof x to a number</span><br><span class="hljs-comment">// When doing mathematical operations, JavaScript can convert numbers to strings, Example:</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span> + <span class="hljs-number">7</span>;       <span class="hljs-comment">// x.valueOf() is 12, typeof x is a number</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span> + <span class="hljs-string">&quot;7&quot;</span>;     <span class="hljs-comment">// x.valueOf() is 57, typeof x is a string</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span> - <span class="hljs-number">7</span>;       <span class="hljs-comment">// x.valueOf() is -2, typeof x is a number</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span> - <span class="hljs-string">&quot;7&quot;</span>;     <span class="hljs-comment">// x.valueOf() is -2, typeof x is a number</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span> - <span class="hljs-string">&quot;x&quot;</span>;    <span class="hljs-comment">// x.valueOf() is NaN, typeof x is a number</span><br><span class="hljs-comment">// Subtracting a string from a string, does not generate an error but returns NaN (Not a Number), Example</span><br><span class="hljs-string">&quot;Hello&quot;</span> - <span class="hljs-string">&quot;Dolly&quot;</span>    <span class="hljs-comment">// returns NaN</span><br></code></pre></td></tr></table></figure>
<h4 id="使用-比较"><a href="#使用-比较" class="headerlink" title="使用 === 比较"></a>使用 <code>===</code> 比较</h4><ul>
<li>== 比较运算符总是在比较之前进行类型转换(以匹配类型)</li>
<li>=== 运算符会强制对值和类型进行比较</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Example</span><br><span class="hljs-number">0</span> == <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> == <span class="hljs-string">&quot;1&quot;</span>;       <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> == <span class="hljs-literal">true</span>;      <span class="hljs-comment">// true</span><br><br><span class="hljs-number">0</span> === <span class="hljs-string">&quot;&quot;</span>;       <span class="hljs-comment">// false</span><br><span class="hljs-number">1</span> === <span class="hljs-string">&quot;1&quot;</span>;    	<span class="hljs-comment">// false</span><br><span class="hljs-number">1</span> === <span class="hljs-literal">true</span>;     <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<h4 id="使用-Parameter-Defaults"><a href="#使用-Parameter-Defaults" class="headerlink" title="使用 Parameter Defaults"></a>使用 Parameter Defaults</h4><ul>
<li>如果调用函数时缺少一个参数, 那么这个缺失参数的值会被设置为 undefined</li>
<li>undefined 值会破坏您的代码。为参数设置默认值是一个好习惯</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">if</span> (y === <span class="hljs-literal">undefined</span>) &#123;<br>        y = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="用-default-来结束-switch"><a href="#用-default-来结束-switch" class="headerlink" title="用 default 来结束 switch"></a>用 default 来结束 switch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getDay</span>()) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    	day = <span class="hljs-string">&quot;Sunday&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>	...<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>      	day = <span class="hljs-string">&quot;Saturday&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>        day = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="避免使用-eval"><a href="#避免使用-eval" class="headerlink" title="避免使用 eval()"></a>避免使用 eval()</h4><ul>
<li>eval() 函数用于将文本作为代码来允许。在几乎所有情况下, 都没有必要使用它</li>
<li>因为允许任意代码运行, 它同时也意味着安全问题</li>
</ul>
<h4 id="“For-in”-Statements"><a href="#“For-in”-Statements" class="headerlink" title="“For in” Statements"></a>“For in” Statements</h4><ul>
<li>遍历对象内的成员时, 你也会得到方法函数。为了解决这个问题, 应始终将你的代码包装在一个 if 语句中来过滤信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> object) &#123;<br>	<span class="hljs-keyword">if</span>(object.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-params">key</span>) &#123;<br>		...then <span class="hljs-keyword">do</span> something...<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="减少循环中的活动"><a href="#减少循环中的活动" class="headerlink" title="减少循环中的活动"></a>减少循环中的活动</h4><ul>
<li>循环每迭代一次, 循环中的每条语句, 包括 for 语句, 都会被执行</li>
<li>能够放在循环之外的语句或赋值会使循环运行得更快</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 差的代码：</span><br><span class="hljs-keyword">var</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;&#125;<br><span class="hljs-comment">// 更好的代码：</span><br><span class="hljs-keyword">var</span> i;<br><span class="hljs-keyword">var</span> l = arr.<span class="hljs-property">length</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-Vanilla-JS"><a href="#2-Vanilla-JS" class="headerlink" title="2. Vanilla JS"></a>2. Vanilla JS</h2><h4 id="What-is-Vanilla-JS？"><a href="#What-is-Vanilla-JS？" class="headerlink" title="What is Vanilla JS？"></a>What is Vanilla JS？</h4><ul>
<li>vanillaJS 是史上最轻量跨平台前端框架, 没有之一</li>
<li>vanillaJS 小巧而符合直觉, Bootstrap5 舍弃了 JQuery , 使用的知名企业很多</li>
<li>其实就是原生 js</li>
</ul>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><ul>
<li>VanillaJS包括如下模块, 下载安装时可以只选择需要的模块, 以便提高性能。<ul>
<li>核心功能、DOM(遍历/选择器)、基于原型的对象系统、AJAX、动画、事件系统、正则表达式、函数作为第一类对象、闭包、数学库、数组库、字符串库</li>
</ul>
</li>
</ul>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><ul>
<li>引入方式只需要在html中加入这行script：<ul>
<li><code>&lt;script src=&quot;path/to/vanilla.js&quot;&gt;&lt;/script&gt;</code></li>
</ul>
</li>
<li><p>当部署在正式环境中, 不需要引用</p>
</li>
<li><p><em>plain JavaScript without any additional libraries</em></p>
</li>
</ul>
<h4 id="通过ID获取元素"><a href="#通过ID获取元素" class="headerlink" title="通过ID获取元素"></a>通过ID获取元素</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230125155615189.png" alt="image-20230125155615189"></p>
<h4 id="JS框架的优点"><a href="#JS框架的优点" class="headerlink" title="JS框架的优点"></a>JS框架的优点</h4><ul>
<li>JS框架封装了复杂困难的代码</li>
<li>JS框架能加快开发速度, 更快完成项目</li>
<li>JS框架让你更专注于产品内容的价值, 而不是实现过程</li>
<li>JS框架让合作更简单, 大家都对基础代码有共同的理解</li>
<li>JS框架还会强迫你练习, 多实践, 顺能生巧</li>
</ul>
<h4 id="JS框架的问题"><a href="#JS框架的问题" class="headerlink" title="JS框架的问题"></a>JS框架的问题</h4><ul>
<li>每个项目的开发都会遇到框架文档没有说明的问题, 这时候就要深入框架查找原因, 这时候就需要对原生JavaScript的深度掌握</li>
<li>新框架频繁发布, 更新快速, 一旦确定了项目的技术栈, 随着时间, 如何升级更新是个问题</li>
</ul>
<h4 id="Why-Vanilla-JavaScript"><a href="#Why-Vanilla-JavaScript" class="headerlink" title="Why Vanilla JavaScript"></a>Why Vanilla JavaScript</h4><ul>
<li>学会 Vanilla JavaScript能真正理解JS框架, 甚至能为其贡献代码, 还能帮助选择合适的框架</li>
<li>如果不知道Web基本原则, 语言本身的演变和新框架的不断到来。。。</li>
<li>知道纯JS将成为一个能够(不用疯狂搜索原因)解决复杂问题的关键工程师</li>
<li>增加通用能力和生产力, 不管在前端还是后端</li>
<li>创新的工具, 而不只是执行</li>
<li>指导什么时候使用或者不使用框架</li>
<li>更好地了解浏览器和计算机工作原理</li>
</ul>
<h2 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3. 正则表达式"></a>3. 正则表达式</h2><h4 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h4><ul>
<li>正则表达式是用于匹配字符串中字符组合的模式</li>
<li>正则表达式是构成搜索模式(search pattern)的字符序列</li>
<li>当您搜索文本中的数据时, 您可使用搜索模式来描述您搜索的内容</li>
<li>正则表达式可以是单字符, 或者更复杂的模式</li>
<li>正则表达式可用于执行所有类型的文本搜索和文本替换操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 格式形如: /正则表达式主体/修饰符(可选)</span><br><span class="hljs-comment">// 邮箱</span><br>/([\w\-]+\@[\w\-]+\.[\w\-]+)/<br><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/ab+c/</span>;<br></code></pre></td></tr></table></figure>
<h4 id="使用简单模式"><a href="#使用简单模式" class="headerlink" title="使用简单模式"></a>使用简单模式</h4><ul>
<li><p>以 / 开始和结束</p>
</li>
<li><p>最简单的正则是子字符串匹配</p>
</li>
<li><p>下述正则表达式匹配任一包含 “abc” 的字符串:</p>
<ul>
<li>YES: “abc”, “abcdef”, “defabc”, “.=.abc.=.”, …</li>
<li><p>NO: “fedcba”, “ab c”, “PHP”, …</p>
</li>
<li><p><code>/abc/</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符: ."></a>匹配单个字符: <code>.</code></h4><ul>
<li><code>.</code> 匹配单个字符, 除了换行和行结束符<ul>
<li><code>/.oo.y/</code> 匹配 “Doocy”, “goofy”, “LooNy”, …</li>
</ul>
</li>
<li>修饰符 <code>i</code> 执行对大小写不敏感的匹配<ul>
<li><code>/mart/i</code> matches “Marty Stepp”, “smart fellow”, “WALMART”, …</li>
</ul>
</li>
</ul>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符: |, (), ^, \"></a>特殊字符: |, (), ^, \</h4><ul>
<li>| 选择匹配<ul>
<li><code>/abc|def|g/</code> 匹配 “abc”, “def”, or “g”</li>
</ul>
</li>
<li>() 子表达式：把一个表达式分割为几个子表达式是非常有用的<ul>
<li><code>/(Homer|Marge) Simpson/</code> 匹配 “Homer Simpson” or “Marge Simpson”</li>
</ul>
</li>
<li>^ 匹配输入的开始。如果多行标志被设置为 true, 那么也匹配换行符后紧跟的位置<ul>
<li><code>/^A/</code> 并不会匹配 “an A” 中的 ‘A’, 但是会匹配 “An E” 中的 ‘A’</li>
</ul>
</li>
<li>\$ 匹配输入的结束。如果多行标志被设置为 true, 那么也匹配换行符前的位置<ul>
<li>例如, <code>/t$/</code> 并不会匹配 “eater” 中的 ‘t’, 但是会匹配 “eat” 中的 ‘t’</li>
</ul>
</li>
<li> 转义<ul>
<li>如果要匹配特殊字符: /\\$.[]()^*+?</li>
<li><code>/&lt;br \/&gt;/</code> 匹配 <code>&lt;br /&gt;</code> 标记</li>
</ul>
</li>
</ul>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词: *, +, ?"></a>量词: *, +, ?</h4><ul>
<li>* 匹配 0 次或更多次<ul>
<li>/abc*/ 匹配 “ab”, “abc”, “abcc”, “abccc”, ..</li>
<li>/a(bc)*/ 匹配 “a”, “abc”, “abcbc”, “abcbcbc”, …</li>
<li>/a.*a/ 匹配 “aa”, “aba”, “a8qa”, “a!?_a”, …</li>
</ul>
</li>
<li>+ 匹配 1 次或更多次<ul>
<li><code>/a(bc)+/</code> 匹配 “abc”, “abcbc”, “abcbcbc”, …</li>
<li><code>/Goo+gle/</code> 匹配 “Google”, “Gooogle”, “Goooogle”, …</li>
</ul>
</li>
<li>? 匹配 0 或 1 次<ul>
<li><code>/a(bc)?/</code> 匹配 “a” or “abc”</li>
</ul>
</li>
</ul>
<h4 id="更多量词-min-max"><a href="#更多量词-min-max" class="headerlink" title="更多量词: {min,max}"></a>更多量词: {min,max}</h4><ul>
<li>{min,max}, 允许重复的次数, 其中, “min” 是 0 或一个正整数, “max” 是一个正整数, 而 max &gt; min, 至少匹配 “min” 次, 最多匹配 “max” 次<ul>
<li><code>/a(bc)&#123;2,4&#125;/</code> matches “abcbc”, “abcbcbc”, or “abcbcbcbc”</li>
</ul>
</li>
<li>省略形式<ul>
<li>{2,} 匹配至少 2 次</li>
<li>{,6} 匹配最多 6 次</li>
<li>{3}  匹配正好 3 次</li>
</ul>
</li>
</ul>
<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集: []"></a>字符集: []</h4><ul>
<li>[] 字符集。 匹配任何一个包含的字符。<ul>
<li><code>/[bcd]art/</code> 匹配包含 “bart”, “cart”, and “dart” 的字符串</li>
<li>等同于 “/(b|c|d)art/“ 但更短</li>
<li><strong>不需要转义</strong></li>
</ul>
</li>
<li>[]中, 许多修饰符作为正常字符<ul>
<li><code>/what[!*?]*/</code> matches “what”, “what!”, “what?**!”, “what??!”, …</li>
</ul>
</li>
<li>匹配 DNA (strings of A, C, G, or T) 的正则表达式?</li>
</ul>
<h4 id="字符范围-start-end"><a href="#字符范围-start-end" class="headerlink" title="字符范围: [start-end]"></a>字符范围: [start-end]</h4><ul>
<li>可以使用连字符来指定字符范围, 但如果连字符显示为方括号中的第一个或最后一个字符, 则它将被视为作为普通字符包含在字符集中的文字连字符。也可以在字符集中包含字符类。<ul>
<li><code>/[a-z]/</code> 匹配任一小写字母</li>
<li><code>/[a-zA-Z0-9]/</code> 匹配任一大小写字母和数字</li>
</ul>
</li>
<li>起始 ^ 表示一个否定的或被补充的字符集。也就是说, 它匹配任何没有包含在括号中的字符<ul>
<li><code>/[^abcd]/</code> 匹配除了 a, b, c, or d 以外的字母</li>
</ul>
</li>
<li>字符集中, - 需要转义<ul>
<li><code>/[+\-]?[0-9]+/</code> 匹配 + 或 -, 随后至少一位数字</li>
</ul>
</li>
<li>匹配评估分数 A, B+, or D- 的正则表达式?<ul>
<li><code>/[ABCDF][+\-]?/</code></li>
</ul>
</li>
</ul>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><ul>
<li>特殊字符集:<ul>
<li><code>\d</code> 匹配任何数字(阿拉伯数字)。 相当于 [0-9]</li>
<li><code>\D</code> 匹配任何非数字(阿拉伯数字)的字符。相当于[^0-9]</li>
<li><code>\w</code> 匹配基本拉丁字母中的任何字母数字字符, 包括下划线。相当于 [A-Zaz0-9_]</li>
<li><code>\W</code> 匹配任何不是来自基本拉丁字母的单词字符。相当于 [^A-Zaz0-9_]</li>
<li><code>\s</code> 匹配一个空白字符, 包括空格、制表符、换页符和换行符</li>
<li><code>\S</code> 匹配一个非空白字符</li>
</ul>
</li>
<li>至少$1000.00的正则表达式?<ul>
<li><code>/\$[1-9]\d&#123;3,&#125;\.\d&#123;2&#125;/</code></li>
</ul>
</li>
</ul>
<h4 id="JavaScript-正则表达式的使用"><a href="#JavaScript-正则表达式的使用" class="headerlink" title="JavaScript 正则表达式的使用"></a>JavaScript 正则表达式的使用</h4><ul>
<li>在 JavaScript 中, 正则表达式常用于两个字符串方法：search() 和 replace()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Visit W3School&quot;</span>;<br><span class="hljs-keyword">var</span> n = str.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/w3school/i</span>); <br></code></pre></td></tr></table></figure>
<ul>
<li>在 JavaScript 中, RegExp 对象是带有预定义属性和方法的正则表达式对象</li>
<li>使用 test(), test() 方法是一个正则表达式方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> patt = <span class="hljs-regexp">/e/</span>;<br>patt.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;The best things in life are free!&quot;</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>
<ul>
<li>使用 exec(), 用于检索字符串中的正则表达式的匹配。该函数返回一个数组, 其中存放匹配的结果。如果未找到匹配, 则返回值为 null</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">/e/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&quot;The best things in life are free&quot;</span>); <span class="hljs-comment">//e</span><br></code></pre></td></tr></table></figure>
<h4 id="JavaScript-RegExp-对象"><a href="#JavaScript-RegExp-对象" class="headerlink" title="JavaScript RegExp 对象"></a>JavaScript RegExp 对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> patt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(pattern,modifiers);<br><span class="hljs-comment">//或者更简单的方式:</span><br><span class="hljs-keyword">var</span> patt = <span class="hljs-regexp">/pattern/m</span>odifiers;<br><br><span class="hljs-comment">//等价</span><br><span class="hljs-keyword">var</span> re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;\\w+&quot;</span>);<br><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/\w+/</span>;<br><br><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/\\/gm</span>;<br><span class="hljs-comment">//正则构造函数</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;\\\\&quot;</span>,<span class="hljs-string">&quot;gm&quot;</span>);<br><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&quot;abc\\123&quot;</span>;　　<span class="hljs-comment">//foo的值为&quot;abc\123&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-title function_">test</span>(foo)); <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(foo)); <br></code></pre></td></tr></table></figure>
<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><h4 id="编写更好的函数"><a href="#编写更好的函数" class="headerlink" title="编写更好的函数"></a>编写更好的函数</h4><ul>
<li>Don’t Repeat Yourself (DRY) 不重复造轮子: 封装为函数, 对象模块</li>
<li>Do One Thing (DOT) 一次只做一件事情：提升代码复用性, 易读性与可调式性</li>
<li>Keep It Simple Stupid (KISS) 保持简单：技巧, 高深 晦涩, 一行代码中安排多个原子性任务</li>
<li>Less Is More 少即是多：易读, 避免一次执行多个任务, 函数内容尽可能精简, 不贪多, 代码量独立完成一个功能点, 拆分多个子函数</li>
</ul>
<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments">arguments对象</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* Warning: arguments.callee is deprecated. </span><br><span class="hljs-comment">   Use with caution.</span><br><span class="hljs-comment">   Used here strictly for illustration.</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// =&gt; [Function: foo] </span><br><br><span class="hljs-comment">//wrong, 不能在分支语句中声明函数, 使用函数表达式</span><br><span class="hljs-keyword">var</span> score = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">if</span>(score&gt;<span class="hljs-number">5</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">grade</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;pass&#x27;</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">grade</span>(<span class="hljs-params"></span>) &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;fail&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><ul>
<li>函数表达式的优点是可以像给变量赋值一样将函数赋给变量</li>
<li>可以依靠函数表达式可靠地遵循应用程序逻辑。例如, 条件分支中按预期工作</li>
<li>缺点是函数表达式创建匿名函数, 除非显式提供名称</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>;<br>&#125;;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// =&gt; [Function] (Note: It&#x27;s anonymous.) </span><br></code></pre></td></tr></table></figure>
<h4 id="对象字面量-方法字面量"><a href="#对象字面量-方法字面量" class="headerlink" title="对象字面量(方法字面量)"></a>对象字面量(方法字面量)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> baz=&#123;<br>	<span class="hljs-attr">f</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>;<br>    &#125;<br>&#125;;<br>baz.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// =&gt; [Function] (Note: Also anonymous.)</span><br></code></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>使用对象字面量对相关函数进行分组非常容易。代码更有条理, 可读性更强。上下文中的代码更容易理解和维护</li>
<li>容易拆解和排列：如果模块变得太大, 可以更容易地重新排列代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> lightBulbAPI = &#123;<br>    <span class="hljs-attr">toggle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">getState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">off</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">on</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">blink</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> lightbulbAPI = &#123;<br>    <span class="hljs-attr">toggle</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">toggle</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">getState</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">getState</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">off</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">off</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">on</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">on</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-attr">blink</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">blink</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="5-原型"><a href="#5-原型" class="headerlink" title="5. 原型"></a>5. 原型</h2><blockquote>
<p>可参考 <a target="_blank" rel="noopener" href="https://zh.javascript.info/prototype-inheritance">https://zh.javascript.info/prototype-inheritance</a></p>
</blockquote>
<h4 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h4><ul>
<li>原型对象为所有对象实例所共享, 因此这些实例也共享了原型函数的成员。通过内部属性绑定到原型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> book = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;High Performance JavaScript&quot;</span>,<br>    <span class="hljs-attr">publisher</span>: <span class="hljs-string">&quot;Yahoo! Press&quot;</span><br>&#125;;<br><span class="hljs-title function_">alert</span>(book.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">//&quot;[object Object]&quot; </span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230125214619517.png" alt="image-20230125214619517" style="zoom:80%;" /></p>
<h4 id="例子—原型链"><a href="#例子—原型链" class="headerlink" title="例子—原型链"></a>例子—原型链</h4><ul>
<li>实例的成员和原型的成员是一种链状的关系</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Book</span>(<span class="hljs-params">title, publisher</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">publisher</span> = publisher;<br>&#125;<br><span class="hljs-title class_">Book</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayTitle</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> book1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;High Performance JavaScript&quot;</span>, <span class="hljs-string">&quot;Yahoo! Press&quot;</span>);<br><span class="hljs-keyword">var</span> book2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;JavaScript: The Good Parts&quot;</span>, <span class="hljs-string">&quot;Yahoo! Press&quot;</span>);<br><span class="hljs-title function_">alert</span>(book1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Book</span>); <span class="hljs-comment">//true</span><br><span class="hljs-title function_">alert</span>(book1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">//true</span><br>book1.<span class="hljs-title function_">sayTitle</span>(); <span class="hljs-comment">//&quot;High Performance JavaScript&quot;</span><br><span class="hljs-title function_">alert</span>(book1.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">//&quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230125214941083.png" alt="image-20230125214941083" style="zoom:80%;" /></p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><ul>
<li>一种语法糖, 对象的一个模板, <strong>本质是一个函数</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-comment">// 注意函数构造的方式</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>    &#125;<br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br>p1.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//&quot;(5, 5)&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Point</span> <span class="hljs-comment">// function</span><br>p1.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Point</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>函数声明可以提升</p>
<p>函数表达式、class 不可以提升, 需要先声明再使用</p>
</blockquote>
<h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Point</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x</span>)&#123;<br>    	<span class="hljs-variable language_">super</span>(x, x);<br>    &#125;<br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>)&#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">toString</span>() + <span class="hljs-string">&#x27;Square!&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>(<span class="hljs-number">4</span>);<br>s1.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//&quot;(4, 4)Square!&quot;</span><br>s1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Point</span> <span class="hljs-comment">// true</span><br>s1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Square</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Square</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Point</span> <span class="hljs-comment">// true, 子类的原型指向父类</span><br><span class="hljs-title class_">Square</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a</span>)&#123;<br>    	<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = a;<br>    &#125;<br>&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">y</span> = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a</span>)&#123;<br>    	<span class="hljs-variable language_">super</span>();<br>    &#125;<br>    <span class="hljs-title function_">getY</span>(<span class="hljs-params"></span>)&#123;<br>    	<span class="hljs-variable language_">super</span>() <span class="hljs-comment">// 报错</span><br>    	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-property">y</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...args</span>) &#123;<br>    	<span class="hljs-variable language_">super</span>(...args);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>();<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>;<br>arr.<span class="hljs-property">length</span> <span class="hljs-comment">// 1</span><br><br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>arr[<span class="hljs-number">0</span>] <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>)&#123;<br>    	<span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br>A.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();<br>a.<span class="hljs-title function_">add</span>()<span class="hljs-comment">// error</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span>&#123;&#125;<br>B.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">// 4 </span><br></code></pre></td></tr></table></figure>
<h2 id="6-this"><a href="#6-this" class="headerlink" title="6. this"></a>6. this</h2><h4 id="this"><a href="#this" class="headerlink" title="this"></a><a target="_blank" rel="noopener" href="https://www.w3schools.com/js/js_this.asp">this</a></h4><ul>
<li><p>在函数体中, 非显式或隐式地简单调用函数时, 在严格模式下, 函数内的 this 会被绑定到 undefined 上, 在非严格模式下则会被绑定到全局对象 window/global 上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-string">&quot;use strict&quot;</span>;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// window</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>
<ul>
<li>this指向最后调用它的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">bar</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>)<br>    &#125;<br>&#125;<br>foo.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &#123;bar: 10, fn: f&#125;, 10</span><br><span class="hljs-keyword">var</span> fn1 = foo.<span class="hljs-property">fn</span>;<br><span class="hljs-title function_">fn1</span>(); <span class="hljs-comment">// window, undefined</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>一般使用 new 方法调用构造函数时, 构造函数内的 this 会被绑定到新创建的对象上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-string">&quot;Lucas&quot;</span><br>&#125;<br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">bar</span>) <span class="hljs-comment">// Lucas</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>一般通过 call/apply/bind 方法显示调用函数时, 函数体内的 this 会被绑定到指定参数的对象上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lucas&#x27;</span>,<br>    <span class="hljs-attr">logName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> bar = &#123;<br>	<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mike&#x27;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">logName</span>.<span class="hljs-title function_">call</span>(bar)) <span class="hljs-comment">// mike</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>一般通过上下文对象调用函数时, 函数体内的this会被绑定到该对象上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> student = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Lucas&#x27;</span>,<br>    <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(student.<span class="hljs-title function_">fn</span>() === student) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Lucas&#x27;</span>,<br>    <span class="hljs-attr">brother</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mike&#x27;</span>,<br>        <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">brother</span>.<span class="hljs-title function_">fn</span>()) <span class="hljs-comment">// Mike</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o1 = &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;o1&#x27;</span>,<br>    <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o2 = &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;o2&#x27;</span>,<br>    <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    	<span class="hljs-keyword">return</span> o1.<span class="hljs-title function_">fn</span>()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o3 = &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;o3&#x27;</span>,<br>    <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> fn = o1.<span class="hljs-property">fn</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>()<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o1.<span class="hljs-title function_">fn</span>())  <span class="hljs-comment">// o1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o2.<span class="hljs-title function_">fn</span>())  <span class="hljs-comment">// o1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o3.<span class="hljs-title function_">fn</span>())  <span class="hljs-comment">// undifined</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在箭头函数中, this的指向是由外层(函数或全局)作用域来决定的</p>
<ul>
<li>由定义的作用域决定而非调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = &#123;<br>    <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>        &#125;)<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-title function_">fn</span>()) <span class="hljs-comment">// window</span><br><br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>        &#125;)<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-title function_">fn</span>()) <span class="hljs-comment">// &#123;fn：f&#125;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="this优先级"><a href="#this优先级" class="headerlink" title="this优先级"></a>this优先级</h4><ul>
<li>显式绑定：通过call、apply、bind、new</li>
<li>隐式绑定：根据调用关系确定this指向</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>&#125;<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;<br>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj2) <span class="hljs-comment">// 2</span><br>obj2.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj1) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>	<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a<br>&#125;<br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(obj1)<br><span class="hljs-title function_">bar</span>(<span class="hljs-number">2</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>) <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz.<span class="hljs-property">a</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> &#123;<br>    	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>    &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;<br>	<span class="hljs-attr">a</span>: <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">call</span>(obj1) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-title function_">call</span>(obj2)) <br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// undefined, 箭头函数的绑定无法被修改</span><br></code></pre></td></tr></table></figure>
<h2 id="7-Babel"><a href="#7-Babel" class="headerlink" title="7. Babel"></a>7. Babel</h2><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><ul>
<li>Babel 是一个 JavaScript 编译器</li>
<li>Babel 是一个工具链, 主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法, 以便能够运行在当前和旧版本的浏览器或其他环境中</li>
<li>下面列出的是 Babel 能为你做的事情：<ul>
<li>语法转换</li>
<li>通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块)</li>
<li>源码转换 (codemods)</li>
<li>…</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a,b</span>)=&gt;a+b<br><span class="hljs-comment">// 转换为</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>	<span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;&#125; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;&#125; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br><span class="hljs-comment">// 转换为</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; <span class="hljs-number">5</span>; _i++) &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">//undefined</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-4-%E7%AC%A6%E5%8F%B7%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-4-%E7%AC%A6%E5%8F%B7%E8%A1%A8/" class="post-title-link" itemprop="url">编译原理(4) 符号表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-05 17:38:45" itemprop="dateCreated datePublished" datetime="2022-12-05T17:38:45+08:00">2022-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205174013530.png" alt="image-20221205174013530" style="zoom:80%;" /></p>
<h3 id="1-符号表"><a href="#1-符号表" class="headerlink" title="1. 符号表"></a>1. 符号表</h3><p><strong>Definition (符号表 (Symbol Table))</strong></p>
<p>$\textcolor{red}{\textbf{符号表}}是用于保存\textcolor{blue}{\textbf{各种信息}}的\textcolor{purple}{\textbf{数据结构}}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205174251234.png" alt="image-20221205174251234" style="zoom:80%;" /></p>
<h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h3><p>“领域特定语言” (DSL) 通常只有<strong>单作用域</strong> (全局作用域)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205174334165.png" alt="image-20221205174334165" style="zoom:80%;" /></p>
<p>“通用程序设计语言” (GPL) 通常需要<strong>嵌套作用域</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205174355820.png" alt="image-20221205174355820" style="zoom:80%;" /></p>
<h4 id="2-1-嵌套作用域"><a href="#2-1-嵌套作用域" class="headerlink" title="2.1 嵌套作用域"></a>2.1 嵌套作用域</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205174444387.png" alt="image-20221205174444387" style="zoom:80%;" /></p>
<blockquote>
<p>一个函数包括两个作用域</p>
<ul>
<li>参数</li>
<li>函数体</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205174728843.png" alt="image-20221205174728843" style="zoom:80%;" /></p>
<h3 id="3-动手写一个符号表"><a href="#3-动手写一个符号表" class="headerlink" title="3. 动手写一个符号表"></a>3. 动手写一个符号表</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221206153825977.png" alt="image-20221206153825977" style="zoom:80%;" /></p>
<p><strong>目标</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221206153914843.png" alt="image-20221206153914843" style="zoom:80%;" /></p>
<h4 id="3-1-类图"><a href="#3-1-类图" class="headerlink" title="3.1 类图"></a>3.1 类图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221206154419395.png" alt="image-20221206154419395" style="zoom:80%;" /></p>
<ul>
<li>通过监听器在遍历语法树的过程中构建符号表</li>
</ul>
<h4 id="3-2-Scope"><a href="#3-2-Scope" class="headerlink" title="3.2 Scope"></a>3.2 Scope</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207141835857.png" alt="image-20221207141835857" style="zoom:80%;" /></p>
<h4 id="3-3-Listener"><a href="#3-3-Listener" class="headerlink" title="3.3 Listener"></a>3.3 Listener</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207150436040.png" alt="image-20221207150436040" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207150444492.png" alt="image-20221207150444492" style="zoom:80%;" /></p>
<h4 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207150521873.png" alt="image-20221207150521873" style="zoom:80%;" /></p>
<h4 id="3-5-参考"><a href="#3-5-参考" class="headerlink" title="3.5 参考"></a>3.5 参考</h4><p><a target="_blank" rel="noopener" href="https://github.com/antlr/symtab">symtab @ antlr by parrt</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/parrt/cs652/tree/master/lectures/code/symtab/src">symtab @ cs652 by parrt</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">计算机操作系统(6) 并发程序设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-05 10:36:43" itemprop="dateCreated datePublished" datetime="2022-12-05T10:36:43+08:00">2022-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第六章-并发程序设计"><a href="#第六章-并发程序设计" class="headerlink" title="第六章 并发程序设计"></a>第六章 并发程序设计</h1><h2 id="6-1-并发进程"><a href="#6-1-并发进程" class="headerlink" title="6.1 并发进程"></a>6.1 并发进程</h2><h3 id="6-1-1-顺序程序设计"><a href="#6-1-1-顺序程序设计" class="headerlink" title="6.1.1 顺序程序设计"></a>6.1.1 顺序程序设计</h3><ul>
<li>一个进程在处理器上的顺序执行是严格按序的, 一个进程只有当一个操作结束后, 才能开始后继操作</li>
<li>顺序程序设计是把一个程序设计成一个顺序执行的程序模块, 顺序的含义不但指一个程序模块内部, 也指两个程序模块之间</li>
</ul>
<h4 id="顺序程序设计特点"><a href="#顺序程序设计特点" class="headerlink" title="顺序程序设计特点"></a>顺序程序设计特点</h4><ul>
<li>程序执行的顺序性</li>
<li>程序环境的封闭性</li>
<li>执行结果的确定性</li>
<li>计算过程的可再现性</li>
</ul>
<h3 id="6-1-2-进程的并发性"><a href="#6-1-2-进程的并发性" class="headerlink" title="6.1.2 进程的并发性"></a>6.1.2 进程的并发性</h3><ul>
<li>进程的并发性(Concurrency)是指一组进程的执行在时间上是重叠的</li>
<li>例如：有两个进程 A(a1、a2、a3) 和 B(b1、b2、b3) 并发执行, 若允许进程交叉执行, 如执行操作序列为 a1, b1, a2, b2, a3, b3 或 a1, a2, b1, b2, b3, a3 等, 则说进程 A 和 B 的执行是并发的</li>
<li>从宏观上看, 并发性反映一个时间段中几个进程都在同一处理器上, 处于运行还未运行结束状态</li>
<li>从微观上看, 任一时刻仅有一个进程在处理器上运行</li>
</ul>
<h4 id="并发程序设计"><a href="#并发程序设计" class="headerlink" title="并发程序设计"></a>并发程序设计</h4><ul>
<li>使一个程序分成若干个可同时执行的程序模块的方法称<strong>并发程序设计(concurrent programming)</strong>, 每个程序模块和它执行时所处理的数据就组成一个进程</li>
</ul>
<h4 id="进程的并发性"><a href="#进程的并发性" class="headerlink" title="进程的并发性"></a>进程的并发性</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205105242312.png" alt="image-20221205105242312" style="zoom:80%;" /></p>
<ul>
<li>由于程序是按照 while(TRUE) {input, process, output} 串行地输入 - 处理 - 输出来编制的, 所以该程序只能顺序地执行, 这时系统的效率相当低</li>
<li>如果把求解这个问题的程序分成三部分：<ul>
<li>i: while(TRUE) {input, send}</li>
<li>p: while(TRUE) {receive, process, send}</li>
<li>o: while(TRUE) {receive, output}</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205105403896.png" alt="image-20221205105403896" style="zoom:80%;" /></p>
<ul>
<li>每一部分是一个小程序, 它们可并发执行, 并会产生制约关系, 其中 send 和 receive 操作用于小程序之间通过通信机制解决制约关系, 以便协调一致地工作</li>
</ul>
<h4 id="并发进程的分类"><a href="#并发进程的分类" class="headerlink" title="并发进程的分类"></a>并发进程的分类</h4><ul>
<li>并发进程分类：无关的, 交互的</li>
<li>无关的并发进程：一个进程的执行与其他并发进程的进展无关<ul>
<li>并发进程的无关性是进程的执行与时间无关的一个充分条件, 又称为Bernstein条件</li>
</ul>
</li>
<li>交互的并发进程: 不满足Bernstein条件, 一个进程的执行可能影响其他并发进程的结果</li>
</ul>
<h4 id="Bernstein条件"><a href="#Bernstein条件" class="headerlink" title="Bernstein条件"></a>Bernstein条件</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205105705207.png" alt="image-20221205105705207" style="zoom:80%;" /></p>
<ul>
<li>没有读写冲突与写写冲突</li>
</ul>
<blockquote>
<p>举例: 有如下分属四个进程中的四条语句：</p>
<ul>
<li>S1: a := x + y</li>
<li>S2: b := z + 1</li>
<li>S3: c := a – b</li>
<li>S4: w := c + 1</li>
</ul>
<p>于是有:</p>
<p>R(S1)={x, y}, R(S2)={z}, R(S3)={a, b}, R(S4)={c}；</p>
<p>W(S1)={a},  W(S2)={b}, W(S3)={c},  W(S4)={w}</p>
<p>S1和S2可并发执行, 满足Bernstein条件</p>
<p>其他语句并发执行可能会产生与时间有关的错误</p>
</blockquote>
<h4 id="与时间有关的错误"><a href="#与时间有关的错误" class="headerlink" title="与时间有关的错误"></a>与时间有关的错误</h4><ul>
<li>对于一组交互的并发进程, 执行的相对速度无法相互控制, 各种与时间有关的错误就可能出现</li>
<li>与时间有关错误的表现形式：<ul>
<li>结果不唯一</li>
<li>永远等待</li>
</ul>
</li>
</ul>
<blockquote>
<p>并发是开放的: 每执行完一条机器指令都有被抢占的风险</p>
<p>顺序是封闭的</p>
</blockquote>
<h4 id="机票问题"><a href="#机票问题" class="headerlink" title="机票问题"></a>机票问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205110025898.png" alt="image-20221205110025898" style="zoom:80%;" /></p>
<ul>
<li>此时出现把同一张票卖给两个旅客的情况, 两个旅客可能各自都买到一张同天同次航班的机票, 可是, Aj 的值实际上只减去 1, 造成余票数不正确。特别是, 当某次航班只有一张余票时, 可能把一张票同时售给两位旅客</li>
</ul>
<h4 id="主存管理问题"><a href="#主存管理问题" class="headerlink" title="主存管理问题"></a>主存管理问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221206175155957.png" alt="image-20221206175155957" style="zoom:80%;" /></p>
<ul>
<li>由于 <code>borrow</code> 和 <code>return</code> 共享代表主存物理资源的临界变量 X, 对并发执行不加限制会导致错误, 例如, 一个进程调用borrow申请主存, 在执行比较 B 和 X 大小的指令后, 发现 B &gt; X, 但在执行 <code>&#123;进程进入等待主存资源队列&#125;</code> 前, 另一个进程调用 return 抢先执行, 归还所借全部主存资源；这时, 由于前一个进程还未成为等待者, return中的 <code>&#123;释放等主存资源进程&#125;</code> 相当于空操作, 以后当调用 borrow 的应用进程被置成 <code>&#123;等主存资源&#125;</code> 时, 可能己经没有其他进程再来归还主存, 从而, 申请资源的进程处于永远等待状态</li>
</ul>
<h3 id="6-1-3-进程的交互-竞争与协作"><a href="#6-1-3-进程的交互-竞争与协作" class="headerlink" title="6.1.3 进程的交互: 竞争与协作"></a>6.1.3 进程的交互: 竞争与协作</h3><ul>
<li>进程之间存在两种基本关系：竞争关系和协作关系</li>
<li>第一种是<strong>竞争关系</strong>, 一个进程的执行可能影响到同其竞争资源的其他进程, 如果两个进程要访问同一资源, 那么, 一个进程通过操作系统分配得到该资源, 另一个将不得不等待</li>
<li>第二种是<strong>协作关系</strong>, 某些进程为完成同一任务需要分工协作, 由于合作的每一个进程都是独立地以不可预知的速度推进, 这就需要相互协作的进程在某些协调点上协调各自的工作。当合作进程中的一个到达协调点后, 在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己, 直到其他合作进程发来协调信号或消息后方被唤醒并继续执行</li>
</ul>
<h4 id="竞争关系带来的问题"><a href="#竞争关系带来的问题" class="headerlink" title="竞争关系带来的问题"></a>竞争关系带来的问题</h4><ul>
<li>资源竞争的两个控制问题：</li>
<li>一个是死锁 (Deadlock) 问题: 一组进程如果都获得了部分资源, 还想要得到其他进程所占有的资源, 最终所有的进程将陷入死锁</li>
<li>一个是饥饿 (Starvation) 问题: 一个进程由于其他进程总是优先于它而被无限期拖延</li>
<li>操作系统需要保证诸进程能互斥地访问临界资源, 既要解决饥饿问题, 又要解决死锁问题</li>
</ul>
<h4 id="竞争关系-死锁"><a href="#竞争关系-死锁" class="headerlink" title="竞争关系: 死锁"></a>竞争关系: 死锁</h4><ul>
<li>死锁 : 一组进程因争夺资源陷入永远等待的状态</li>
<li>P0 和 P1 两个进程, 均需要使用 S 和 Q 两类资源, 每类资源数为1</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207221321962.png" alt="image-20221207221321962" style="zoom:80%;" /></p>
<h4 id="竞争关系-进程的互斥"><a href="#竞争关系-进程的互斥" class="headerlink" title="竞争关系: 进程的互斥"></a>竞争关系: 进程的互斥</h4><ul>
<li><strong>进程的互斥(mutual exclusion)</strong> 是解决进程间竞争关系(间接制约关系)的手段。进程互斥指若干个进程要使用同一共享资源时, 任何时刻最多允许一个进程去使用, 其他要使用该资源的进程必须等待, 直到占有资源的进程释放该资源</li>
</ul>
<h4 id="协作关系-进程的同步"><a href="#协作关系-进程的同步" class="headerlink" title="协作关系: 进程的同步"></a>协作关系: 进程的同步</h4><ul>
<li><strong>进程的同步(Synchronization)</strong> 是解决进程间协作关系(直接制约关系)的手段。进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号, 当一个进程没有得到来自于另一个进程的消息或信号时则需等待, 直到消息或信号到达才被唤醒</li>
</ul>
<h4 id="进程的交互-竞争与协作"><a href="#进程的交互-竞争与协作" class="headerlink" title="进程的交互: 竞争与协作"></a>进程的交互: 竞争与协作</h4><ul>
<li>进程互斥关系是一种特殊的进程同步关系, 即逐次使用互斥共享资源, 是对进程使用资源次序上的一种协调</li>
</ul>
<h2 id="6-2-临界区管理"><a href="#6-2-临界区管理" class="headerlink" title="6.2 临界区管理"></a>6.2 临界区管理</h2><h3 id="6-2-1-互斥与临界区"><a href="#6-2-1-互斥与临界区" class="headerlink" title="6.2.1 互斥与临界区"></a>6.2.1 互斥与临界区</h3><h4 id="互斥与临界区"><a href="#互斥与临界区" class="headerlink" title="互斥与临界区"></a>互斥与临界区</h4><ul>
<li>并发进程中与共享变量有关的程序段叫“临界区”(critical section), 共享变量代表的资源叫“临界资源”</li>
<li>与同一变量有关的临界区分散在各进程的程序段中, 而各进程的执行速度不可预见</li>
<li>竞争条件(race condition)</li>
<li>如果保证进程在临界区执行时, 不让另一个进程进入临界区, 即各进程对共享变量的访问是互斥的, 就不会造成与时间有关的错误</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207224320111.png" alt="image-20221207224320111" style="zoom:80%;" /></p>
<h4 id="临界区调度原则"><a href="#临界区调度原则" class="headerlink" title="临界区调度原则"></a>临界区调度原则</h4><ul>
<li>临界区调度原则(Dijkstra, 1965)：<ul>
<li>一次至多一个进程能够进入临界区内执行</li>
<li>如果已有进程在临界区, 其他试图进入的进程应等待</li>
<li>进入临界区内的进程应在有限时间内退出, 以便让等待进程中的一个进入</li>
</ul>
</li>
</ul>
<h3 id="6-2-2-临界区管理的尝试"><a href="#6-2-2-临界区管理的尝试" class="headerlink" title="6.2.2 临界区管理的尝试"></a>6.2.2 临界区管理的尝试</h3><h4 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202161342205.png" alt="image-20230202161342205" style="zoom:80%;" /></p>
<ul>
<li><strong>存在的问题: 两个进程可能都进去</strong></li>
</ul>
<h4 id="尝试二"><a href="#尝试二" class="headerlink" title="尝试二"></a>尝试二</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202161443892.png" alt="image-20230202161443892" style="zoom:80%;" /></p>
<ul>
<li><strong>存在的问题: 两个进程都进不去</strong></li>
</ul>
<h4 id="实现临界区的软件算法-Peterson算法"><a href="#实现临界区的软件算法-Peterson算法" class="headerlink" title="实现临界区的软件算法: Peterson算法"></a>实现临界区的软件算法: Peterson算法</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202161817788.png" alt="image-20230202161817788" style="zoom:80%;" /></p>
<ul>
<li>下面这种方案也可以实现, 但是不满足通用性的要求<ul>
<li>P0 和 P1 使用临界区的次序变成了完全一比一的交替方式</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207233038513.png" alt="image-20221207233038513" style="zoom:80%;" /></p>
<ul>
<li>P0中执行了turn=1, 暂时进不去, 等P1中执行turn=0, P0可以进去, P0使用完临界区, 退出临界区的时候, 将turn=0(好像是多余的), 此时P1还是进不去, 要等P0执行turn=1, 使得P1有机会进入临界区</li>
<li>之后, P1退出临界区的时候, turn=1, P0暂时进不去, 等在P1中执行turn=0, P0可以再次进入临界区</li>
<li>因此, P0和P1使用临界区的次序变成了完全一比一的交替方式, 这只能是临界区互斥使用的一个特例, 不能满足临界区互斥使用的完全随机性</li>
</ul>
<h3 id="6-2-3-实现临界区管理的硬件设施"><a href="#6-2-3-实现临界区管理的硬件设施" class="headerlink" title="6.2.3 实现临界区管理的硬件设施"></a>6.2.3 实现临界区管理的硬件设施</h3><h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><ul>
<li>实现互斥的最简单方法</li>
<li>关中断适用场合</li>
<li>关中断方法的缺点</li>
</ul>
<h4 id="测试并建立指令"><a href="#测试并建立指令" class="headerlink" title="测试并建立指令"></a>测试并建立指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// TS指令的处理过程</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">TS</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;x)</span> &#123;<br>    <span class="hljs-keyword">if</span>(x) &#123;<br>        x = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// TS指令实现进程互斥</span><br><span class="hljs-type">bool</span> s = <span class="hljs-literal">true</span>;<br>cobegin<br>process <span class="hljs-title function_">Pi</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//i=1，2，...，n</span><br>    <span class="hljs-keyword">while</span>(!TS(s)); <span class="hljs-comment">//上锁</span><br>    &#123;临界区&#125;;<br>    s = <span class="hljs-literal">true</span>; <span class="hljs-comment">//开锁</span><br>&#125;<br>coend<br></code></pre></td></tr></table></figure>
<h4 id="对换指令"><a href="#对换指令" class="headerlink" title="对换指令"></a>对换指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SWAP</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;a，<span class="hljs-type">bool</span> &amp;b)</span> &#123;<br>    <span class="hljs-type">bool</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-comment">//对换指令实现进程互斥</span><br><span class="hljs-type">bool</span> lock = <span class="hljs-literal">false</span>;<br>cobegin<br>Process <span class="hljs-title function_">Pi</span><span class="hljs-params">( )</span>&#123; <span class="hljs-comment">//i=1，2，...，n</span><br>    <span class="hljs-type">bool</span> keyi = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        SWAP(keyi，lock);<br>    &#125; <span class="hljs-keyword">while</span> (keyi); <span class="hljs-comment">//上锁</span><br>    &#123;临界区&#125;;<br>    SWAP(keyi，lock); <span class="hljs-comment">//开锁</span><br>&#125;<br>coend<br></code></pre></td></tr></table></figure>
<h2 id="6-3-信号量与PV操作"><a href="#6-3-信号量与PV操作" class="headerlink" title="6.3 信号量与PV操作"></a>6.3 信号量与PV操作</h2><h3 id="6-3-1-信号量与PV操作的问题背景"><a href="#6-3-1-信号量与PV操作的问题背景" class="headerlink" title="6.3.1 信号量与PV操作的问题背景"></a>6.3.1 信号量与PV操作的问题背景</h3><h4 id="并发程序设计的基本概念"><a href="#并发程序设计的基本概念" class="headerlink" title="并发程序设计的基本概念"></a>并发程序设计的基本概念</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202170410386.png" alt="image-20230202170410386" style="zoom:80%;" /></p>
<ul>
<li><strong>临界资源</strong>：并发进程之间需要<strong>互斥使用的共享资源</strong>, 称为临界资源<ul>
<li>举例: 火车上的卫生间就是一种互斥使用的共享资源</li>
<li>使用<strong>共享变量代表共享资源</strong></li>
<li>并发进程中<strong>与共享变量有关的程序段叫“临界区”</strong>(critical section)</li>
<li>临界区：并发进程之间控制共享资源使用的程序段</li>
</ul>
</li>
<li>并发进程之间的关系</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202170853336.png" alt="image-20230202170853336" style="zoom:80%;" /></p>
<h4 id="“忙式等待”方法解决临界区调度问题的缺点"><a href="#“忙式等待”方法解决临界区调度问题的缺点" class="headerlink" title="“忙式等待”方法解决临界区调度问题的缺点"></a>“忙式等待”方法解决临界区调度问题的缺点</h4><ul>
<li>临界区管理的简单方法（忙式等待/反复测试）<ol>
<li>关中断</li>
<li>测试并建立指令</li>
<li>对换指令</li>
<li>Peterson算法</li>
</ol>
</li>
<li>存在的问题<ol>
<li>对不能进入临界区的进程, 采用忙式等待测试法, 浪费CPU时间</li>
<li>将测试能否进入临界区的责任推给各个竞争的进程会削弱系统的可靠性, 加重用户编程负担</li>
</ol>
</li>
<li>通用的解决方案：信号量与PV操作</li>
</ul>
<h4 id="操作系统中“并发问题”解决方案的知识框架"><a href="#操作系统中“并发问题”解决方案的知识框架" class="headerlink" title="操作系统中“并发问题”解决方案的知识框架"></a>操作系统中“并发问题”解决方案的知识框架</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221207234329963.png" alt="image-20221207234329963" style="zoom:80%;" /></p>
<h3 id="6-3-2-信号量与PV操作的基本原理"><a href="#6-3-2-信号量与PV操作的基本原理" class="headerlink" title="6.3.2 信号量与PV操作的基本原理"></a>6.3.2 信号量与PV操作的基本原理</h3><ul>
<li>前面方法解决临界区调度问题的缺点:<ol>
<li>对不能进入临界区的进程, 采用忙式等待测试法, 浪费CPU时间</li>
<li>将测试能否进入临界区的责任推给各个竞争的进程会削弱系统的可靠性, 加重用户编程负担</li>
</ol>
</li>
<li>1965年E.W.Dijkstra提出了新的同步工具—信号量和P、V操作原语(荷兰语中“检测(Proberen)”和“增量(Verhogen)”的头字母)</li>
<li>一个进程在某一特殊点上被迫停止执行直到接收到一个对应的特殊变量值, 这种特殊变量就是<strong>信号量(semaphore)</strong>, 复杂的进程协作需求都可以通过适当的信号结构得到满足</li>
</ul>
<h4 id="信号量与PV操作的数据结构与原语操作"><a href="#信号量与PV操作的数据结构与原语操作" class="headerlink" title="信号量与PV操作的数据结构与原语操作"></a>信号量与PV操作的数据结构与原语操作</h4><p>设s为一个<strong>记录型数据结构</strong>, 一个分量为<strong>整型量value</strong>, 另一个为<strong>信号量队列queue</strong>, P和V操作原语定义</p>
<ul>
<li>P(s): 将信号量 s 减 1, 若结果 &lt; 0, 则调用 P(s) 的进程被置成<strong>等待信号量 s 的状态(阻塞态)</strong></li>
<li>V(s): 将信号量 s 加 1, 若结果 &lt;= 0, 则释放(唤醒)一个等待信号量 s 的进程, 使其转换为<strong>就绪态</strong></li>
<li>原语: CPU处于内核态, 在<strong>关中断</strong>环境下执行的一段指令序列<ul>
<li>原子性：不被中断, 确保安全且完整执行这段指令序列</li>
</ul>
</li>
</ul>
<p><strong>强调：</strong>对于信号量, <strong>只允许使用P, V原语操作访问信号量</strong>, 不能直接对信号量的整型值做读写操作, 也不能对信号量的队列做任何其他操作</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208001244075.png" alt="image-20221208001244075" style="zoom:80%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-type">int</span> value;	<span class="hljs-comment">// 信号量值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcb</span>* <span class="hljs-title">list</span>;</span>	<span class="hljs-comment">// 信号量队列指针</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(semaphore s)</span> &#123; <span class="hljs-comment">// also named wait</span><br>    s.value--;<br>    <span class="hljs-keyword">if</span> (s.value &lt; <span class="hljs-number">0</span>) &#123;<br>        sleep(s.<span class="hljs-built_in">list</span>); <span class="hljs-comment">// 若信号量值小于0, 执行 P 操作的进程调用 sleep 阻塞自己, 被置成等待信号量 s 状态并移入 s 信号量队列, 转向进程调度程序</span><br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">V</span><span class="hljs-params">(semaphore s)</span> &#123; <span class="hljs-comment">// also named signal</span><br>	s.value++;<br>    <span class="hljs-keyword">if</span> (s.value &lt;= <span class="hljs-number">0</span>) &#123;<br>        wakeup(s.<span class="hljs-built_in">list</span>); <span class="hljs-comment">// 若信号量值小于等于0, 调用 wakeup 从信号量 s 队列中释放一个等待信号量 s 的进程并转换成就绪态, 进程继续执行</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="PV操作与进程状态转换模型"><a href="#PV操作与进程状态转换模型" class="headerlink" title="PV操作与进程状态转换模型"></a>PV操作与进程状态转换模型</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202171833199.png" alt="image-20230202171833199"></p>
<h4 id="PV操作与进程状态队列模型"><a href="#PV操作与进程状态队列模型" class="headerlink" title="PV操作与进程状态队列模型"></a>PV操作与进程状态队列模型</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208001550844.png" alt="image-20221208001550844" style="zoom:80%;" /></p>
<p>强调: 不同的进程因为请求不同资源, 将进入不同信号量的等待队列, 分为不同的等待队列进行管理</p>
<h4 id="信号量与PV操作的推论"><a href="#信号量与PV操作的推论" class="headerlink" title="信号量与PV操作的推论"></a>信号量与PV操作的推论</h4><ul>
<li>推论1：若<strong>信号量 s 为正值</strong>, 则该值等于在封锁进程之前对<strong>信号量 s 可施行的 P 操作次数</strong>、亦等于 s 所代表的<strong>实际还可以使用的物理资源数</strong></li>
<li>推论2：若<strong>信号量 s 为负值</strong>, 则其绝对值等于登记排列在该<strong>信号量 s 队列之中等待的进程个数</strong>、亦即恰好等于对信号量 s 实施 P 操作而被封锁起来并进入信号量 s 队列的进程数</li>
<li>推论3：通常, P 操作意味着请求一个资源, V 操作意味着释放一个资源。在一定条件下, P 操作代表阻塞进程操作, 而 V 操作代表唤醒被阻塞进程的操作</li>
</ul>
<h3 id="6-3-3-信号量的应用"><a href="#6-3-3-信号量的应用" class="headerlink" title="6.3.3 信号量的应用"></a>6.3.3 信号量的应用</h3><h4 id="信号量程序设计的一般结构"><a href="#信号量程序设计的一般结构" class="headerlink" title="信号量程序设计的一般结构"></a>信号量程序设计的一般结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore s = <span class="hljs-number">1</span>;<br>cobegin<br>    Process Pi &#123; <span class="hljs-comment">/* i=1，…，n */</span><br>        ...<br>        P(s);<br>        <span class="hljs-comment">/* critical region 临界区*/</span><br>        V(s); <br>        ...<br>    &#125;;<br>coend<br></code></pre></td></tr></table></figure>
<ul>
<li>在表达纯粹互斥关系时信号量初值为 1, 且同一个信号量的PV操作处于同一侧进程中。但这种情形不适用于同步关系</li>
</ul>
<h4 id="信号量与PV操作控制并发进程之间的临界资源"><a href="#信号量与PV操作控制并发进程之间的临界资源" class="headerlink" title="信号量与PV操作控制并发进程之间的临界资源"></a>信号量与PV操作控制并发进程之间的临界资源</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208142449148.png" alt="image-20221208142449148" style="zoom:80%;" /></p>
<h4 id="互斥问题-飞机票问题"><a href="#互斥问题-飞机票问题" class="headerlink" title="互斥问题: 飞机票问题"></a>互斥问题: 飞机票问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208145047961.png" alt="image-20221208145047961" style="zoom:80%;" /></p>
<ul>
<li><p>上面代码有缺陷: 将不同航班剩余票数合并为同一个信号量, 效率很低</p>
</li>
<li><p>改进</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208145205395.png" alt="image-20221208145205395" style="zoom:80%;" /></p>
<h4 id="互斥问题-哲学家就餐问题"><a href="#互斥问题-哲学家就餐问题" class="headerlink" title="互斥问题: 哲学家就餐问题"></a>互斥问题: 哲学家就餐问题</h4><p>有五个哲学家围坐在一圆桌旁, 桌中央有一盘通心面, 每人面前有一只空盘子, 每两人之间放一把叉子。每个哲学家思考、饥饿、然后吃通心面。为了吃面, <strong>每个哲学家必须获得两把叉子, 且每人只能直接从自己左边或右边去取叉子</strong></p>
<ul>
<li>哲学家顺时针编号</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208145438484.png" alt="image-20221208145438484" style="zoom:80%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore fork[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>    fork[i]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// cobegin 并发开始</span><br>process <span class="hljs-title function_">philosopher_i</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//i=0，1，2，3，4</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        think();<br>        P(fork[i]); <span class="hljs-comment">//先取右手的叉子</span><br>        P(fork[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <span class="hljs-comment">//再取左手的叉子</span><br>        eat();<br>        V(fork[i]);<br>        V(fork[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// coend</span><br></code></pre></td></tr></table></figure>
<ul>
<li>问题: 两个 P 操作之间存在缝隙, 如果哲学家进程均在取到第一个叉子后被中断, 会产生<strong>死锁</strong></li>
</ul>
<h5 id="有若干种办法可避免这类死锁"><a href="#有若干种办法可避免这类死锁" class="headerlink" title="有若干种办法可避免这类死锁"></a>有若干种办法可避免这类死锁</h5><ul>
<li>至多允许四个哲学家同时取叉子(C.A.R. Hoare方案)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore fork[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>    fork[i]= <span class="hljs-number">1</span>;<br>&#125;<br>semaphore room=<span class="hljs-number">4</span>; <span class="hljs-comment">//增加一个侍者, 设想有两个房间1号房间是会议室, 2号房间是餐厅</span><br><span class="hljs-comment">// cobegin</span><br>process <span class="hljs-title function_">philosopher_i</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">/*i=0, 1, 2, 3, 4 */</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        think();<br>        P(room); <span class="hljs-comment">//控制最多允许4位哲学家进入2号房间餐厅取叉子</span><br>        P(fork[i];<br>        P(fork[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        eat();<br>        V(fork[i]);<br>        V(fork([i+<span class="hljs-number">1</span>] % <span class="hljs-number">5</span>);<br>        V(room);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// coend</span><br></code></pre></td></tr></table></figure>
<ul>
<li>奇数号先取左手边的叉子, 偶数号先取右手边的叉子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">philosopher</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123; <br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        P(fork[i]); <span class="hljs-comment">//偶数哲学家先右手</span><br>        P(fork[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]); <span class="hljs-comment">//后左手</span><br>        eat();<br>        V(fork[i]);<br>        V(fork[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        P(fork[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]); <span class="hljs-comment">//奇数哲学家, 先左手</span><br>        P(fork[i]); <span class="hljs-comment">//后右手</span><br>        eat();<br>        V(fork[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        V(fork[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>每个哲学家取到手边的两把叉子才吃, 否则一把叉子也不取(第五版教材, Page 188, AND型信号量)</li>
</ul>
<h4 id="同步问题-生产者-消费者问题"><a href="#同步问题-生产者-消费者问题" class="headerlink" title="同步问题: 生产者-消费者问题"></a>同步问题: 生产者-消费者问题</h4><p>有 n 个生产者和 m 个消费者, 连接在一个有 k 个单位缓冲区的有界缓冲上。其中, 生产者进程 Producer_i 和消费者进程 Consumer_j 都是并发进程, <strong>只要缓冲区未满, 生产者 Producer_i 生产的产品就可投入缓冲区；只要缓冲区不空, 消费者进程 Consumer_j 就可从缓冲区取走并消耗产品</strong></p>
<p>可能情形</p>
<ul>
<li>n = 1, m = 1, k = 1</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202194743796.png" alt="image-20230202194743796" style="zoom:80%;" /></p>
<ul>
<li>n = 1, m = 1, k &gt; 1</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202194823170.png" alt="image-20230202194823170" style="zoom:80%;" /></p>
<ul>
<li>n &gt; 1, m &gt; 1, k &gt; 1</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202194839839.png" alt="image-20230202194839839" style="zoom:80%;" /></p>
<h4 id="同步问题-苹果-橘子问题"><a href="#同步问题-苹果-橘子问题" class="headerlink" title="同步问题: 苹果-橘子问题"></a>同步问题: 苹果-橘子问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208153217954.png" alt="image-20221208153217954" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208153248165.png" alt="image-20221208153248165" style="zoom:80%;" /></p>
<h4 id="信号量-前驱关系"><a href="#信号量-前驱关系" class="headerlink" title="信号量-前驱关系"></a>信号量-前驱关系</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">Semaphore s1=<span class="hljs-number">0</span>; <span class="hljs-comment">/*表示进程P1是否已经执行完成*/</span><br>Semaphore s2=<span class="hljs-number">0</span>; <span class="hljs-comment">/*表示进程P2是否已经执行完成*/</span><br>Semaphore s3=<span class="hljs-number">0</span>; <span class="hljs-comment">/*表示进程P3是否已经执行完成*/</span><br>Semaphore s4=<span class="hljs-number">0</span>; <span class="hljs-comment">/*表示进程P4是否已经执行完成*/</span><br>Semaphore s5=<span class="hljs-number">0</span>; <span class="hljs-comment">/*表示进程P5是否已经执行完成*/</span><br>main () &#123;<br>cobegin<br>    <span class="hljs-title function_">P1</span><span class="hljs-params">()</span>;<br>    P2();<br>    P3();<br>    P4();<br>    P5();<br>    p6();<br>coend<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230710162452442.png" alt="image-20230710162452442"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202210826126.png" alt="image-20230202210826126" style="zoom:80%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者/写者问题"></a>读者/写者问题</h4><p>读者与写者问题(reader-writer problem) (Courtois, 1971)也是一个经典的并发程序设计问题。有两组并发进程：读者和写者, 共享一个文件 F, 要求：</p>
<ol>
<li>允许多个读者可同时对文件执行读操作</li>
<li>只允许一个写者往文件中写信息</li>
<li>任意写者在完成写操作之前不允许其他读者或写者工作</li>
<li>写者执行写操作前, 应让已有的写者和读者全部退出</li>
</ol>
<p>使用PV操作求解该问题</p>
<p><strong>读者优先</strong></p>
<ul>
<li><code>rmutex</code> 控制对 <code>read_count</code> 的互斥访问；</li>
<li>读者需要对互斥信号量 <code>rmutex</code> 进行排队；</li>
<li>只有第一个读者需要对 <code>wmutex</code> 排队，后来的读者不需要对 <code>wmutex</code> 排队，可以插队到写者前面；</li>
<li>为了保证读时不被打断，读时用 <code>wmutex</code> 信号量阻塞写者；当前所有读者读完后，写者才开始写。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore rmutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 控制对 read_count 的互斥访问</span><br>semaphore wmutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 控制对文件内容的互斥写</span><br><span class="hljs-type">int</span> read_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 读者进程</span><br>process <span class="hljs-title function_">reader_i</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        P(rmutex);<br>        <span class="hljs-keyword">if</span>(read_count == <span class="hljs-number">0</span>)<br>            P(wmutex);<br>        read_count++;<br>        V(rmutex);<br>        <br>        read();<br>        <br>        P(rmutex);<br>        read_count--;<br>        <span class="hljs-keyword">if</span>(read_count == <span class="hljs-number">0</span>)<br>            V(wmutex);<br>        V(rmutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 写者进程</span><br>process <span class="hljs-title function_">writer_i</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        P(wmutex);<br>        write();<br>        V(wmutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>写者优先</strong></p>
<ul>
<li>后来的写者可以插队到先来的、还未开始读的读者前面；</li>
<li>互斥变量 <code>z</code> 保证了每次最多只有一个读者在互斥变量 <code>rmutex</code> 排队；</li>
<li>“第一个”写者到来时，写者可以立刻对 <code>rmutex</code> 排队，且此时最多只有一个读者在 <code>rmutex</code> 排队；</li>
<li>“后来的”写者到来时，不用对 <code>rmutex</code> 排队，直接等前面的写者写完后继续写；</li>
<li>“最后一个”写者离开时，开放 <code>rmutex</code> 使得读者可以开始读；</li>
<li>写者使用 <code>rmutex</code> 阻塞读者。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>, z = <span class="hljs-number">1</span>; <span class="hljs-comment">// read_count, write_count互斥</span><br>semaphore rmutex = <span class="hljs-number">1</span>, wmutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 读锁、写锁</span><br><span class="hljs-type">int</span> read_count = <span class="hljs-number">0</span>, write_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 读者进程</span><br>process <span class="hljs-title function_">reader_i</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    	P(z);<br>        P(rmutex);<br>        P(x);<br>        <span class="hljs-keyword">if</span>(read_count == <span class="hljs-number">0</span>)<br>            P(wmutex);<br>        read_count++;<br>        V(x);<br>        V(rmutex);<br>        V(z);<br><br>        read();<br><br>        P(x);<br>        read_count--;<br>        <span class="hljs-keyword">if</span>(read_count == <span class="hljs-number">0</span>)<br>            V(wmutex);<br>        V(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 写者进程</span><br>process <span class="hljs-title function_">writer_i</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    	P(y);<br>        <span class="hljs-keyword">if</span>(write_count == <span class="hljs-number">0</span>)<br>            P(rmutex);<br>        write_count++;<br>        V(y);<br><br>        P(wmutex);<br>        write();<br>        V(wmutex);<br><br>        P(y);<br>        write_count--;<br>        <span class="hljs-keyword">if</span>(write_count == <span class="hljs-number">0</span>)<br>            V(rmutex);<br>        V(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>读写公平</strong></p>
<ul>
<li>只比读者优先增加了一个互斥信号量 <code>S</code>；</li>
<li>所有读者和写者一起对互斥信号量 <code>S</code> 排队，这样后来的读者无法插队到先来的写者前面；</li>
<li>其他性质与读者优先相同。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore rmutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 控制对 read_count 的互斥访问</span><br>semaphore wmutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 控制对文件内容的互斥写</span><br>semaphore s = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> read_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 读者进程</span><br>process <span class="hljs-title function_">reader_i</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        P(s);<br>        P(rmutex);<br>        <span class="hljs-keyword">if</span>(read_count == <span class="hljs-number">0</span>)<br>            P(wmutex);<br>        read_count++;<br>        V(rmutex);<br>        V(s);<br>        <br>        read();<br>        <br>        P(rmutex);<br>        read_count--;<br>        <span class="hljs-keyword">if</span>(read_count == <span class="hljs-number">0</span>)<br>            V(wmutex);<br>        V(rmutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 写者进程</span><br>process <span class="hljs-title function_">writer_i</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        P(s);<br>        P(wmutex);<br>        write();<br>        V(wmutex);<br>        V(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202211221247.png" alt="image-20230202211221247" style="zoom:80%;" /></p>
<h4 id="睡眠的理发师问题"><a href="#睡眠的理发师问题" class="headerlink" title="睡眠的理发师问题"></a>睡眠的理发师问题</h4><p>理发店里有一位理发师、一把理发椅和 n 把供等候理发的顾客坐的椅子</p>
<p>如果没有顾客, 理发师便在理发椅上睡觉, 一个顾客到来时, 它必须叫醒理发师, 如果理发师正在理发时又有顾客来到, 如果有空椅子可坐, 就坐下来等待, 否则就离开</p>
<p>使用PV操作求解该问题</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202211603175.png" alt="image-20230202211603175" style="zoom:80%;" /></p>
<h4 id="农夫猎人问题"><a href="#农夫猎人问题" class="headerlink" title="农夫猎人问题"></a>农夫猎人问题</h4><p>有一个铁笼子, 每次只能放入一个动物。猎手向笼中放入老虎, 农夫向笼中放入羊；动物园等待取笼中的老虎, 饭店等待取笼中的羊。请用P、V操作原语写出同步执行的程序</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202211938726.png" alt="image-20230202211938726" style="zoom:80%;" /></p>
<h4 id="银行业务问题"><a href="#银行业务问题" class="headerlink" title="银行业务问题"></a>银行业务问题</h4><p>某大型银行办理人民币储蓄业务, 由 n 个储蓄员负责。每个顾客进入银行后先至取号机取一个号, 并且在等待区找到空沙发坐下等着叫号。取号机给出的号码依次递增, 并假定有足够多的空沙发容纳顾客。当一个储蓄员空闲下来, 就叫下一个号。</p>
<p>请用信号量和 PV 操作正确编写储蓄员进程和顾客进程的程序</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202223152625.png" alt="image-20230202223152625" style="zoom:80%;" /></p>
<h4 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h4><p>有 n 个进程将字符逐个读入到一个容量为 80 的缓冲区中(n &gt; 1), 当缓冲区满后, 由输出进程 Q 负责一次性取走这 80 个字符。这种过程循环往复, 请用信号量和P、V操作写出 n 个读入进程(P1, P2, …Pn)和输出进程 Q 能正确工作的动作序列</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230202224056349.png" alt="image-20230202224056349" style="zoom:80%;" /></p>
<h4 id="售票问题"><a href="#售票问题" class="headerlink" title="售票问题"></a>售票问题</h4><p>汽车司机与售票员之间必须协同工作, 一方面只有售票员把车门关好了司机才能开车, 因此, 售票员关好门应通知司机开车, 然后售票员进行售票。另一方面, 只有当汽车已经停下, 售票员才能开门上下客, 故司机停车后应该通知售票员。假定某辆公共汽车上有一名司机与两名售票员, 汽车当前正在始发站停车上客, 试用信号量与P、V操作写出他们的同步算法</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203124338266.png" alt="image-20230203124338266" style="zoom:80%;" /></p>
<h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><p>一个经典同步问题：吸烟者问题(patil, 1971)。三个吸烟者在一个房间内, 还有一个香烟供应者。为了制造并抽掉香烟, 每个吸烟者需要三样东西：烟草、纸和火柴, 供应者有丰富货物提供。三个吸烟者中, 第一个有自己的烟草, 第二个有自己的纸, 第三个有自己的火柴。供应者随机地将两样东西放在桌子上, 允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者, 供应者再把两样东西放在桌子上, 唤醒另一个吸烟者。试用信号量和P、V操作求解该问题</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203124508358.png" alt="image-20230203124508358" style="zoom:80%;" /></p>
<h2 id="6-4-管程"><a href="#6-4-管程" class="headerlink" title="6.4 管程"></a>6.4 管程</h2><h3 id="6-4-1-管程和条件变量"><a href="#6-4-1-管程和条件变量" class="headerlink" title="6.4.1 管程和条件变量"></a>6.4.1 管程和条件变量</h3><p>为什么要引入管程？</p>
<ul>
<li>把分散在各进程中的临界区集中起来进行管理</li>
<li>防止进程有意或无意的违法同步操作</li>
<li>便于用高级语言来书写程序</li>
</ul>
<h4 id="管程定义和属性"><a href="#管程定义和属性" class="headerlink" title="管程定义和属性"></a>管程定义和属性</h4><ul>
<li>管程的定义<ul>
<li>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块</li>
</ul>
</li>
<li>管程的属性<ul>
<li>共享性、安全性、互斥性</li>
</ul>
</li>
</ul>
<h4 id="管程的形式"><a href="#管程的形式" class="headerlink" title="管程的形式"></a>管程的形式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">type &lt;管程名&gt; = monitor &#123;<br>    &lt;局部变量说明&gt;;<br>    &lt;条件变量说明&gt;;<br>    &lt;初始化语句&gt;;<br>    define &lt;管程内定义的, 管程外可调用的过程或函数名列表&gt;;<br>    use &lt;管程外定义的, 管程内将调用的过程或函数名列表&gt;;<br>    <br>    &lt;过程名/函数名&gt;(&lt;形式参数表&gt;) &#123;<br>    	&lt;过程/函数体&gt;;<br>    &#125;<br>    ...<br>    &lt;过程名/函数名&gt;(&lt;形式参数表&gt;) &#123;<br>    	&lt;过程/函数体&gt;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="管程的结构"><a href="#管程的结构" class="headerlink" title="管程的结构"></a>管程的结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203142923995.png" alt="image-20230203142923995" style="zoom:80%;" /></p>
<h4 id="管程的条件变量"><a href="#管程的条件变量" class="headerlink" title="管程的条件变量"></a>管程的条件变量</h4><ul>
<li>条件变量: 是出现在管程内的一种数据结构, 且只有在管程中才能被访问, 它对管程内的所有过程是全局的, 只能通过两个原语操作来控制它<ul>
<li><code>wait()</code>: 阻塞调用进程并释放管程, 直到另一个进程在该条件变量上执行signal()</li>
<li><code>signal()</code>:<ul>
<li>如果存在其他进程由于对条件变量执行 wait() 而被阻塞, 便释放之</li>
<li>如果没有进程在等待, 那么, 信号不被保存, 并不是立即退出管程等待队列，而是进入 next 信号量，以保证多个进程都可以正常退出。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="管程问题讨论"><a href="#管程问题讨论" class="headerlink" title="管程问题讨论"></a>管程问题讨论</h4><ul>
<li>使用 signal 释放等待进程时, 可能出现两个进程同时停留在管程内。解决方法：<ul>
<li>执行 signal 的进程等待, 直到被释放进程退出管程或等待另一个条件变量</li>
<li>被释放进程等待, 直到执行 signal 的进程退出管程或等待另一个条件</li>
</ul>
</li>
<li>霍尔(Hoare, 1974)采用第一种办法</li>
<li>汉森(Hansen)选择两者的折衷, 规定管程中的过程所执行的signal操作是过程体的最后一个操作</li>
</ul>
<h3 id="6-4-2-管程的实现-Hoare方法"><a href="#6-4-2-管程的实现-Hoare方法" class="headerlink" title="6.4.2 管程的实现(Hoare方法)"></a>6.4.2 管程的实现(Hoare方法)</h3><ul>
<li>霍尔方法使用 P 和 V 操作原语来实现对管程中过程的互斥调用, 及实现对共享资源互斥使用的管理</li>
<li>不要求 signal 操作是过程体的最后一个操作, 且 wait 和 signal 操作可被设计成可以中断的过程</li>
<li>使用 <code>signal()</code> 释放一个等待进程时，霍尔管程让执行 <code>signal()</code> 的进程等待，直到<strong>被释放进程退出管程或等待另一个条件</strong></li>
<li>霍尔管程基于 PV 操作原语实现：<ul>
<li><code>wait()</code> 和 <code>signal()</code> 可以是程序过程</li>
<li>可以用语言机制实现霍尔管程</li>
</ul>
</li>
</ul>
<h4 id="Hoare管程数据结构"><a href="#Hoare管程数据结构" class="headerlink" title="Hoare管程数据结构"></a>Hoare管程数据结构</h4><p><code>mutex</code></p>
<ul>
<li>对每个管程, 使用用于管程中过程互斥调用的信号量 mutex (初值为1)</li>
<li>进程调用管程中的任何过程时, 应执行P(mutex)；进程退出管程时, 需要判断是否有进程在 next 信号量等待, <strong>如果有(即 next_count &gt; 0), 则通过 V(next) 唤醒一个发出 signal 的进程, 否则应执行 V(mutex) 开放管程</strong>, 以便让其他调用者进入</li>
<li><strong>为了使进程在等待资源期间, 其他进程能进入管程, 故在 wait 操作中也必须执行 V(mutex)</strong>, 否则会妨碍其他进程进入管程, 导致无法释放资源</li>
</ul>
<p><code>next, next-count</code></p>
<ul>
<li>对每个管程, 引入信号量 next(初值为0), <strong>凡发出 signal 操作的进程应该用 P(next) 阻塞自己</strong>, 直到被释放进程退出管程或产生其他等待条件</li>
<li>进程在退出管程的过程前, 须检查是否有别的进程在信号量 next 上等待, 若有, 则用 V(next) 唤醒它。next-count(初值为0), 用来记录在 next 上等待的进程个数</li>
</ul>
<p><code>x-sem, x-count</code></p>
<ul>
<li>引入信号量 x-sem(初值为0), 申请资源得不到满足时, 执行 P(x-sem) 阻塞。由于释放资源时, 需要知道是否有别的进程在等待资源, 用计数器 x-count(初值为0) 记录等待资源的进程数</li>
<li>执行 signal 操作时, 应让等待资源的诸进程中的某个进程立即恢复运行, 而不让其他进程抢先进入管程, 这可以用 V(x-sem) 来实现</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203153058116.png" alt="image-20230203153058116" style="zoom:80%;" /></p>
<h3 id="6-4-3-管程求解进程的同步与互斥问题"><a href="#6-4-3-管程求解进程的同步与互斥问题" class="headerlink" title="6.4.3 管程求解进程的同步与互斥问题"></a>6.4.3 管程求解进程的同步与互斥问题</h3><h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203152456907.png" alt="image-20230203152456907" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203152512970.png" alt="image-20230203152512970" style="zoom:80%;" /></p>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203153252412.png" alt="image-20230203153252412" style="zoom:80%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">cobegin<br>process <span class="hljs-title function_">philosopher_i</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    	thinking();<br>        dining_philosopers.pickup(i);<br>        eating();<br>        dining_philosophers.putdown(i);<br>    &#125;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203153221933.png" alt="image-20230203153221933" style="zoom:80%;" /></p>
<h4 id="苹果-橘子问题"><a href="#苹果-橘子问题" class="headerlink" title="苹果-橘子问题"></a>苹果-橘子问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203153239345.png" alt="image-20230203153239345" style="zoom:80%;" /></p>
<h2 id="6-5-进程通信"><a href="#6-5-进程通信" class="headerlink" title="6.5 进程通信"></a>6.5 进程通信</h2><h3 id="6-5-1-进程通信-消息传递"><a href="#6-5-1-进程通信-消息传递" class="headerlink" title="6.5.1 进程通信(消息传递)"></a>6.5.1 进程通信(消息传递)</h3><ul>
<li>当进程互相交互时, 必须满足两个基本要求：同步和通信<ul>
<li>为实施互斥, 进程间需要同步</li>
<li>为了协作, 进程间需要交换信息</li>
</ul>
</li>
<li>消息传递提供了这些功能, 最典型的消息传递原语<ul>
<li>send 发送消息的原语</li>
<li>receive 接收消息的原语</li>
</ul>
</li>
</ul>
<h4 id="进程直接通信"><a href="#进程直接通信" class="headerlink" title="进程直接通信"></a>进程直接通信</h4><ul>
<li>对称直接寻址, 发送进程和接收进程必须命名对方以便通信, 原语 send() 和 receive() 定义如下：<ul>
<li>send(P, messsage) 发送消息到进程P</li>
<li>receive(Q, message) 接收来自进程Q的消息</li>
</ul>
</li>
<li>非对称直接寻址, 只要发送者命名接收者, 而接收者不需要命名发送者, send() 和 receive() 定义如下：<ul>
<li>send(P, messsage) 发送消息到进程P</li>
<li>receive(id, message) 接收来自任何进程的消息, 变量id置成与其通信的进程名称</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203155706290.png" alt="image-20230203155706290" style="zoom:80%;" /></p>
<h4 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203161752192.png" alt="image-20230203161752192" style="zoom:80%;" /></p>
<h4 id="进程间接通信"><a href="#进程间接通信" class="headerlink" title="进程间接通信"></a>进程间接通信</h4><ul>
<li>消息不是直接从发送者发送到接收者, 而是发送到由临时保存这些消息的队列组成的一个共享数据结构, 这些队列通常成为信箱(mailbox)</li>
<li>一个进程给合适的信箱发送消息, 另一进程从信箱中获得消息</li>
<li><p>间接通信的 send() 和 receive() 定义如下：</p>
<ul>
<li>send(A, message)：把一封信件(消息)传送到信箱 A</li>
<li>receive(A, message)：从信箱 A 接收一封信件(消息)</li>
</ul>
</li>
<li><p>信箱可以分成信箱头和信箱体两部分, 信箱头指出信箱容量、信件格式、存放信件位置的指针等；信箱体用来存放信件, 信箱体分成若干个区, 每个区可容纳一封信</p>
</li>
<li>“发送”和“接收”两条原语的功能为：<ul>
<li>发送信件：如果指定的信箱未满, 则将信件送入信箱中由指针所指示的位置, 并释放等待该信箱中信件的等待者；否则, 发送信件者被置成等待信箱状态</li>
<li>接收信件：如果指定信箱中有信, 则取出一封信件, 并释放等待信箱的等待者, 否则, 接收信件者被置成等待信箱中信件的状态</li>
</ul>
</li>
</ul>
<h4 id="send-receive原语的算法描述"><a href="#send-receive原语的算法描述" class="headerlink" title="send/receive原语的算法描述"></a>send/receive原语的算法描述</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203162732043.png" alt="image-20230203162732043" style="zoom:80%;" /></p>
<h4 id="消息传递求解生产者消费者问题"><a href="#消息传递求解生产者消费者问题" class="headerlink" title="消息传递求解生产者消费者问题"></a>消息传递求解生产者消费者问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203162507141.png" alt="image-20230203162507141" style="zoom:80%;" /></p>
<h4 id="有关消息传递的若干问题"><a href="#有关消息传递的若干问题" class="headerlink" title="有关消息传递的若干问题"></a>有关消息传递的若干问题</h4><ul>
<li>关于信箱容量问题</li>
<li>关于多进程与信箱相连的信件接收问题</li>
<li>关于信箱的所有权问题<ul>
<li>信箱为操作系统所有是指由操作系统统一设置信箱, 归系统所有, 供相互通信的进程共享, 消息缓冲机制就是一个著名的例子</li>
</ul>
</li>
<li>关于信件的格式问题和其他有关问题</li>
<li>关于通信进程的同步问题</li>
</ul>
<blockquote>
<p>消息缓冲是在1973年由P.B.Hansan提出的一种进程间高级通信设施, 并在RC4000系统中实现</p>
<p>消息缓冲通信的基本思想是：由操作系统统一管理一组用于通信的消息缓冲存储区, 每一个消息缓冲存储区可存放一个消息(信件)。当一个进程要发送消息时, 先在自己的消息发送区里生成待发送的消息, 包括：接收进程名、消息长度、消息正文等。然后, 向系统申请一个消息缓冲区, 把消息从发送区复制到消息缓冲区中, 注意在复制过程中系统会将接收进程名换成发送进程名, 以便接收者识别。随后该消息缓冲区被挂到接收消息的进程的消息队列上, 供接收者在需要时从消息队列中摘下并复制到消息接收区去使用, 同时释放消息缓冲区。</p>
</blockquote>
<h4 id="消息缓冲通信"><a href="#消息缓冲通信" class="headerlink" title="消息缓冲通信"></a>消息缓冲通信</h4><p>消息缓冲通信涉及的数据结构：</p>
<ul>
<li>sender：发送消息的进程名或标识符</li>
<li>size：发送的消息长度</li>
<li>text：发送的消息正文</li>
<li>next-ptr：指向下一个消息缓冲区的指针</li>
</ul>
<p>在进程的PCB中涉及通信的数据结构：</p>
<ul>
<li>mptr：消息队列队首指针</li>
<li>mutex：消息队列互斥信号量, 初值为1</li>
<li>sm：表示接收进程消息队列上消息的个数, 初值为0, 是控制收发进程同步的信号量</li>
</ul>
<p>发送原语和接收原语的实现如下：</p>
<ul>
<li>发送原语Send：申请一个消息缓冲区, 把发送区内容复制到这个缓冲区中；找到接收进程的PCB, 执行互斥操作 P(mutex)；把缓冲区挂到接收进程消息队列的尾部, 执行V(sm)、即消息数加1；执行V(mutex)</li>
<li>接收原语Receive：执行P(sm)查看有否信件；执行互斥操作P(mutex), 从消息队列中摘下第一个消息, 执行V(mutex)；把消息缓冲区内容复制到接收区, 释放消息缓冲区</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203163117130.png" alt="image-20230203163117130" style="zoom:80%;" /></p>
<h4 id="管道和套接字"><a href="#管道和套接字" class="headerlink" title="管道和套接字"></a>管道和套接字</h4><ul>
<li>管道(pipeline)是Unix和C的传统通信方式</li>
<li>套接字(socket)起源于Unix BSD版本, 目前已经被Unix和Windows操作系统广泛采用, 并支持TCP/IP协议, 即支持本机的进程间通信, 也支持网络级的进程间通信</li>
<li>管道和套接字都是基于信箱的消息传递方式的一种变体, 它们与传统的信箱方式等价, 区别在于没有预先设定消息的边界。换言之, 如果一个进程发送10条100字节的消息, 而另一个进程接收1000个字节, 那么接收者将一次获得10条消息</li>
</ul>
<h3 id="6-5-2-高级进程通信机制"><a href="#6-5-2-高级进程通信机制" class="headerlink" title="6.5.2 高级进程通信机制"></a>6.5.2 高级进程通信机制</h3><h4 id="基于流的进程通信"><a href="#基于流的进程通信" class="headerlink" title="基于流的进程通信"></a>基于流的进程通信</h4><ul>
<li><p>多个进程使用一个共享的消息缓冲区(可称为管道、多路转换器、套接字)</p>
</li>
<li><p>一些进程往消息缓冲区写入字符流(send/write)</p>
</li>
<li>一些进程从消息缓冲区读出字符流(receive/read)</li>
<li>信息交换单位基于字符流, 长度任意</li>
</ul>
<h4 id="基于字符流的进程通信规约"><a href="#基于字符流的进程通信规约" class="headerlink" title="基于字符流的进程通信规约"></a>基于字符流的进程通信规约</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203163500686.png" alt="image-20230203163500686" style="zoom:80%;" /></p>
<h4 id="远程过程调用RPC"><a href="#远程过程调用RPC" class="headerlink" title="远程过程调用RPC"></a>远程过程调用RPC</h4><ul>
<li>采用<strong>客户/服务器</strong>计算模式</li>
<li><strong>服务器进程</strong>提供一系列<strong>过程/服务</strong>, 供客户进程调用</li>
<li><p><strong>客户进程</strong>通过调用服务器进程提供的<strong>过程/服务</strong>获得鼓舞</p>
</li>
<li><p>考虑到客户计算机和服务器计算机的硬件异构型, 外部数据表示 XDR 被引入来转换每台计算机的特殊数据格式为标准数据格式</p>
</li>
</ul>
<h4 id="基于RPC-XDR的高级通信规约"><a href="#基于RPC-XDR的高级通信规约" class="headerlink" title="基于RPC/XDR的高级通信规约"></a>基于RPC/XDR的高级通信规约</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203163812713.png" alt="image-20230203163812713" style="zoom:80%;" /></p>
<h4 id="远程过程调用-RPC-Remote-Procedure-Call"><a href="#远程过程调用-RPC-Remote-Procedure-Call" class="headerlink" title="远程过程调用(RPC, Remote Procedure Call)"></a>远程过程调用(RPC, Remote Procedure Call)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203163945300.png" alt="image-20230203163945300" style="zoom:80%;" /></p>
<h4 id="RPC执行步骤"><a href="#RPC执行步骤" class="headerlink" title="RPC执行步骤"></a>RPC执行步骤</h4><ol>
<li>客户进程以普通方式调用客户存根</li>
<li>客户存根组织RPC消息并执行Send, 激活内核程序</li>
<li>内核把消息通过网络发送到远地内核</li>
<li>远地内核把消息送到服务器存根</li>
<li>服务器存根取出消息中参数后调用服务器过程</li>
<li>服务器过程执行完后把结果返回至服务器存根</li>
<li>服务器存根进程将它打包并激活内核程序</li>
<li>服务器内核把消息通过网络发送至客户机内核</li>
<li>客户内核把消息交给客户存根</li>
<li>客户存根从消息中取出结果返回给客户进程</li>
<li>客户进程获得控制权并得到了过程调用的结果</li>
</ol>
<h2 id="6-6-死锁"><a href="#6-6-死锁" class="headerlink" title="6.6 死锁"></a>6.6 死锁</h2><h3 id="6-6-1-死锁的产生"><a href="#6-6-1-死锁的产生" class="headerlink" title="6.6.1 死锁的产生"></a>6.6.1 死锁的产生</h3><h4 id="若干死锁的例子"><a href="#若干死锁的例子" class="headerlink" title="若干死锁的例子"></a>若干死锁的例子</h4><p><strong>进程推进顺序不当产生死锁</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203165502862.png" alt="image-20230203165502862" style="zoom:80%;" /></p>
<p><strong>PV操作使用不当产生死锁</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203165733619.png" alt="image-20230203165733619" style="zoom:80%;" /></p>
<p><strong>资源分配不当引起死锁</strong></p>
<ul>
<li>若系统中有 m 个资源被 n 个进程共享, 每个进程都要求 K 个资源, 而 m &lt; nk 时, 即资源数小于进程所要求的总数时, 如果分配不当就可能引起死锁</li>
</ul>
<p><strong>对临时性资源使用不加限制引起死锁</strong></p>
<ul>
<li>进程通信使用的信件是一种临时性资源, 如果对信件的发送和接收不加限制, 可能引起死锁</li>
<li>进程 P1 等待进程 P3 的信件 S3 来到后再向进程 P2 发送信件 S1；P2 又要等待 P1 的信件 S1 来到后再向 P3 发送信件 S2；而 P3 也要等待 P2 的信件 S2 来到后才能发出信件 S3。这种情况下形成了循环等待, 产生死锁</li>
</ul>
<h4 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h4><ul>
<li>操作系统中的死锁指：如果在一个进程集合中的每个进程都在等待只能由该集合中的其他一个进程才能引发的事件, 则称一组进程或系统此时发生死锁。</li>
<li>例如, n个进程P1, P2, …, Pn, Pi因为申请不到资源 Rj 而处于等待状态, 而 Rj 又被 Pi+1 占有, Pn 欲申请的资源被 P1 占有, 此时这 n 个进程的等待状态永远不能结束, 则说这 n 个进程处于死锁状态</li>
</ul>
<h4 id="产生死锁因素"><a href="#产生死锁因素" class="headerlink" title="产生死锁因素"></a>产生死锁因素</h4><ul>
<li>不仅与系统拥有的资源数量有关, 而且与资源分配策略, 进程对资源的使用要求以及并发进程的推进顺序有关</li>
</ul>
<h3 id="6-6-2-死锁的防止"><a href="#6-6-2-死锁的防止" class="headerlink" title="6.6.2 死锁的防止"></a>6.6.2 死锁的防止</h3><h4 id="系统形成死锁的四个必要条件"><a href="#系统形成死锁的四个必要条件" class="headerlink" title="系统形成死锁的四个必要条件"></a>系统形成死锁的四个必要条件</h4><ul>
<li><strong>互斥条件</strong>(mutual exclusion)：系统中存在临界资源, 进程应互斥地使用这些资源</li>
<li><strong>占有和等待条件</strong>(hold and wait)：进程请求资源得不到满足而等待时, 不释放已占有的资源</li>
<li><strong>不剥夺条件</strong>(no preemption)：已被占用的资源只能由属主释放, 不允许被其它进程剥夺</li>
<li><strong>循环等待条件</strong>(circular wait)：存在循环等待链, 其中, 每个进程都在链中等待下一个进程所持有的资源, 造成这组进程永远等待</li>
</ul>
<h4 id="破坏条件"><a href="#破坏条件" class="headerlink" title="破坏条件"></a>破坏条件</h4><p>破坏第一个条件</p>
<ul>
<li>使资源可同时访问而不是互斥使用</li>
<li>可再入程序、只读数据文件、时钟、磁盘等软硬件资源均可用这种办法管理, <strong>但有许多资源如可写文件、磁带机等由于特殊性质决定只能互斥占有</strong>, 而不能被同时访问, 所以这种做法许多场合行不通。(有些资源具有天生的互斥性)</li>
</ul>
<p>破坏第二个条件</p>
<ul>
<li>静态分配</li>
<li><strong>进程在执行中不再申请资源</strong>, 就不会出现占有某些资源再等待另一些资源的情况</li>
<li>实现简单, 被许多操作系统采用, 但会<strong>严重地降低资源利用率</strong>, 因为在每个进程占有的资源中, 有些资源在运行后期使用, 甚至有些资源在例外情况下才被使用, 可能造成进程占有一些几乎不用的资源, 而使其他想用这些资源的进程产生等待</li>
</ul>
<p>破坏第三个条件</p>
<ul>
<li>采用剥夺式调度方法</li>
<li>当进程在申请资源未获准许的情况下, 如主动释放资源(一种剥夺式), 然后才去等待</li>
</ul>
<p>破坏第四个条件</p>
<ul>
<li>上述死锁防止办法造成资源利用率和吞吐率低。介绍两种比较实用的死锁防止方法</li>
</ul>
<h4 id="采用层次分配策略-破坏条件2和4"><a href="#采用层次分配策略-破坏条件2和4" class="headerlink" title="采用层次分配策略(破坏条件2和4)"></a>采用层次分配策略(破坏条件2和4)</h4><ul>
<li>资源被分成多个层次</li>
<li>当进程得到某一层的一个资源后, 它只能再申请较高层次的资源</li>
<li>当进程要释放某层的一个资源时, 必须先释放占有的较高层次的资源</li>
<li>当进程得到某一层的一个资源后, 它想申请该层的另一个资源时, 必须先释放该层中的已占资源</li>
</ul>
<h4 id="层次策略的变种按序分配策略"><a href="#层次策略的变种按序分配策略" class="headerlink" title="层次策略的变种按序分配策略"></a>层次策略的变种按序分配策略</h4><ul>
<li>把系统的所有资源排一个顺序, 例如, 系统若共有 n 个进程, 共有 m 个资源, 用 ri 表示第 i 个资源, 于是这 m 个资源是：r1, r2…, rm</li>
<li>规定如果进程不得在占用资源 ri(1&lt;=i&lt;=m) 后再申请 rj(j&lt;i)。不难证明, 按这种策略分配资源时系统不会发生死锁</li>
</ul>
<h3 id="6-6-3-死锁的避免"><a href="#6-6-3-死锁的避免" class="headerlink" title="6.6.3 死锁的避免"></a>6.6.3 死锁的避免</h3><ul>
<li>银行家算法<ul>
<li>银行家拥有一笔周转资金</li>
<li>客户要求分期贷款, 如果客户能够得到各期贷款, 就一定能够归还贷款, 否则就一定不能归还贷款</li>
<li>银行家应谨慎的贷款, 防止出现坏帐</li>
</ul>
</li>
<li>用银行家算法避免死锁<ul>
<li>操作系统(银行家)</li>
<li>操作系统管理的资源(周转资金)</li>
<li>进程(要求贷款的客户)</li>
</ul>
</li>
</ul>
<h4 id="银行家算法的数据结构"><a href="#银行家算法的数据结构" class="headerlink" title="银行家算法的数据结构"></a>银行家算法的数据结构</h4><p>一个系统有 <strong>n 个进程和 m 种不同类型的资源</strong>, 定义包含以下向量和矩阵的数据结构:</p>
<ul>
<li>系统每类资源总数—该 m 个元素的向量为系统中每类资源的数量<ul>
<li>Resource = (R1, R2 , …, Rm)</li>
</ul>
</li>
<li><p>每类资源未分配数量—该 m 个元素的向量为系统中每类资源尚可供分配的数量</p>
<ul>
<li>Available = (V1, V2 , …, Vm)</li>
</ul>
</li>
<li><p>最大需求矩阵—每个进程对每类资源的最大需求量, Cij表示进程 Pi 需 Rj 类资源最大数</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203171542152.png" alt="image-20230203171542152" style="zoom:80%;" /></p>
<ul>
<li>分配矩阵—表示进程当前已分得的资源数, Aij 表示进程 Pi 已分到 Rj 类资源的个数</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203171616097.png" alt="image-20230203171616097" style="zoom:80%;" /></p>
<h4 id="银行家算法中下列关系式确保成立"><a href="#银行家算法中下列关系式确保成立" class="headerlink" title="银行家算法中下列关系式确保成立"></a>银行家算法中下列关系式确保成立</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203171718724.png" alt="image-20230203171718724" style="zoom:80%;" /></p>
<h4 id="一种死锁避免策略"><a href="#一种死锁避免策略" class="headerlink" title="一种死锁避免策略"></a>一种死锁避免策略</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203171817254.png" alt="image-20230203171817254" style="zoom:80%;" /></p>
<h4 id="系统安全性定义"><a href="#系统安全性定义" class="headerlink" title="系统安全性定义"></a>系统安全性定义</h4><p>在时刻 T0 系统是安全的, 仅当存在一个进程序列P1, …, Pn , 对进程Pk满足公式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203171853323.png" alt="image-20230203171853323" style="zoom:80%;" /></p>
<h4 id="实例说明系统所处的安全或不安全状态"><a href="#实例说明系统所处的安全或不安全状态" class="headerlink" title="实例说明系统所处的安全或不安全状态"></a>实例说明系统所处的安全或不安全状态</h4><ul>
<li>如果系统中共有五个进程和 A、B、C 三类资源</li>
<li>A类资源共有10个, B类资源共有5个, C类资源共有7个</li>
<li>在时刻T0, 系统目前资源分配情况如下</li>
<li>资源总数[10 5 7]</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203171944508.png" alt="image-20230203171944508" style="zoom:80%;" /></p>
<p>可以断言目前系统处于安全状态, 因为, 序列{P1, P3, P4, P2, P0}能满足安全性条件</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203172228269.png" alt="image-20230203172228269" style="zoom:80%;" /></p>
<h4 id="银行家算法的基本思想"><a href="#银行家算法的基本思想" class="headerlink" title="银行家算法的基本思想"></a>银行家算法的基本思想</h4><ul>
<li>系统中的所有进程进入进程集合</li>
<li>在安全状态下系统收到进程的资源请求后, 先把资源<strong>试探性分配</strong>给它</li>
<li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较, 在进程集合中<strong>找到剩余资源能满足最大需求量的进程</strong>, 从而, <strong>保证这个进程运行完毕并归还全部资源</strong></li>
<li>把这个进程<strong>从集合中去掉</strong>, 系统的剩余资源更多了, 反复执行上述步骤。//进程退出系统, 资源回收</li>
<li>最后, 检查进程集合, 若为空表明本次申请可行, 系统处于安全状态, 可实施本次分配; 否则, 有进程执行不完, 系统处于不安全状态, 本次资源分配暂不实施, 让申请进程等待。</li>
</ul>
<h3 id="6-6-4-死锁的检测和解除"><a href="#6-6-4-死锁的检测和解除" class="headerlink" title="6.6.4 死锁的检测和解除"></a>6.6.4 死锁的检测和解除</h3><h4 id="资源分配图和死锁定理"><a href="#资源分配图和死锁定理" class="headerlink" title="资源分配图和死锁定理"></a>资源分配图和死锁定理</h4><ul>
<li>解决死锁问题的一条途径是<strong>死锁检测和解除</strong>，这种方法对资源的分配不加任何限制，也不采取死锁避免措施，但系统定时地运行一个“死锁检测”程序，判断系统内是否已出现死锁，如果检测到系统已发生了死锁，再采取措施解除它</li>
</ul>
<h4 id="进程-资源分配图"><a href="#进程-资源分配图" class="headerlink" title="进程-资源分配图"></a>进程-资源分配图</h4><ul>
<li>约定 Pi-&gt;Rj 为请求边，表示进程 Pi 申请资源类 Rj 中的一个资源得不到满足而处于等待 Rj 类资源的状态，该有向边从进程开始指到方框的边缘，表示进程 Pi 申请 Rj 类中的一个资源。</li>
<li>Rj-&gt;Pi 为分配边，表示 Rj 类中的一个资源已被进程 Pi 占用，由于已把一个具体的资源分给了进程 Pi，故该有向边从方框内的某个黑圆点出发指向进程。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203173105215.png" alt="image-20230203173105215" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203173204493.png" alt="image-20230203173204493" style="zoom:80%;" /></p>
<h4 id="简化进程-资源分配图检测系统是否处于死锁状态"><a href="#简化进程-资源分配图检测系统是否处于死锁状态" class="headerlink" title="简化进程-资源分配图检测系统是否处于死锁状态"></a>简化进程-资源分配图检测系统是否处于死锁状态</h4><ul>
<li>如果进程-资源分配图中<strong>无环路</strong>，则此时系统<strong>没有发生死锁</strong></li>
<li>如果进程-资源分配图中<strong>有环路</strong>，且<strong>每个资源类中仅有一个资源</strong>，则系统中发生了死锁，此时，<strong>环路是系统发生死锁的充要条件</strong>，环路中的进程便为死锁进程</li>
<li><p>如果进程-资源分配图中<strong>有环路</strong>，且涉及的资源类中有多个资源，则环路的存在<strong>只是产生死锁的必要条件</strong>而不是充分条件</p>
</li>
<li><p>如果能在进程-资源分配图中<strong>消去此进程的所有请求边和分配边</strong>，成为<strong>孤立结点</strong>。经一系列简化，使所有进程成为孤立结点，则该图是可完全简化的；否则则称该图是不可完全简化的</p>
</li>
<li>系统为死锁状态的<strong>充分条件</strong>是：当且仅当该状态的进程-资源分配图是<strong>不可完全简化</strong>的。该充分条件称为<strong>死锁定理</strong></li>
</ul>
<h4 id="死锁的检测和解除方法"><a href="#死锁的检测和解除方法" class="headerlink" title="死锁的检测和解除方法"></a>死锁的检测和解除方法</h4><ul>
<li>借助于死锁的安全性测试算法来实现。<strong>死锁检测算法与死锁避免算法是类似的，不同在于前者考虑了检查每个进程还需要的所有资源能否满足要求</strong>；而后者则仅要根据进程的当前申请资源量来判断系统是否进入了不安全状态</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203173634312.png" alt="image-20230203173634312"></p>
<h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><ul>
<li>结束所有进程的执行，重新启动操作系统。方法简单，但以前工作全部作废，损失很大。</li>
<li>撤销陷于死锁的所有进程，解除死锁继续运行。</li>
<li>逐个撤销陷于死锁的进程，回收其资源重新分派，直至死锁解除。</li>
<li>剥夺陷于死锁的进程占用的资源，但并不撤销它，直至死锁解除。可仿照撤销陷于死锁进程的条件来选择剥夺资源的进程</li>
<li>根据系统保存的检查点，让所有进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制</li>
<li>当检测到死锁时，如果存在某些未卷入死锁的进程，而随着这些进程执行到结束，有可能释放足够的资源来解除死锁</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/02/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-5-%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/02/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-5-%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">Web前端开发(5) 事件、作用域、闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-02 13:59:24" itemprop="dateCreated datePublished" datetime="2022-12-02T13:59:24+08:00">2022-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-1-JS-事件"><a href="#7-1-JS-事件" class="headerlink" title="7.1 JS 事件"></a>7.1 JS 事件</h1><h2 id="1-JS-事件"><a href="#1-JS-事件" class="headerlink" title="1 JS 事件"></a>1 JS 事件</h2><h3 id="1-1-事件"><a href="#1-1-事件" class="headerlink" title="1.1 事件"></a>1.1 事件</h3><ul>
<li>事件和事件处理<ul>
<li>使 web 应用程序的响应性、动态性和交互性更强</li>
<li>通过回调编程</li>
</ul>
</li>
<li>JS 事件<ul>
<li>允许脚本影响用户与网页上元素的交互</li>
<li>是否可以启动对页面的修改</li>
</ul>
</li>
</ul>
<h3 id="1-2-事件驱动编程"><a href="#1-2-事件驱动编程" class="headerlink" title="1.2 事件驱动编程"></a>1.2 事件驱动编程</h3><ul>
<li>事件驱动编程是一种编程范式, 其中程序流由事件决定, 诸如用户操作(鼠标点击、按键)、传感器输出或来自其他程序/线程的消息</li>
<li><p>事件驱动编程是图形用户界面和其它应用程序(如 JS web应用程序)中使用的主要范式, 这些应用程序以执行特定的操作来影响用户输入为中心</p>
</li>
<li><p>在事件驱动的应用程序中, 通常有一个主循环监听事件, 然后在检测到其中一个事件时触发回调函数</p>
</li>
<li>事件驱动程序可以用任何编程语言编写, 尽管使用提供高级抽象的语言(如闭包)更容易完成此任务</li>
</ul>
<h3 id="1-3-事件处理程序"><a href="#1-3-事件处理程序" class="headerlink" title="1.3 事件处理程序"></a>1.3 事件处理程序</h3><ul>
<li>处理程序接收的输入的回调子例程(在 Java 和 JS 中被称为侦听器)</li>
<li>当事件发生时调用的函数</li>
<li>通常与 XHTML 元素相关联</li>
<li>必须注册<ul>
<li>也就是说, 必须指定关联</li>
</ul>
</li>
</ul>
<h3 id="1-4-JS-的用途"><a href="#1-4-JS-的用途" class="headerlink" title="1.4 JS 的用途"></a>1.4 JS 的用途</h3><ul>
<li><p>事件处理程序可用于处理和验证用户输入、用户操作和浏览器操作</p>
<ul>
<li>每次加载页面时应该做的事情</li>
<li>当页面关闭时应该做的事情</li>
<li>当用户单击按钮时应该执行的操作</li>
<li>当用户输入数据时应该验证的内容</li>
<li>…</li>
</ul>
</li>
<li><p>可以使用许多不同的方法让 JS 处理事件</p>
<ul>
<li>HTML事件属性可以直接执行 JS 代码</li>
<li>HTML事件属性可以调用 JS 函数</li>
<li>可以将自己的事件处理函数分配给 HTML 元素</li>
<li><p>可以阻止事件的发送或处理</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-语法"><a href="#1-5-语法" class="headerlink" title="1.5 语法"></a>1.5 语法</h3><ul>
<li><code>element.addEventListener(event, function, useCapture);</code><ul>
<li>第一个参数是事件类型(如 “click” 或 “mousedown”)</li>
<li>第⼆个参数是我们想在事件发生时调用的函数</li>
<li>第三个参数是一个布尔值, 指定是使用事件冒泡还是使用事件捕获, 是可选参数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, myFunction);<br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, mySecondFunction);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myDiv&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, myFunction, <span class="hljs-literal">true</span>);<br>element.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;mousemove&quot;</span>, myFunction);<br></code></pre></td></tr></table></figure>
<h3 id="1-6-观察者模式"><a href="#1-6-观察者模式" class="headerlink" title="1.6 观察者模式"></a>1.6 观察者模式</h3><ul>
<li>观察者模式是一种软件设计模式, 在这种模式中, 一个称为主题的对象维护一个名为观察者的依赖项列表, 通常通过调用它们的一个方法自动通知其任何状态变化</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221201225704728.png" alt="image-20221201225704728" style="zoom:80%;" /></p>
<ul>
<li>主要用于实现分布式事件处理系统</li>
<li>观察者模式也是我们熟悉的 模型-视图-控制器(MVC) 体系结构模式中的关键部分。观察者模式在许多编程库和系统中实现, 包括几乎所有的GUI工具包</li>
<li>发布者/订阅者模式的子集</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221201225734442.png" alt="image-20221201225734442" style="zoom:80%;" /></p>
<ul>
<li>事件使得一个主题可能有多个观察者队列</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221201225913162.png" alt="image-20221201225913162" style="zoom:80%;" /></p>
<h4 id="1-6-1-特征"><a href="#1-6-1-特征" class="headerlink" title="1.6.1 特征"></a>1.6.1 特征</h4><ul>
<li>好处<ul>
<li>主题与观察者之间的抽象耦合</li>
<li>支持广播通信</li>
</ul>
</li>
<li>注意<ul>
<li>观察者模式会导致内存泄漏, 即所谓的失效侦听器问题</li>
</ul>
</li>
</ul>
<h3 id="1-7-用-jQuery-方式附加事件处理程序"><a href="#1-7-用-jQuery-方式附加事件处理程序" class="headerlink" title="1.7 用 jQuery 方式附加事件处理程序"></a>1.7 用 jQuery 方式附加事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> hiddenBox = $( <span class="hljs-string">&quot;#banner-message&quot;</span> );<br>$(<span class="hljs-string">&quot;#button-container button&quot;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>	hiddenBox.<span class="hljs-title function_">show</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<h2 id="2-事件类型"><a href="#2-事件类型" class="headerlink" title="2 事件类型"></a>2 事件类型</h2><h3 id="2-1-可能发生的不同事件"><a href="#2-1-可能发生的不同事件" class="headerlink" title="2.1 可能发生的不同事件"></a>2.1 可能发生的不同事件</h3><ul>
<li><p>在 Web 中, 事件在浏览器窗口中被触发并且通常被绑定到窗口内部的特定部分: 可能是一个元素、一系列元素、被加载到这个窗口的 HTML 代码或者是整个浏览器窗口。举几个可能发生的不同事件</p>
<ul>
<li>用户在某个元素上点击鼠标或悬停光标</li>
<li>用户在键盘中按下某个按键</li>
<li>用户调整浏览器的大小或者关闭浏览器窗口</li>
<li>一个网页停止加载</li>
<li>提交表单</li>
<li>播放、暂停、关闭视频</li>
<li>发生错误</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Events">Event reference</a></p>
</li>
</ul>
<h3 id="2-2-DOM-2-事件类型"><a href="#2-2-DOM-2-事件类型" class="headerlink" title="2.2 DOM 2 事件类型"></a>2.2 DOM 2 事件类型</h3><ul>
<li>用户界面(UI)事件:<ul>
<li>DOMFocusIn, DOMFocusOut, DOMActivate</li>
</ul>
</li>
<li>鼠标事件:<ul>
<li>click, mousedown, mouseup, mouseover, mousemove, mouseout</li>
</ul>
</li>
<li>键盘事件: (not in DOM 2, but will in DOM 3)</li>
<li>变动事件:<ul>
<li>DOMSubtreeModified, DOMNodeInserted, …</li>
</ul>
</li>
<li>HTML事件:<ul>
<li>load, unload, abort, error, select, change, submit, reset, focus, blur, resize, scroll</li>
</ul>
</li>
</ul>
<h3 id="2-3-HTML5-新事件"><a href="#2-3-HTML5-新事件" class="headerlink" title="2.3 HTML5 新事件"></a>2.3 HTML5 新事件</h3><ul>
<li>audio, video<ul>
<li>canplay, playing, suspend, …</li>
</ul>
</li>
<li>drag/drop</li>
<li>history</li>
<li>new form events<ul>
<li>invalid</li>
</ul>
</li>
<li>offline, online, …</li>
<li>message</li>
</ul>
<h3 id="2-4-触屏和移动设备事件"><a href="#2-4-触屏和移动设备事件" class="headerlink" title="2.4 触屏和移动设备事件"></a>2.4 触屏和移动设备事件</h3><ul>
<li>功能强大的移动设备, 特别是带有触摸屏的移动设备被⼴泛采用, 要求创建新的事件类别</li>
<li>在许多情况下, 触屏事件映射到传统事件类型, 如单击和滚动。但并⾮所有触屏UI的交互都模仿鼠标, 也不是所有的触摸都可以被视为鼠标事件<ul>
<li>gesturestart, gestureend </li>
</ul>
</li>
</ul>
<h3 id="2-5-事件类型的使用"><a href="#2-5-事件类型的使用" class="headerlink" title="2.5 事件类型的使用"></a>2.5 事件类型的使用</h3><ul>
<li>问题: 事件是棘⼿的, 有跨浏览器的不兼容性方面的原因:<ul>
<li>模糊W3C事件规范</li>
<li>IE不符合网络标准</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="2-6-事件对象"><a href="#2-6-事件对象" class="headerlink" title="2.6 事件对象"></a>2.6 事件对象</h3><ul>
<li>有时候在事件处理函数内部, 您可能会看到一个固定指定名称的参数, 例如event, evt 或简单的 e。这被称为事件对象, 它被自动传递给事件处理函数, 以提供额外的功能和信息。事件对象具有以下属性/方法:</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141218046.png" alt="image-20221202141218046" style="zoom:80%;" /></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-comment">// an event handler function ...</span><br>&#125; <br></code></pre></td></tr></table></figure>
<h3 id="2-7-鼠标事件"><a href="#2-7-鼠标事件" class="headerlink" title="2.7 鼠标事件"></a>2.7 鼠标事件</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141346694.png" alt="image-20221202141346694" style="zoom:80%;" /></p>
<h2 id="3-事件处理模型"><a href="#3-事件处理模型" class="headerlink" title="3 事件处理模型"></a>3 事件处理模型</h2><h3 id="3-1-DOM-0"><a href="#3-1-DOM-0" class="headerlink" title="3.1 DOM 0"></a>3.1 DOM 0</h3><ul>
<li>此事件处理模型是由Netscape Navigator引入的, 到2005年仍然是跨浏览器最多的模型。有两种模型类型：<ul>
<li>内联模型: 事件处理程序作为元素的属性添加。</li>
<li>传统模型: 可以通过脚本添加/删除事件处理程序。与内联模型一样, 每个事件只能注册一个事件处理程序。通过将处理程序名称分配给元素对象的事件属性来添加事件。要删除事件处理程序, 只需将属性设置为null。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hey <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.example.com&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;triggerAlert(&#x27;Joe&#x27;); return false;&quot;</span>&gt;</span>Joe<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>!<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">triggerAlert</span>(<span class="hljs-params">name</span>) &#123;</span><br><span class="language-javascript">	<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hey &quot;</span> + name);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> triggerAlert = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">	<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hey Joe&quot;</span>);</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"><span class="hljs-comment">// Assign an event handler</span></span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">onclick</span> = triggerAlert;</span><br><span class="language-javascript"><span class="hljs-comment">// Assign another event handler</span></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = triggerAlert;</span><br><span class="language-javascript"><span class="hljs-comment">// Remove the event handler that was just assigned</span></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-literal">null</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="3-2-DOM-事件流"><a href="#3-2-DOM-事件流" class="headerlink" title="3.2 DOM 事件流"></a>3.2 DOM 事件流</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202141751120.png" alt="image-20221202141751120" style="zoom:80%;" /></p>
<h4 id="3-2-1-事件处理阶段"><a href="#3-2-1-事件处理阶段" class="headerlink" title="3.2.1 事件处理阶段"></a>3.2.1 事件处理阶段</h4><ul>
<li>在 DOM 兼容浏览器中, 事件流分为3个阶段：<ul>
<li>捕获阶段：事件从 Document 节点自上而下向目标节点传播的阶段</li>
<li>目标阶段：真正的目标节点正在处理事件的阶段</li>
<li>冒泡阶段：事件从目标节点自下而上向Document节点传播的阶段</li>
</ul>
</li>
<li>在现代浏览器中, 默认情况下, 所有事件处理程序都在冒泡阶段进行注册。</li>
</ul>
<h4 id="3-2-2-事件流"><a href="#3-2-2-事件流" class="headerlink" title="3.2.2 事件流"></a>3.2.2 事件流</h4><ul>
<li>每个事件都有一个目标节点, 可以通过事件访问该目标</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">onclick</span> = <span class="hljs-title function_">handler</span>(e);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-keyword">if</span>(!e) <span class="hljs-keyword">var</span> e = <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br>    <span class="hljs-comment">// e refers to the event</span><br>    <span class="hljs-comment">// see detail of event</span><br>    <span class="hljs-keyword">var</span> original = e.<span class="hljs-property">eventTarget</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>每个事件都起源于浏览器, 并传递给DOM</li>
<li>职责链模式</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202142426300.png" alt="image-20221202142426300" style="zoom:80%;" /></p>
<h4 id="3-2-3-DOM-2-中的方法"><a href="#3-2-3-DOM-2-中的方法" class="headerlink" title="3.2.3 DOM 2 中的方法"></a>3.2.3 DOM 2 中的方法</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202142518683.png" alt="image-20221202142518683" style="zoom:80%;" /></p>
<h4 id="3-2-4-浏览器兼容性"><a href="#3-2-4-浏览器兼容性" class="headerlink" title="3.2.4 浏览器兼容性"></a>3.2.4 浏览器兼容性</h4><ul>
<li>表中的数字指定了完全支持这些方法的第一个浏览器版本</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202142558788.png" alt="image-20221202142558788" style="zoom:80%;" /></p>
<h3 id="3-3-阻止默认行为"><a href="#3-3-阻止默认行为" class="headerlink" title="3.3 阻止默认行为"></a>3.3 阻止默认行为</h3><ul>
<li>停止事件的传播<ul>
<li><code>event.stopPropagation()</code></li>
<li><code>cancelBubble=true</code>(IE某些版本)</li>
</ul>
</li>
<li>禁止默认行为<ul>
<li><code>event.preventDefault()</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">video.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">stopPropagation</span>();<br>    video.<span class="hljs-title function_">play</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-4-重写3-1中使用的示例"><a href="#3-4-重写3-1中使用的示例" class="headerlink" title="3.4 重写3.1中使用的示例"></a>3.4 重写3.1中使用的示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> heyJoe = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">	<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hey Joe!&quot;</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-comment">// Add an event handler</span></span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&quot;click&quot;</span>, heyJoe, <span class="hljs-literal">true</span> ); <span class="hljs-comment">// capture phase</span></span><br><span class="language-javascript"><span class="hljs-comment">// Add another event handler</span></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&quot;load&quot;</span>, heyJoe, <span class="hljs-literal">false</span> ); <span class="hljs-comment">// bubbling phase</span></span><br><span class="language-javascript"><span class="hljs-comment">// Remove the event handler just added</span></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>( <span class="hljs-string">&quot;load&quot;</span>, heyJoe, <span class="hljs-literal">false</span> );</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="3-5-Microsoft-specific-模型"><a href="#3-5-Microsoft-specific-模型" class="headerlink" title="3.5 Microsoft-specific 模型"></a>3.5 Microsoft-specific 模型</h3><ul>
<li>微软直到Internet Explorer 8 才遵循 W3C 模型, 因为它自⼰的模型是在 W3C 标准批准之前创建的。Internet Explorer 9 遵循 DOM3 事件, Internet Explorer 11 删除了对微软特定模型的支持</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202143453557.png" alt="image-20221202143453557" style="zoom:80%;" /></p>
<h3 id="3-6-IE-曾经的特定操作"><a href="#3-6-IE-曾经的特定操作" class="headerlink" title="3.6 IE 曾经的特定操作"></a>3.6 IE 曾经的特定操作</h3><ul>
<li>为了防止事件冒泡, 开发人员必须设置事件的cancelBubble属性</li>
<li>为了防止事件的默认动作被调用, 开发人员必须设置事件的 returnValue 属性</li>
<li><p>避免使用 !!</p>
</li>
<li><p>跨浏览器的解决方式示例</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myBtn&quot;</span>);<br><span class="hljs-keyword">if</span> (x.<span class="hljs-property">addEventListener</span>) &#123;<br>	<span class="hljs-comment">// For all major browsers, except IE 8 and earlier</span><br>    x.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, myFunction);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.<span class="hljs-property">attachEvent</span>) &#123;<br>    <span class="hljs-comment">// For IE 8 and earlier versions</span><br>    x.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&quot;onclick&quot;</span>, myFunction);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-7-事件处理程序的绑定"><a href="#3-7-事件处理程序的绑定" class="headerlink" title="3.7 事件处理程序的绑定"></a>3.7 事件处理程序的绑定</h3><ul>
<li>内联:<ul>
<li><code>&lt;a href=&quot;somewhere.html&quot; onClick=&quot;myFunction()&quot;&gt;</code></li>
</ul>
</li>
<li>传统:<ul>
<li><code>element.onclick = myFunction;</code></li>
</ul>
</li>
<li>DOM 2:<ul>
<li><code>element.addEventListener(&quot;click&quot;, myFunction);</code></li>
</ul>
</li>
<li>IE: (evil enough!)<ul>
<li><code>element.attachEvent(&#39;onclick&#39;, myFunction);</code></li>
</ul>
</li>
<li>JQuery, Prototype and so on:<ul>
<li><code>jQuery.on()</code></li>
<li><code>Event.observe(&#39;target&#39;, &#39;click&#39;, myFunction);</code></li>
</ul>
</li>
</ul>
<h1 id="7-2-JS-作用域与闭包"><a href="#7-2-JS-作用域与闭包" class="headerlink" title="7.2 JS 作用域与闭包"></a>7.2 JS 作用域与闭包</h1><h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1 作用域"></a>1 作用域</h2><h3 id="1-1-JS-作用域"><a href="#1-1-JS-作用域" class="headerlink" title="1.1 JS 作用域"></a>1.1 JS 作用域</h3><ul>
<li>作用域是当前的执行上下文, 值(en-US)和表达式在其中”可见”或可被访问, 即作用域指的是有权访问的变量集合<ul>
<li>如果一个变量(en-US)或表达式不在当前的作用域中, 那么它是不可用的</li>
<li>作用域也可以堆叠成层次结构, 子作用域可以访问父作用域, 反过来则不行</li>
</ul>
</li>
<li>JavaScript 的作用域分以下三种：<ul>
<li>全局作用域：脚本模式运行所有代码的默认作用域</li>
<li>模块作用域：模块模式中运行代码的作用域</li>
<li>函数作用域：由函数创建的作用域</li>
</ul>
</li>
<li>此外, (ES6)用 let 或 const 声明的变量属于额外的作用域：<ul>
<li>块级作用域：用一对花括号(一个代码块)创建出来的作用域</li>
<li>块级作用域只对 <code>let</code> 和 <code>const</code> 声明有效，对 <code>var</code> 声明无效。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 1</span><br><br>&#123;<br>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// ReferenceError: x is not defined</span><br></code></pre></td></tr></table></figure>
<h3 id="1-2-JS-变量"><a href="#1-2-JS-变量" class="headerlink" title="1.2 JS 变量"></a>1.2 JS 变量</h3><ul>
<li>在 JavaScript 中, 对象和函数也是变量</li>
<li>作用域决定了从代码不同部分对变量、对象和函数的可访问性</li>
</ul>
<h4 id="1-2-1-全局变量"><a href="#1-2-1-全局变量" class="headerlink" title="1.2.1 全局变量"></a>1.2.1 全局变量</h4><ul>
<li>在函数之外声明的变量, 叫做全局变量, 因为它可被当前文档中的任何其他代码所访问</li>
<li>全局变量的作用域是全局的：网页的所有脚本和函数都能够访问它</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> carName = <span class="hljs-string">&quot; Volvo&quot;</span>;<br><span class="hljs-comment">// code here can use carName</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// code here can use carName</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1-2-2-自动全局"><a href="#1-2-2-自动全局" class="headerlink" title="1.2.2 自动全局"></a>1.2.2 自动全局</h4><ul>
<li>如果为尚未声明的变量赋值, 此变量会自动成为全局变量</li>
<li>这段代码将声明一个全局变量 carName, 即使在函数内进行了赋值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// code here can use carName</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>    carName = <span class="hljs-string">&quot;Volvo&quot;</span>;<br>    <span class="hljs-comment">// code here can use carName</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-3-函数作用域"><a href="#1-3-函数作用域" class="headerlink" title="1.3 函数作用域"></a>1.3 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions">函数</a>作用域</h3><ul>
<li>在函数内定义的变量不能在函数之外的任何地方访问, 因为变量仅仅在该函数的域的内部有定义</li>
<li>相对应的, 一个函数可以访问定义在其范围内的任何变量和函数。</li>
<li>换言之, 定义在全局域中的函数可以访问所有定义在全局域中的变量</li>
<li>在另一个函数中定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// code here can not use carName</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> carName = <span class="hljs-string">&quot;Volvo&quot;</span>;<br>    <span class="hljs-comment">// code here can use carName</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-4-JS-变量的有效期"><a href="#1-4-JS-变量的有效期" class="headerlink" title="1.4 JS 变量的有效期"></a>1.4 JS 变量的有效期</h3><ul>
<li>JavaScript 变量的有效期始于其被创建时</li>
<li>局部变量会在函数完成时被删除</li>
<li>全局变量会在关闭页面时被删除</li>
<li>函数参数<ul>
<li>函数参数也是函数内的局部变量</li>
</ul>
</li>
<li>HTML 中的全局变量<ul>
<li>通过JavaScript, 全局作用域形成了完整的 JavaScript 环境</li>
<li>在 HTML 中, 全局作用域是 window。所有全局变量均属于 window 对象。</li>
</ul>
</li>
</ul>
<h2 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2 闭包"></a>2 闭包</h2><h3 id="2-1-计数器困境"><a href="#2-1-计数器困境" class="headerlink" title="2.1 计数器困境"></a>2.1 计数器困境</h3><ul>
<li>假设想要使用一个变量来计算, 并且希望这个计数器对所有函数都可用</li>
<li>可以使用一个全局变量和一个函数来增加计数器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    counter += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>但是如果在函数内部声明了计数器, 没有人可以在不调用 add() 的情况下更改它:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br>    counter += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br><span class="hljs-comment">// the counter should now be 3, but it does not work !</span><br></code></pre></td></tr></table></figure>
<h3 id="2-2-JS-嵌套函数"><a href="#2-2-JS-嵌套函数" class="headerlink" title="2.2 JS 嵌套函数"></a>2.2 JS 嵌套函数</h3><ul>
<li>所有函数都可以访问全局作用域</li>
<li>事实上, 在JavaScript中, 所有函数都可以访问它们”上层”的作用域</li>
<li>JavaScript支持嵌套函数。嵌套函数可以访问它们”上层”的作用域</li>
<li>在这个例子中, 内部函数plus()可以访问父函数中的counter变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params"></span>) &#123;counter += <span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-title function_">plus</span>();   <br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-JS-闭包"><a href="#2-3-JS-闭包" class="headerlink" title="2.3 JS 闭包"></a>2.3 JS 闭包</h3><ul>
<li>给变量 add 分配一个自调用函数的返回值</li>
<li>自调用函数只运行一次。它将计数器设置为零(0), 并返回一个函数表达式</li>
<li>这样add就变成了一个函数。”奇妙的”部分是它可以访问父作用域中的计数器</li>
<li>这称为JavaScript闭包。它使函数具有”私有”变量成为可能</li>
<li>计数器受匿名函数作用域的保护, 只能使用add函数进行更改</li>
<li>闭包是可以访问父作用域的函数, 即使父函数已经关闭。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> add = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> counter += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;)();<br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br></code></pre></td></tr></table></figure>
<h3 id="2-4-闭包的定义"><a href="#2-4-闭包的定义" class="headerlink" title="2.4 闭包的定义"></a>2.4 闭包的定义</h3><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包(closure)</a>是一个函数以及其捆绑的周边环境状态(lexical environment, 词法环境)的引用的组合。换而言之, 闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中, 闭包会随着函数的创建而被同时创建</li>
<li>闭包是函数和执行它的作用域组成的综合体 ——《JavaScript权威指南》<ul>
<li>所有的函数都是闭包</li>
</ul>
</li>
<li>函数可以访问它被创建时的上下文环境, 称为闭包 ——《JavaScript语言精粹》<ul>
<li>内部函数比它的外部函数具有更长的生命周期</li>
</ul>
</li>
<li>更简单的定义: 闭包是引用了自由变量的函数<ul>
<li>自由变量是作用域可以导出到外部作用域的变量<ul>
<li>函数内部变量和函数参数都可以是自由变量</li>
<li>函数参数不包含 this 和 arguments</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-词法作用域"><a href="#2-5-词法作用域" class="headerlink" title="2.5 词法作用域"></a>2.5 词法作用域</h3><ul>
<li>词法(lexical)一词指的是, 词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部作用域的变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Mozilla&quot;</span>; <span class="hljs-comment">// name 是一个被 init 创建的局部变量</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">displayName</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// displayName() 是内部函数, 一个闭包</span><br>    	<span class="hljs-title function_">alert</span>(name); <span class="hljs-comment">// 使用了父函数中声明的变量</span><br>    &#125;<br>    <span class="hljs-title function_">displayName</span>();<br>&#125;<br><span class="hljs-title function_">init</span>();<br></code></pre></td></tr></table></figure>
<h3 id="2-6-闭包应用场景"><a href="#2-6-闭包应用场景" class="headerlink" title="2.6 闭包应用场景"></a>2.6 闭包应用场景</h3><ul>
<li>闭包很有用, 因为它允许将函数与其所操作的某些数据(环境)关联起来。这显然类似于面向对象编程。<ul>
<li>实现私有成员</li>
<li>保护命名空间</li>
<li>避免污染全局变量</li>
<li>变量需要长期驻留在内存</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(++i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">a</span>();<br><span class="hljs-title function_">c</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>用闭包模拟私有方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>) &#123;<br>    	privateCounter += val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>    	<span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    		<span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>);<br>    	&#125;,<br>    	<span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    		<span class="hljs-title function_">changeBy</span>(-<span class="hljs-number">1</span>);<br>    	&#125;,<br>    	<span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    		<span class="hljs-keyword">return</span> privateCounter;<br>    	&#125;<br>    &#125;<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">/* logs 0 */</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">/* logs 2 */</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">decrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">/* logs 1 */</span><br></code></pre></td></tr></table></figure>
<h2 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3 作用域链"></a>3 作用域链</h2><h3 id="3-1-作用域链"><a href="#3-1-作用域链" class="headerlink" title="3.1 作用域链"></a>3.1 作用域链</h3><ul>
<li>function 对象同其他对象一样, 拥有 可以编程访问的属性 和 一系列不能通过代码访问而仅供 js 引擎存取的内部属性, 其中一个是 <strong>[[scope]]</strong>, 包含了一个函数被创建的作用域中对象的集合。称为作用域链(Scope chain)。决定了那些数据可以被函数访问。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>    <span class="hljs-keyword">var</span> sum = num1 + num2;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125; <br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202152529413.png" alt="image-20221202152529413" style="zoom:80%;" /></p>
<h4 id="3-1-1-执行-add-函数"><a href="#3-1-1-执行-add-函数" class="headerlink" title="3.1.1 执行 add 函数"></a>3.1.1 执行 add 函数</h4><ul>
<li>执行环境和作用域链</li>
<li>绿色的称为活动对象</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202152636530.png" alt="image-20221202152636530" style="zoom:80%;" /></p>
<h3 id="3-2-例子"><a href="#3-2-例子" class="headerlink" title="3.2 例子"></a>3.2 例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> bd = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>,<br>    links = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;a&quot;</span>),<br>    i = <span class="hljs-number">0</span>,<br>    len = links.<span class="hljs-property">length</span>;<br><br>    <span class="hljs-keyword">while</span>(i &lt; len)&#123;<br>    	<span class="hljs-title function_">update</span>(links[i++]);<br>    &#125;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;go-btn&quot;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    	<span class="hljs-title function_">start</span>();<br>    &#125;;<br>    bd.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;active&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 改良, 全局对象和局部对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> doc = <span class="hljs-variable language_">document</span>,<br>    bd = doc.<span class="hljs-property">body</span>,<br>    links = doc.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;a&quot;</span>),<br>    i= <span class="hljs-number">0</span>,len = links.<span class="hljs-property">length</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-改变作用域链-with"><a href="#3-3-改变作用域链-with" class="headerlink" title="3.3 改变作用域链-with"></a>3.3 改变作用域链-with</h3><ul>
<li>不推荐使用with, 在 ECMAScript 5 严格模式中该标签已被禁止</li>
<li>推荐的替代方案是声明一个临时变量来承载你所需要的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initUI</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">with</span> (<span class="hljs-variable language_">document</span>)&#123; <span class="hljs-comment">//avoid!</span><br>        <span class="hljs-keyword">var</span> bd = body,<br>        links = <span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;a&quot;</span>),<br>        i= <span class="hljs-number">0</span>,<br>        len = links.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; len)&#123;<br>        	<span class="hljs-title function_">update</span>(links[i++]);<br>        &#125;<br>        <span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;go-btn&quot;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        	<span class="hljs-title function_">start</span>();<br>        &#125;;<br>        bd.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;active&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-3-1-改变作用域链-性能问题"><a href="#3-3-1-改变作用域链-性能问题" class="headerlink" title="3.3.1 改变作用域链-性能问题"></a>3.3.1 改变作用域链-性能问题</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202153709686.png" alt="image-20221202153709686" style="zoom:80%;" /></p>
<ul>
<li>顶层多了一个对象, 活动对象深了一层, 性能下降</li>
</ul>
<h3 id="3-4-try-catch"><a href="#3-4-try-catch" class="headerlink" title="3.4 try-catch"></a>3.4 try-catch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-title function_">methodThatMightCauseAnError</span>(); &#125;<br><span class="hljs-keyword">catch</span> (ex)&#123;<br>    <span class="hljs-comment">// 异常对象将添加到作用域链的首部</span><br>     <span class="hljs-title function_">alert</span>(ex.<span class="hljs-property">message</span>); <span class="hljs-comment">//scope chain is augmented here</span><br>&#125;<br><br><span class="hljs-comment">// 建议使用</span><br><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-title function_">methodThatMightCauseAnError</span>(); &#125;<br><span class="hljs-keyword">catch</span> (ex)&#123;<br>    <span class="hljs-comment">// 没有对局部变量的使用</span><br>     <span class="hljs-title function_">handleError</span>(ex); <span class="hljs-comment">//delegate to handler method</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-5-闭包、作用域和内存"><a href="#3-5-闭包、作用域和内存" class="headerlink" title="3.5 闭包、作用域和内存"></a>3.5 闭包、作用域和内存</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">assignEvents</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> id = <span class="hljs-string">&quot;xdi9592&quot;</span>;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;save-btn&quot;</span>)<br>            .<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>                <span class="hljs-title function_">saveDocument</span>(id);<br>            &#125;;<br>&#125; <br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202154313441.png" alt="image-20221202154313441" style="zoom:80%;" /></p>
<h4 id="3-5-1-闭包执行"><a href="#3-5-1-闭包执行" class="headerlink" title="3.5.1 闭包执行"></a>3.5.1 闭包执行</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221202154522893.png" alt="image-20221202154522893" style="zoom:80%;" /></p>
<h2 id="4-提升"><a href="#4-提升" class="headerlink" title="4 提升"></a>4 提升</h2><h3 id="4-1-提升-Hosting"><a href="#4-1-提升-Hosting" class="headerlink" title="4.1 提升(Hosting)"></a>4.1 提升(Hosting)</h3><ul>
<li>引擎会在解释JavaScript代码之前首先进行编译，编译过程中的⼀部分⼯作就是<strong>找到所有的声明</strong>，并用合适的作用域将他们关联起来，这也正是词法作用域的核心内容。</li>
<li>JavaScript 变量的另⼀个不同寻常的地方是，你可以先使用变量稍后再声明变量而不会引发异常。这⼀概念称为<strong>变量提升</strong>；JavaScript 变量感觉上是被”提升”或移到了函数或语句的最前面。</li>
<li>但是，提升后的变量将返回 <code>undefined</code> 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 <code>undefined</code> 值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 例子 1*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/* 例子 2*/</span><br><span class="hljs-comment">// will return a value of undefined</span><br><span class="hljs-keyword">var</span> myvar = <span class="hljs-string">&quot;my value&quot;</span>;<br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myvar); <span class="hljs-comment">// undefined</span><br>	<span class="hljs-keyword">var</span> myvar = <span class="hljs-string">&quot;local value&quot;</span>;<br>&#125;)();<br><br><br><span class="hljs-comment">/* 例子 1*/</span><br><span class="hljs-keyword">var</span> x;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br>x = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/* 例子 2*/</span><br><span class="hljs-keyword">var</span> myvar = <span class="hljs-string">&quot;my value&quot;</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">var</span> myvar;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myvar); <span class="hljs-comment">// undefined</span><br>	myvar = <span class="hljs-string">&quot;local value&quot;</span>;<br>&#125;)();<br></code></pre></td></tr></table></figure>
<ul>
<li>由于存在变量提升，⼀个函数中所有的var语句应尽可能地放在接近函数顶部的地方。这个习惯将大大提升代码的清晰度。</li>
</ul>
<h3 id="4-2-let-const"><a href="#4-2-let-const" class="headerlink" title="4.2 let const"></a>4.2 let const</h3><ul>
<li>ES6新增块级作用域。这个区块对这些变量从⼀开始就形成了封闭作用域，直到声明语句完成，这些变量才能被访问(获取或设置)，否则会报错ReferenceError</li>
<li>暂时性死区(temporal dead zone，简 TDZ)，即代码块开始到变量声明语句完成之间的区域</li>
<li>通过 let 声明的变量<strong>没有变量提升</strong>、<strong>拥有暂时性死区</strong>，作用于<strong>块级作用域</strong>：<ul>
<li>当进入变量的作用域(包围它的语法块)，立即为它创建(绑定)存储空间，不会立即初始化，也不会被赋值</li>
<li>访问(获取或设置)该变量会抛出异常 ReferenceError</li>
<li>当执行到变量的声明语句时，如果变量定义了值则会被赋值，如果变量没有定义值，则被赋值为undefined</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <span class="hljs-comment">// TDZ starts at beginning of scope</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// undefined</span><br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// ReferenceError</span><br>	<span class="hljs-keyword">var</span> bar = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">let</span> foo = <span class="hljs-number">2</span>; <span class="hljs-comment">// End of TDZ (for foo)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-temporal"><a href="#4-3-temporal" class="headerlink" title="4.3 temporal"></a>4.3 temporal</h3><ul>
<li>使用术语”temporal”是因为区域取决于执行顺序(时间)，而不是编写代码的顺序(位置)。例如，下面的代码会生效，是因为即使使用 let 变量的函数出现在变量声明之前，但函数的执行是在暂时性死区的外面 </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>	<span class="hljs-comment">// TDZ starts at beginning of scope</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(letVar); <span class="hljs-comment">// OK</span><br>	<span class="hljs-comment">// Within the TDZ letVar access throws `ReferenceError`</span><br>	<span class="hljs-keyword">let</span> letVar = <span class="hljs-number">3</span>; <span class="hljs-comment">// End of TDZ (for letVar)</span><br>	<span class="hljs-title function_">func</span>(); <span class="hljs-comment">// Called outside TDZ!</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-4-函数提升"><a href="#4-4-函数提升" class="headerlink" title="4.4 函数提升"></a>4.4 函数提升</h3><ul>
<li>对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 函数声明 */</span><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &quot;bar&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 函数表达式 */</span><br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// 类型错误：baz 不是⼀个函数</span><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar2&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>函数会提升 class关键字不会提升</p>
</blockquote>
<h3 id="4-5-举例"><a href="#4-5-举例" class="headerlink" title="4.5 举例"></a>4.5 举例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br><span class="hljs-keyword">var</span> object = &#123;<br>    name : <span class="hljs-string">&quot;My Object&quot;</span>,<br>    getNameFunc : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>        &#125;;<br>    &#125;<br>&#125;;<br><span class="hljs-title function_">alert</span>(object.<span class="hljs-title function_">getNameFunc</span>()());  <span class="hljs-comment">// The Window</span><br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br><span class="hljs-keyword">var</span> object = &#123;<br>	name : <span class="hljs-string">&quot;My Object&quot;</span>,<br>    getNameFunc : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        	<span class="hljs-keyword">return</span> that.<span class="hljs-property">name</span>;<br>        &#125;;<br>    &#125;<br>&#125;;<br><span class="hljs-title function_">alert</span>(object.<span class="hljs-title function_">getNameFunc</span>()());   <span class="hljs-comment">// My Object</span><br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/25/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-4-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/25/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-4-JavaScript/" class="post-title-link" itemprop="url">Web前端开发(4) JavaScript、DOM、BOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-25 14:02:17" itemprop="dateCreated datePublished" datetime="2022-11-25T14:02:17+08:00">2022-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="6-1-JS-Basics"><a href="#6-1-JS-Basics" class="headerlink" title="6.1 JS Basics"></a>6.1 JS Basics</h1><h2 id="1-客户端基础"><a href="#1-客户端基础" class="headerlink" title="1 客户端基础"></a>1 客户端基础</h2><h3 id="1-1-客户端脚本"><a href="#1-1-客户端脚本" class="headerlink" title="1.1 客户端脚本"></a>1.1 客户端脚本</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221125151322702.png" alt="image-20221125151322702" style="zoom:80%;" /></p>
<h3 id="1-2-客户端编程"><a href="#1-2-客户端编程" class="headerlink" title="1.2 客户端编程"></a>1.2 客户端编程</h3><ul>
<li>HTML适合于开发静态页面<ul>
<li>可以指定文本/图像布局, 链接…</li>
<li>Web页面每次访问时看起来都是一样的</li>
<li>为了开发交互/响应式页面, 必须以某种形式集成编程</li>
</ul>
</li>
<li>客户端编程<ul>
<li>程序是用单独的编程(或脚本)语言编写的<ul>
<li>例如, JavaScript, JScript, VBScript</li>
</ul>
</li>
<li>程序被嵌入到Web页面的HTML中, 使用(HTML)标记来标识程序组件<ul>
<li>例如, <code>&lt;script type=&quot;text/javascript&quot;&gt; ... &lt;/script&gt;</code></li>
</ul>
</li>
<li>浏览器在加载页面时执行程序, 将程序的动态输出与HTML的静态内容集成在一起</li>
<li>还允许用户(客户端)输入信息并对其进行处理, 可在将输入提交到远程服务器之前对其进行验证</li>
</ul>
</li>
</ul>
<h3 id="1-3-客户端与服务器端编程"><a href="#1-3-客户端与服务器端编程" class="headerlink" title="1.3 客户端与服务器端编程"></a>1.3 客户端与服务器端编程</h3><ul>
<li>客户端脚本(JavaScript)的好处:<ul>
<li>可用性: 可以修改页面而不必返回到服务器(更快的UI)</li>
<li>效率: 可以在不等待服务器的情况下对页面进行小而快速的更改</li>
<li>事件驱动: 可以响应用户操作, 如点击和按键源代码</li>
<li>平台独立性: 任何支持脚本的浏览器都可以解释代码</li>
</ul>
</li>
<li>服务器端编程(例如PHP)的好处:<ul>
<li>安全性: 可以访问服务器的私有数据;客户端看不到</li>
<li>兼容性: 不受浏览器兼容性问题的影响</li>
<li>功能全: 可以写文件, 打开与服务器的连接, 连接数据库…</li>
</ul>
</li>
</ul>
<h3 id="1-4-常见脚本任务"><a href="#1-4-常见脚本任务" class="headerlink" title="1.4 常见脚本任务"></a>1.4 常见脚本任务</h3><ul>
<li>向Web页面添加动态特性<ul>
<li>表单数据的验证(可能是最常用的应用程序)</li>
<li>图像翻转</li>
<li>时间敏感或随机页面元素</li>
<li>处理cookies</li>
</ul>
</li>
<li>定义Web接⼝<ul>
<li>利用按钮, 文本框, 可点击的图像, 提示等</li>
</ul>
</li>
<li>客户端脚本的限制<ul>
<li>因为脚本代码嵌入在页面中, 所以它对外界是可见的</li>
<li>出于安全原因, 脚本所能做的事情是有限的<ul>
<li>例如, 无法访问客户端的硬盘驱动器</li>
</ul>
</li>
<li>因为它们被设计为在任何机器平台上运行, 所以脚本不包含特定于平台的命令</li>
<li>脚本语言功能不全<ul>
<li>例如, JavaScript对象非常粗糙, 不适合大型项目开发</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-JavaScript概述"><a href="#2-JavaScript概述" class="headerlink" title="2 JavaScript概述"></a>2 JavaScript概述</h2><h3 id="2-1-何为JavaScript"><a href="#2-1-何为JavaScript" class="headerlink" title="2.1 何为JavaScript"></a>2.1 何为JavaScript</h3><ul>
<li>从”玩具”到流行<ul>
<li>网页, AJAX, Web 2.0／3.0</li>
<li>大量web应用</li>
<li>APP</li>
<li>控制硬件, Arduino, Tessel, Espruino, NodeBots等, 应用于嵌入式系统、IOT、机器人等领域</li>
<li>桌面程序(Electron), SpaceX 龙飞船的触控 UI 基于 Chromium + JavaScript 技术栈开发, 开放的 Web 技术就此成为了人类首个应用到载人航天领域的 GUI 技术栈</li>
<li>服务端</li>
<li>命令行⼯具</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Always bet on JS</strong></p>
<ul>
<li>Brendan Eich 在 2011 年一次名为「JSLOL」[Eich 2011e] 的会议演讲中, 是这么描述 JavaScript 的：<ul>
<li>最早他们说 JavaScript 没法做「富互联网应用」。</li>
<li>然后他们说 JavaScript 没法快起来。</li>
<li>然后他们说 JavaScript 没法修复语言问题。</li>
<li>然后他们说 JavaScript 没法做多核与 GPU 运算。</li>
<li>他们每次都错了！我建议：永远押宝在 JS。</li>
</ul>
</li>
</ul>
<p><strong>阿特伍德定律</strong></p>
<ul>
<li>Atwood’s Law是Jeff Atwood在2007年提出的<ul>
<li>“any application that can be written in JavaScript, will eventually be written in JavaScript.”</li>
<li>任何可以用JavaScript来写的应用, 最终都将用JavaScript来写</li>
</ul>
</li>
</ul>
<p><strong>发展史</strong></p>
<ul>
<li>由Netscape的Brendan Eich 开发</li>
<li>JScript , Microsoft</li>
<li>European Computer Manufacturers Association (ECMA)标准化<ul>
<li><a target="_blank" rel="noopener" href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">http://www.ecma-international.org/publications/standards/Ecma-262.htm</a></li>
</ul>
</li>
<li>ECMAScript 2015</li>
<li>ECMAScript 2016</li>
</ul>
</blockquote>
<h3 id="2-2-JS的优势"><a href="#2-2-JS的优势" class="headerlink" title="2.2 JS的优势"></a>2.2 JS的优势</h3><ul>
<li>性能<ul>
<li>JIT</li>
<li>垃圾收集和动态绑定的开销</li>
</ul>
</li>
<li>对象<ul>
<li>JavaScript使用原型继承模型</li>
</ul>
</li>
<li>语法<ul>
<li>对于任何有 C 家族语言使用经验的人来说很熟悉, 比如c++、Java、c# 和 PHP</li>
</ul>
</li>
<li>一等函数<ul>
<li>JavaScript中的几乎所有东西都是对象, 包括函数。</li>
</ul>
</li>
<li>事件<ul>
<li>在浏览器内部, 一切都在一个事件循环中运行</li>
</ul>
</li>
<li>可重用性<ul>
<li>最可移植、可重用的代码</li>
<li>JavaScript可以模块化和封装</li>
</ul>
</li>
</ul>
<h3 id="2-3-JS概述"><a href="#2-3-JS概述" class="headerlink" title="2.3 JS概述"></a>2.3 JS概述</h3><ul>
<li>JavaScript 是一种脚本语言</li>
<li>JavaScript 程序由 JavaScript 解释器/引擎计算和执行<ul>
<li>Rhino, SpiderMonkey, V8, Squirrelfish</li>
</ul>
</li>
<li>主流用途和用法:<ul>
<li>在运行时公开应用程序的对象, 用于定制/嵌入用户逻辑。</li>
<li>改进网站的用户界面</li>
<li>让你的网站更容易浏览</li>
<li>在不重新加载页面的情况下替换页面上的图像</li>
<li>表单验证</li>
<li>页面修饰和特效</li>
<li>动态内容操作</li>
<li>新兴的Web 2.0:客户端功能在客户端实现</li>
<li>还有很多…</li>
</ul>
</li>
</ul>
<h3 id="2-4-JavaScript-vs-Java"><a href="#2-4-JavaScript-vs-Java" class="headerlink" title="2.4 JavaScript vs. Java"></a>2.4 JavaScript vs. Java</h3><ul>
<li>解释的, 不是编译的</li>
<li>更宽松的语法和规则<ul>
<li>更少、更”松散”的数据类型</li>
<li>变量不需要声明 </li>
<li>错误通常是无声的(少数例外)</li>
</ul>
</li>
<li>关键结构是函数而不是类<ul>
<li>“一等”函数</li>
</ul>
</li>
<li>包含在网页中, 并与其HTML/CSS内容集成</li>
</ul>
<h3 id="2-5-使用-lt-script-gt"><a href="#2-5-使用-lt-script-gt" class="headerlink" title="2.5 使用&lt;script&gt;"></a>2.5 使用<code>&lt;script&gt;</code></h3><ul>
<li><p>为网页嵌入脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>	script commands and comments<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>访问外部的脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><br>	script commands and comments<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-JavaScript基本语法"><a href="#3-JavaScript基本语法" class="headerlink" title="3 JavaScript基本语法"></a>3 JavaScript基本语法</h2><h3 id="3-1-语言基础"><a href="#3-1-语言基础" class="headerlink" title="3.1 语言基础"></a>3.1 语言基础</h3><ul>
<li>JavaScript大小写敏感<ul>
<li>HTML 大小写不敏感; onClick, ONCLICK, … are HTML</li>
</ul>
</li>
<li>以回车或分号(;)结束的语句<ul>
<li><code>x = x + 1;</code> same as <code>x = x + 1</code></li>
<li>分号减少错误</li>
</ul>
</li>
<li><p>JavaScript 代码块</p>
<ul>
<li>JavaScript 语句通过代码块的形式进行组合</li>
<li>块由左花括号开始, 由右花括号结束</li>
<li>块的作用是使语句序列一起执行</li>
</ul>
</li>
<li><p>注释: 与Java的注释语法相同</p>
</li>
<li><p>if/else 条件语句</p>
<ul>
<li>结构与Java的if/else语句相同</li>
<li>JavaScript几乎允许任何东西作为条件</li>
</ul>
</li>
<li><p>for循环</p>
<ul>
<li>for、for-in、for-of</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x;<br><span class="hljs-keyword">var</span> txt=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">var</span> person=&#123;<span class="hljs-attr">fname</span>:<span class="hljs-string">&quot;Bill&quot;</span>,<span class="hljs-attr">lname</span>:<span class="hljs-string">&quot;Gates&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">56</span>&#125;;<br><span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> person) &#123;<br>     txt = txt + person[x];<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>while, do/while</p>
<ul>
<li>同Java</li>
<li>break 和 continue 关键字也和 Java 中的一样</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">cars=[<span class="hljs-string">&quot;BMW&quot;</span>,<span class="hljs-string">&quot;Volvo&quot;</span>,<span class="hljs-string">&quot;Saab&quot;</span>,<span class="hljs-string">&quot;Ford&quot;</span>];<br><span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cars[i])&#123;<br>     <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(cars[i] + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);<br>     i++;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-对象"><a href="#3-2-对象" class="headerlink" title="3.2 对象"></a>3.2 对象</h3><ul>
<li>对象是命名属性的集合<ul>
<li>简单视图: 哈希表或关联数组</li>
<li>可以通过一组 <code>名称:值</code> 对进行定义<ul>
<li><code>objBob = &#123;name: &quot;Bob&quot;, grade: &#39;A&#39;, level: 3&#125;;</code></li>
</ul>
</li>
<li>新成员可以随时添加<ul>
<li><code>objBob.fullname = &#39;Robert&#39;;</code></li>
</ul>
</li>
<li>可以有方法</li>
</ul>
</li>
<li>数组、函数也是对象<ul>
<li>对象的属性可以是函数(=方法)</li>
</ul>
</li>
</ul>
<h3 id="3-3-变量与类型"><a href="#3-3-变量与类型" class="headerlink" title="3.3 变量与类型"></a>3.3 变量与类型</h3><ul>
<li>变量<ul>
<li><code>var, let, const(case sensitive)</code></li>
<li>Define implicitly by its first use, which must be an assignment<ul>
<li>Implicit definition has global scope, even if it occurs in nested scope? </li>
</ul>
</li>
</ul>
</li>
<li>类型没有指定, 但JS确实有类型(“loosely typed”)<ul>
<li><code>Number, Boolean, String, Array, Object, Function, Null, Undefined</code></li>
<li>can find out a variable’s type by calling <code>typeof</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Gates&quot;</span>, age = <span class="hljs-number">60</span>, job = <span class="hljs-string">&quot;CEO&quot;</span>;<br><span class="hljs-keyword">var</span> carname = <span class="hljs-string">&quot;Benz&quot;</span>;<br><span class="hljs-keyword">var</span> carname;<br></code></pre></td></tr></table></figure>
<h3 id="3-4-数值"><a href="#3-4-数值" class="headerlink" title="3.4 数值"></a>3.4 数值</h3><ul>
<li>数值在内部是通过双精度浮点型的形式表示的 (没有 int vs. double)</li>
<li>同样的运算符:<code>+ - * / % ++ --</code> etc</li>
<li>优先级相似java</li>
<li>许多运算符自动转换类型<ul>
<li><code>&quot;2&quot; * 3</code> is <code>6</code></li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129170410768.png" alt="image-20221129170410768" style="zoom:80%;" /></p>
<h3 id="3-5-IEEE-754"><a href="#3-5-IEEE-754" class="headerlink" title="3.5 IEEE 754"></a>3.5 IEEE 754</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://0.30000000000000004.com/#ada">https://0.30000000000000004.com/#ada</a></p>
</li>
<li><p>EcmaScript的安全整数</p>
<ul>
<li>Number.MAX_SAFE_INTEGER, 9007199254740991</li>
<li>最大安全整数和最小安全整数之间的整数统称为安全整数</li>
<li>54位有符号整数类型</li>
<li>只有在所有的运算因子、运算结果以及中间结果都是安全整数的情况下, 才能精确的整数计算, 才适用于加法结合律和乘法分配律, 一旦有一项的值不是安全整数, 变不可控。</li>
</ul>
</li>
<li><p>JS仅有number这个数值类型, 而number采用IEEE 754 64位双精度浮点数编码。而浮点数表示方式具有以下特点：</p>
<ul>
<li>浮点数可表示的值范围比同等位数的整数表示方式的值范围要大得多</li>
<li>浮点数无法精确表示其值范围内的所有数值, 而有符号和无符号整数则是精确表示其值范围内的 每个数值</li>
<li>浮点数只能精确表示 m * $2^e$的数值</li>
<li>当 biased-exponent 为 $2^{e-1}$ - 1 时, 浮点数能精确表示该范围内的各整数值</li>
<li>当 biased-exponent 不为 $2^{e-1}$ - 1时 , 浮点数不能精确表示该范围内的各整数值</li>
</ul>
</li>
<li><p>由于部分数值无法精确表示(存储), 于是在运算统计后偏差会愈见明显。</p>
</li>
<li><p>通常推荐先将数字转换成整数。</p>
</li>
<li><p>比较两个浮点数差值的绝对值, 是否超过误差精度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compareTwo</span>(<span class="hljs-params">n1,n2</span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>( n1 - n2 ) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;<br>&#125;<br><span class="hljs-title function_">compareTwo</span>(<span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-6-String"><a href="#3-6-String" class="headerlink" title="3.6 String"></a>3.6 String</h3><ul>
<li><p>方法: <code>charAt, charCodeAt, fromCharCode, indexOf, lastIndexOf, replace, split, substring, toLowerCase, toUpperCase</code></p>
<ul>
<li><code>charAt</code> returns a one-letter String (there is no char type)</li>
</ul>
</li>
<li><p>length 属性 (非Java中的方法)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> txt = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(txt.<span class="hljs-property">length</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>&quot;&quot;</code> 或 <code>&#39;&#39;</code></p>
</li>
<li><p>连接 <code>+</code></p>
<ul>
<li><code>1 + 1</code> is 2, <code>&quot;1&quot; + 1</code> is “11”</li>
</ul>
</li>
<li><p>转义, 与Java中的相同: <code>\&#39; \&quot; \&amp; \n \t \\</code> </p>
</li>
<li><p>在数值和字符串之间转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&quot;&quot;</span> + x; <span class="hljs-comment">//&quot;30&quot;</span><br><span class="hljs-keyword">var</span> n1 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10 oranges&quot;</span>); <span class="hljs-comment">//10</span><br><span class="hljs-keyword">var</span> n2 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//NaN</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>访问字符串的字符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> firstLetter = s[<span class="hljs-number">0</span>]; <span class="hljs-comment">//fails in IE</span><br><span class="hljs-keyword">var</span> firstLetter = s.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">var</span> lastLetter = s.<span class="hljs-title function_">charAt</span>(s.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串拼接变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// old</span><br><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;The user &quot;</span>+ user.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + user.<span class="hljs-property">lastName</span> +<br><span class="hljs-string">&quot; cannot be &quot;</span>+ action + <span class="hljs-string">&quot;because &quot;</span> + validationError;<br><span class="hljs-comment">// new</span><br><span class="hljs-keyword">var</span> message = <span class="hljs-string">`The user <span class="hljs-subst">$&#123;user.firstName&#125;</span> <span class="hljs-subst">$&#123;user.lastName&#125;</span> cannot be</span><br><span class="hljs-string"> <span class="hljs-subst">$&#123;action&#125;</span> because <span class="hljs-subst">$&#123;validationError&#125;</span>`</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-7-布尔式犯蠢类型"><a href="#3-7-布尔式犯蠢类型" class="headerlink" title="3.7 布尔式犯蠢类型"></a>3.7 布尔式犯蠢类型</h3><ul>
<li><p>任何值都可以用作布尔值</p>
<ul>
<li>false: 0, -0, 0.0, NaN, “”, null, undefined</li>
<li>true: anything else</li>
</ul>
</li>
<li><p>将值显式转换为布尔值</p>
<ul>
<li><code>var boolValue = Boolean(otherValue);</code></li>
<li><code>var boolValue = !!(otherValue);</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(o !== <span class="hljs-literal">null</span>) ...<br>!!<span class="hljs-string">&quot;&quot;</span> -&gt; <span class="hljs-literal">false</span><br>!![] -&gt; <span class="hljs-literal">true</span><br>+!![] -&gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="3-8-null-NaN-undefined"><a href="#3-8-null-NaN-undefined" class="headerlink" title="3.8 null, NaN, undefined"></a>3.8 null, NaN, undefined</h3><ul>
<li>NaN<ul>
<li>isNaN()</li>
<li>typeof(NaN) -&gt; number</li>
<li>比如字符串转换成数值失败时</li>
<li>与所有的值都不相等。包括它自己</li>
</ul>
</li>
<li>undefined</li>
<li>null<ul>
<li>typeof(null) —&gt; object</li>
</ul>
</li>
<li>(-)Infinity：大到无法表示的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1000</span> / <span class="hljs-number">0</span>;  <span class="hljs-comment">// number</span><br><span class="hljs-built_in">isNaN</span>(x);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<h3 id="3-9"><a href="#3-9" class="headerlink" title="3.9 ==="></a>3.9 <code>===</code></h3><ul>
<li>平常业务中比较建议尽量不要使用 <code>==</code> 和 <code>!=</code>。这两个比较的时候会做一些强制的类型转换, 所以比较结果很可能有误。务必使用 <code>=== 和 !==</code>。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129174208384.png" alt="image-20221129174208384" style="zoom:80%;" /></p>
<blockquote>
<p>undifined == null  -&gt; true</p>
</blockquote>
<h3 id="3-10-Math对象"><a href="#3-10-Math对象" class="headerlink" title="3.10 Math对象"></a>3.10 Math对象</h3><ul>
<li>methods: abs, ceil, cos, floor, log, max, min, pow, random, round, sin, sqrt, tan</li>
<li>properties: E, PI</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> pi_value = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>;<br><span class="hljs-keyword">var</span> sqrt_value = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure>
<h3 id="3-11-逻辑运算符"><a href="#3-11-逻辑运算符" class="headerlink" title="3.11 逻辑运算符"></a>3.11 逻辑运算符</h3><ul>
<li><p><code>&gt; &lt; &gt;= &lt;= &amp;&amp; || ! == != === !==</code></p>
</li>
<li><p>大多数逻辑运算符自动转换类型</p>
<ul>
<li>5 &lt; “7” 为true</li>
<li>42 == 42.0 为 true</li>
<li>“5.0” == 5 为 true</li>
</ul>
</li>
<li><p><code>===</code> 与 <code>!==</code>是严格的相等检查, 同时比较类型和值</p>
<ul>
<li>“5.0” === 5 is false</li>
</ul>
</li>
</ul>
<h3 id="3-12-数组"><a href="#3-12-数组" class="headerlink" title="3.12 数组"></a>3.12 数组</h3><ul>
<li>两种方法初始化数组</li>
<li>长度属性(在添加元素时根据需要增长)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> empty = [];<br><span class="hljs-keyword">var</span> mycars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br>mycars[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Saab&quot;</span><br>mycars[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Volvo&quot;</span><br>mycars[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;BMW&quot;</span><br><span class="hljs-keyword">var</span> misc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1.1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;BMW&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="3-13-Array方法"><a href="#3-13-Array方法" class="headerlink" title="3.13 Array方法"></a>3.13 Array方法</h3><ul>
<li>数组可以实现多种数据结构: list, queue, stack, …</li>
<li>方法: concat, join, pop, push, reverse, shift, slice, sort, splice, toString, unshift<ul>
<li>push and pop add / remove from back</li>
<li>unshift and shift add / remove from front</li>
<li>shift and pop return the element that is removed</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>];<br>fruits.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Apple&quot;</span>);<br>fruits.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&quot;Mango&quot;</span>);<br>fruits.<span class="hljs-title function_">pop</span>();<br>fruits.<span class="hljs-title function_">shift</span>();<br>fruits.<span class="hljs-title function_">sort</span>();<br><span class="hljs-title function_">alert</span>(fruits);<br></code></pre></td></tr></table></figure>
<h3 id="3-14-函数"><a href="#3-14-函数" class="headerlink" title="3.14 函数"></a>3.14 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">parameters</span>) &#123;<br>	<span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>声明可以出现在函数体中</p>
<ul>
<li>Local variables, “inner” functions</li>
<li>=&gt;<ul>
<li><code>(arg1, arg2) =&gt; &#123;//something here&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>匿名函数</p>
<ul>
<li><code>(function (x,y) &#123;return x+y&#125;) (2,3);</code></li>
</ul>
</li>
</ul>
<h3 id="3-15-参数"><a href="#3-15-参数" class="headerlink" title="3.15 参数"></a>3.15 参数</h3><ul>
<li><p>参数传递</p>
<ul>
<li>基本类型按值传递, 对象按引用传递</li>
</ul>
</li>
<li><p>调用可以提供任意数量的实参</p>
<ul>
<li>functionname.length : # of arguments in definition</li>
<li>functionname.arguments.length : # args in call</li>
</ul>
</li>
</ul>
<h1 id="6-2-JS-DOM、BOM"><a href="#6-2-JS-DOM、BOM" class="headerlink" title="6.2 JS DOM、BOM"></a>6.2 JS DOM、BOM</h1><h2 id="1-DOM"><a href="#1-DOM" class="headerlink" title="1 DOM"></a>1 DOM</h2><ul>
<li>当一个网页被加载时, 浏览器会创建一个页面的文档对象模型 (Document Object Model, DOM)</li>
<li>HTML DOM 模型被构造成一个对象树</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130222429027.png" alt="image-20221130222429027" style="zoom:80%;" /></p>
<h3 id="1-1-功能"><a href="#1-1-功能" class="headerlink" title="1.1 功能"></a>1.1 功能</h3><ul>
<li>通过对象模型, JS获得了创建动态 HTML 所需的所有功能<ul>
<li>JavaScript可以更改页面中的所有HTML元素</li>
<li>JavaScript可以更改页面中的所有HTML属性</li>
<li>JavaScript可以更改页面中的所有CSS样式</li>
<li>JavaScript可以删除现有的HTML元素和属性</li>
<li>JavaScript可以添加新的HTML元素和属性</li>
<li>JavaScript可以对页面中所有现有的HTML事件做出反应</li>
<li>JavaScript可以在页面中创建新的HTML事件</li>
</ul>
</li>
</ul>
<h3 id="1-2-DOM是什么"><a href="#1-2-DOM是什么" class="headerlink" title="1.2 DOM是什么"></a>1.2 DOM是什么</h3><ul>
<li>DOM是W3C(万维网联盟)标准</li>
<li>DOM定义了⼀个访问文档的标准:<ul>
<li>W3C文档对象模型(DOM)是⼀个平台和语言无关的接口, 它允许程序和脚本动态访问和更新文档的内容、结构和样式</li>
</ul>
</li>
<li>W3C DOM标准分为3个不同的部分:<ul>
<li>核心DOM——所有文档类型的标准模型</li>
<li>XML DOM——XML文档的标准模型</li>
<li>HTML DOM——HTML文档的标准模型</li>
</ul>
</li>
</ul>
<h3 id="1-3-HTML-DOM"><a href="#1-3-HTML-DOM" class="headerlink" title="1.3 HTML DOM"></a>1.3 HTML DOM</h3><ul>
<li>HTML DOM 是 HTML 的标准对象模型和编程接口。它定义了:<ul>
<li>HTML 元素作为对象</li>
<li>所有 HTML 元素的属性</li>
<li>访问所有 HTML 元素的方法</li>
<li>所有 HTML 元素的事件</li>
</ul>
</li>
<li>换句话说: HTML DOM 是获取、更改、添加或删除 HTML 元素的标准</li>
</ul>
<h3 id="1-4-DOM-编程接口"><a href="#1-4-DOM-编程接口" class="headerlink" title="1.4 DOM 编程接口"></a>1.4 DOM 编程接口</h3><ul>
<li>可以使用 JS(以及其他编程语言)访问 HTML DOM</li>
<li>在 DOM 中, 所有 HTML 元素都定义为对象</li>
<li>编程接口是每个对象的属性和方法</li>
<li>属性是可以获取或设置的值(如更改 HTML 元素的内容)</li>
<li>方法是可以执行的操作(如添加或删除 HTML 元素)</li>
</ul>
<h3 id="1-5-DOM-元素"><a href="#1-5-DOM-元素" class="headerlink" title="1.5 DOM 元素"></a>1.5 DOM 元素</h3><ul>
<li>页面上的每个元素都有一个对应的 DOM 对象</li>
<li>使用 <code>objectName.attributeName</code> 访问/修改 DOM 对象的属性</li>
<li>事实上, 浏览器在运行时将 Web 页面计算为相应的 DOM 对象</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;Hello World!&quot;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="1-6-查找-HTML-元素"><a href="#1-6-查找-HTML-元素" class="headerlink" title="1.6 查找 HTML 元素"></a>1.6 查找 HTML 元素</h3><ul>
<li>通过 id 查找<ul>
<li><code>var myElement = document.getElementById(&quot;intro&quot;);</code></li>
</ul>
</li>
<li>通过 标记名 查找<ul>
<li><code>var x = document.getElementsByTagName(&quot;p&quot;)</code></li>
</ul>
</li>
<li>通过 类名 查找<ul>
<li><code>var x = document.getElementsByClassName(&quot;intro&quot;);</code></li>
</ul>
</li>
<li>通过 CSS选择器 查找<ul>
<li><code>var x = document.querySelectorAll(&quot;p.intro&quot;);</code></li>
</ul>
</li>
<li>通过 HTML对象集合 查找<ul>
<li><code>var x = document.forms[&quot;frm1&quot;];</code></li>
</ul>
</li>
</ul>
<h3 id="1-7-JS-HTML-DOM-导航"><a href="#1-7-JS-HTML-DOM-导航" class="headerlink" title="1.7 JS HTML DOM 导航"></a>1.7 JS HTML DOM 导航</h3><ul>
<li>页面的元素嵌套在对象的树状结构中——DOM树<ul>
<li>DOM 具有遍历该树的属性和方法</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130222429027.png" alt="image-20221130222429027" style="zoom:80%;" /></p>
<h4 id="1-7-1-DOM-节点类型"><a href="#1-7-1-DOM-节点类型" class="headerlink" title="1.7.1 DOM 节点类型"></a>1.7.1 DOM 节点类型</h4><ul>
<li>每个节点都有 nodeType(节点类型)、nodeName(节点名称)、nodeValue(节点值) 属性</li>
<li>HTML DOM 中常出现的类型<ul>
<li>Element(元素节点)</li>
<li>Text(文本节点)</li>
<li>Attr(属性节点)</li>
<li>Comment(注释节点)</li>
<li>Document(文档节点)</li>
<li>DocumentFragment(文档片段节点)</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    This is a paragraph of text with a<br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/path/page,html&quot;</span>&gt;</span>link in it<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221201152247948.png" alt="image-20221201152247948" style="zoom:80%;" /></p>
<h4 id="1-7-2-遍历-DOM-树"><a href="#1-7-2-遍历-DOM-树" class="headerlink" title="1.7.2 遍历 DOM 树"></a>1.7.2 遍历 DOM 树</h4><ul>
<li><p>每个节点的 DOM 对象都有以下属性</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221201152838756.png" alt="image-20221201152838756" style="zoom:80%;" /></p>
</li>
<li><p>浏览器不兼容问题 (IE很糟糕)</p>
</li>
<li><p>遍历实例</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221201152951766.png" alt="image-20221201152951766" style="zoom:80%;" /></p>
</li>
</ul>
<h2 id="2-BOM"><a href="#2-BOM" class="headerlink" title="2 BOM"></a>2 BOM</h2><ul>
<li>浏览器对象模型(Browser Object Model, 简称 BOM)是 JS 的组成部分之一, BOM 赋予了 JS 程序与浏览器交互的能力</li>
<li>每个浏览器的 JS 程序都可以引入以下全局对象</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221201153325357.png" alt="image-20221201153325357" style="zoom:80%;" /></p>
<h3 id="2-1-window-对象"><a href="#2-1-window-对象" class="headerlink" title="2.1 window 对象"></a>2.1 window 对象</h3><ul>
<li>所有浏览器都支持 window 对象。他表示浏览器的窗口</li>
<li>所有 JS 全局对象、函数和变量都自动成为窗口对象的成员</li>
<li>在客户端 JS 中, Window 对象是全局对象, 所有的表达式都在当前的环境中计算。也就是说, 要引用当前窗口根本不需要特殊的语法, 可以把那个窗口的属性作为全局变量来使用<ul>
<li><code>window.document.getElementById(&quot;header&quot;);</code></li>
<li><code>document.getElementById(&quot;header&quot;);</code></li>
</ul>
</li>
</ul>
<h3 id="2-2-document-对象"><a href="#2-2-document-对象" class="headerlink" title="2.2 document 对象"></a>2.2 document 对象</h3><ul>
<li>每个载入浏览器的 HTML 文档都会成为 Document 对象</li>
<li>Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问</li>
<li>提示: Document 对象是 Window 对象的一部分, 可以通过 <code>window.document</code> 属性对其进行访问</li>
<li>Document 对象是 HTML 文档的根节点</li>
<li>属性:<ul>
<li>anchors, body, cookie, domain, forms, images, links, referrer, title, URL</li>
</ul>
</li>
<li>方法<ul>
<li>getElementById</li>
<li>getElementsByName</li>
<li>getElementsByTagName</li>
<li>close, open, write, writeln</li>
</ul>
</li>
</ul>
<h3 id="2-3-location-对象"><a href="#2-3-location-对象" class="headerlink" title="2.3 location 对象"></a>2.3 location 对象</h3><ul>
<li>Location 对象包含有关当前 URL 的信息</li>
<li>Location 对象是 Window 对象的一个部分, 可通过 <code>window.location</code> 属性来访问</li>
<li>例子<ul>
<li><code>window.location.href</code> 设置或返回完整的 URL</li>
<li><code>window.location.hostname</code> 设置或返回当前 URL 的主机名</li>
<li><code>window.location.pathname</code> 设置或返回当前 URL 的路径部分</li>
<li><code>window.location.protocol</code> 设置或返回当前 URL 的协议。 (<a target="_blank" rel="noopener" href="http://或https://">http://或https://</a>)</li>
<li><code>window.location.assign()</code> 加载新的文档</li>
</ul>
</li>
</ul>
<h3 id="2-4-navigator-对象"><a href="#2-4-navigator-对象" class="headerlink" title="2.4 navigator 对象"></a>2.4 navigator 对象</h3><ul>
<li><code>window.navigator</code> 对象包含有关浏览器的信息</li>
<li>注释: 没有应用于 navigator 对象的公开标准, 不过所有浏览器都支持该对象</li>
<li>例子:<ul>
<li><code>navigator.appName</code> 返回浏览器的名称</li>
<li><code>navigator.onLine</code> 返回指明系统是否处于脱机模式的布尔值</li>
<li><code>navigator.appCodeName</code> 返回浏览器的代码名</li>
<li><code>navigator.platform</code> 返回运行浏览器的操作系统平台</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> =</span><br><span class="language-javascript">    <span class="hljs-string">&quot;Name is &quot;</span> + navigator.<span class="hljs-property">appName</span> + <span class="hljs-string">&quot;. Code name is &quot;</span> +</span><br><span class="language-javascript">    navigator.<span class="hljs-property">appCodeName</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>注意: </strong>来自 navigator 对象的信息通常会产生误导, 不应该用于检测浏览器版本, 因为:<ul>
<li>不同的浏览器可以使用相同的名称</li>
<li>浏览器所有者可以更改浏览器数据</li>
<li>一些浏览器为了绕过站点测试而故意错误标识自身</li>
<li>浏览器不能报告比浏览器晚发布的新操作系统</li>
</ul>
</li>
</ul>
<h3 id="2-5-screen-对象"><a href="#2-5-screen-对象" class="headerlink" title="2.5 screen 对象"></a>2.5 screen 对象</h3><ul>
<li><p><code>window.screen</code> 对象包含有关客户端显示屏幕的信息</p>
</li>
<li><p>注释: 没有应用于 screen 对象的公开标准, 不过所有浏览器都支持该对象</p>
</li>
<li>属性:<ul>
<li><code>screen.width</code> 返回显示器屏幕的宽度</li>
<li><code>screen.height</code> 返回显示屏幕的高度</li>
<li><code>screen.availWidth</code> 返回显示屏幕的宽度 (除 Windows 任务栏之外)</li>
<li><code>screen.availHeight</code> 返回显示屏幕的高度 (除 Windows 任务栏之外)</li>
<li><code>screen.colorDepth</code> 返回目标设备或缓冲器上的调色板的比特深度</li>
<li><code>screen.pixelDepth</code> 返回显示屏幕的颜色分辨率（比特每像素）</li>
</ul>
</li>
</ul>
<h3 id="2-6-history-对象"><a href="#2-6-history-对象" class="headerlink" title="2.6 history 对象"></a>2.6 history 对象</h3><ul>
<li><code>window.history</code> 对象包括用户(在浏览器窗口中)访问过的 URL</li>
<li>History 对象是 window 对象的一部分, 可通过 <code>window.history</code> 属性对其进行访问</li>
<li>为了保护用户的隐私, 对 JS 访问该对象的方式有限制</li>
<li>注释: 没有应用于 History 对象的公开标准, 不过所有浏览器都支持该对象</li>
<li>方法:<ul>
<li><code>history.back()</code> 加载 history 列表中的前一个 URL</li>
<li><code>history.forward()</code> 加载 history 列表中的下一个 URL</li>
</ul>
</li>
</ul>
<h3 id="2-7-Cookies"><a href="#2-7-Cookies" class="headerlink" title="2.7 Cookies"></a>2.7 Cookies</h3><ul>
<li>Cookies 可以让你在网页中存储用户信息</li>
<li>cookie 是存储在计算机上的小文本文件中的数据</li>
<li>Cookies 的发明是为了解决”如何记住用户信息”的问题:<ul>
<li>当⼀个用户访问⼀个网页时, 他的名字会被存储在⼀个 cookie 中。下次用户访问该页面时, cookie 就会”记住”他的名字。</li>
</ul>
</li>
<li>cookie 以 名称-值对 的形式保存, 例如 username=Tom</li>
<li>当浏览器从服务器请求⼀个网页时, 属于该网页的 cookies 被添加到请求中。通过这种方式, 服务器获得必要的数据来”记住”关于用户的信息</li>
</ul>
<h4 id="2-7-1-用-JS-创建一个-Cookie"><a href="#2-7-1-用-JS-创建一个-Cookie" class="headerlink" title="2.7.1 用 JS 创建一个 Cookie"></a>2.7.1 用 JS 创建一个 Cookie</h4><ul>
<li><p>JS 可以使用 <code>document.cookie</code> 属性来创建、读取和删除cookie</p>
<ul>
<li>例如: <code>document.cookie=&quot;username=Tom&quot;;</code></li>
</ul>
</li>
<li><p>还可以添加一个过期日期(以UTC时间表示)。缺省情况下, 关闭浏览器时删除 cookie:</p>
<ul>
<li><code>document.cookie=&quot;username=Tom; expires=Thu, 18 Sep 2015 10:00:00 UTC&quot;;</code></li>
</ul>
</li>
<li><p>通过路径参数，可以告诉浏览器 cookie 属于哪个路径。缺省情况下，cookie 属于当前页面</p>
<ul>
<li><code>document.cookie=&quot;username=Tom; expires=Thu, 18 Sep 2015 10:00:00 UTC; path=/&quot;;</code></li>
</ul>
</li>
</ul>
<h4 id="2-7-2-如何使用-cookies"><a href="#2-7-2-如何使用-cookies" class="headerlink" title="2.7.2 如何使用 cookies"></a>2.7.2 如何使用 cookies</h4><ul>
<li><p>使用 JS 读取一个 cookie</p>
<ul>
<li><p><code>var x = document.cookie;</code></p>
</li>
<li><p><code>document.cookie</code> will return all cookies in one string much like: <code>cookie1=value1; cookie2=value2; cookie3=value3;</code></p>
</li>
</ul>
</li>
<li><p>使用 JS 修改</p>
<ul>
<li><code>document.cookie=&quot;username=Tom; expires=Thu, 18 Sep 2015 10:00:00 UTC; path=/&quot;;</code></li>
</ul>
</li>
<li><p>使用 JS 删除 Cookie，非常简单，只需将expires参数设置为⼀个过去的日期:</p>
<ul>
<li><code>document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 UTC&quot;;</code></li>
<li>注意，在删除 cookie 时不必指定 cookie 值。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setCookie</span>(<span class="hljs-params">cname, cvalue, exdays</span>) &#123;<br>    <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    d.<span class="hljs-title function_">setTime</span>(d.<span class="hljs-title function_">getTime</span>() + (exdays * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>));<br>    <span class="hljs-keyword">var</span> expires = <span class="hljs-string">&quot;expires=&quot;</span> + d.<span class="hljs-title function_">toGMTString</span>();<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = cname + <span class="hljs-string">&quot;=&quot;</span> + cvalue + <span class="hljs-string">&quot;; &quot;</span> + expires;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCookie</span>(<span class="hljs-params">cname</span>) &#123;<br>    <span class="hljs-keyword">var</span> name = cname + <span class="hljs-string">&quot;=&quot;</span>;<br>    <span class="hljs-keyword">var</span> ca = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;;&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ca.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">var</span> c = ca[i];<br>        <span class="hljs-keyword">while</span> (c.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            c = c.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c.<span class="hljs-title function_">indexOf</span>(name) == <span class="hljs-number">0</span>) &#123;<br>        	<span class="hljs-keyword">return</span> c.<span class="hljs-title function_">substring</span>(name.<span class="hljs-property">length</span>, c.<span class="hljs-property">length</span>);<br>    	&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkCookie</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> user = <span class="hljs-title function_">getCookie</span>(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-keyword">if</span> (user != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>    	<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Welcome again &quot;</span> + user);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        user = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Please enter your name:&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (user != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; user != <span class="hljs-literal">null</span>) &#123;<br>        	<span class="hljs-title function_">setCookie</span>(<span class="hljs-string">&quot;username&quot;</span>, user, <span class="hljs-number">30</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-3-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-3-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理(3) 语法分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-21 15:29:12" itemprop="dateCreated datePublished" datetime="2022-11-21T15:29:12+08:00">2022-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><h2 id="一、ANTLR-4-语法分析器"><a href="#一、ANTLR-4-语法分析器" class="headerlink" title="一、ANTLR 4 语法分析器"></a>一、ANTLR 4 语法分析器</h2><h3 id="1-二义性文法"><a href="#1-二义性文法" class="headerlink" title="1. 二义性文法"></a>1. 二义性文法</h3><ul>
<li>二义性是不能接受的，必须消除</li>
</ul>
<h4 id="1-1-IfStat"><a href="#1-1-IfStat" class="headerlink" title="1.1 IfStat"></a>1.1 IfStat</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs antlr">// 不考虑 antlr 的处理, 单看文法这是有二义性的<br>stat : &#x27;if&#x27; expr &#x27;then&#x27; stat<br>     | &#x27;if&#x27; expr &#x27;then&#x27; stat &#x27;else&#x27; stat<br>     | expr<br>     ;<br>     <br>/* <br> if a then if b then c else d<br> 此处 else d 归属是模糊的<br>*/<br><br>// 解决方法非常复杂:<br>// 将 else 与最近的未被匹配的 if 匹配<br>stat : matched_stat | open_stat ;<br><br>matched_stat : &#x27;if&#x27; expr &#x27;then&#x27; matched_stat &#x27;else&#x27; matched_stat<br>             | expr<br>             ;<br><br>open_stat: &#x27;if&#x27; expr &#x27;then&#x27; stat<br>         | &#x27;if&#x27; expr &#x27;then&#x27; matched_stat &#x27;else&#x27; open_stat<br>         ;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Q: 如何判断文法有没有二义性</p>
<p>A: 做不到, 只能靠经验</p>
<p>Q: ANTLR 如何解决二义性问题</p>
<p>A: 通过书写规则的顺序来决定优先级, 优先解释为优先级高的结构</p>
</blockquote>
<h4 id="1-2-Left-Factoring"><a href="#1-2-Left-Factoring" class="headerlink" title="1.2 Left-Factoring"></a>1.2 Left-Factoring</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs antlr">stat : &#x27;if&#x27; expr &#x27;then&#x27; stat<br>     | &#x27;if&#x27; expr &#x27;then&#x27; stat &#x27;else&#x27; stat<br>     | expr<br>     ;<br>==============================================<br>stat : &#x27;if&#x27; expr &#x27;then&#x27; stat stat_prime ;<br>stat_prime : &#x27;else&#x27; stat<br>     |<br>     ;<br></code></pre></td></tr></table></figure>
<ul>
<li>很明显, 提取左公因子无助于消除文法二义性</li>
<li>ANTLR 4 可以处理有左公因子的文法</li>
</ul>
<h4 id="1-3-Expr"><a href="#1-3-Expr" class="headerlink" title="1.3 Expr"></a>1.3 Expr</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs antlr">expr :<br>  | expr &#x27;*&#x27; expr<br>  | expr &#x27;-&#x27; expr<br>  | DIGIT<br>  ;<br><br>// 同样存在二义性<br>1-2-3 -&gt; (1-2)-3 | 1-(2-3)<br>1-2*3 -&gt; (1-2)*3 | 1-(2*3)<br><br>// 解决方法, 但是引入很多冗余文法符号<br>// 左递归文法, expr 只有左侧的 expr 是递归的<br>expr : expr &#x27;-&#x27; term<br>     | term<br>     ;<br>     <br>term : term &#x27;*&#x27; factor<br>     | factor<br>     ;<br>     <br>factor : DIGIT ;<br><br>// 右递归文法, 也能解决优先级, 但会改变结合性 1-2-3 -&gt; 1-(2-3)<br>expr : term expr_prime ;<br>expr_prime : &#x27;-&#x27; term expr_prime<br>     |<br>     ;<br>     <br>term : factor term_prime ;<br>term_prime : &#x27;*&#x27; factor term_prime<br>     |<br>     ;<br>     <br>factor : DIGIT ;<br></code></pre></td></tr></table></figure>
<ul>
<li>左递归(左结合)，右递归(右结合)</li>
<li>ANTLR 4 可以处理(直接)左递归<ul>
<li>写在上方的规则优先级高</li>
<li>但是有些情况需要右结合(^)<ul>
<li>二元运算符需要特别标记 <code>&lt;assoc = right&gt; expr &#39;^&#39; expr</code></li>
<li>一元运算符不需要标记，因为只能解释为右结合 <code>------1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-Call-Graphs"><a href="#2-Call-Graphs" class="headerlink" title="2. Call Graphs"></a>2. Call Graphs</h3><h4 id="2-1-监听器模式-Listener"><a href="#2-1-监听器模式-Listener" class="headerlink" title="2.1 监听器模式(Listener)"></a>2.1 监听器模式(Listener)</h4><ul>
<li><p>ANTLR 通过深度优先遍历生成的语法树</p>
<ul>
<li>除了叶子节点, 所有的内部节点至少会经过两次</li>
<li>ANTLR 会为其生成 <code>ENTERXXX(), EXITXXX()</code> 的方法</li>
</ul>
</li>
<li><p>一条规则有不同选择时, 通过添加 <code>#label</code> 来区分, 单个选择内部使用 <code>op</code> 来区分</p>
<ul>
<li>ANTLR 会生成对应的 <code>ENTER\EXIT LABEL</code> 方法, <code>op</code> 则作为成员变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs antlr">expr: ID &#x27;(&#x27; exprList? &#x27;)&#x27;    # Call // function call<br>    | expr &#x27;[&#x27; expr &#x27;]&#x27;       # Index // array subscripts<br>    | op = &#x27;-&#x27; expr                # Negate // right association<br>    | op = &#x27;!&#x27; expr                # Not // right association<br>    | &lt;assoc = right&gt; expr &#x27;^&#x27; expr # Power<br>    | lhs = expr (op = &#x27;*&#x27;| op = &#x27;/&#x27;) rhs = expr     # MultDiv<br>    | lhs = expr (op = &#x27;+&#x27;| op = &#x27;-&#x27;) rhs = expr     # AddSub<br>    | lhs = expr (op = &#x27;==&#x27; | op = &#x27;!=&#x27;) rhs = expr  # EQNE<br>    | &#x27;(&#x27; expr &#x27;)&#x27;            # Parens<br>    | ID                      # Id<br>    | INT                     # Int<br>    ;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221122164530981.png" alt="image-20221122164530981" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="2-2-访问者模式-Visitor"><a href="#2-2-访问者模式-Visitor" class="headerlink" title="2.2 访问者模式(Visitor)"></a>2.2 访问者模式(Visitor)</h4><ul>
<li><p>详见实验</p>
</li>
<li><p>Visitor在访问每个节点的子节点前会调用<code>visitChildren()</code>函数</p>
</li>
<li>Visitor在访问每个终结符节点时会调用<code>visitTerminal()</code>函数</li>
<li>对于每一个语法规则都存在一个对应的visit函数，如 exp 规则对应的函数为<code>visitExp()</code></li>
</ul>
<h3 id="3-上下文无关文法"><a href="#3-上下文无关文法" class="headerlink" title="3. 上下文无关文法"></a>3. 上下文无关文法</h3><h4 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h4><h5 id="Definition-Context-Free-Grammar-CFG-上下文无关文法"><a href="#Definition-Context-Free-Grammar-CFG-上下文无关文法" class="headerlink" title="Definition (Context-Free Grammar (CFG); 上下文无关文法)"></a>Definition (Context-Free Grammar (CFG); 上下文无关文法)</h5><p>上下文无关文法 $G$ 是一个四元组 $G = (T,N,P,S):$</p>
<ul>
<li><p>$T$ 是<strong>终结符号</strong> (Terminal) 集合, 对应于词法分析器产生的词法单元;</p>
</li>
<li><p>$N$ 是<strong>非终结符号</strong> (Non-terminal) 集合;</p>
</li>
<li><p>$P$ 是<strong>产生式</strong> (Production) 集合;</p>
<ul>
<li><p>$A \in N \longrightarrow α \in (T \cup N)^\ast$</p>
</li>
<li><p>头部/左部 (Head) $A$: <strong>单个</strong>非终结符</p>
</li>
<li><p>体部/右部 (Body) $α$: 终结符与非终结符构成的串, 也可以是空串 $\epsilon$</p>
</li>
</ul>
</li>
<li><p>$S$ 为<strong>开始</strong> (Start) 符号。要求 $S \in N$ 且唯一。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124173937897.png" alt="image-20221124173937897" style="zoom:80%;" /></p>
<h4 id="3-2-语义"><a href="#3-2-语义" class="headerlink" title="3.2 语义"></a>3.2 语义</h4><p>上下文无关文法 $G$ 定义了一个<strong>语言</strong> $L(G)$</p>
<ul>
<li>语言是<strong>串</strong>的集合</li>
<li>串从何来?</li>
</ul>
<h5 id="推导-Derivation"><a href="#推导-Derivation" class="headerlink" title="推导 (Derivation)"></a>推导 (Derivation)</h5><ul>
<li>推导即是将某个产生式的左边<strong>替换</strong>成它的右边</li>
<li>每一步推导需要选择<strong>替换哪个非终结符号</strong>, 以及<strong>使用哪个产生式</strong></li>
</ul>
<blockquote>
<p>$E \to E + E \mid E \ast E \mid (E) \mid -E \mid \bf id$</p>
<ul>
<li>$E \implies -E \implies -(E) \implies -(E + E) \implies -(\textbf{id} + E) \implies -(\textbf{id} + \textbf{id})$</li>
<li>$E \implies -E \implies -(E) \implies -(E + E) \implies \textcolor{blue}{-(E + \textbf{id})} \implies -(\textbf{id} + \textbf{id})$</li>
</ul>
<p>$E \implies -E:$ 经过一步推导得出</p>
<p>$E \stackrel{+}{\implies} -(\textbf{id} + E):$ 经过一步或多步推导得出</p>
<p>$E \stackrel{\ast}{\implies} -(\textbf{id} + E):$ 经过零步或多步推导得出</p>
</blockquote>
<h5 id="Definition-Sentential-Form-句型"><a href="#Definition-Sentential-Form-句型" class="headerlink" title="Definition (Sentential Form; 句型)"></a>Definition (Sentential Form; 句型)</h5><p>如果 $S \stackrel{\ast}{\implies} \alpha ,$ 且 $ \alpha \in (T \cup N)^\ast ,$ 则称 $\alpha$ 是文法 $G$ 的一个<strong>句型</strong></p>
<blockquote>
<ul>
<li>$E \to E + E \mid E \ast E \mid (E) \mid -E \mid \bf id$</li>
<li>$E \implies -E \implies -(E) \implies -(E + E) \implies -(\textbf{id} + E) \implies -(\textbf{id} + \textbf{id})$<ul>
<li>夹杂着终结符和非终结符的串都叫做句型</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="Definition-Sentence-句子"><a href="#Definition-Sentence-句子" class="headerlink" title="Definition (Sentence; 句子)"></a>Definition (Sentence; 句子)</h5><p>如果 $S \stackrel{\ast}{\implies} w ,$ 且 $w \in T^\ast ,$ 则称 $w$ 是文法 $G$ 的一个<strong>句子</strong></p>
<h5 id="Definition-文法-G-生成的语言-L-G"><a href="#Definition-文法-G-生成的语言-L-G" class="headerlink" title="Definition (文法 $G$ 生成的语言 $L(G)$)"></a>Definition (文法 $G$ 生成的语言 $L(G)$)</h5><p>文法 $G$ 的<strong>语言</strong> $L(G)$ 是它能推导出的<strong>所有句子</strong>构成的集合。</p>
<ul>
<li>$w \in L(G) \iff S \stackrel{\ast}{\Rightarrow} w$</li>
</ul>
<h4 id="3-3-关于文法-G-的两个基本问题"><a href="#3-3-关于文法-G-的两个基本问题" class="headerlink" title="3.3 关于文法 $G$ 的两个基本问题"></a>3.3 关于文法 $G$ 的两个基本问题</h4><ul>
<li><p><strong>Membership问题:</strong> 给定字符串 $x \in \textcolor{red}{T^\ast} , x \in L(G)$ ?</p>
</li>
<li><p>$L(G)$ 究竟是什么?</p>
</li>
</ul>
<h5 id="3-3-1-给定字符串-x-in-T-ast-x-in-L-G"><a href="#3-3-1-给定字符串-x-in-T-ast-x-in-L-G" class="headerlink" title="3.3.1 给定字符串 $x \in T^\ast , x \in L(G)$ ?"></a>3.3.1 给定字符串 $x \in T^\ast , x \in L(G)$ ?</h5><ul>
<li><p>即, 检查 $x$ 是否符合文法 $G$</p>
</li>
<li><p>这就是<strong>语法分析器</strong>的任务:</p>
<ul>
<li>为输入的词法单元流寻找推导、<strong>构建语法分析树</strong>, 或者报错</li>
</ul>
</li>
</ul>
<h5 id="3-3-2-L-G-是什么"><a href="#3-3-2-L-G-是什么" class="headerlink" title="3.3.2 $L(G)$ 是什么?"></a>3.3.2 $L(G)$ 是什么?</h5><ul>
<li><p>这是<strong>程序设计语言设计者</strong>需要考虑的问题</p>
</li>
<li><p>一些例子</p>
<ul>
<li><p>$L(G) = \set{良匹配括号串}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126144503343.png" alt="image-20221126144503343" style="zoom:80%;" /></p>
</li>
<li><p>$L(G) = \set{a^nb^n \mid n \ge 0}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126144707716.png" alt="image-20221126144707716" style="zoom:80%;" /></p>
</li>
<li><p>$字母表 \Sigma = \set{a, b} 上的所有 \textcolor{blue}{\textbf{回文串}} (Palindrome) 构成的语言$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126144933786.png" alt="image-20221126144933786" style="zoom:80%;" /></p>
</li>
<li><p>$\set{b^na^mb^{2n} \mid n \ge 0, m \ge 0}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126145059081.png" alt="image-20221126145059081" style="zoom:80%;" /></p>
</li>
<li><p>$\set{x \in \set{a, b}^\ast \mid x 中 a, b 个数 \textcolor{red}{\textbf{相同}}}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126145228086.png" alt="image-20221126145228086" style="zoom:80%;" /></p>
<ul>
<li>$a, b$ 开头是对称的, 此处只考虑 $a$ 开头</li>
<li>一定存在一个 $b$ 使得按这个 $b$ 分割的两个串中 $a, b$ 个数相同</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126145545729.png" alt="image-20221126145544058" style="zoom: 25%;" /></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>$\set{x \in \set{a, b}^\ast \mid x 中 a, b 个数 \textcolor{red}{\textbf{不同}}}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126150206032.png" alt="image-20221126150206032" style="zoom:80%;" /></p>
</li>
</ul>
<h3 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4 正则表达式"></a>4 正则表达式</h3><p>为什么不使用优雅、强大的<strong>正则表达式</strong>描述程序设计语言的语法?</p>
<ul>
<li>正则表达式的表达能力<strong>严格弱于</strong>上下文无关文法</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126150328339.png" alt="image-20221126150328339" style="zoom:80%;" /></p>
<h4 id="4-1-RE-rightarrow-CFG"><a href="#4-1-RE-rightarrow-CFG" class="headerlink" title="4.1 RE $\rightarrow$ CFG"></a>4.1 RE $\rightarrow$ CFG</h4><p>每个<strong>正则表达式</strong> $r$ 对应的语言 $L(r)$ 都可以使用<strong>上下文无关文法</strong>来描述</p>
<ul>
<li><p>RE</p>
<ul>
<li>$r = (a \mid b)^\ast abb$</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126151201551.png" alt="image-20221126151201551" style="zoom:80%;" /></p>
</li>
<li><p>CFG</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126151258746.png" alt="image-20221126151258746" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="4-2-CFG-rightarrow-RE-反例"><a href="#4-2-CFG-rightarrow-RE-反例" class="headerlink" title="4.2 CFG $\rightarrow$ RE 反例"></a>4.2 CFG $\rightarrow$ RE 反例</h4><ul>
<li><p>CFG</p>
<ul>
<li><p>$L = \set{a^nb^n \mid n \ge 0}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126151604143.png" alt="image-20221126151604143" style="zoom:80%;" /></p>
</li>
</ul>
</li>
<li><p>RE</p>
<ul>
<li>该语言<strong>无法</strong>使用正则表达式来描述</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126151732638.png" alt="image-20221126151732638" style="zoom:80%;" /></p>
<ul>
<li>因为 $m \gt k$, 所以一定会有状态经过了不止一次, 假设就是 $s_i$, 上图画出第一次碰到和最后一次碰到的状态<ul>
<li>第一次到最后一次中间消耗的 $a$ 的个数一定 $\ge 1$</li>
</ul>
</li>
<li>假设消耗掉 $a^i$ 后第一次到达 $s_i$, 此时接收 $b^i$ 后根据假设应当到达终止状态 $f$ <ul>
<li>但因为第一次到达和最后一次到达的 $s_i$ 是相同的状态, 因此也应当可以接受 $a^{i+j}b^i$</li>
<li><strong>矛盾！</strong> </li>
</ul>
</li>
</ul>
<ul>
<li><p>该反例称为泵引理, Pumping Lemma</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221126153050203.png" alt="image-20221126153050203" style="zoom:80%;" /></p>
</li>
</ul>
<h2 id="二、递归下降的-LL-1-语法分析器"><a href="#二、递归下降的-LL-1-语法分析器" class="headerlink" title="二、递归下降的$LL(1)$语法分析器"></a>二、递归下降的$LL(1)$语法分析器</h2><h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h3><p>语法分析算法可分为两类: $LL$, $LR$</p>
<ul>
<li>$LR$ 更加复杂</li>
</ul>
<p><strong>构建语法分析树</strong>: 自顶向下 $vs.$ 自底向上</p>
<ul>
<li>$LL$ 为自顶向下</li>
<li>$LR$ 为自底向上</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129212330806.png" alt="image-20221129212330806" style="zoom:80%;" /></p>
<p>只考虑<strong>无二义性</strong>的文法</p>
<ul>
<li>这意味着, 每个句子对应唯一的一棵语法分析树</li>
<li>本节主题: <strong>$LL(1)$ 语法分析器</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129212519129.png" alt="image-20221129212519129" style="zoom:80%;" /></p>
<p>ANTLR</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129212642012.png" alt="image-20221129212642012" style="zoom:80%;" /></p>
<h3 id="2-什么是-LL-1-语法分析器"><a href="#2-什么是-LL-1-语法分析器" class="headerlink" title="2. 什么是$LL(1)$语法分析器"></a>2. 什么是$LL(1)$语法分析器</h3><ul>
<li>自顶向下的、</li>
<li>递归下降的、</li>
<li>基于预测分析表的、</li>
<li>适用于$\textcolor{red}{LL(1) \textbf{文法}}$的、</li>
<li>$LL(1)$ 语法分析器</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130144459907.png" alt="image-20221130144459907" style="zoom:80%;" /></p>
<h4 id="2-1-自顶向下"><a href="#2-1-自顶向下" class="headerlink" title="2.1 自顶向下"></a>2.1 自顶向下</h4><p>$\textcolor{red}{\textbf{自顶向下}}构建语法分析树$</p>
<ul>
<li>$\textcolor{blue}{\textbf{根节点}}是文法的起始符号$ $S$</li>
<li>$每个\textcolor{blue}{\textbf{中间节点}}表示\textcolor{purple}{\textbf{对某个非终结符应用某个产生式进行推导}}$<ul>
<li>$\textcolor{red}{Q:}选择哪个非终结符, 以及选择哪个产生式$</li>
</ul>
</li>
<li>$\textcolor{blue}{\textbf{叶节点}}是词法单元流$ $w\$$<ul>
<li>$仅包含终结符号与特殊的\textcolor{teal}{\textbf{文件结束符}}$ $\textcolor{teal}{\$}$ $\textcolor{teal}{\texttt{(EOF)}}$</li>
</ul>
</li>
</ul>
<h5 id="如何选择非终结符"><a href="#如何选择非终结符" class="headerlink" title="如何选择非终结符"></a>如何选择非终结符</h5><ul>
<li>在推导的每一步, $L\textcolor{red}{L}(1)$ 总是选择<strong>最左边的非终结符进行展开</strong><ul>
<li>Leftmost derivation, 最左推导</li>
</ul>
</li>
<li>$\textcolor{red}{L}L(1)$: 从左向右读入词法单元</li>
</ul>
<h4 id="2-2-递归下降"><a href="#2-2-递归下降" class="headerlink" title="2.2 递归下降"></a>2.2 递归下降</h4><p>$\textcolor{red}{\textbf{递归}}\textcolor{blue}{\textbf{下降}}的典型实现框架$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129215551497.png" alt="image-20221129215551497" style="zoom:80%;" /></p>
<ul>
<li>为每个<strong>非终结符</strong>写一个<strong>递归函数</strong></li>
<li>内部按需调用其它非终结符对应的递归函数, <strong>下降</strong>一层</li>
</ul>
<h5 id="递归下降示例"><a href="#递归下降示例" class="headerlink" title="递归下降示例"></a>递归下降示例</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129222116911.png" alt="image-20221129222116911" style="zoom:80%;" /></p>
<ul>
<li>每次都选择语法分析树<strong>最左边</strong>的非终结符进行展开</li>
</ul>
<blockquote>
<p>$Q: 同样是展开非终结符 S, 为什么前两次选择了 S \to (S + F), 而第三次选择了 S \to F$ $?$</p>
<ul>
<li>因为它们面对的<strong>当前词法单元</strong>不同</li>
</ul>
</blockquote>
<h4 id="2-3-预测分析表"><a href="#2-3-预测分析表" class="headerlink" title="2.3 预测分析表"></a>2.3 预测分析表</h4><p>$使用\textcolor{red}{\textbf{预测分析表}}确定产生式$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129222546435.png" alt="image-20221129222546435" style="zoom:80%;" /></p>
<ul>
<li><p>$指明了每个\textcolor{blue}{\textbf{非终结符}}在面对不同的\textcolor{red}{\textbf{词法单元或文件结束符}}时,$</p>
<p>$该选择哪个\textcolor{teal}{\textbf{产生式}} (按编号进行索引) 或者\textcolor{cyan}{\textbf{报错}} (空单元格)$</p>
</li>
</ul>
<h4 id="2-4-Definition-LL-1-文法"><a href="#2-4-Definition-LL-1-文法" class="headerlink" title="2.4 Definition ($LL(1)$ 文法)"></a>2.4 Definition ($LL(1)$ 文法)</h4><p>$如果文法$ $G$ 的$\textcolor{red}{\textbf{预测分析表}}是\textcolor{blue}{\textbf{无冲突}}的, 则$ $G$ $是$ $LL(1)$ $文法$</p>
<ul>
<li><p>$\textcolor{blue}{\textbf{无冲突}}: 每个单元格里只有一个产生式 (编号)$ </p>
</li>
<li><p>$对于当前选择的\textcolor{blue}{\textbf{非终结符}},$ </p>
<p>$仅根据输入中\textcolor{red}{\textbf{当前的词法单元}} (LL(\textcolor{red}{1}))$ $即可确定需要使用哪条\textcolor{teal}{\textbf{产生式}}$</p>
</li>
</ul>
<h5 id="递归下降的、预测分析实现方法"><a href="#递归下降的、预测分析实现方法" class="headerlink" title="递归下降的、预测分析实现方法"></a>递归下降的、预测分析实现方法</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129222546435.png" alt="image-20221129222546435" style="zoom: 67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129224308689.png" alt="image-20221129224308689" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129224316884.png" alt="image-20221129224316884" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129224326342.png" alt="image-20221129224326342" style="zoom:80%;" /></p>
<h3 id="3-计算给定文法-G-的预测分析表"><a href="#3-计算给定文法-G-的预测分析表" class="headerlink" title="3. 计算给定文法 $G$ 的预测分析表"></a>3. 计算给定文法 $G$ 的预测分析表</h3><h4 id="3-1-引入"><a href="#3-1-引入" class="headerlink" title="3.1 引入"></a>3.1 引入</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129225435287.png" alt="image-20221129225435287" style="zoom:80%;" /></p>
<ul>
<li>重点在于 optional_init 展开时如何选择</li>
<li>非终结符展开要考虑两件事<ul>
<li>最左侧的终结符是不是所需要的</li>
<li>如果要展开的非终结符的一个备选分支是 $\epsilon$, 后面的字符是不是所需要的</li>
</ul>
</li>
</ul>
<h4 id="3-2-FIRST-alpha"><a href="#3-2-FIRST-alpha" class="headerlink" title="3.2 FIRST($\alpha$)"></a>3.2 FIRST($\alpha$)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129231109091.png" alt="image-20221129231109091" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129231302198.png" alt="image-20221129231302198" style="zoom:80%;" /></p>
<h4 id="3-3-FOLLOW-A"><a href="#3-3-FOLLOW-A" class="headerlink" title="3.3 FOLLOW($A$)"></a>3.3 FOLLOW($A$)</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129231515371.png" alt="image-20221129231515371" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129231529491.png" alt="image-20221129231529491" style="zoom:80%;" /></p>
<h4 id="3-4-计算FIRST-FOLLOW"><a href="#3-4-计算FIRST-FOLLOW" class="headerlink" title="3.4 计算FIRST,FOLLOW"></a>3.4 计算FIRST,FOLLOW</h4><h5 id="3-4-1-FIRST"><a href="#3-4-1-FIRST" class="headerlink" title="3.4.1 FIRST"></a>3.4.1 FIRST</h5><ol>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129232019642.png" alt="image-20221129232019642" style="zoom:80%;" /><ul>
<li>只有前面所有非终结符都能推出 $\epsilon$, 才需要考虑下一个</li>
</ul>
</li>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129232037559.png" alt="image-20221129232037559" style="zoom:80%;" /></li>
</ol>
<p><strong>举例</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130141836513.png" alt="image-20221130141836513" style="zoom:80%;" /></p>
<h5 id="3-4-2-FOLLOW"><a href="#3-4-2-FOLLOW" class="headerlink" title="3.4.2 FOLLOW"></a>3.4.2 FOLLOW</h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130142137823.png" alt="image-20221130142137823" style="zoom:80%;" /></p>
<p><strong>举例</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130142657320.png" alt="image-20221130142657320" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130142720412.png" alt="image-20221130142720412" style="zoom:80%;" /></p>
<h4 id="3-5-计算预测分析表"><a href="#3-5-计算预测分析表" class="headerlink" title="3.5 计算预测分析表"></a>3.5 计算预测分析表</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204172348302.png" alt="image-20221204172348302" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204172356127.png" alt="image-20221204172356127" style="zoom:80%;" /></p>
<blockquote>
<p>当下的选择未必正确, 但 “你别无选择”</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130144017088.png" alt="image-20221130144017088" style="zoom:80%;" /></p>
<blockquote>
<p>什么是 $LL(0)$ : 每个非终结符只有一条产生式</p>
</blockquote>
<h3 id="4-非递归的预测分析算法"><a href="#4-非递归的预测分析算法" class="headerlink" title="4. 非递归的预测分析算法"></a>4. 非递归的预测分析算法</h3><p>S: 初始符号</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130144758691.png" alt="image-20221130144758691" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221130144842886.png" alt="image-20221130144842886" style="zoom:80%;" /></p>
<h3 id="5-非-LL-1-文法如何解决"><a href="#5-非-LL-1-文法如何解决" class="headerlink" title="5. 非$LL(1)$文法如何解决"></a>5. 非$LL(1)$文法如何解决</h3><p><strong>改造他!</strong></p>
<ul>
<li>消除左递归</li>
<li>提取左公因子</li>
</ul>
<h4 id="5-1-提取左公因子"><a href="#5-1-提取左公因子" class="headerlink" title="5.1 提取左公因子"></a>5.1 提取左公因子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs antlr">x -&gt; aB | aC	// 这种情况开始都有 a, 不知道要使用哪条<br><br>// 改造为<br>x -&gt; aD<br>D -&gt; B | C<br></code></pre></td></tr></table></figure>
<ul>
<li>antlr 不需要这么处理, 会使用更好的技术来处理</li>
</ul>
<h4 id="5-2-消除左递归"><a href="#5-2-消除左递归" class="headerlink" title="5.2 消除左递归"></a>5.2 消除左递归</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204173936840.png" alt="image-20221204173936840" style="zoom:80%;" /></p>
<ul>
<li>但是左递归文法在使用$LL(1)$文法的情况下是不能运行的</li>
<li>$LL(1)$文法需要为 $E$ 写一个递归函数</li>
<li>$E 在 \textcolor{red}{\textbf{不消耗任何词法单元}}的情况下, 直接递归调用 E, 造成\textcolor{green}{\textbf{死循环}}$</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204174331739.png" alt="image-20221204174331739" style="zoom:80%;" /></p>
<h5 id="右递归"><a href="#右递归" class="headerlink" title="右递归"></a>右递归</h5><p>如果一定要使用$LL(1)$文法，可以改为<strong>右递归</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204174513260.png" alt="image-20221204174513260" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204174554340.png" alt="image-20221204174554340" style="zoom:80%;" /></p>
<h4 id="5-3-文件结束符-的必要性"><a href="#5-3-文件结束符-的必要性" class="headerlink" title="5.3 文件结束符 \$ 的必要性"></a>5.3 文件结束符 \$ 的必要性</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204174726446.png" alt="image-20221204174726446" style="zoom:80%;" /></p>
<ul>
<li>观察蓝框, 在输入结束的情况下, 栈中还有内容, 此时就需要利用 \$ 来清空</li>
</ul>
<h2 id="三、Adaptive-LL-ast-语法分析算法"><a href="#三、Adaptive-LL-ast-语法分析算法" class="headerlink" title="三、Adaptive $LL(\ast)$ 语法分析算法"></a>三、Adaptive $LL(\ast)$ 语法分析算法</h2><h3 id="1-ANTLR-4"><a href="#1-ANTLR-4" class="headerlink" title="1. ANTLR 4"></a>1. ANTLR 4</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204223047803.png" alt="image-20221204223047803" style="zoom:80%;" /></p>
<blockquote>
<p>直接左递归: E -&gt; E + T</p>
<p>间接左递归: A -&gt; B, B -&gt; A</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204224354903.png" alt="image-20221204224354903" style="zoom:80%;" /></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/courses-at-nju-by-hfwei/compilers-papers-we-love/tree/master/parsing">courses-at-nju-by-hfwei/compilers-papers-we-love</a></p>
</blockquote>
<h3 id="2-直接左递归与优先级"><a href="#2-直接左递归与优先级" class="headerlink" title="2. 直接左递归与优先级"></a>2. 直接左递归与优先级</h3><h4 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221204224547753.png" alt="image-20221204224547753" style="zoom:80%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs antlr">// parser-allstar/LRExpr.g4<br><br>stat : expr &#x27;;&#x27; EOF;<br><br>expr : expr &#x27;*&#x27; expr<br>     | expr &#x27;+&#x27; expr<br>     | INT<br>     | ID<br>     ;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205143936396.png" alt="image-20221205143936396" style="zoom:80%;" /></p>
<blockquote>
<p>优先级体现在 * 比 + 深一层</p>
<p>换言之，以上图为例，要考虑 expr:1 在哪一层展开</p>
<ul>
<li>和 + 同一层, 即上图情况, 则 * 更深, 优先级更高</li>
<li>和的父节点一层, 则 + 与 * 优先级相同</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205144439777.png" alt="image-20221205144439777" style="zoom:80%;" /></p>
<h4 id="2-2-ANTLR-处理方法-优先级上升算法"><a href="#2-2-ANTLR-处理方法-优先级上升算法" class="headerlink" title="2.2 ANTLR 处理方法(优先级上升算法)"></a>2.2 ANTLR 处理方法(优先级上升算法)</h4><blockquote>
<p>antlr4 LRExpr -Xlog</p>
<ul>
<li>添加 -Xlog 可以查看被 antlr4 重写后的文法</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205144716053.png" alt="image-20221205144716053" style="zoom: 67%;" /></p>
<p>$\Longrightarrow$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205144800009.png" alt="image-20221205144800009" style="zoom:80%;" /></p>
<p>$\stackrel{简化一下}{\Longrightarrow}$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205144906176.png" alt="image-20221205144906176" style="zoom:67%;" /></p>
<p>可以先简单看作 $(\texttt{INT} \mid \texttt{ID})(\ast E \mid + E)^\ast$</p>
<p>重点: 提供了一个优先级参数 <code>_p</code></p>
<ul>
<li>antlr4中, 优先级从上至下以此降低, 最底层优先级为 1, 每往上一层 +1<ul>
<li>ID-1, INT-2, (expr ‘+’ expr)-3, (expr ‘*‘ expr)-4</li>
</ul>
</li>
</ul>
<blockquote>
<p>举例</p>
<p><strong>1 + 2 + 3</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205151912558.png" alt="image-20221205151912558" style="zoom:80%;" /></p>
<ul>
<li><p>当遇到最后的 +3 时, 因为优先级限制不能直接展开, 否则就变成右结合了</p>
</li>
<li><p>exp[4] 中的 4 限制了要在哪一层展开, 这一层不满足, 要返回到上一层</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205152206296.png" alt="image-20221205152206296" style="zoom:80%;" /></p>
<ul>
<li>在上一层展开 就变为 <code>ID &#39;+&#39; EXP[4] &#39;+&#39; EXP[4]</code></li>
</ul>
<p><strong>1 + 2 * 3</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205152508686.png" alt="image-20221205152508686" style="zoom:80%;" /></p>
<p><strong>1 * 2 + 3</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205152655882.png" alt="image-20221205152655882" style="zoom:80%;" /></p>
</blockquote>
<h4 id="2-3-扩展一下语法"><a href="#2-3-扩展一下语法" class="headerlink" title="2.3 扩展一下语法"></a>2.3 扩展一下语法</h4><ol>
<li><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205152929622.png" alt="image-20221205152929622" style="zoom:80%;" /></p>
<ul>
<li>非常简单，因为不是左递归，处理时和 INT ID 一组</li>
</ul>
</li>
<li><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205153045251.png" alt="image-20221205153045251" style="zoom:80%;" /></p>
<ul>
<li><code>&#39;-&#39; expr</code> 非左递归, 尽管优先级高, 处理时和 ID 一组</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205153149299.png" alt="image-20221205153149299" style="zoom:80%;" /></p>
</li>
</ol>
<blockquote>
<p>举例</p>
<p><strong>-a + b!</strong> $\implies$ (-a) + (b!)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205153459054.png" alt="image-20221205153459054" style="zoom:80%;" /></p>
<p><strong>-a!!</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205154249678.png" alt="image-20221205154249678" style="zoom:80%;" /></p>
</blockquote>
<ol>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205161948138.png" alt="image-20221205161948138" style="zoom:80%;" /><ul>
<li>为了实现幂运算的右结合, 推导幂运算是, expr的优先级仍然是 <code>expr[3]</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>举例</p>
<p><strong>1\^2\^3 + 4</strong></p>
</blockquote>
<h4 id="2-4-如何决定优先级"><a href="#2-4-如何决定优先级" class="headerlink" title="2.4 如何决定优先级"></a>2.4 如何决定优先级</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205162834597.png" alt="image-20221205162834597" style="zoom:80%;" /></p>
<h3 id="3-错误报告与恢复"><a href="#3-错误报告与恢复" class="headerlink" title="3. 错误报告与恢复"></a>3. 错误报告与恢复</h3><h4 id="3-1-引入-1"><a href="#3-1-引入-1" class="headerlink" title="3.1 引入"></a>3.1 引入</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205162938835.png" alt="image-20221205162938835" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205163008937.png" alt="image-20221205163008937" style="zoom:80%;" /></p>
<blockquote>
<p>短短 10 行的代码竟出现 100 个错误,</p>
<ul>
<li>说明不是遇到错误就停下来</li>
</ul>
</blockquote>
<h4 id="3-2-恐慌-应急-Panic-模式"><a href="#3-2-恐慌-应急-Panic-模式" class="headerlink" title="3.2 恐慌/应急(Panic)模式"></a>3.2 恐慌/应急(Panic)模式</h4><ul>
<li>假装成功、调整状态、继续进行</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205163248878.png" alt="image-20221205163248878" style="zoom:80%;" /></p>
<blockquote>
<p>单词法符号移除</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205163551701.png" alt="image-20221205163551701" style="zoom:80%;" /></p>
<p>单词法符号补全</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205163601281.png" alt="image-20221205163601281" style="zoom:80%;" /></p>
</blockquote>
<ul>
<li>但这种方法只能解决简单的错误, 复杂可使用 “同步-返回” 策略</li>
</ul>
<h4 id="3-3-同步-返回-策略"><a href="#3-3-同步-返回-策略" class="headerlink" title="3.3 同步-返回 策略"></a>3.3 同步-返回 策略</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205163621087.png" alt="image-20221205163621087" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205164406514.png" alt="image-20221205164406514" style="zoom:80%;" /></p>
<blockquote>
<p>静态与动态的区别</p>
<p>例如图右侧, 因为group匹配的是第一条规则, expr跟着的只可能是 ‘]’, 而不包括 ‘)’</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205164851153.png" alt="image-20221205164851153" style="zoom:80%;" /></p>
<h3 id="4-Adaptive-LL-ast"><a href="#4-Adaptive-LL-ast" class="headerlink" title="4. Adaptive $LL(\ast)$"></a>4. Adaptive $LL(\ast)$</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205165442256.png" alt="image-20221205165442256" style="zoom:80%;" /></p>
<blockquote>
<p>$A: a^\ast b$</p>
</blockquote>
<ol>
<li>为每个非终结符构造ATN网络</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205165458601.png" alt="image-20221205165458601" style="zoom:80%;" /></p>
<ol>
<li>根据ATN网络, 构造”向前看DFA”</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205172932199.png" alt="image-20221205172932199" style="zoom:80%;" /></p>
<p>要点: </p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205171258755.png" alt="image-20221205171258755" style="zoom:80%;" /></p>
<p>示例: </p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205173007857.png" alt="image-20221205173007857" style="zoom:80%;" /></p>
<blockquote>
<p>$D_0$: 初始状态</p>
<p>$f_{1/2}$: 第1/2条备选分支</p>
<p>第一个分量: 状态名</p>
<p>第二个分量: 当前子解析器在探索第几条分支</p>
<p>第三个分量: 递归调用的符号组成的栈</p>
<p>粗体是通过 move 得到，其他都是通过 闭包 得到的</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">计算机操作系统(5) 文件管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-21 14:33:04" itemprop="dateCreated datePublished" datetime="2022-11-21T14:33:04+08:00">2022-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章-文件管理"><a href="#第五章-文件管理" class="headerlink" title="第五章 文件管理"></a>第五章 文件管理</h1><h2 id="5-1-文件系统概述"><a href="#5-1-文件系统概述" class="headerlink" title="5.1 文件系统概述"></a>5.1 文件系统概述</h2><h3 id="5-1-1-文件的概念"><a href="#5-1-1-文件的概念" class="headerlink" title="5.1.1 文件的概念"></a>5.1.1 文件的概念</h3><h4 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h4><ul>
<li><p>文件是具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列</p>
</li>
<li><p>文件(document)与计算机文件(file)</p>
</li>
<li>文件名是由字母、数字和其他符号组成的一个字符串，其格式和长度因系统而异</li>
</ul>
<h4 id="文件的命名"><a href="#文件的命名" class="headerlink" title="文件的命名"></a>文件的命名</h4><ul>
<li>文件命名一般包括文件名和扩展名：<ul>
<li>前者用于识别文件，后者用于标识文件特性，两者之间用圆点隔开</li>
</ul>
</li>
<li>每个 OS 都有约定的扩展名，Windows中：<ul>
<li><code>.COM</code>表示可执行的二进制代码文件</li>
<li><code>.EXE</code>表示可执行的浮动二进制代码文件</li>
<li><code>.LIB</code>表示库程序文件</li>
<li><code>.BAT</code>表示批命令文件</li>
<li><code>.OBJ</code>表示编译或汇编生成的目标文件</li>
</ul>
</li>
<li>UNIX的约定文件名，请大家自己阅读</li>
</ul>
<h4 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h4><ul>
<li>按用途可分成：系统文件、库文件、用户文件</li>
<li>按保护级别可分成：只读文件、读写文件、不保护文件</li>
<li>按信息时限可分成：临时文件、永久文件、档案文件</li>
<li>按设备类型可分成：磁盘文件、磁带文件、光盘文件、软盘文件</li>
<li>还可以按文件的逻辑结构或物理结构分类</li>
</ul>
<h4 id="引入文件的优点"><a href="#引入文件的优点" class="headerlink" title="引入文件的优点"></a>引入文件的优点</h4><ul>
<li><strong>用户使用方便</strong>：使用者无需记住信息存放在辅助存储器中的物理位置，也无需考虑如何将信息存放到存储介质上，只要知道文件名，给出有关操作系统要求便可存取信息，实现了”按名存取”</li>
<li><p><strong>文件安全可靠</strong>：由于用户通过文件系统才能实现对文件的访问，而文件系统能提供各种安全、保密和保护措施，故可防止对文件信息的有意或无意的破坏或窃用</p>
</li>
<li><p><strong>文件可备份</strong>：可组织转储或备份，在文件使用过程中出现硬件故障时，文件系统可组织重执，提高可靠性</p>
</li>
<li><p><strong>文件可共享</strong>：文件系统还能提供文件的共享功能，如不同的用户可以使用同名或异名的同一文件，提高了文件和文件空间的利用率</p>
</li>
<li><p>总之，把数据组织成文件形式加以管理和控制是计算机数据管理的重大进展</p>
</li>
</ul>
<h3 id="5-1-2-文件系统及其功能"><a href="#5-1-2-文件系统及其功能" class="headerlink" title="5.1.2 文件系统及其功能"></a>5.1.2 文件系统及其功能</h3><h4 id="文件系统的概念"><a href="#文件系统的概念" class="headerlink" title="文件系统的概念"></a>文件系统的概念</h4><ul>
<li>文件系统是操作系统中负责存取和管理信息的模块，它用统一的方式管理用户和系统信息的存储、检索、更新、共享和保护，并为用户提供一整套方便有效的文件使用和操作方法</li>
</ul>
<h4 id="文件系统中的文件"><a href="#文件系统中的文件" class="headerlink" title="文件系统中的文件"></a>文件系统中的文件</h4><ul>
<li>文件这一术语不但反映了用户概念中的<strong>逻辑结构</strong>，而且和存放它的辅助存储器(也称文件存储器)的<strong>存储结构</strong>紧密相关</li>
<li>所以，同一个文件必须从<strong>逻辑文件</strong>和<strong>物理文件</strong>两个侧面来观察他</li>
</ul>
<h4 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h4><ul>
<li><p>文件系统面向用户的功能是</p>
<ul>
<li>文件的按名存取</li>
<li>文件的共享和保护</li>
<li>文件的操作和使用</li>
</ul>
</li>
<li><p>为了实现这些功能，OS 必须考虑</p>
<ul>
<li>文件目录的建立和维护</li>
<li>存储空间的分配和回收</li>
<li>数据的保密和保护</li>
<li>监督用户存取和修改文件的权限</li>
<li>实现在不同存储介质上信息的表示方式、编址方式、存储次序，以及信息检索等问题</li>
</ul>
</li>
</ul>
<h4 id="文件系统的组成"><a href="#文件系统的组成" class="headerlink" title="文件系统的组成"></a>文件系统的组成</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124135005799.png" alt="image-20221124135005799" style="zoom:80%;" /></p>
<h2 id="5-2-文件的组织"><a href="#5-2-文件的组织" class="headerlink" title="5.2 文件的组织"></a>5.2 文件的组织</h2><h3 id="5-2-1-文件的存储"><a href="#5-2-1-文件的存储" class="headerlink" title="5.2.1 文件的存储"></a>5.2.1 文件的存储</h3><h4 id="卷和块"><a href="#卷和块" class="headerlink" title="卷和块"></a>卷和块</h4><ul>
<li>文件存储介质有磁带、光盘和磁盘</li>
<li><strong>卷</strong>是存储介质的物理单位，对应于一盘磁带、一块软盘、一个光盘片、一个硬盘分区</li>
<li><strong>块</strong>是存储介质上连续信息所组成的一个区域，也叫做物理记录</li>
<li><p>块在主存储器和辅助存储器进行信息交换的物理单位，每次总是交换一块或整数块信息</p>
</li>
<li><p>决定块的大小要考虑用户使用方式、数据传输效率和存储设备类型等多种因素</p>
</li>
<li>不同类型的存储介质，块的长短常常各不相同；对同一类型的存储介质，块的大小一般相同，但也可以不同</li>
<li>外围设备由于启停机械动作或识别不同块的要求，两个相邻块之间必须留有间隙<ul>
<li>间隙是块之间不记录用户代码信息的区域</li>
</ul>
</li>
</ul>
<h4 id="顺序存取存储设备的信息安排"><a href="#顺序存取存储设备的信息安排" class="headerlink" title="顺序存取存储设备的信息安排"></a>顺序存取存储设备的信息安排</h4><ul>
<li>顺序存取设备是严格依赖信息的物理位置次序进行定位和读写的存储设备</li>
<li>磁带机是最常用的一种顺序存取存储设备，它具有存储容量大、稳定可靠、卷可装卸和便于保存等优点，广泛用作存档</li>
<li>磁带的一个突出特点是块长的变化范围较大，块可以很小，也可以很大，原则上没有限制</li>
<li>光盘也是一种顺序存取存储设备</li>
</ul>
<h4 id="直接存取存储设备的信息安排"><a href="#直接存取存储设备的信息安排" class="headerlink" title="直接存取存储设备的信息安排"></a>直接存取存储设备的信息安排</h4><ul>
<li>磁盘是一种直接存取存储设备，又叫随机存取存储设备</li>
<li>移臂与旋转两维组织，存取速度高</li>
<li>它的每个物理记录有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置</li>
</ul>
<h3 id="5-2-2-文件的逻辑结构"><a href="#5-2-2-文件的逻辑结构" class="headerlink" title="5.2.2 文件的逻辑结构"></a>5.2.2 文件的逻辑结构</h3><h4 id="逻辑文件"><a href="#逻辑文件" class="headerlink" title="逻辑文件"></a>逻辑文件</h4><ul>
<li><strong>逻辑文件</strong>，又称为<strong>文件的逻辑结构</strong><ul>
<li>独立于物理环境的，用户概念中的抽象信息组织方式</li>
<li>用户能观察到的，并加以处理的数据集合</li>
</ul>
</li>
<li>文件的逻辑结构分为两种形式<ul>
<li>一种是<strong>流式文件</strong></li>
<li>一种是<strong>记录式文件</strong></li>
</ul>
</li>
</ul>
<h4 id="流式文件"><a href="#流式文件" class="headerlink" title="流式文件"></a>流式文件</h4><ul>
<li><strong>流式文件</strong>指文件内的数据不再组成记录，只是由一串依次的字节组成的信息流序列</li>
<li>这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界</li>
</ul>
<h4 id="记录式文件"><a href="#记录式文件" class="headerlink" title="记录式文件"></a>记录式文件</h4><ul>
<li><strong>记录式文件</strong>是一种有结构的文件，它是若干逻辑记录信息所组成的记录流文件</li>
<li>逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</li>
<li>如，每个职工的工资信息是一个逻辑记录；整个单位职工的工资信息便组成了该单位工资信息的记录式文件</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124142641691.png" alt="image-20221124142641691" style="zoom:80%;" /></p>
<h4 id="记录式文件与数据库"><a href="#记录式文件与数据库" class="headerlink" title="记录式文件与数据库"></a>记录式文件与数据库</h4><ul>
<li>数据库管理系统也支持逻辑记录</li>
<li>但数据库有别于记录式文件，数据库中的记录之间可以通过数据冗余构成某种联系</li>
<li>数据库管理系统支持基于联系的数据查询，文件系统则不行</li>
</ul>
<h3 id="5-2-3-记录的成组与分解"><a href="#5-2-3-记录的成组与分解" class="headerlink" title="5.2.3 记录的成组与分解"></a>5.2.3 记录的成组与分解</h3><h4 id="成组与分解的提出"><a href="#成组与分解的提出" class="headerlink" title="成组与分解的提出"></a>成组与分解的提出</h4><ul>
<li><p>一个物理记录只存放一个逻辑记录可能造成极大的浪费</p>
</li>
<li><p>若干个逻辑记录合并成一组，写入一个块叫<strong>记录的成组</strong>，每块中的逻辑记录数称<strong>块因子</strong></p>
</li>
<li>对于流式文件，一个物理记录可以存放很多个连续字节</li>
</ul>
<h4 id="成组与分解操作"><a href="#成组与分解操作" class="headerlink" title="成组与分解操作"></a>成组与分解操作</h4><ul>
<li>系统设置独立于用户数据区的输入/输出缓冲区</li>
<li><strong>记录的成组操作</strong>在输出缓冲区内进行，凑满一块后才将缓冲区内的信息写到存储介质上</li>
<li>当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离出来的操作叫<strong>记录的分解操作</strong></li>
</ul>
<h4 id="成组与分解操作示意"><a href="#成组与分解操作示意" class="headerlink" title="成组与分解操作示意"></a>成组与分解操作示意</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124145408709.png" alt="image-20221124145408709" style="zoom:80%;" /></p>
<h4 id="成组与分解的特征"><a href="#成组与分解的特征" class="headerlink" title="成组与分解的特征"></a>成组与分解的特征</h4><ul>
<li>优点：记录成组与分解不仅节省存储空间，还能减少输入输出操作次数，提高系统效率</li>
<li>记录成组与分解处理带来的新特征：<ul>
<li>用户读请求，导致包含该逻辑记录的物理块读入输入缓冲区；这一操作可能读入了多个逻辑记录，这一现象称为<strong>提前读</strong></li>
<li>用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出，这一现象称为<strong>推迟写</strong></li>
</ul>
</li>
</ul>
<h3 id="5-2-4-文件的物理结构"><a href="#5-2-4-文件的物理结构" class="headerlink" title="5.2.4 文件的物理结构"></a>5.2.4 文件的物理结构</h3><h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><ul>
<li><strong>文件的物理结构和组织</strong>是指文件在物理存储空间中的存放方法和组织关系</li>
<li>又称为物理文件</li>
<li>文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等许多问题</li>
<li>其优劣直接影响文件系统的性能</li>
</ul>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><ul>
<li>将一个文件中逻辑上连续的信息存放到存储介质的依次相邻的块中便形成顺序结构，这类文件叫顺序文件，又称连续文件</li>
<li>磁带文件、光盘文件是典型例子</li>
</ul>
<h4 id="顺序文件的优缺点"><a href="#顺序文件的优缺点" class="headerlink" title="顺序文件的优缺点"></a>顺序文件的优缺点</h4><ul>
<li><strong>优点</strong>：顺序存取记录时速度较快<ul>
<li>批处理文件，系统文件用得最多</li>
<li>采用磁带存放顺序文件时，总可以保持快速存取的优点</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>建立文件前需要能预先确定文件长度，以便分配存储空间</li>
<li>修改、插入和增加文件记录有困难</li>
</ul>
</li>
</ul>
<h4 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h4><ul>
<li>连接文件，又称串联文件；连接结构的特点是使用连接字来表示文件中各个物理块之间的先后次序</li>
<li>第一块文件信息的物理地址由文件目录给出，而每一块的连接字指出了文件的下一个物理块位置；连接字内容为 0 时，表示文件至本块结束</li>
<li>像输入井、输出井等都用此类文件</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124144402437.png" alt="image-20221124144402437" style="zoom:80%;" /></p>
<h4 id="连接文件的特点"><a href="#连接文件的特点" class="headerlink" title="连接文件的特点"></a>连接文件的特点</h4><ul>
<li><strong>优点</strong><ul>
<li>易于对文件记录做增、删、改，易于动态增长记录</li>
<li>不必预先确知文件长度</li>
<li>存储空间利用率高</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>存放指针需额外的存储空间</li>
<li>由于存取须通过缓冲区，待获得连接字后，才能找到下一物理块的地址，因而，仅适用于顺序存取</li>
</ul>
</li>
</ul>
<h4 id="直接文件"><a href="#直接文件" class="headerlink" title="直接文件"></a>直接文件</h4><ul>
<li><strong>直接文件</strong>，又称<strong>散列文件</strong>，它通过计算记录的关键字建立与其物理存储地址之间的对应关系</li>
<li>这种变换通常采用散列法 (hash法)</li>
<li>计算寻址结构可能出现’冲突’，即不同的关键字可能变换出相同的地址来，解决办法有拉链法、循环探查法、二次散列法、溢出区法等</li>
</ul>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><ul>
<li>索引文件为每个文件建立了一张索引表，其中，每个表目包含一个记录的键(或逻辑记录号)及其存储地址</li>
<li>索引表的地址可由文件目录指出，查阅索引表先找到相应记录键(或逻辑记录号)，然后获得数据存储地址</li>
</ul>
<h4 id="索引文件的访问方式"><a href="#索引文件的访问方式" class="headerlink" title="索引文件的访问方式"></a>索引文件的访问方式</h4><ul>
<li>索引文件在文件存储器上分两个区：<strong>索引区和数据区</strong></li>
<li>访问索引文件需两步操作：第一步查找索引表，第二步获得记录物理地址</li>
<li>需要两次访问辅助存储器，若文件索引已预先调入主存储器，那么，就可减少一次内外存信息交换</li>
</ul>
<h4 id="索引文件的特点"><a href="#索引文件的特点" class="headerlink" title="索引文件的特点"></a>索引文件的特点</h4><ul>
<li>索引结构可以被认为是连接结构的一种扩展，除了具备连接文件的优点外，还克服了它只能作顺序存取的缺点，具有直接读写任意一个记录的能力，便于文件的增、删、改</li>
<li>索引文件的<strong>缺点</strong>是：增加了索引表的空间开销和查找时间</li>
</ul>
<h4 id="索引表的组织"><a href="#索引表的组织" class="headerlink" title="索引表的组织"></a>索引表的组织</h4><ul>
<li>一级索引</li>
<li>二级索引</li>
<li>多级索引</li>
</ul>
<h4 id="一种多级索引结构"><a href="#一种多级索引结构" class="headerlink" title="一种多级索引结构"></a>一种多级索引结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124145124548.png" alt="image-20221124145124548" style="zoom:80%;" /></p>
<h2 id="5-3-文件目录"><a href="#5-3-文件目录" class="headerlink" title="5.3 文件目录"></a>5.3 文件目录</h2><h3 id="5-3-1-文件目录结构"><a href="#5-3-1-文件目录结构" class="headerlink" title="5.3.1 文件目录结构"></a>5.3.1 文件目录结构</h3><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><ul>
<li>文件目录是实现文件的 <strong>“按名存取”</strong> 的关键数据结构</li>
<li>文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求编排的目录便于查找、防止冲突</li>
<li>文件目录需要永久保存，因此也组织成文件存放在磁盘上，称<strong>目录文件</strong></li>
</ul>
<h4 id="一级目录结构"><a href="#一级目录结构" class="headerlink" title="一级目录结构"></a>一级目录结构</h4><ul>
<li>一级目录结构：在操作系统中构造一张线性表，与每个文件的相关属性占用一个目录项，构成了一级目录结构</li>
<li>由于用户与文件众多，容易重名，不利记忆</li>
</ul>
<h4 id="二级目录结构"><a href="#二级目录结构" class="headerlink" title="二级目录结构"></a>二级目录结构</h4><ul>
<li>第一级为主文件目录，它用于管理所有用户文件目录，它的目录项登记了系统接受的用户的名字及该用户文件目录的地址</li>
<li>第二级为用户的文件目录，它为该用户的每个文件保存一个登记栏，其内容与一级目录的目录项相同</li>
<li>每一用户只允许查看自己的文件目录</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124151737496.png" alt="image-20221124151737496" style="zoom:80%;" /></p>
<h4 id="二级目录结构的特点"><a href="#二级目录结构的特点" class="headerlink" title="二级目录结构的特点"></a>二级目录结构的特点</h4><ul>
<li>采用二级目录管理文件时，因为任何文件的存取都通过主文件目录，于是可以检查访问文件者的存取权限，避免一个用户未经授权就存取另一个用户的文件，使用户文件的私有性得到保证，实现了对文件的保密和保护</li>
<li>特别是不同用户具有同名文件时，由于各自有不同的用户文件目录而不会导致混乱</li>
<li>对于同一个用户而言，同样存在文件多、容易重名问题</li>
</ul>
<h4 id="树形目录结构"><a href="#树形目录结构" class="headerlink" title="树形目录结构"></a>树形目录结构</h4><ul>
<li>每一级目录可以登记下一级目录，也可以登记文件，从而，形成了<strong>层次文件目录结构</strong></li>
<li>层次目录结构通常采用<strong>树形目录结构</strong>，它是一棵倒向的有根树，树根是根目录；从根向下，每一个树分叉是一个子目录；而树叶是文件</li>
</ul>
<h4 id="树形目录结构的特点"><a href="#树形目录结构的特点" class="headerlink" title="树形目录结构的特点"></a>树形目录结构的特点</h4><ul>
<li>较好地反映现实世界中具有层次关系的数据集合和较确切地反映系统内部文件的组织结构</li>
<li>不同文件可以重名，只要它们不位于同一末端的子目录中</li>
<li>易于规定不同层次或子树中文件的不同存取权限，便于文件的保护、保密和共享</li>
</ul>
<h4 id="树形目录结构中的文件定位"><a href="#树形目录结构中的文件定位" class="headerlink" title="树形目录结构中的文件定位"></a>树形目录结构中的文件定位</h4><ul>
<li>在树形目录结构中，一个文件的全名包括从根目录开始到文件为止，通路上遇到的所有子目录路径，又称为路径名</li>
<li>各子目录名之间用正斜线 / (反斜线 \ )隔开</li>
<li>一个硬盘分区可以组织成一颗子树<ul>
<li>每棵子树可以对应于一个逻辑盘符(Win)</li>
<li>也可以把众多子树嫁接成一颗大树(UNIX)</li>
</ul>
</li>
</ul>
<h4 id="树形目录结构-1"><a href="#树形目录结构-1" class="headerlink" title="树形目录结构"></a>树形目录结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221124152156116.png" alt="image-20221124152156116" style="zoom:80%;" /></p>
<h3 id="5-3-2-文件目录管理"><a href="#5-3-2-文件目录管理" class="headerlink" title="5.3.2 文件目录管理"></a>5.3.2 文件目录管理</h3><h4 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h4><ul>
<li>文件查找是文件目录管理的重要工作，”按名存取”文件就是系统根据用户提供的<strong>文件路径名</strong>来搜索各级文件目录，找到该文件<ul>
<li>可以从根目录查起(绝对路径名)</li>
<li>也可以从”当前目录”查起(相对路径名)，用.表示当前目录，..表示父目录</li>
<li>现代操作系统都设置有改变工作目录命令，即变更当前工作目录</li>
</ul>
</li>
</ul>
<h4 id="目录项查找"><a href="#目录项查找" class="headerlink" title="目录项查找"></a>目录项查找</h4><ul>
<li>搜索具体目录项时，可以采用顺序查找法，依次扫描文件目录中的目录项，将目录项中的名字与欲查找的文件名相比较</li>
<li>可以采用一些优化办法加快查找目录的速度<ul>
<li>目录表项是按键的顺序编排，则可以采用”二分查找法”</li>
<li>或者采用”杂凑法”，把每个文件名经过变换函数变换成唯一的目录表表项</li>
</ul>
</li>
</ul>
<h4 id="文件目录处理"><a href="#文件目录处理" class="headerlink" title="文件目录处理"></a>文件目录处理</h4><ul>
<li>树型目录结构存在的一个问题是：当一个文件经过许多目录节点时，使用很不方便；系统在沿路径查找目录时，往往要多次访问文件存储器，使访问速度大大减慢</li>
<li>若把所有文件的目录都复制到主存，访问速度是加快了，但又增加了主存的开销</li>
<li>一种有效办法是把常用和正在使用的那些文件目录复制进主存，这样，既不增加太多的主存开销，又可明显减少目录查找时间</li>
</ul>
<h4 id="活动文件表"><a href="#活动文件表" class="headerlink" title="活动文件表"></a>活动文件表</h4><ul>
<li>系统可以为每个用户进程建立一张活动文件表，当用户使用一个文件之前，先通过”打开”操作，把该文件有关目录信息复制到指定主存区域，有关信息填入活动文件表，以建立用户进程和该文件索引的联系</li>
<li>当不再使用该文件时，使用”关闭”，切断用户进程和这个文件的联系，同时，若该目录已被修改过，则应更新辅存中对应的文件目录</li>
</ul>
<h2 id="5-4-文件的共享、保护和保密"><a href="#5-4-文件的共享、保护和保密" class="headerlink" title="5.4 文件的共享、保护和保密"></a>5.4 文件的共享、保护和保密</h2><h3 id="5-4-1-文件的安全与保护"><a href="#5-4-1-文件的安全与保护" class="headerlink" title="5.4.1 文件的安全与保护"></a>5.4.1 文件的安全与保护</h3><h4 id="文件的安全与保护"><a href="#文件的安全与保护" class="headerlink" title="文件的安全与保护"></a>文件的安全与保护</h4><ul>
<li>文件是计算机系统的重要资源，因此，要求文件系统具有保障文件安全的手段，提供文件保密的措施，有效地实现文件的共享</li>
<li><strong>文件共享</strong>是指不同用户共同使用某些文件</li>
<li><strong>文件保护</strong>是指防止文件被破坏</li>
<li><strong>文件保密</strong>则是指防止文件及其内容被其他用户窃取</li>
</ul>
<h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><ul>
<li>文件共享是计算机用户完成共同任务所必需的</li>
<li>文件共享带来许多好处，如：<ul>
<li>减少用户大量重复性劳动</li>
<li>免除系统复制文件的工作</li>
<li>节省文件占用的存储空间</li>
<li>减少程序设计输入输出文件的次数</li>
</ul>
</li>
</ul>
<h4 id="文件共享的并发控制"><a href="#文件共享的并发控制" class="headerlink" title="文件共享的并发控制"></a>文件共享的并发控制</h4><ul>
<li>在允许文件共享的系统中，操作系统应提供手段实现对共享文件的同步控制</li>
<li>多个进程可能同时存取一个文件，如果它们同时进行读操作，操作系统应对文件进行公用控制</li>
<li>如果有进程进行写操作，例如，有两个进程，进程A要求修改文件，同时进程B要求读出同一文件中的数据，则操作系统必须提供同步控制机制，以保证文件数据的完整性</li>
</ul>
<h4 id="文件的保密措施"><a href="#文件的保密措施" class="headerlink" title="文件的保密措施"></a>文件的保密措施</h4><ul>
<li>文件保密是指文件及其内容不能被未经文件主授权的其他用户窃取</li>
<li>文件的保密措施有以下几种：<ol>
<li>隐蔽文件目录</li>
<li>设置口令</li>
<li>使用密码</li>
</ol>
</li>
</ul>
<h3 id="5-4-2-文件的保护"><a href="#5-4-2-文件的保护" class="headerlink" title="5.4.2 文件的保护"></a>5.4.2 文件的保护</h3><h4 id="文件的保护"><a href="#文件的保护" class="headerlink" title="文件的保护"></a>文件的保护</h4><ul>
<li><strong>文件保护</strong>是指防止文件被破坏</li>
<li>操作系统必须提供文件保护机制，有效实现文件的完整性</li>
<li>常用的文件保护办法<ul>
<li>文件副本</li>
<li>文件存取矩阵与文件存取表</li>
<li>文件属性</li>
</ul>
</li>
</ul>
<h4 id="文件的副本"><a href="#文件的副本" class="headerlink" title="文件的副本"></a>文件的副本</h4><ul>
<li>文件系统必须要有防止硬软件故障，保存信息完整性的能力</li>
<li>文件副本是主要实现机制<ul>
<li>动态多副本技术</li>
<li>转储、备份与恢复</li>
</ul>
</li>
</ul>
<h4 id="动态多副本"><a href="#动态多副本" class="headerlink" title="动态多副本"></a>动态多副本</h4><ul>
<li>第一种办法是在多个介质上维持同一内容的文件，并且在更新内容时同时进行</li>
<li>这种方法需要增加设备费用和系统负载，一般适用于容量较小且较为重要的文件，例如不需更新的系统文件及专用文件，当文件发生故障时只要切换到备用设备就可</li>
</ul>
<h4 id="文件转储"><a href="#文件转储" class="headerlink" title="文件转储"></a>文件转储</h4><ul>
<li>文件转储：定时把文件复制转储到其它介质上，当某介质上出现故障时，复原转储文件</li>
<li>转储又可分成两种方式：<ul>
<li>一是在一定时间间隔或一个单位处理结束时，系统自动复写更新过的文件和数据</li>
<li>二是每天或每周把文件信息全部复写一遍，需要时再通过装入转储文件来恢复系统，诸如BACKUP、RESTORE等命令</li>
</ul>
</li>
</ul>
<h4 id="文件的存取控制矩阵"><a href="#文件的存取控制矩阵" class="headerlink" title="文件的存取控制矩阵"></a>文件的存取控制矩阵</h4><ul>
<li>系统为每个用户设置访问每个文件对象的存取属性</li>
<li>系统的全部用户对全部文件的存取属性就组成的一个二维矩阵，称为存取控制矩阵</li>
<li><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205103154217.png" alt="image-20221205103154217" style="zoom:80%;" /></li>
</ul>
<h4 id="存取控制表"><a href="#存取控制表" class="headerlink" title="存取控制表"></a>存取控制表</h4><ul>
<li>由于操作系统拥有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵，可以将其简化为一张存取控制表</li>
<li>每行包括：用户、文件、存取属性</li>
<li>存取控制表仅登记那些对文件拥有存取属性的部分</li>
</ul>
<h4 id="基于存取控制矩阵-表的文件保护"><a href="#基于存取控制矩阵-表的文件保护" class="headerlink" title="基于存取控制矩阵/表的文件保护"></a>基于存取控制矩阵/表的文件保护</h4><ul>
<li>存取属性：可以有访问、读、写、执行、创建、删除、授权等等</li>
<li>系统通过查阅(矩阵/表)核对用户对文件的存取权限</li>
<li>文件属主使用GRANT、REVOKE等命令进行授权，甚至把授权权转授给他信任的用户</li>
<li>系统管理用户(超级用户)等同于文件属主权限，并获得对系统文件的授访问权权限</li>
</ul>
<h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><ul>
<li>存取控制表的一种简化方法是用户分类，再针对每类用户规定文件属性</li>
<li>用户分类：属主、合作者、其他</li>
<li>文件属性：读、写、执行、…</li>
<li>文件属性可以放在文件目录项中，管理大为简化</li>
<li>用户使用文件时，通过核对文件属性，实现保护</li>
</ul>
<h4 id="文件属性的例子"><a href="#文件属性的例子" class="headerlink" title="文件属性的例子"></a>文件属性的例子</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205103440530.png" alt="image-20221205103440530" style="zoom:80%;" /></p>
<h2 id="5-5-文件的使用"><a href="#5-5-文件的使用" class="headerlink" title="5.5 文件的使用"></a>5.5 文件的使用</h2><h3 id="5-5-1-文件的存取方法"><a href="#5-5-1-文件的存取方法" class="headerlink" title="5.5.1 文件的存取方法"></a>5.5.1 文件的存取方法</h3><h4 id="文件的存取方法"><a href="#文件的存取方法" class="headerlink" title="文件的存取方法"></a>文件的存取方法</h4><ul>
<li>文件存取方法是操作系统为用户程序提供的使用文件的技术和手段</li>
<li>文件存取方法在某种程度上依赖于文件的物理结构</li>
</ul>
<h4 id="顺序存取"><a href="#顺序存取" class="headerlink" title="顺序存取"></a>顺序存取</h4><ul>
<li>按记录顺序进行读／写操作的存取方法称顺序存取</li>
<li>读操作根据<strong>读指针</strong>读出当前记录，同时推进读指针，指向下一次要读出的记录</li>
<li>写操作则设置<strong>写指针</strong>，把一个记录写到文件末端，同时推进写指针</li>
<li>允许对读指针进行前跳或后退 n (整数)个记录的操作</li>
</ul>
<h4 id="直接存取"><a href="#直接存取" class="headerlink" title="直接存取"></a>直接存取</h4><ul>
<li>很多应用场合要求快速地以任意次序直接读写某个记录</li>
<li>例如，航空订票系统，用航班号作标识，把特定航班的所有信息存放在物理块中，用户预订某航班时，直接计算出该航班的存位置</li>
</ul>
<h4 id="索引存取"><a href="#索引存取" class="headerlink" title="索引存取"></a>索引存取</h4><ul>
<li>基于索引文件的索引存取方法</li>
<li>对于这种文件，信息块的地址都可以通过查找记录键而换算出</li>
<li>除可采用按键存取外，也可以采用顺序存取或直接存取的方法</li>
<li>实际的系统中，大都采用多级索引，以加速记录查找过程</li>
</ul>
<h3 id="5-5-2-文件的使用"><a href="#5-5-2-文件的使用" class="headerlink" title="5.5.2 文件的使用"></a>5.5.2 文件的使用</h3><h4 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h4><ul>
<li>用户通过两类接口与文件系统联系</li>
<li>第一类是与文件有关的操作命令，例如，UNIX中的<code>cat，cd，cp，find，mv， rm，mkdir，rmdir</code>等等</li>
<li>第二类是提供给用户程序使用的文件类系统调用，基本文件类系统调用有：建立、打开、读/写、定位、关闭、撤销</li>
</ul>
<h4 id="建立文件"><a href="#建立文件" class="headerlink" title="建立文件"></a>建立文件</h4><ul>
<li>“建立文件” 用于创建一个文件</li>
<li>所需参数：文件名、设备类(号)、文件属性及存取控制信息</li>
<li>处理流程：在相应设备上建立一个文件目录项，为文件分配第一个物理块，在活动文件表中申请一个项，登记有关目录信息，并返回一个文件句柄</li>
</ul>
<h4 id="撤销文件"><a href="#撤销文件" class="headerlink" title="撤销文件"></a>撤销文件</h4><ul>
<li>“撤销文件”用于删除一个文件</li>
<li>所需参数：文件名和设备类(号)</li>
<li>处理流程：若文件没有关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删去相应目录项；释放文件占用的文件存储空间</li>
</ul>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><ul>
<li>“打开文件” 用于建立起文件和用户进程之间的使用联系</li>
<li>所需参数：文件名、设备类(号)、打开方式</li>
<li>处理流程：在主存活动文件表中申请一个项，返回一个文件句柄；根据文件名查找目录文件，把目录信息复制到活动文件表相应栏；按存取控制说明检查访问的合法性；若打开的是共享文件，则应有相应处理</li>
</ul>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><ul>
<li>“关闭文件” 用于结束一个文件的读写</li>
<li>所需参数：文件句柄</li>
<li>处理流程：将活动文件表中该文件的”当前使用用户数”减1；若此值为0，则收回此活动文件表；完成”推迟写”；若活动文件表目内容已被改过，则应先将表目内容写回文件存储器上相应表目中，以使文件目录保持最新状态</li>
</ul>
<h4 id="读-写文件"><a href="#读-写文件" class="headerlink" title="读/写文件"></a>读/写文件</h4><ul>
<li>“读/写文件”用于读写文件</li>
<li>所需参数参数：文件句柄、用户数据区地址、读写的记录或字节个数</li>
<li>处理流程：按文件句柄从活动文件表中找到该文件的目录项信息；根据目录项指出的该文件的逻辑和物理组织方式，把相关逻辑记录转换成物理块</li>
</ul>
<h4 id="定位文件"><a href="#定位文件" class="headerlink" title="定位文件"></a>定位文件</h4><ul>
<li>“定位文件”用于调整所打开文件的读写指针位置</li>
<li>所需参数：文件句柄，定位指针</li>
</ul>
<h2 id="5-6-文件系统的实现"><a href="#5-6-文件系统的实现" class="headerlink" title="5.6 文件系统的实现"></a>5.6 文件系统的实现</h2><h3 id="5-6-1-辅存空间管理"><a href="#5-6-1-辅存空间管理" class="headerlink" title="5.6.1 辅存空间管理"></a>5.6.1 辅存空间管理</h3><h4 id="辅存空间管理"><a href="#辅存空间管理" class="headerlink" title="辅存空间管理"></a>辅存空间管理</h4><ul>
<li>磁盘等大容量辅存空间被OS及许多用户共享，用户进程运行期间常常要建立和删除文件，OS应能自动管理和控制辅存空间</li>
<li>随着用户文件不断建立和撤销，文件存储空间会出现许多’碎片’</li>
<li>OS解决’碎片’的办法是整理’碎片’；在整理过程中，往往对文件重新组织，让其存放在连续存储区中</li>
</ul>
<h4 id="辅存空间的分配方式"><a href="#辅存空间的分配方式" class="headerlink" title="辅存空间的分配方式"></a>辅存空间的分配方式</h4><ul>
<li>连续分配：存放在辅存空间连续存储区中(连续的物理块号)<ul>
<li>优点是顺序访问时速度快，管理较为简单，但为了获得足够大的连续存储区，需<strong>定时进行’碎片’整理</strong></li>
</ul>
</li>
<li>非连续分配：动态分配给若干扇区或簇(几个连续扇区)，不要求连续<ul>
<li>优点是辅存空间管理效率高，便于<strong>文件动态增长和收缩</strong></li>
</ul>
</li>
</ul>
<h4 id="空闲块的管理-位示图"><a href="#空闲块的管理-位示图" class="headerlink" title="空闲块的管理: 位示图"></a>空闲块的管理: 位示图</h4><ul>
<li>使用若干字节构成一张表，表中每一字位对应一个物理块，字位的次序与块的相对次序一致。</li>
<li>字位为”1”表示相应块已占用，字位为”0”状态表示该块空闲</li>
<li>其主要优点是，可以把位示图全部或大部分保存在主存中，再配合现代计算机都具有的位操作指令，可实现高速物理块分配和去配</li>
</ul>
<h4 id="空闲块的管理：空闲块成组连接法"><a href="#空闲块的管理：空闲块成组连接法" class="headerlink" title="空闲块的管理：空闲块成组连接法"></a>空闲块的管理：空闲块成组连接法</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208010437962.png" alt="image-20221208010437962" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208010507041.png" alt="image-20221208010507041" style="zoom:80%;" /></p>
<h3 id="5-6-2-文件系统的实现层次"><a href="#5-6-2-文件系统的实现层次" class="headerlink" title="5.6.2 文件系统的实现层次"></a>5.6.2 文件系统的实现层次</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208010558457.png" alt="image-20221208010558457" style="zoom:80%;" /></p>
<h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><h2 id="1-Inode、目录项、层次目录结构"><a href="#1-Inode、目录项、层次目录结构" class="headerlink" title="1. Inode、目录项、层次目录结构"></a>1. Inode、目录项、层次目录结构</h2><h4 id="Linux特殊目录项建立方法"><a href="#Linux特殊目录项建立方法" class="headerlink" title="Linux特殊目录项建立方法"></a>Linux特殊目录项建立方法</h4><p>Linux系统的 FCB 中的文件名和其他管理信息分开，其他信息单独组成一个数据结构，称为索引节点 inode，此索引节点在磁盘上的位置由 inode号 标识。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205082251475.png" alt="image-20221205082251475" style="zoom:80%;" /></p>
<blockquote>
<p>文件名(含路径) $\stackrel{目录检索}{\longrightarrow}$ 目录项 $\longrightarrow$ [文件名(不含路径), inode号]</p>
</blockquote>
<h4 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h4><ul>
<li>文件系统中的每个文件都有一个磁盘 inode 与之对应，这些inode被集中存放于磁盘上的 inode 区。FCB 对于文件的作用，犹如 PCB 对于进程的作用，集中这个文件的所有相关信息，找到inode，就能获得此文件的必要信息。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i_ino; <span class="hljs-comment">/*inode号*/</span><br>    <span class="hljs-type">atomic_t</span> i_count; <span class="hljs-comment">/*inode引用数*/</span><br>    <span class="hljs-type">kdev_t</span> i_dev; <span class="hljs-comment">/*inode所在设备*/</span><br>	...<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>数据块索引在union结构的每个具体文件系统中，其中的 <code>i_data[15]</code> 数组给出数据块地址索引<ul>
<li>前12项为直接索引，第13项为一次间接索引，第14项为二次间接索引，第15项为三次间接索引。</li>
</ul>
</li>
<li>磁盘 inode 记录文件的属性和相关信息，文件访问过程中会频繁地用到它，不断来回于内外存之间引用它，当然是极不经济的。为此，为此，在内存区开辟一张 活动inode 表。磁盘inode 反映文件静态特性，活动inode 反映文件动态特性。</li>
<li>当访问某文件时，若在活动inode 表中找不到其inode，就申请一个空闲活动 inode，把磁盘inode 内容复制给它，随之就可用来控制文件读写</li>
<li>当用户关闭文件时，活动inode 的内容回写到对应的磁盘inode 中，再释放活动inode 以供它用。把FCB的主要内容与索引节点号分开，不仅能够加快目录检索速度，而且，便于实现文件共享。</li>
</ul>
<h4 id="层次目录结构"><a href="#层次目录结构" class="headerlink" title="层次目录结构"></a>层次目录结构</h4><ul>
<li>每一级目录可以是下一级目录的说明，也可以是文件的说明，形成层次关系</li>
<li>多级目录结构采用<strong>树型结构</strong>，是一棵倒向有根树，树根是根目录；从根向下，每个树枝是一个子目录；而树叶是文件</li>
<li>树型多级目录优点:<ul>
<li>较好地反映现实世界中具有层次关系的数据集合和确切地反映系统内部文件的分支结构；</li>
<li><strong>不同文件可重名，只要它们不位于同一末端子目录中，易于规定不同层次或子目录中文件的不同存取权限，便于文件的保护、保密和共享</strong>等，有利于系统的维护和查找。</li>
</ul>
</li>
<li>如果规定每个文件都只有一个父目录，称为<strong>纯树型目录结构</strong>，其缺点是<strong>文件共享不是对称的，父目录有效拥有该文件，其他被授权用户必须经过属主目录才能对该文件进行访问</strong></li>
<li>有向无环图目录 尽管它<strong>允许文件有多个父目录而破坏树的特性</strong>，但不同用户可以对称方式实现文件共享，即可能属于不同用户的多个目录，使用不同文件名能访问和共享同一个文件。</li>
<li>有向无环图目录结构的维护比纯树型目录结构复杂，<strong>由于一个文件可能有多个父目录，需为每个文件维护一个引用计数，用来记录文件的父目录个数，仅当引用计数为1时，删除操作才移去文件，否则仅仅把相关记录从父目录中删去。</strong></li>
<li><strong>Linux支持多父目录，但其中一个是主父目录，它是文件拥有者</strong>，且文件被物理存储在此目录下，其他次父目录通过link方式来连结和引用文件，允许任一父目录删除共享文件。<ul>
<li>下图示例这种文件共享的情形，文件/home/fei1为myfile.c的主父目录(图中实线表示)，/home/fei2和/home/fei3/fei4均为文件myfile.c的次父目录(图中虚线表示)。</li>
</ul>
</li>
<li>Windows实现被称作”快捷方式”的多父目录连结，快捷方式是一些指向不同文件夹(子目录)和菜单之间任意复制和移动的文件及文件夹的指针，删除快捷方式就是删除指针。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205093920792.png" alt="image-20221205093920792" style="zoom:80%;" /></p>
<h2 id="2-Unix-Linux文件系统的多重索引结构"><a href="#2-Unix-Linux文件系统的多重索引结构" class="headerlink" title="2. Unix/Linux文件系统的多重索引结构"></a>2. Unix/Linux文件系统的多重索引结构</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205094000697.png" alt="image-20221205094000697" style="zoom:80%;" /></p>
<blockquote>
<p>在UNIX系统中，每个i节点中分别含有 10 个直接地址的索引和一、二、三级间接索引。若每个盘块放128个盘块地址，则一个1MB的文件分别占用多少各级索引所使用的数据物理块？20MB的文件呢？设每个盘块有512B。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205094103433.png" alt="image-20221205094103433" style="zoom:80%;" /></p>
</blockquote>
<h2 id="3-文件系统的功能与实现"><a href="#3-文件系统的功能与实现" class="headerlink" title="3. 文件系统的功能与实现"></a>3. 文件系统的功能与实现</h2><h3 id="3-1-文件系统调用的实现"><a href="#3-1-文件系统调用的实现" class="headerlink" title="3.1 文件系统调用的实现"></a>3.1 文件系统调用的实现</h3><ul>
<li>文件系统提供给用户程序的一组系统调用，包括：<strong>创建、删除、打开、关闭、读、写和控制</strong>，通过这些系统调用用户能获得文件系统的各种服务。</li>
<li>在为应用程序服务时，文件系统需要沿路径查找目录以获得该文件的各种信息，这往往要多次访问文件存储器，使访问速度减慢，若把所有文件目录都复制到主存，访问速度可加快，但却又增加主存开销。</li>
<li>方案: 把常用和正在使用的那些文件目录复制进主存，这样，<strong>既不增加太多主存开销，又可明显减少查找时间</strong></li>
<li>系统为每个用户进程建立一张活动文件表，用户使用文件之前先通过”打开”操作，把该文件的文件目录复制到指定主存区域</li>
<li>当不再使用该文件时，使用”关闭”操作切断和该文件目录的联系，这样，文件被打开后，可被用户多次使用，直至文件被关闭或撤销，大大减少访盘次数，提高文件系统的效率</li>
</ul>
<h4 id="文件系统磁盘结构"><a href="#文件系统磁盘结构" class="headerlink" title="文件系统磁盘结构"></a>文件系统磁盘结构</h4><ol>
<li><p>超级块：占用 1# 号块</p>
<ul>
<li><p>占用1#号块，存放文件系统结构和管理信息</p>
<blockquote>
<p>如记录inode表所占盘块数、文件数据所占盘块数、主存中登记的空闲盘块数、主存中登记的空闲块物理块号、主存中登记的空闲inode数、主存中登记的空闲inode编号，及其他文件管理控制信息</p>
</blockquote>
</li>
<li><p>可见超级块既有盘位示图的功能，又记录整个文件卷的控制数据。</p>
</li>
<li><p>每当一个块设备作为文件卷被安装时，该设备的超级块就要复制到主存系统区中备用，而拆卸文件卷时，修改过的超级块需复制回磁盘的超级块中。</p>
</li>
</ul>
</li>
<li><p>索引节点区：2#～k+1# 块</p>
<ul>
<li>存放inode表，每个文件都有各种属性，它们被记录在称为索引节点inode的结构中；所有inode都有相同大小，且inode表是inode结构的列表，文件系统中的每个文件在该表中都有一个inode。又分磁盘inode表和主存活动inode表，后者解决频繁访问磁盘inode表的效率问题</li>
</ul>
</li>
<li><p>数据区：k+2#～n# 为数据块 </p>
<ul>
<li>文件的内容保存在这个区域，磁盘上所有物理块的大小是一样的，如果文件包含超过一块的数据，则文件内容会存放在多个盘块中</li>
</ul>
</li>
</ol>
<h5 id="重要数据结构"><a href="#重要数据结构" class="headerlink" title="重要数据结构"></a>重要数据结构</h5><ul>
<li><strong>用户打开文件表</strong><ul>
<li>进程的PCB结构中保留一个files_struct，称为用户打开文件表或文件描述符表，表项的序号为文件描述符fd，该登记项内登记<strong>系统打开文件表的一个入口指针fp</strong>，通过此系统打开文件表项连接到打开文件的活动inode</li>
</ul>
</li>
<li><strong>系统打开文件表</strong><ul>
<li>是为解决多用户进程共享文件、父子进程共享文件而设置的系统数据结构file_struct，主存专门开辟最多可登记256项的系统打开文件表区，<strong>当打开一个文件时，通过此表项把用户打开文件表的表项与文件活动inode联接起来，以实现数据的访问和信息的共享</strong></li>
</ul>
</li>
<li><strong>主存活动inode表</strong><ul>
<li>为解决频繁访问磁盘索引节点inode表的效率问题，系统开辟的主存区，正在使用的文件的inode被调入主存活动索引节点inode中，以加快文件访问速度</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205100646528.png" alt="image-20221205100646528" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205100848938.png" alt="image-20221205100848938" style="zoom:80%;" /></p>
<h4 id="文件系统调用"><a href="#文件系统调用" class="headerlink" title="文件系统调用"></a>文件系统调用</h4><h5 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd, mode;<br><span class="hljs-type">char</span> *filenamep;<br>fd = create(filenamep, mode);<br></code></pre></td></tr></table></figure>
<ol>
<li>为新文件分配<strong>索引节点和活动索引节点</strong>，并把<strong>索引节点编号与文件分量名</strong>组成<strong>新目录项</strong>，记到目录中</li>
<li>在新文件所对应的活动索引节点中置初值，如<strong>置存取权限i_mode，连接计数i_nlink</strong>等</li>
<li>分配<strong>用户打开文件表项和系统打开文件表项，置表项初值，读写位移f_offset清”0”</strong></li>
<li>把各表项及文件<strong>对应的活动索引节点用指针连接起来</strong>，把文件描述字返回给调用者。</li>
</ol>
<h5 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h5><ul>
<li>删除把指定文件从所在的目录文件中除去</li>
<li>如果没有连接用户(i_link 为”1”)，还要把<strong>文件占用的存储空间释放</strong>。删除系统调用形式为：<code>unlink(filenamep)</code></li>
<li>在执行删除时，必须要求用户对该文件具有”写”操作权</li>
</ul>
<h5 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd, mode;<br><span class="hljs-type">char</span> * filenamep;<br>fd = open (filenamep, mode);<br></code></pre></td></tr></table></figure>
<ul>
<li>检索目录，把它的<strong>外存索引节点复制到活动索引节点表</strong></li>
<li>根据参数mode核对权限，如果非法，则这次打开失败</li>
<li>当”打开”合法时，<strong>为文件分配用户打开文件表项和系统打开文件表项</strong>，并为表项设置初值。<strong>通过指针建立这些表项与活动索引节点间的联系</strong>。把文件描述字，即用户打开文件表中相应<strong>文件表项的序号返回给调用者</strong></li>
</ul>
<h5 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd;<br>close (fd);<br></code></pre></td></tr></table></figure>
<ul>
<li>根据<strong>fd找到用户打开文件表项，再找到系统打开文件表项</strong>。<strong>释放</strong>用户打开文件表项</li>
<li>把对应<strong>系统打开文件表项中的f_count减”1”</strong>，如果非”0” ，说明还有进程共享这一表项，不用释放直接返回；否则释放表项</li>
<li>把<strong>活动索引节点中的i_count减”1”</strong> ，若不为”0”，表明还有用户进程正在使用该文件，不用释放而直接返回，<strong>否则在把该活动索引节点中的内容复制回文件卷上的相应索引节点中后，释放该活动索引节点</strong></li>
<li>f_count和i_count分别反映进程动态地共享一个文件的两种方式<ul>
<li>f_count<strong>反映不同进程通过同一个系统打开文件表项共享一个文件的情况</strong></li>
<li>i_count<strong>反映不同进程通过不同系统打开文件表项共享一个文件的情况</strong></li>
<li>通过两种方式，进程之间既可用相同的位移指针f_offset，也可用不同位移指针f_offset共享同一个文件</li>
</ul>
</li>
</ul>
<h5 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> nr, fd, count;<br><span class="hljs-type">char</span> buf [ ]<br>nr = read (fd, buf, count);<br></code></pre></td></tr></table></figure>
<ul>
<li>系统根据f_flag中的信息，<strong>检查读操作合法性</strong></li>
<li>再<strong>根据当前位移量f_offset值，要求读出的字节数</strong>，及活动索引节点中<strong>i_data[15]指出的文件物理块存放地址，把相应的物理块读到缓冲区中</strong>，然后再送到bufp指向的用户主存区中。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221205102611877.png" alt="image-20221205102611877" style="zoom:80%;" /></p>
<h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">nw = write(fd, buf, count);<br></code></pre></td></tr></table></figure>
<ul>
<li>buf是信息传送的源地址，即把buf所指向的用户主存区中的信息，写入到文件中。</li>
</ul>
<h5 id="文件的随机存取"><a href="#文件的随机存取" class="headerlink" title="文件的随机存取"></a>文件的随机存取</h5><ul>
<li>在文件初次”打开”时，文件的位移量<strong><code>f_offset</code></strong>清空为零，以后的文件读写操作总是根据offset的当前值，顺序地读写文件。为了支持文件的随机访问，提供系统调用<code>lseek</code>，它允许用户在读、写文件前，事先改变<code>f_offset</code>的指向</li>
<li>系统调用的形式为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> lseek;<br><span class="hljs-type">long</span> offset;<br><span class="hljs-type">int</span> whence, fd;<br>lseek(fd, offset, whence);<br></code></pre></td></tr></table></figure>
<ul>
<li>文件描述字 fd 必须指向一个用读或写方式打开的文件</li>
<li>当whence是”0”时，则f_offset被置为offset</li>
<li>当whence是”1”时，则f_offset被置为文件当前位置加上offset。</li>
</ul>
<h3 id="3-2-文件共享"><a href="#3-2-文件共享" class="headerlink" title="3.2 文件共享"></a>3.2 文件共享</h3><h4 id="文件的静态共享"><a href="#文件的静态共享" class="headerlink" title="文件的静态共享"></a>文件的静态共享</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">chat * oldnamep, * newnamep;<br>link(oldnamep, newnamep);<br></code></pre></td></tr></table></figure>
<ul>
<li>检索目录找到 <code>oldnamep</code> 所指向文件的索引节点inode编号</li>
<li>再次检索目录找到 <code>newnamep</code> 所指文件的父目录文件，并把已存在文件的索引节点inode编号与别名构成一个目录项，记入到该目录中去</li>
<li>把已存在文件索引节点inode的连接计数 <code>i_nlink</code> 加 1</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208130412662.png" alt="image-20221208130412662" style="zoom:80%;" /></p>
<ul>
<li>链接实际上是<strong>共享已存在文件的索引节点 inode</strong>，完成链接的系统调用<ul>
<li><code>link(&quot;/home/fei1/myfile.c&quot;, &quot;/home/fei2/myfile.c&quot;);</code></li>
<li><code>link(&quot;/home/fei1/myfile.c&quot;, &quot;/home/fei3/fei4/testfile.c&quot;);</code></li>
</ul>
</li>
<li>执行后，三个路径名指的是同一个文件:<ul>
<li><code>/home/fei1/myfile.c，/home/fei2/myfile.c，/home/fei3/fei4/testfile.c</code></li>
</ul>
</li>
</ul>
<p>文件解除链接调用形式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">unlink(namep);<br></code></pre></td></tr></table></figure>
<ul>
<li>解除链接与文件删除执行的是同一系统调用代码。删除文件是从文件主角度讲的，解除文件连接是从共享文件的其他用户角度讲的。都要删去目录项，把 i_nlink 减 “1”，不过，只有当i_nlink减为”0”时，才真正删除文件。</li>
</ul>
<h4 id="文件的动态共享"><a href="#文件的动态共享" class="headerlink" title="文件的动态共享"></a>文件的动态共享</h4><ul>
<li>文件动态共享是系统中不同的用户进程或同一用户的不同进程并发访问同一文件</li>
<li>这种共享关系只有当用户进程存在时才可能出现，一旦用户的进程消亡，其共享关系也就自动消失</li>
<li>文件的每次读写由一个读/写位移指针指出要读写的位置。现在的问题是：<strong>应让多个进程共用同一个读/写位移，还是各个进程具有各自的读写位移呢?</strong></li>
<li>同一用户父、子进程协同完成任务，使用同一读/写位移，同步地对文件进行操作</li>
<li>该位移指针宜放在相应文件的活动索引节点中。当用系统调用fork建立子进程时<strong>，父进程的PCB结构被复制到子进程的PCB结构中，使两个进程的打开文件表指向同一活动的索引节点，达到共享同一位移指针的目的。</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208133726368.png" alt="image-20221208133726368" style="zoom:80%;" /></p>
<ul>
<li>多用户共享文件，每个希望独立地读、写文件，这时不能只设置一个读写位移指针，须<strong>为每个用户进程分别设置一个读、写位移指针</strong></li>
<li><strong>位移指针应放在每个进程用户打开文件表的表目中</strong>。这样，当一个进程读、写文件，并修改位移指针时，另一个进程的位移指针不会随之改变，从而，使两个进程能独立地访问同一文件</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221208133846993.png" alt="image-20221208133846993" style="zoom:80%;" /></p>
<h4 id="文件的符号链接共享"><a href="#文件的符号链接共享" class="headerlink" title="文件的符号链接共享"></a>文件的符号链接共享</h4><ul>
<li>操作系统可支持多个物理磁盘或多个逻辑磁盘(分区)，那么，文件系统是建立一棵目录树还是多棵目录树呢?</li>
<li>Windows采用将盘符或卷标分配给磁盘或分区，并将其名字作为文件路径名的一部分。</li>
<li><p>UNIX/Linux的<strong>每个分区有自己的文件目录树</strong>，当有多个文件系统时，可通过安装的办法整合成一棵更大的文件目录树。</p>
</li>
<li><p>问题：系统中每个文件对应一个inode，编号是唯一的，但两个不同的磁盘或分区都含有相同inode号对应的文件，也就是说，整合的目录树中，inode号并不唯一地标识一个文件</p>
<ul>
<li>办法：拒绝创建跨越文件系统的硬链接</li>
</ul>
</li>
<li><p>符号链接又称软链接，是一种只有文件名，不指向inode的文件</p>
</li>
<li>符号链接共享文件的实现思想：<ul>
<li>用户A目录中形式为<code>afile -&gt; bfile</code>，实现A的目录与B的文件的链接。其中<strong>只包含被链接文件bfile的路径名</strong>而不是它的inode号，而<strong>文件的拥有者才具有指向inode的指针</strong></li>
<li>当用户A要访问被符号链接的用户B的文件bfile，且要读“符号链接”类文件时，被操作系统截获，它将依据符号链接中的路径名去读文件，于是就能实现用户A使用文件名afile对用户B的文件bfile的共享</li>
</ul>
</li>
<li>优点：能用于链接计算机系统中不同文件系统中的文件，可链接计算机网络中不同机器上的文件，此时，仅需提供文件所在机器地址和该机器中文件的路径名</li>
<li>缺点：搜索文件路径开销大，需要额外的空间查找存储路径。</li>
</ul>
<h3 id="3-3-文件空间管理"><a href="#3-3-文件空间管理" class="headerlink" title="3.3 文件空间管理"></a>3.3 文件空间管理</h3><p>磁盘文件空间分配采用两种办法</p>
<ul>
<li>连续分配：文件存放在辅存空间连续存储区中，在建立文件时，用户必须给出文件大小，然后，查找到能满足的连续存储区供使用。</li>
<li>非连续分配：一种方法是以块(扇区)为单位，扇区不一定要连续，同一文件的扇区按文件记录的逻辑次序用链指针连接或位示图指示</li>
<li>另一种方法是以簇为单位，簇是由若干个连续扇区组成的分配单位；实质上是连续分配和非连续分配的结合。各个簇可以用链指针、索引表，位示图来管理</li>
</ul>
<h4 id="磁盘空闲空间管理方法"><a href="#磁盘空闲空间管理方法" class="headerlink" title="磁盘空闲空间管理方法"></a>磁盘空闲空间管理方法</h4><p><strong>位示图</strong></p>
<ul>
<li>磁盘空间通常使用固定大小的块，<strong>可方便地用位示图管理，用若干字节构成一张位示图</strong>，其中每一字位对应一个物理块，字位的次序与块的相对次序一致，字位为‘1’表示相应块已占用，字位为‘0’表示该块空闲。</li>
<li>微型机操作系统VM/SP、Windows和Macintosh等操作系统均使用这种技术管理文件存储空间</li>
<li>主要优点是：每个盘块仅需 1 个附加位，如盘块长 1KB，位示图开销仅占 0.012%；可把位示图全部或大部分保存在主存，再配合现代机器都具有的位操作指令，实现高速物理块分配和去配</li>
</ul>
<p><strong>空闲区表</strong></p>
<ul>
<li>该方法常用于<strong>连续文件</strong>，将<strong>空闲存储块的位置及其连续空闲的块数构成一张表</strong>。</li>
<li>分配时，系统<strong>依次扫描空闲区表，寻找合适的空闲块并修改登记项</strong>；</li>
<li>删除文件释放空闲区时，把空闲区位置及连续的空闲区长度填入空闲区表，出现邻接的空闲区时，还需执行合并操作并修改登记项。</li>
<li>空闲区表的搜索算法有<strong>首次适应、邻近适应、最佳适应和最坏适应算法</strong>等，参见pp.239。</li>
</ul>
<p><strong>空闲块链</strong></p>
<ul>
<li><strong>把所有空闲块连接在一起</strong>，系统保持指针指向第一个空闲块，每一空闲块中包含指向下一空闲块的指针</li>
<li>申请一块时，从链头取一块并修改系统指针</li>
<li>删除时释放占用块，使其成为空闲块并将它挂到空闲链上</li>
<li>这种方法效率低，<strong>每申请一块都要读出空闲块并取得指针，申请多块时要多次读盘，但便于文件动态增长和收缩</strong></li>
</ul>
<h4 id="UNIX-Linux空闲块成组连接法"><a href="#UNIX-Linux空闲块成组连接法" class="headerlink" title="UNIX/Linux空闲块成组连接法"></a>UNIX/Linux空闲块成组连接法</h4><ul>
<li>存储空间分成 512 字节一块。假定文件卷启用时共有可用文件 338 块，编号从 12 至 349。每 100 块划分一组，<strong>每组第一块登记下一组空闲块的盘物理块号和空闲总数</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230203174705186.png" alt="image-20230203174705186" style="zoom:80%;" /></p>
<h3 id="3-4-主存映射文件"><a href="#3-4-主存映射文件" class="headerlink" title="3.4 主存映射文件"></a>3.4 主存映射文件</h3><ul>
<li>首先，用于读写文件的操作在功能与格式上与读写主存的操作有很大不同，如果能消除这种差异就能简化编程工作</li>
<li>其次，文件中的数据是一部分一部分在进程空间与磁盘空间之间传送，文件操作实现不但管理复杂且开销较大，能否找出一种方法既降低开销，又能通过直接读写主存来使用文件信息呢?</li>
<li>针对这一点，最早由MULTICS首创通过结合虚存管理和文件管理技术来提供一种新的文件使用方法，称主存映射文件，UNIX/Linux及Windows等现代操作系统都已实现这一功能。</li>
</ul>
<h4 id="主存映射文件"><a href="#主存映射文件" class="headerlink" title="主存映射文件"></a>主存映射文件</h4><p>什么是主存映射文件</p>
<ul>
<li>系统提供两个新的系统调用<ol>
<li>映射文件，有两个参数：一个文件名和一个虚拟地址，<strong>把一个文件映射到进程地址空间</strong>。</li>
<li>移去映射文件，让文件与进程地址空间断开，<strong>并把映射文件的数据写回磁盘文件</strong>。</li>
</ol>
</li>
<li>优点是：方便易用、节省空间、便于共享、灵活高效</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224141108533.png" alt="image-20230224141108533" style="zoom:80%;" /></p>
<p>优点：进程读写虚存内容相当于执行文件读写操作，在建立映射后，不再需要使用文件系统调用来读写数据，能大大降低开销；在主存中仅需一个页面副本，既节省空间，又不需要缓冲到主存的复制操作</p>
<h4 id="文件系统的系统视图"><a href="#文件系统的系统视图" class="headerlink" title="文件系统的系统视图"></a>文件系统的系统视图</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224142310663.png" alt="image-20230224142310663" style="zoom:80%;" /></p>
<h3 id="3-5-虚拟文件系统"><a href="#3-5-虚拟文件系统" class="headerlink" title="3.5 虚拟文件系统"></a>3.5 虚拟文件系统</h3><ul>
<li>第一个虚拟文件系统在1986年由Sun公司开发成功，并在SunOS中使用。</li>
<li>虚拟文件系统也称虚拟文件系统开关VFS (Virtual Filesystem Switch)</li>
<li>它是内核的一个子系统，提供一个通用文件系统模型，该模型概括所能见到的文件系统常用功能和行为，处理一切和底层设备驱动相关的细节，为应用程序提供标准的接口(文件系统API)。</li>
</ul>
<h4 id="虚拟文件系统要实现以下目标"><a href="#虚拟文件系统要实现以下目标" class="headerlink" title="虚拟文件系统要实现以下目标"></a>虚拟文件系统要实现以下目标</h4><ul>
<li>同时支持多种文件系统</li>
<li>多个文件系统应与传统的单一文件系统没有区别，在用户面前表现为一致的接口</li>
<li>提供通过网络共享文件的支持，访问远程结点上的文件系统应与访问本地结点的文件系统一致</li>
<li>可以开发出新的文件系统，以模块方式加入到操作系统中。</li>
</ul>
<h4 id="Linux虚拟文件系统"><a href="#Linux虚拟文件系统" class="headerlink" title="Linux虚拟文件系统"></a>Linux虚拟文件系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224143118663.png" alt="image-20230224143118663" style="zoom:80%;" /></p>
<h4 id="虚拟文件系统设计思想"><a href="#虚拟文件系统设计思想" class="headerlink" title="虚拟文件系统设计思想"></a>虚拟文件系统设计思想</h4><ol>
<li>应用层：<ul>
<li>VFS模型源于UNIX文件系统，使得用户可直接使用标准UNIX文件系统调用来操作文件，无需考虑具体文件系统特性和物理存储介质，通过VFS访问文件系统，才使得不同文件系统之间的协作性和通用性成为可能</li>
</ul>
</li>
<li>虚拟层：<ul>
<li>对所有具体文件系统的共同特性进行抽象的基础上，形成一个与具体文件系统实现无关的虚拟层，并在此层次上定义与用户的一致性接口</li>
</ul>
</li>
<li>实现层：<ul>
<li>该层使用类似开关表技术进行具体文件系统转接，实现各种具体文件系统的细节，每一个是自包含的，包含文件系统实现的各种设施，如超级块、节点区、数据区以及各种数据结构和文件类的操作函数</li>
</ul>
</li>
</ol>
<h4 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h4><p>VFS实质上是一种存在于主存中的，支持多种类型具体文件系统的运行环境，功能有：</p>
<ul>
<li>记录安装的文件系统类型</li>
<li>建立设备与文件系统的联系</li>
<li>实现面向文件的通用操作</li>
<li>涉及特定文件系统的操作时映射到具体文件系统中去。</li>
</ul>
<h4 id="Linux虚拟文件系统-1"><a href="#Linux虚拟文件系统-1" class="headerlink" title="Linux虚拟文件系统"></a>Linux虚拟文件系统</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224145414967.png" alt="image-20230224145414967" style="zoom:80%;" /></p>
<h4 id="VFS的组成"><a href="#VFS的组成" class="headerlink" title="VFS的组成"></a>VFS的组成</h4><ul>
<li>超级块对象 - 代表一个文件系统。<ul>
<li>存放已安装的文件系统信息，如果是基于磁盘的文件系统，该对象便对应于存放在磁盘上的文件系统控制块，每个文件系统都对应一个超级块对象。</li>
<li>如Ext2超级块，并被存放在磁盘特定扇区上，当内核对一个具体文件系统进行初始化和注册时，调用alloc_super()函数为其分配一个VFS超级块，并从磁盘读取具体文件系统超级块中的信息填充进来，即VFS超级块在具体文件系统安装时才建立，并在它们卸载时被自动删除，可见VFS超级块仅存于主存中。</li>
</ul>
</li>
<li>索引节点对象 - 代表一个文件。<ul>
<li>存放通用的文件信息，如果是基于磁盘的文件系统，该对象对应于存放在磁盘上的文件FCB，即每个文件的inode对象，而每个inode都有一个inode索引节点号，唯一地标识某个文件系统中的指定文件。</li>
<li>对于UNIX类文件系统来说，这些信息从磁盘inode直接读入VFS的inode对象中。可把具体文件系统存放在磁盘上的inode称为静态节点，它的内容被读入主存VFS的inode才能工作，后者也称为动态节点</li>
</ul>
</li>
<li>目录项对象 - 代表路径中的一个组成部分。<ul>
<li>存放目录项与对应文件进行链接的各种信息，VFS把最近最常使用的dentry对象放在目录项高速缓存中，加快文件路径名搜索过程，以提高系统性能</li>
</ul>
</li>
<li>文件对象 - 代表由进程已打开的一个文件。<ul>
<li>存放已打开文件与进程的交互信息，这些信息仅当进程访问文件期间才存于主存中</li>
<li>文件对象在执行系统调用open()时创建，执行系统调用close()时撤销。</li>
<li>每个文件都用一个32位数字来表示下一个读写的字节位置，通常称它为文件位置或偏移量(offset)，每当打开一个文件时，偏移量被置0，读写操作便从这里开始，允许通过系统调用lseek对文件位置作随机定位。</li>
<li>Linux建立文件对象(file)来保存打开文件的文件位置，file结构除保存文件当前位置外，还把指向该文件inode的目录项指针也放在其中，并形成一个双向链表，称系统打开文件表。</li>
<li>操作系统之所以不直接使用dentry结构是因为多个进程能够打开同一个文件，因为每一个file结构实际上对应了一个进程的一次打开过程。file结构中记录了文件访问模式，读写指针等信息。</li>
<li>文件描述符fd用来描述打开的文件，每个进程用一个files_struct结构来记录文件描述符的使用情况，这个结构称为用户打开文件表。</li>
<li>指向该结构的指针被保存在进程的task_struct结构的成员files中</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224150106624.png" alt="image-20230224150106624" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224150641250.png" alt="image-20230224150641250" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224151231371.png" alt="image-20230224151231371" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224153404909.png" alt="image-20230224153404909" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224153529284.png" alt="image-20230224153529284" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224153625151.png" alt="image-20230224153625151" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224153643673.png" alt="image-20230224153643673" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224153725825.png" alt="image-20230224153725825" style="zoom:80%;" /></p>
<h4 id="文件系统注册与注销，安装与卸载"><a href="#文件系统注册与注销，安装与卸载" class="headerlink" title="文件系统注册与注销，安装与卸载"></a>文件系统注册与注销，安装与卸载</h4><p>文件系统的注册与注销</p>
<ul>
<li>Linux支持多个物理磁盘，每个磁盘可划分为一个或多个磁盘分区，每个分区上可建立一个文件系统，一个安装好的Linux操作系统究竟支持几种不同类型的文件系统，是通过文件系统类型注册链表来描述的，VFS以链表形式管理已注册的具体文件系统。</li>
<li>向系统注册文件系统类型有两种途径<ul>
<li>一是在编译操作系统内核时确定可支持哪些文件系统，在文件系统被引导时，在VFS中进行注册</li>
<li>二是文件系统当作可装载模块，通过insmod/rmmod命令在装入该文件系统模块时向VFS注册/注销。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224153910074.png" alt="image-20230224153910074" style="zoom:80%;" /></p>
<ol>
<li><p>文件系统安装: 文件系统类型名、所在物理设备名、安装点，再用mount命令安装</p>
</li>
<li><p>文件系统安装过程: 寻找匹配的file_system_type、查找安装点VFS inode、分配一个VFS超级块、利用read_super()函数读入参数、申请一个vfsmount数据结构。</p>
</li>
<li>文件系统卸载过程: 是否可卸载、如果为“脏”把VFS超级块写回磁盘、删去vfsmount。</li>
</ol>
<h4 id="文件系统的缓存机制"><a href="#文件系统的缓存机制" class="headerlink" title="文件系统的缓存机制"></a>文件系统的缓存机制</h4><p>VFS inode缓存</p>
<ul>
<li>把当前使用的inode采用散列技术保存起来，从中快速找到所需inode</li>
</ul>
<p>VFS目录高速缓存</p>
<ul>
<li>系统维护表达路径与inode对应关系的VFS目录缓存，其中存放被访问过的目录。</li>
</ul>
<p>页高速缓冲区</p>
<ul>
<li>Linux维护一组页缓冲区，它独立于任何类型的文件系统，被所有物理设备所共享</li>
<li>优点：<ul>
<li>数据一经使用，就在页缓冲区中留下备份，再次使用时可直接找回，避免不必要的磁盘I/O</li>
<li>“脏”页写回磁盘时，可适当进行排序，实现磁盘驱动调度优化。</li>
</ul>
</li>
</ul>
<h4 id="EXT2文件系统"><a href="#EXT2文件系统" class="headerlink" title="EXT2文件系统"></a>EXT2文件系统</h4><ul>
<li>EXT(92年)和EXT2(94年)是专为Linux设计的可扩展文件系统。</li>
<li>EXT2把它所占用的磁盘逻辑分区划分为块组，每个块组依次包括超级块、组描述符表、块位示图、inode位示图、inode表以及数据块。</li>
<li>块位示图集中本组各数据块的使用情况</li>
<li>inode位示图记录inode表中inode的使用情况。</li>
<li>inode表保存本组所有的inode，inode用于描述文件，一个inode对应一个文件和子目录，有一个唯一的inode号，并记录了文件在外存的位置、存取权限、修改时间、类型等信息。</li>
</ul>
<h4 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230224155556986.png" alt="image-20230224155556986" style="zoom:80%;" /></p>
<h4 id="EXT2的超级块"><a href="#EXT2的超级块" class="headerlink" title="EXT2的超级块"></a>EXT2的超级块</h4><ul>
<li>Ext2超级块用来描述目录和文件在磁盘上的静态分布，包括尺寸和结构，每个块组都有一个超级块，只有块1的超级块才被读入主存工作，直至卸载，其他块组的超级块仅作为恢复备份。</li>
<li>超级块主要包括：块组编号、块数量、块长度(1KB至4KB)、空闲块数量、inode数量、空闲inode数量、第一个inode号、第一个数据块位置、每个块组中的块数、每个块组的inode数，以及安装时间、最后一次写时间、安装信息、文件系统状态信息等内容。</li>
</ul>
<h4 id="EXT2的组描述符"><a href="#EXT2的组描述符" class="headerlink" title="EXT2的组描述符"></a>EXT2的组描述符</h4><ul>
<li>数据块位示图。表示数据块位示图占用的块号，此位示图反映块组中数据块的分配情况，在分配或释放数据块时需使用数据块位示图。</li>
<li>inode位示图。表示inode位示图占用的块号，此位示图反映块组中inode的分配情况，在创建或删除文件时需使用inode位示图。</li>
<li>inode表。块组中inode占用的数据块数，系统中的每个文件对应一个inode，每个inode都由一个数据结构来描述。</li>
<li>空闲块数、空闲inode数和已用数目。</li>
</ul>
<h4 id="EXT2的inode"><a href="#EXT2的inode" class="headerlink" title="EXT2的inode"></a>EXT2的inode</h4><p>inode用于描述文件，一个inode对应一个文件和子目录，有一个唯一的inode号，并记录了文件的类型及存取权限、用户和组标识、修改/访问/创建/删除时间、link数、文件长度和占用块数、在外存的位置、以及其他控制信息。</p>
<h4 id="Linux数据块分配策略"><a href="#Linux数据块分配策略" class="headerlink" title="Linux数据块分配策略"></a>Linux数据块分配策略</h4><p>EXT2采用两个策略减少文件碎片</p>
<ul>
<li>原地先查找策略：为文件分配数据块时，尽量在文件原有数据块附近查找。先试探紧跟文件末尾的数据块，然后试探位于同一个块组相邻的64个数据块，接着在同一个块组中寻找其他空闲数据块；实在不得己才搜索其他块组，且首先考虑8个一簇的连续的块。</li>
<li>预分配策略：引入预分配机制，就从预分配的数据块取一块来用，紧跟该块后的若干个数据块空闲的话，也被保留，保证尽可能多的数据块被集中成一簇。</li>
<li>数据结构中包含属性prealloc_block和prealloc_count，前者指向可预分配数据块链表中第一块的位置，后者表示可预分配数据块的总数。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/18/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-3-CSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/18/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-3-CSS/" class="post-title-link" itemprop="url">Web前端开发(3) CSS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 14:44:25" itemprop="dateCreated datePublished" datetime="2022-11-18T14:44:25+08:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-CSS-Basics"><a href="#4-CSS-Basics" class="headerlink" title="4-CSS Basics"></a>4-CSS Basics</h1><h2 id="1-什么是CSS"><a href="#1-什么是CSS" class="headerlink" title="1 什么是CSS"></a>1 什么是CSS</h2><h3 id="1-1-CSS"><a href="#1-1-CSS" class="headerlink" title="1.1 CSS"></a>1.1 CSS</h3><ul>
<li>Cascading Style Sheets, 层叠样式表</li>
<li>CSS 用于设计风格和布局<ul>
<li>比如, 可以使用 CSS 来更改内容的字体、颜色、大小、间距, 将内容分为多列, 或者添加动画及其他装饰效果</li>
</ul>
</li>
</ul>
<blockquote>
<p>Cascading Style Sheets (CSS) is a style sheet language used for describing the presentation of a document written in a markup language such as HTML or XML (including XML dialects such as SVG, MathML or XHTML). CSS is a cornerstone technology of the World Wide Web, alongside HTML and JavaScript.(CSS - Wikipedia)</p>
</blockquote>
<h3 id="1-2-CSS-简史"><a href="#1-2-CSS-简史" class="headerlink" title="1.2 CSS 简史"></a>1.2 CSS 简史</h3><ul>
<li>1994 提出了 CSS 的最初建议</li>
<li>1996.12 W3C 终于推出了 CSS 规范的第一版本</li>
<li>1998 W3C 发布了 CSS2<ul>
<li>CSS2.1</li>
</ul>
</li>
<li>CSS3</li>
</ul>
<h3 id="1-3-CSS-优势"><a href="#1-3-CSS-优势" class="headerlink" title="1.3 CSS 优势"></a>1.3 CSS 优势</h3><ul>
<li>丰富的样式定义</li>
<li>灵活：易于使用和修改</li>
<li>简介、清晰</li>
<li>多页面应用</li>
<li>多设备兼容性：样式表允许针对多种不同类型的设备进行优化内容</li>
<li>减少开发成本与维护成本</li>
<li>提高页面性能</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118151745429.png" alt="image-20221118151745429" style="zoom:80%;" /></p>
<h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h2><h3 id="2-1-CSS语法"><a href="#2-1-CSS语法" class="headerlink" title="2.1 CSS语法"></a>2.1 CSS语法</h3><ul>
<li>CSS 语法组成<ul>
<li>选择器</li>
<li>声明：属性/值</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118151859837.png" alt="image-20221118151859837" style="zoom:80%;" /></p>
<h3 id="2-2-选择器"><a href="#2-2-选择器" class="headerlink" title="2.2 选择器"></a>2.2 选择器</h3><ul>
<li>id选择器</li>
<li>class选择器</li>
<li>标签选择器</li>
<li>属性选择器</li>
<li>伪类选择器</li>
<li>伪元素选择器</li>
<li>组合选择器</li>
</ul>
<h4 id="2-2-1-id选择器"><a href="#2-2-1-id选择器" class="headerlink" title="2.2.1 id选择器"></a>2.2.1 id选择器</h4><ul>
<li><p>id选择器可以为标有特定 id 的 HTML 元素指定特定的样式</p>
<ul>
<li><p>HTML 元素以 id 属性来设置 id选择器, CSS 中 id选择器以 “#” 来定义</p>
</li>
<li><p>下面的样式规则将应用于有属性 <code>id=&quot;para1&quot;</code> 的元素:</p>
<p><code>#para1 &#123;text-align:center;color:red;&#125;</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-类选择器"><a href="#2-2-2-类选择器" class="headerlink" title="2.2.2 类选择器"></a>2.2.2 类选择器</h4><ul>
<li><p>class选择器用于描述一组元素的样式, class 选择器有别于id选择器, class可以在多个元素中使用</p>
</li>
<li><p>class 选择器在 HTML 中以 class 属性表示, 在 CSS 中, 类选择器以一个点 . 号显示</p>
</li>
<li><p>在以下的例子中, 所有拥有 center 类的 HTML 元素均为居中。</p>
<p><code>.center &#123;text-align:center;&#125;</code></p>
</li>
</ul>
<h4 id="2-2-3-标签选择器"><a href="#2-2-3-标签选择器" class="headerlink" title="2.2.3 标签选择器"></a>2.2.3 标签选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-4-属性选择器"><a href="#2-2-4-属性选择器" class="headerlink" title="2.2.4 属性选择器"></a>2.2.4 属性选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[title]</span> &#123;<br>	<span class="hljs-attribute">color</span>:blue;<br>&#125;<br>&lt;<span class="hljs-selector-tag">h1</span> title=&quot;Hello world&quot;&gt;Hello world&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-5-伪类选择器"><a href="#2-2-5-伪类选择器" class="headerlink" title="2.2.5 伪类选择器"></a>2.2.5 伪类选择器</h4><ul>
<li>CSS 伪类是用来添加一些选择器的特殊效果</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">selector:pseudo-class &#123;property:value;&#125;<br>selector<span class="hljs-selector-class">.class</span>:pseudo-class &#123;property:value;&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#000000</span>;&#125; <span class="hljs-comment">/* 未访问链接*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#00FF00</span>;&#125; <span class="hljs-comment">/* 已访问链接 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#FF00FF</span>;&#125; <span class="hljs-comment">/* ⿏标移动到链接上 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#0000FF</span>;&#125; <span class="hljs-comment">/* ⿏标点击时 */</span><br></code></pre></td></tr></table></figure>
<h4 id="2-2-6-伪元素选择器"><a href="#2-2-6-伪元素选择器" class="headerlink" title="2.2.6 伪元素选择器"></a>2.2.6 伪元素选择器</h4><ul>
<li>可以使用 “FIRST-LINE” 伪元素向文本的首行设置特殊样式</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">selector:pseudo-element &#123;property:value;&#125;<br>selector<span class="hljs-selector-class">.class</span>:pseudo-element &#123;property:value;&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-line &#123;<br>    <span class="hljs-attribute">color</span>:<span class="hljs-number">#ff0000</span>;<br>    <span class="hljs-attribute">font-variant</span>:small-caps;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-7-CSS-组合选择符"><a href="#2-2-7-CSS-组合选择符" class="headerlink" title="2.2.7 CSS 组合选择符"></a>2.2.7 CSS 组合选择符</h4><ul>
<li><p><strong>后代选择器</strong>(以空格分隔)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118152649269.png" alt="image-20221118152649269" style="zoom:80%;" /></p>
</li>
<li><p><strong>子元素选择器</strong>(以大于号分隔)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118152712352.png" alt="image-20221118152712352" style="zoom:80%;" /></p>
</li>
<li><p><strong>相邻兄弟选择器</strong>(以加号分隔)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118152723788.png" alt="image-20221118152723788" style="zoom:80%;" /></p>
</li>
<li><p><strong>通用兄弟选择器</strong>(以波浪线分隔)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118152737919.png" alt="image-20221118152737919" style="zoom:80%;" /></p>
</li>
</ul>
<h3 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3 注释"></a>2.3 注释</h3><ul>
<li><code>/* ... */</code></li>
</ul>
<h2 id="3-层叠排序"><a href="#3-层叠排序" class="headerlink" title="3 层叠排序"></a>3 层叠排序</h2><h3 id="3-1-层叠样式表"><a href="#3-1-层叠样式表" class="headerlink" title="3.1 层叠样式表"></a>3.1 层叠样式表</h3><ul>
<li>用来解决样式说明冲突的整个排序过程称为层叠<ul>
<li>浏览器缺省样式</li>
<li>内联样式</li>
<li>嵌入样式表</li>
<li>外部样式表</li>
</ul>
</li>
</ul>
<h4 id="3-1-1-外部样式表"><a href="#3-1-1-外部样式表" class="headerlink" title="3.1.1 外部样式表"></a>3.1.1 外部样式表</h4><ul>
<li><p>链接方式：指的是使用 HTML 头部的<code>&lt;link&gt;</code>标签引入外部的 CSS 文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>导入方式：指的是使用 CSS 规则引入外部 CSS 文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">	<span class="hljs-keyword">@import</span> url(style.css);</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>比较</p>
<ul>
<li>link 属于 HTML, 通过 <code>&lt;link&gt;</code> 标签中的 href 属性来引入外部文件, 而 <code>@import</code> 属于 CSS, 所以导入语句应写在 CSS 中, 要注意的是导入语句应写在样式表的开头, 否则无法正确导入外部文件</li>
<li><code>@import</code> 是 CSS2.1 才出现的概念, 所以如果浏览器版本较低, 无法正确导入外部样式文件；</li>
<li>当 HTML 文件被加载时, link 引用的文件会同时被加载, 而 @import 引用的文件则会等页面全部下载完毕再被加载</li>
<li>使用 DOM 控制样式时的差别。</li>
</ul>
</li>
</ul>
<h4 id="3-1-2-嵌入的样式表"><a href="#3-1-2-嵌入的样式表" class="headerlink" title="3.1.2 嵌入的样式表"></a>3.1.2 嵌入的样式表</h4><ul>
<li><p>嵌入方式指的是在 HTML 头部中的 <code>&lt;style&gt;</code> 标签下书写 CSS 代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>my page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css”&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">    p&#123;color:red&#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">&lt;/style&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">&lt;/head&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">&lt;body&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">	&lt;p&gt;this is a simple paragraph&lt;/p&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">&lt;/body&gt;</span></span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-1-3-内联样式"><a href="#3-1-3-内联样式" class="headerlink" title="3.1.3 内联样式"></a>3.1.3 内联样式</h4><ul>
<li><p>内联方式指的是直接在 HTML 标签中的 style 属性中添加 CSS</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span> <br>    This is a simple paragraph and the inline style makes it red.<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-CSS-如何用于网页"><a href="#3-2-CSS-如何用于网页" class="headerlink" title="3.2 CSS 如何用于网页"></a>3.2 CSS 如何用于网页</h3><ul>
<li>Web 开发人员很少使用内联 CSS。因为不喜欢把内容和呈现混合在一起, 而且它效率不高, 因为必须为每个组件单独声明样式。</li>
<li>嵌入和外部样式表更受欢迎, 因为可以用一条规则设置多个元素的样式。</li>
<li>外部样式表是最好的, 因为允许将所有样式信息保存在一个单独的文件中。然后可以修改网站的样式, 它将更新网站中的所有页面。</li>
</ul>
<h3 id="3-3-样式冲突"><a href="#3-3-样式冲突" class="headerlink" title="3.3 样式冲突"></a>3.3 样式冲突</h3><ul>
<li><p>嵌入的样式表对于h3选择器具有以下属性:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> &#123; <br>    <span class="hljs-attribute">text-align</span>: right;<br>	<span class="hljs-attribute">font-size</span>: <span class="hljs-number">20pt</span> <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>外部样式表有如下属性:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> &#123; <br>    <span class="hljs-attribute">color</span>: red;<br> 	<span class="hljs-attribute">text-align</span>: left;<br> 	<span class="hljs-attribute">font-size</span>: <span class="hljs-number">8pt</span> <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>浏览器缺省设置为</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span> &#123; <br>    <span class="hljs-attribute">color</span>: black;<br> 	<span class="hljs-attribute">font</span> size: <span class="hljs-number">10pt</span> <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>&lt;h3&gt;</code>的最终样式将如何</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">color</span>: red;<br>test-align: right;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">20pt</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-4-继承"><a href="#3-4-继承" class="headerlink" title="3.4 继承"></a>3.4 继承</h3><ul>
<li>当元素的一个继承属性(inherited property)没有指定值时, 则取父元素的同属性的计算值</li>
<li>不是所有的属性都被继承</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118154504029.png" alt="image-20221118154504029" style="zoom:80%;" /></p>
<h3 id="3-5-CSS-声明的源"><a href="#3-5-CSS-声明的源" class="headerlink" title="3.5 CSS 声明的源"></a>3.5 CSS 声明的源</h3><ul>
<li>CSS 声明可以有不同的来源：<ul>
<li>用户代理：浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称用户代理样式。一些浏览器通过使用真正的样式表, 而其他则通过代码模拟, 但无论是哪种情形都应是不可被检测的。而且部分浏览器允许用户修改用户代理样式。尽管 HTML 标准对用户代理样式做了诸多限制, 浏览器仍大有可为, 具体表现在不同浏览器间会存在重大的差异。为了减轻开发成本以及降低样式表运行所需的基本环境, 网页开发者通常会使用一个 CSS reset 样式表, 强制将常见的属性值转为确定状态。</li>
<li>网页作者, 可以定义文档的样式, 这是最常见的样式表。大多数情况下此类型样式表会定义多个, 它们构成网站的视觉和体验, 即主题。</li>
<li>用户, 作为浏览器的用户, 可以使用自定义样式表定制使用体验。</li>
</ul>
</li>
</ul>
<h3 id="3-6-层叠顺序"><a href="#3-6-层叠顺序" class="headerlink" title="3.6 层叠顺序"></a>3.6 层叠顺序</h3><ul>
<li>层叠算法决定如何找出要应用到每个文档元素的每个属性上的值<ul>
<li>首先过滤来自不同源的全部规则, 并保留要应用到指定元素上的那些规则。这意味着这些规则的选择器匹配指定元素, 同时也是一个合适的 @规则(at-rule) 的一部分。</li>
<li>其次, 它依据重要性对这些规则进行排序。即是指, 规则后面是否跟随着 !important 以及规则的来源。层叠是按升序排列的, 这意味着来着用户自定义样式表的 !important 值比用户代理样式表的普通值优先级高</li>
<li>假如层叠顺序相等, 则使用哪个值取决于优先级。</li>
</ul>
</li>
</ul>
<h3 id="3-7-根据来源和重要程度排序"><a href="#3-7-根据来源和重要程度排序" class="headerlink" title="3.7 根据来源和重要程度排序"></a>3.7 根据来源和重要程度排序</h3><ul>
<li>相互冲突的声明将按以下顺序应用, 后一种声明将覆盖前一种声明：<ul>
<li>用户代理样式表中的声明(例如, 浏览器的默认样式, 在没有设置其他样式时使用)。</li>
<li>用户样式表中的常规声明(由用户设置的自定义样式)。</li>
<li>作者样式表中的常规声明(这些是我们 web 开发人员设置的样式)。</li>
<li>作者样式表中的 !important 声明</li>
<li>用户样式表中的 !important 声明</li>
<li>用户代理样式表中的 !important 声明</li>
</ul>
</li>
</ul>
<h3 id="3-8-优先级-specificity"><a href="#3-8-优先级-specificity" class="headerlink" title="3.8 优先级(specificity)"></a>3.8 优先级(specificity)</h3><ul>
<li>优先级就是分配给指定的 CSS 声明的一个权重, 它由匹配的选择器中的每一种选择器类型的数值决定。</li>
<li>而当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候, CSS 中最后的那个声明将会被应用到元素上。</li>
<li>当同一个元素有多个声明的时候, 优先级才会有意义</li>
<li>给元素添加的内联样式 (例如, <code>style=&quot;fontweight:bold&quot;</code>) 总会覆盖外部样式表的任何样式, 因此可看作是具有最高的优先级。</li>
</ul>
<h3 id="3-9-优先级的计算"><a href="#3-9-优先级的计算" class="headerlink" title="3.9 优先级的计算"></a>3.9 优先级的计算</h3><ul>
<li>如果声明来自一个 “style” 属性而不是一条选择器样式规则, 算1, 否则就是0 (= a)(HTML中, 一个元素的 “style” 属性值是样式表规则, 这些属性没有选择器, 所以a=1, b=0, c=0, d=0)</li>
<li>计算选择器中ID属性的数量 (= b)</li>
<li>计算选择器中其它属性和伪类的数量 (= c)</li>
<li>计算选择器中元素名和伪元素的数量 (= d)</li>
<li>4个数连起来a-b-c-d表示优先级</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118194812665.png" alt="image-20221118194812665" style="zoom:80%;" /></p>
<ul>
<li><p><code>!important</code> 例子</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221118194957882.png" alt="image-20221118194957882" style="zoom:80%;" /></p>
</li>
</ul>
<h2 id="4-CSS3"><a href="#4-CSS3" class="headerlink" title="4 CSS3"></a>4 CSS3</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221123102604661.png" alt="image-20221123102604661" style="zoom:80%;" /></p>
<h3 id="4-1-CSS3"><a href="#4-1-CSS3" class="headerlink" title="4.1 CSS3"></a>4.1 CSS3</h3><ul>
<li>CSS3 规范的一个新特点是被分为若干个相互独立的模块<ul>
<li>一方面分成若干较小的模块较利于规范及时更新和发布, 及时调整模块的内容, 这些模块独立实现和发布, 也为日后 CSS 的扩展奠定了基础</li>
<li>另外一方面, 由于受支持设备和浏览器厂商的限制, 设备或者厂商可以有选择的支持一部分模块, 支持 CSS3 的一个子集, 这样有利于 CSS3 的推广</li>
</ul>
</li>
</ul>
<h3 id="4-2-CSS3-的新特征"><a href="#4-2-CSS3-的新特征" class="headerlink" title="4.2 CSS3 的新特征"></a>4.2 CSS3 的新特征</h3><ul>
<li>很多: 圆角效果、图形化边界、块阴影与文字阴影、使用 RGBA 实现透明效果、渐变效果、使用 @Font-Face 实现定制字体、多背景图、文字或图像的变形处理(旋转、缩放、倾斜、移动)、多栏布局、媒体查询等</li>
</ul>
<h4 id="4-2-1-CSS-圆角"><a href="#4-2-1-CSS-圆角" class="headerlink" title="4.2.1 CSS 圆角"></a>4.2.1 CSS 圆角</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221123104147284.png" alt="image-20221123104147284" style="zoom:80%;" /></p>
<h4 id="4-2-2-CSS-Sprites-图像精灵"><a href="#4-2-2-CSS-Sprites-图像精灵" class="headerlink" title="4.2.2 CSS Sprites 图像精灵"></a>4.2.2 CSS Sprites 图像精灵</h4><ul>
<li>图像精灵是单个图像中包含的图像集合<ul>
<li>图像精灵将网页中的多个图片合并为一个大图片</li>
</ul>
</li>
<li>优点:<ul>
<li>包含许多图像的网页可能需要很长时间才能加载, 同时会生成多个服务器请求</li>
<li>使用图像精灵将减少服务器请求的数量并节约带宽</li>
<li>解决了网页设计师在图片命名上的困扰</li>
<li>更换风格方便</li>
</ul>
</li>
<li>缺点:<ul>
<li>维护麻烦</li>
<li>图片合并费时费力</li>
</ul>
</li>
</ul>
<h4 id="4-2-3-CSS-渐变"><a href="#4-2-3-CSS-渐变" class="headerlink" title="4.2.3 CSS 渐变"></a>4.2.3 CSS 渐变</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#grad</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to right, red,orange,yellow,green,blue,indigo,violet);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221123105353519.png" alt="image-20221123105353519"></p>
<h4 id="4-2-4-网络字体"><a href="#4-2-4-网络字体" class="headerlink" title="4.2.4 网络字体"></a>4.2.4 网络字体</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://fonts.googleapis.com/css?family=Tangerine&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Tangerine&#x27;</span>, serif;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">48px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Making the Web Beautiful!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221123104934650.png" alt="image-20221123104934650" style="zoom:80%;" /></p>
<h1 id="5-CSS-布局"><a href="#5-CSS-布局" class="headerlink" title="5-CSS 布局"></a>5-CSS 布局</h1><h2 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1 盒模型"></a>1 盒模型</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127132056191.png" alt="image-20221127132056191" style="zoom:80%;" /></p>
<ul>
<li>网页就是由一个个这样的盒子构成</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127154558006.png" alt="image-20221127154558006" style="zoom:80%;" /></p>
<h3 id="1-1-元素的宽度和高度"><a href="#1-1-元素的宽度和高度" class="headerlink" title="1.1 元素的宽度和高度"></a>1.1 元素的宽度和高度</h3><ul>
<li>最终元素的总宽度计算公式是这样的：<ul>
<li>总元素的宽度 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距</li>
</ul>
</li>
<li>元素的总高度最终计算公式是这样的：<ul>
<li>总元素的高度 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127133532661.png" alt="image-20221127133532661"  /></p>
<h3 id="1-2-IE怪异盒模型"><a href="#1-2-IE怪异盒模型" class="headerlink" title="1.2 IE怪异盒模型"></a>1.2 IE怪异盒模型</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127133649900.png" alt="image-20221127133649900" style="zoom:80%;" /></p>
<h2 id="2-Position"><a href="#2-Position" class="headerlink" title="2 Position"></a>2 Position</h2><ul>
<li>定位的基本思想很简单, 它允许你定义元素框相对于其正常位置应该出现的位置, 或者相对于父元素、另一个元素甚⾄浏览器窗口本身的位置。这个功能非常强大, 用户代理对 CSS2 中定位的支持远胜于对其它方面的支持。</li>
<li>CSS position 属性用于指定一个元素在文档中的定位方式<ul>
<li>static</li>
<li>relative</li>
<li>fixed</li>
<li>absolute</li>
<li>sticky</li>
</ul>
</li>
</ul>
<h3 id="2-1-页面正常流"><a href="#2-1-页面正常流" class="headerlink" title="2.1 页面正常流"></a>2.1 页面正常流</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127160034322.png" alt="image-20221127160034322" style="zoom:80%;" /></p>
<h3 id="2-2-默认布局"><a href="#2-2-默认布局" class="headerlink" title="2.2 默认布局"></a>2.2 默认布局</h3><ul>
<li>默认的, 一个块级元素的内容宽度是其父元素的 100%, 其高度与其内容高度一致。内联元素的 height width 与内容一致。<ul>
<li>你无法设置内联元素的 height width, 它们就那样置于块级元素的内容里</li>
<li>如果你想控制内联元素的尺寸, 你需要为元素设置<code>display: block;</code>(或者, <code>display: inline-block;</code> inlineblock 混合了 inline 和 block 的特性)</li>
</ul>
</li>
<li>正常布局流是一套在浏览器视口内放置、组织元素的系统。默认的, 块级元素按块流向布置, 即基于其父元素的书写顺序(默认值：<code>horizontal-tb</code>)。<ul>
<li>每个块级元素会在上一个元素下面另起一行, 它们会被设置好的 margin 分隔。</li>
<li>以英语为例, 或者其他的水平书写、⾃上而下模式里, 块级元素被垂直组织的。</li>
</ul>
</li>
<li>内联元素的表现有所不同: <strong>它们不会另起一行</strong><ul>
<li>只要在其父级块级元素的宽度内有足够的空间, 它们与其他内联元素、相邻的文本内容(或者被包裹的)被安排在同一行</li>
<li>如果空间不够, 溢出的文本或元素将移到新的一行。</li>
<li>如果两个相邻的元素都设置了 margin 并且两个 margin 有重叠, 那么更大的设置会被保留, 小的则会消失: 这被称为<strong>外边距叠加</strong></li>
</ul>
</li>
</ul>
<h3 id="2-3-absolute"><a href="#2-3-absolute" class="headerlink" title="2.3 absolute"></a>2.3 absolute</h3><ul>
<li><code>position: absolute;</code> 的元素相对于最近的定位祖先元素进行定位(而不是相对于视口定位, 如 fixed)</li>
<li><p>然而, 如果绝对定位的元素没有祖先, 它将使用文档主体(body), 并随页面滚动一起移动</p>
</li>
<li><p>绝对定位不占据页面正常流的空间, 会有覆盖其他元素的现象, 可通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index">z-index</a> 属性来设置</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127162946902.png" alt="image-20221127162946902"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">h2</span><span class="hljs-selector-class">.pos_abs</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pos_abs&quot;</span>&gt;</span>这是带有绝对定位的标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>通过绝对定位, 元素可以放置到页面上的任何位置. 下面的标题距离页面左侧 100px, 距离页面顶部 150px.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>====================================================================<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>====================================================================<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>====================================================================<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>====================================================================<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>====================================================================<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-4-relative"><a href="#2-4-relative" class="headerlink" title="2.4 relative"></a>2.4 relative</h3><ul>
<li><p><code>position: relative;</code> 的元素相对于其正常位置进行定位。</p>
</li>
<li><p>依然保留其在正常文档流中的空间</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127165700986.png" alt="image-20221127165700986" style="zoom:80%;" /></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">h2</span><span class="hljs-selector-class">.pos_left</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: -<span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">h2</span><span class="hljs-selector-class">.pos_right</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>这是位于正常位置的标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pos_left&quot;</span>&gt;</span>这个标题相对于其正常位置向左移动<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pos_right&quot;</span>&gt;</span>这个标题相对于其正常位置向右移动<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>相对定位会按照元素的原始位置对该元素进行移动。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>样式 &quot;left:-20px&quot; 从元素的原始左侧位置减去 20 像素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>样式 &quot;left:20px&quot; 向元素的原始左侧位置增加 20 像素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="2-5-fixed"><a href="#2-5-fixed" class="headerlink" title="2.5 fixed"></a>2.5 fixed</h3><ul>
<li><code>position: fixed;</code> 的元素是相对于视口定位的, 这意味着即使滚动页面, 它也始终位于同一位置。</li>
<li>top、right、bottom 和 left 属性用于定位此元素。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.fixed</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: fixed;</span><br><span class="language-css">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#73AD21</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fixed&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127171042560.png" alt="image-20221127171042560" style="zoom:80%;" /></p>
<h3 id="2-6-static"><a href="#2-6-static" class="headerlink" title="2.6 static"></a>2.6 static</h3><ul>
<li>HTML 元素默认情况下的定位方式为 static(静态)</li>
<li>静态定位的元素不受 top、bottom、left 和 right 属性的影响</li>
<li><code>position: static;</code> 的元素不会以任何特殊方式定位；它始终根据页面的正常流进行定位</li>
</ul>
<h3 id="2-7-sticky"><a href="#2-7-sticky" class="headerlink" title="2.7 sticky"></a>2.7 sticky</h3><ul>
<li><code>position: sticky;</code> 的元素根据用户的滚动位置进行定位。</li>
<li>粘性元素根据滚动位置在相对(relative)和固定(fixed)之间切换。起先它会被相对定位, 直到在视口中遇到给定的偏移位置为止<ul>
<li>然后将其”粘贴”在适当的位置(比如 position:fixed)</li>
</ul>
</li>
<li>示例: <a target="_blank" rel="noopener" href="https://mdn.github.io/learning-area/css/css-layout/positioning/7_sticky-positioning.html">Sticky positioning</a></li>
</ul>
<h3 id="2-8-float"><a href="#2-8-float" class="headerlink" title="2.8 float"></a>2.8 float</h3><ul>
<li>浮动的框可以向左或向右移动, 直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li>
<li>由于浮动框不在文档的普通流中, 所以文档的普通流中的块框表现得就像浮动框不存在一样。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221127221814528.png" alt="image-20221127221814528" style="zoom:80%;" /></p>
<h2 id="3-Formatting-Context"><a href="#3-Formatting-Context" class="headerlink" title="3 Formatting Context"></a>3 Formatting Context</h2><ul>
<li>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域, 并且有一套渲染规则, 它决定了其子元素将如何定位, 以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称 IFC)</li>
<li>BFC是一个独立的布局环境, 其中的元素布局是不受外界的影响, 并且在一个BFC中, 块盒与行盒(行盒由一行中所有的内联元素所组成)都会垂直的沿着其父元素的边框排列</li>
</ul>
<h3 id="3-1-BFC"><a href="#3-1-BFC" class="headerlink" title="3.1 BFC"></a>3.1 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">BFC</a></h3><ul>
<li>定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域, 只有Block-level box参与, 它规定了内部的Block-level Box如何布局, 并且与这个区域外部毫不相干</li>
</ul>
<h4 id="3-1-1-BFC的形成"><a href="#3-1-1-BFC的形成" class="headerlink" title="3.1.1 BFC的形成"></a>3.1.1 BFC的形成</h4><p>下列方式会创建块格式化上下文：</p>
<ul>
<li>根元素(<code>&lt;html&gt;</code>)</li>
<li>浮动元素(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 值不为 <code>none</code>)</li>
<li>绝对定位元素(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>absolute</code> 或 <code>fixed</code>)</li>
<li>行内块元素(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>inline-block</code>)</li>
<li>表格单元格(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>table-cell</code>, HTML 表格单元格默认值)</li>
<li>表格标题(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>table-caption</code>, HTML 表格标题默认值)</li>
<li>匿名表格单元格元素(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>(分别是 HTML table、tr、tbody、thead、tfoot 的默认值)或 <code>inline-table</code>)</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 值不为 <code>visible</code>、<code>clip</code> 的块元素</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flow-root</code> 的元素</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 值为 <code>layout</code>、<code>content</code> 或 <code>paint</code> 的元素</li>
<li>弹性元素(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flex</code> 或 <code>inline-flex</code> 元素的直接子元素), 如果它们本身既不是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Flex_Container">flex</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Container">grid</a> 也不是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Table">table</a> 容器</li>
<li>网格元素(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素), 如果它们本身既不是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Flex_Container">flex</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Container">grid</a> 也不是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Table">table</a> 容器</li>
<li>多列容器(<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a> 值不为 <code>auto</code>, 包括<code>column-count</code> 为 <code>1</code>)</li>
<li><code>column-span</code> 值为 <code>all</code> 的元素始终会创建一个新的 BFC, 即使该元素没有包裹在一个多列容器中 (<a target="_blank" rel="noopener" href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">规范变更</a>, <a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>)</li>
</ul>
<h4 id="3-1-2-BFC的布局规则"><a href="#3-1-2-BFC的布局规则" class="headerlink" title="3.1.2 BFC的布局规则"></a>3.1.2 BFC的布局规则</h4><ul>
<li>内部的 Box 会在垂直方向, 一个接一个地放置。</li>
<li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li>
<li>每个盒子(块盒与行盒)的 margin box 的左边, 与包含块 border box 的左边相接触(对于从左往右的格式化, 否则相反)。即使存在浮动也是如此。</li>
<li>BFC 的区域不会与 float box 重叠。</li>
<li>BFC 就是页面上的一个隔离的独立容器, 容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li><strong>计算 BFC 的高度时, 浮动元素也参与计算</strong></li>
</ul>
<h4 id="3-1-3-格式化上下文影响布局"><a href="#3-1-3-格式化上下文影响布局" class="headerlink" title="3.1.3 格式化上下文影响布局"></a>3.1.3 格式化上下文影响布局</h4><p>通常, 我们会为定位和清除浮动创建新的 BFC, 而不是更改布局, 因为它将：</p>
<ul>
<li>包含内部浮动</li>
<li>排除外部浮动</li>
<li>阻止外边距重叠</li>
</ul>
<h4 id="3-1-4-高度塌陷"><a href="#3-1-4-高度塌陷" class="headerlink" title="3.1.4 高度塌陷"></a>3.1.4 高度塌陷</h4><ul>
<li><p>当父元素未设置高度时, 所有子元素浮动后, 造成子元素脱离文档流进而无法把父元素撑开, 父元素高度为 0 产生高度塌陷, 称为高度塌陷问题</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.par</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid green;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid yellow;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;par&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129144256765.png" alt="image-20221129144256765" style="zoom:80%;" /></p>
</li>
<li><p>这个时候我们就需要<strong>清除浮动</strong></p>
<ul>
<li><p>添加 <code>overflow: hidden;</code> 创建 BFC</p>
</li>
<li><p>计算 BFC 高度时, 浮动元素也计算在内</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.par</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid green;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129144811600.png" alt="image-20221129144811600" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
<h4 id="3-1-5-避免margin重叠"><a href="#3-1-5-避免margin重叠" class="headerlink" title="3.1.5 避免margin重叠"></a>3.1.5 避免margin重叠</h4><ul>
<li>通过创建 BFC 避免 margin 重叠</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    * &#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: yellow;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>看看我的margin<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>看看我的margin<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>看看我的margin<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129145717475.png" alt="image-20221129145717475" style="zoom:80%;" /></p>
<h3 id="3-2-IFC"><a href="#3-2-IFC" class="headerlink" title="3.2 IFC"></a>3.2 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Inline_formatting_context">IFC</a></h3><h4 id="3-2-1-IFC的形成"><a href="#3-2-1-IFC的形成" class="headerlink" title="3.2.1 IFC的形成"></a>3.2.1 IFC的形成</h4><ul>
<li>当多个内联(块级)元素排列在一起的时候就会形成一个IFC, 之间不能穿插有块级元素, 否则会被切割成多个IFC。</li>
</ul>
<h4 id="3-2-2-IFC的影响"><a href="#3-2-2-IFC的影响" class="headerlink" title="3.2.2 IFC的影响"></a>3.2.2 IFC的影响</h4><p>IFC对布局产生的影响主要有以下三个方面：</p>
<ul>
<li>一个IFC内的元素都是水平排列的</li>
<li>横向的margin、border、padding属性对于这些元素都是有效的</li>
<li>垂直方向可以调整对⻬方式</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129151245397.png" alt="image-20221129151245397" style="zoom:80%;" /></p>
<h2 id="4-网页设计"><a href="#4-网页设计" class="headerlink" title="4 网页设计"></a>4 网页设计</h2><h3 id="4-1-复杂的div嵌套"><a href="#4-1-复杂的div嵌套" class="headerlink" title="4.1 复杂的div嵌套"></a>4.1 复杂的div嵌套</h3><ul>
<li>代码复杂度高, 网页加载速度慢</li>
<li>语义化弱, 可读性差</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129151551044.png" alt="image-20221129151551044" style="zoom:80%;" /></p>
<ul>
<li><p>解决办法, 借助 HTML5 + CSS3</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129151650286.png" alt="image-20221129151650286" style="zoom:80%;" /></p>
</li>
</ul>
<h3 id="4-2-现状"><a href="#4-2-现状" class="headerlink" title="4.2 现状"></a>4.2 现状</h3><p>上方内容主要针对PC, 但现在移动端碎片化</p>
<ul>
<li>不同平台:Windows,Mac,Linux,iOS,Android,WebOS,Chrome OS…</li>
<li>大量的设备</li>
<li>不同的分辨率</li>
<li>横屏与竖屏</li>
<li>智能设备快速增长</li>
<li>云计算、浏览器是未来</li>
</ul>
<h3 id="4-3-如何应对"><a href="#4-3-如何应对" class="headerlink" title="4.3 如何应对"></a>4.3 如何应对</h3><h4 id="4-3-1-CSS布局"><a href="#4-3-1-CSS布局" class="headerlink" title="4.3.1 CSS布局"></a>4.3.1 CSS布局</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129152014627.png" alt="image-20221129152014627" style="zoom:80%;" /></p>
<h4 id="4-3-2-最佳可访问性和可读性"><a href="#4-3-2-最佳可访问性和可读性" class="headerlink" title="4.3.2 最佳可访问性和可读性"></a>4.3.2 最佳可访问性和可读性</h4><p>编码时保持良好的html源码顺序非常重要, 原因：</p>
<ul>
<li>网站技术故障时不能正确显示css样式, 或移动和无线网络环境下, 带宽有限, 导致浏览器中出现没有样式的HTML。</li>
<li>资源顺序对网站的可访问性起着重要作用, 因为对于盲人用户, 当代码有一定的逻辑顺序时, 能够快速跳过页眉和导航区域, 直达页面的主要内容。</li>
<li>确保网站的主导航链接和主要网页内容在资源排序中排在最前面, 这样可以帮助搜索引擎优化。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129152922246.png" alt="image-20221129152922246" style="zoom:80%;" /></p>
<h2 id="5-响应式Web设计"><a href="#5-响应式Web设计" class="headerlink" title="5 响应式Web设计"></a>5 响应式Web设计</h2><ul>
<li>自适应网页设计(英语：Responsive web design, 通常缩写为RWD)是一种网页设计方法, 该设计可使网站在多种浏览设备(从桌面电脑显示器到移动电话或其他移动产品设备)上阅读和导航, 同时减少缩放、平移和滚动。</li>
</ul>
<blockquote>
<p>Responsive web design (RWD) is a web design approach aimed at crafting sites to provide an optimal viewing experience—easy reading and navigation with a minimum of resizing, panning, and scrolling—across a wide range of devices (from mobile phones to desktop computer monitors). </p>
<p>——Ethan Marcotte</p>
</blockquote>
<h3 id="5-1-响应式布局"><a href="#5-1-响应式布局" class="headerlink" title="5.1 响应式布局"></a>5.1 响应式布局</h3><ul>
<li>曾经流行, 不再是必不可少, 原因<ul>
<li>公司研发人员越来越充足, 可以在pc端和移动端实现两套布局, 分项目进行维护。</li>
<li>响应式布局在适配上越来越简单。</li>
</ul>
</li>
<li>仍有存在的价值：<ul>
<li>移动端碎片化的现象将会无限期存在</li>
<li>前端也必然进入物联网领域, 任何设备界面的响应布局都将会成为关键挑战。</li>
<li>响应式布局是CSS逐步发展中的一环, 体现了CSS的灵活性。</li>
</ul>
</li>
</ul>
<h3 id="5-2-优势"><a href="#5-2-优势" class="headerlink" title="5.2 优势"></a>5.2 优势</h3><ul>
<li>网站可用性得到提升, 同时与移动优先设计以及内容策略能够非常好的融合在一起。</li>
<li>简化服务器端</li>
<li>更容易维护</li>
<li>只提供一个入口给搜索引擎</li>
<li>能够支持未知设备</li>
</ul>
<h3 id="5-3-缺点"><a href="#5-3-缺点" class="headerlink" title="5.3 缺点"></a>5.3 缺点</h3><ul>
<li>性能<ul>
<li>兼容各种设备⼯作量大, 效率低下</li>
<li>代码累赘, 会出现隐藏无用的元素, 加载时间加长</li>
</ul>
</li>
<li>限制应用的复杂性<ul>
<li>折衷性质的设计解决方案, 多方面因素影响而达不到最佳效果</li>
</ul>
</li>
<li>一定程度上改变了网站原有的布局结构, 会出现用户混淆的情况</li>
</ul>
<h2 id="6-响应式网页设计"><a href="#6-响应式网页设计" class="headerlink" title="6 响应式网页设计"></a>6 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Responsive_Design">响应式网页设计</a></h2><ul>
<li>围绕着三个概念建立<ul>
<li>流畅或灵活的页面布局, 根据浏览器窗口大小成比例缩放。</li>
<li>灵活、比例适中的图像和视听媒体。</li>
<li>使用CSS3媒体查询(media query), 确定浏览器屏幕的宽度并作出相应的调整。</li>
</ul>
</li>
</ul>
<h3 id="6-1-流式布局和比例度量"><a href="#6-1-流式布局和比例度量" class="headerlink" title="6.1 流式布局和比例度量"></a>6.1 流式布局和比例度量</h3><ul>
<li>页面固定宽度布局：<ul>
<li>几年前流行</li>
<li>复杂页面布局中, 有助于用户更好地了解页面上的信息。</li>
<li>尺寸固定, 不能适应当今屏幕大小各异的互联网世界。</li>
</ul>
</li>
<li>不设定为一个固定宽度</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221125141233300.png" alt="image-20221125141233300" style="zoom:80%;" /></p>
<h4 id="6-1-1-流体表格"><a href="#6-1-1-流体表格" class="headerlink" title="6.1.1 流体表格"></a>6.1.1 流体表格</h4><ul>
<li>流体表格将页面栅格化, 使用 em 相对单位取代 px 绝对单位<ul>
<li><a target="_blank" rel="noopener" href="https://alistapart.com/article/fluidgrids/">https://alistapart.com/article/fluidgrids/</a></li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221125141416825.png" alt="image-20221125141416825" style="zoom: 67%;" /></p>
<h4 id="6-1-2-em-排版尺寸"><a href="#6-1-2-em-排版尺寸" class="headerlink" title="6.1.2 em 排版尺寸"></a>6.1.2 em 排版尺寸</h4><ul>
<li>单纯成比例的流式布局并不能完全解决屏幕尺寸问题, 因为在小屏幕上页面布局可能会被压扁, 而在大屏幕上会被拉伸变形。</li>
<li><p>使用em排版尺寸就非常重要, 原因：</p>
<ul>
<li>当设备屏幕上的排版太大或太小时, 用户都可以很容易地进行调整, 这对于有视力障碍的用户来说是一个重要的可访问特性。</li>
<li>在CSS控制下, 相对类型的大小可以很容易地缩放, 在 <code>&lt;html&gt;</code> 或 <code>&lt;body&gt;</code> 标签中使用font-size元素, 就可以很容易地对整个页面排版尺寸进行缩放。通过调整 em 的值, 可以立刻放大或缩小页面上的所有排版, 这在响应式设计中是一种非常有用的功能, 可以快速缩放页面排版, 以轻松匹配整个屏幕尺寸和分辨率。</li>
</ul>
</li>
<li><p>使用 em 尺寸</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221125142147416.png" alt="image-20221125142147416" style="zoom: 67%;" /></p>
<h4 id="6-1-3-比例图像和媒体"><a href="#6-1-3-比例图像和媒体" class="headerlink" title="6.1.3 比例图像和媒体"></a>6.1.3 比例图像和媒体</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221125142218080.png" alt="image-20221125142218080" style="zoom:80%;" /></p>
<h3 id="6-2-HTML5-lt-picture-gt-元素"><a href="#6-2-HTML5-lt-picture-gt-元素" class="headerlink" title="6.2 HTML5 &lt;picture&gt; 元素"></a>6.2 HTML5 <code>&lt;picture&gt;</code> 元素</h3><ul>
<li>picture 元素允许我们在不同的设备上显示不同的图片, 一般用于响应式。</li>
<li>HTML5 引入了 <code>&lt;picture&gt;</code> 元素, 该元素可以让图片资源的调整更加灵活。</li>
<li><code>&lt;picture&gt;</code> 元素包括零或多个 <code>&lt;source&gt;</code> 元素和一个 <code>&lt;img&gt;</code> 元素,  每个 <code>&lt;source&gt;</code> 元素匹配不同的设备并引用不同的图像源, 如果没有匹配的, 就选择 <code>&lt;img&gt;</code> 元素的 src 属性中的 url</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 650px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;demo1.jpg&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 465px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;demo2.jpg&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img_girl.jpg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="6-3-流体图片-Liquid-Image"><a href="#6-3-流体图片-Liquid-Image" class="headerlink" title="6.3 流体图片(Liquid Image)"></a>6.3 流体图片(Liquid Image)</h3><ul>
<li>图片是否传达了应该放在alt属性中的文本信息?</li>
<li>是否想要确保图像总是打印出来, 因为没有它打印输出就没有意义或不完整?</li>
<li>是否需要链接图片?</li>
</ul>
<p>如果以上任何一个问题的答案是肯定的, 那么图像就是内容, 应该保存在(X)HTML中。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221125142623048.png" alt="image-20221125142623048"></p>
<blockquote>
<p>飞碟是内容, 城市是背景</p>
</blockquote>
<h3 id="6-4-CSS3-media-query"><a href="#6-4-CSS3-media-query" class="headerlink" title="6.4 CSS3 media query"></a>6.4 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Media_queries">CSS3 media query</a></h3><ul>
<li>有条件地检测用户显示屏的各个方面, 然后根据这些条件有选择地加载出样式表, 并提供最合适的布局、排版和图形</li>
<li>媒体查询可用于检测很多事情 ：<ul>
<li>viewport(视窗)的宽度与高度</li>
<li>设备的宽度与高度</li>
<li>朝向(智能⼿机横屏, 竖屏)</li>
<li>DPI分辨率</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">400px</span>) &#123;<br>  <span class="hljs-selector-class">.figure</span>,<br>  <span class="hljs-selector-tag">li</span><span class="hljs-selector-id">#f-mycroft</span> &#123;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">3.317535545023696682%</span>;  <span class="hljs-comment">/* 21px / 633px */</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">48.341232227488151658%</span>;  <span class="hljs-comment">/* 306px / 633px */</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1300px</span>)&#123;<br>  <span class="hljs-selector-class">.figure</span>,<br>  <span class="hljs-selector-tag">li</span><span class="hljs-selector-id">#f-mycroft</span> &#123;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">3.317535545023696682%</span>;      <span class="hljs-comment">/* 21px / 633px */</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">13.902053712480252764%</span>;        <span class="hljs-comment">/* 88px / 633px */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="6-4-1-独特布局"><a href="#6-4-1-独特布局" class="headerlink" title="6.4.1 独特布局"></a>6.4.1 独特布局</h4><ul>
<li>响应式设计不仅仅是拉伸和缩小页面布局, 而是要将内容和导航的独特布局以最好的方式显示到各种尺寸的屏幕上。</li>
<li>大部分响应式设计会使用⾄少三种不同的布局样式表。</li>
</ul>
<h4 id="6-4-2-断点测量"><a href="#6-4-2-断点测量" class="headerlink" title="6.4.2 断点测量"></a>6.4.2 断点测量</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129160556966.png" alt="image-20221129160556966" style="zoom:80%;" /></p>
<h2 id="7-移动优先"><a href="#7-移动优先" class="headerlink" title="7 移动优先"></a>7 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Responsive/Mobile_first">移动优先</a></h2><ul>
<li>优先内容和功能<ul>
<li>优先显示最重要的内容和功能, 如果空间允许, 再逐步加入次要内容和功能。</li>
</ul>
</li>
</ul>
<h3 id="7-1-好处"><a href="#7-1-好处" class="headerlink" title="7.1 好处"></a>7.1 好处</h3><p>通用访问</p>
<ul>
<li>只要移动端做的好, 即使用户使用的是旧版本浏览器、没有 Javascript 或者关闭了 Javascript 的浏览器, 或为视力残障人士设计的读屏浏览器, 也能看到一个拥有基本功能的网站。</li>
<li>移动优先是<strong>渐进渐强</strong>理念的良好范例, 所有用户都能访问核心内容和功能。不存在不能访问的情况。</li>
</ul>
<blockquote>
<p>渐进渐强基本理念是首先基于一个具有广泛兼容性的核心方案, 创建一个基线版本, 然后再根据可能用到的浏览器的特性, 慢慢添加一些特性和功能。</p>
<p><strong>移动优先, 渐进渐强</strong></p>
</blockquote>
<h3 id="7-2-最佳实践"><a href="#7-2-最佳实践" class="headerlink" title="7.2 最佳实践"></a>7.2 最佳实践</h3><ul>
<li>使用有效的, 广泛支持的 HTML5 和 CSS3 来构建你的站点。</li>
<li>利用 HTML5 新语义元素和 ARIA 为内容添加意义、可访问性和搜索可见性。</li>
<li>在布局和排版中使用比例度量, 如百分比和em。</li>
<li>根据用户的需求、观看设备的可能范围以及特定内容的性质, 计算响应断点并使用媒体查询。</li>
<li>使用移动优先的方法, 建立最小和最基本的体验。</li>
<li>根据屏幕空间、带宽和浏览器功能, 逐步提升移动优先的体验。</li>
<li>在研发周期中优先考虑浏览器因素, 尽量避免使用复杂的、面向桌面的 Photoshop 排版和静态图形设计。花哨的静态设计模型是一种过时的思维方式, 与现代 web 实现完全脱节</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129162132482.png" alt="image-20221129162132482" style="zoom:80%;" /></p>
<h2 id="8-面包屑导航"><a href="#8-面包屑导航" class="headerlink" title="8 面包屑导航"></a>8 面包屑导航</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221129162509401.png" alt="image-20221129162509401" style="zoom:80%;" /></p>
<h3 id="8-1-作用"><a href="#8-1-作用" class="headerlink" title="8.1 作用"></a>8.1 作用</h3><ul>
<li>让用户了解当前所处位置, 以及当前页面在整个网站中的位置</li>
<li>体现了网站的架构层级, 能够帮助用户快速学习和了解网站内容和组织方式, 从而形成很好的位置感</li>
<li>提供返回各个层级的快速入口, 方便用户操作</li>
<li>Google 已经将面包屑导航整合到搜索结果里面, 因此优化面包屑导航每个层级的名称, 多使用关键字, 都可以实现 SEO 优化。面包屑路径, 对于提高用户体验来说, 是很有帮助的</li>
<li>方便用户, 面包屑主要用于为用户提供导航一个网站的次要方法, 通过为一个大型多级网站的所有页面提供面包屑路径, 用户可以更容易的定位到上一次目录, 引导用户通行</li>
<li>减少返回到上一级页面的点击或操作, 不用使用浏览器的”返回”按钮或网站的主要导航来返回到上一级页面</li>
<li>不用常常占用屏幕空间, 因为它们通常是水平排列以及简单的样式, 面包屑路径不会占用页面太多的空间。这样的好处是, 从内容过载方面来说, 他们几乎没有任何负面影响</li>
<li>降低跳出率, 面包屑路径会是一个诱惑首次访问者在进入一个页面后去浏览这个网站的非常好的方法。比如说, 一个用户通过谷歌搜索到一个页面, 然后看到一个面包屑路径, 这将会诱使用户点击上一级页面去浏览感兴趣的相关主题。这样可以降低网站的总体跳出率</li>
<li>有利于百度蜘蛛对网站的抓取, 蜘蛛直接沿着那个链走就可以了, 很方便</li>
<li>面包屑有利于网站内链的建设, 用面包屑大大增加了网站的内部连接, 提高用户体验。</li>
</ul>
<h3 id="8-2-适用条件"><a href="#8-2-适用条件" class="headerlink" title="8.2 适用条件"></a>8.2 适用条件</h3><p>虽然眼下很多网站都流行使用面包屑导航, 但是并不是所有的网站都适用。符合下面两个条件的网站才适合使用面包屑导航。</p>
<ul>
<li>层级较深的网站, 面包屑导航适合层级较深的网站, 如果只有一级分类的话, 通过主导航就可以起到快速定位的作用。比如”豆瓣网”类型扁平构架的网站就没有使用面包屑导航</li>
<li>独立不交叉的网站结构, 由于面包屑网站导航路径是线性结构的, 因此网站内容必须划分的非常清晰, 且不存在交叉；否则面包屑导航的路径就不是唯一的, 同一分类可能出现在不同的路径中, 让用户感到困惑</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/18/SpringCloud-5-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/18/SpringCloud-5-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/" class="post-title-link" itemprop="url">SpringCloud(5) 服务网关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 14:20:34" itemprop="dateCreated datePublished" datetime="2022-11-18T14:20:34+08:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h1><h2 id="1-Zuul"><a href="#1-Zuul" class="headerlink" title="1 Zuul"></a>1 Zuul</h2><p>Zuul开发人员窝里斗，实属明日黄花</p>
<p>重点关注Gateway</p>
<h2 id="2-Gateway"><a href="#2-Gateway" class="headerlink" title="2 Gateway"></a>2 Gateway</h2><h3 id="2-1-Gateway是什么"><a href="#2-1-Gateway是什么" class="headerlink" title="2.1 Gateway是什么"></a>2.1 Gateway是什么</h3><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。</p>
<p>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如:熔断、限流、重试等。</p>
<p>SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring 5.0+Spring Boot 2.0和Project Reactor等技术开发的网关，它旨在为微服务架构提供—种简单有效的统一的API路由管理方式。</p>
<p>SpringCloud Gateway作为Spring Cloud 生态系统中的网关，目标是替代Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，<strong>SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</strong></p>
<p>Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter链的方式提供了网关基本的功能，例如:安全，监控/指标，和限流。</p>
<ul>
<li><strong>作用</strong><ul>
<li>反向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>微服务架构中网关的位置</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220730160741357.png" alt="image-20220730160741357"></p>
<h3 id="2-2-Gateway非阻塞异步模型"><a href="#2-2-Gateway非阻塞异步模型" class="headerlink" title="2.2 Gateway非阻塞异步模型"></a>2.2 Gateway非阻塞异步模型</h3><ul>
<li>SpringCloud Gateway具有如下特性<ul>
<li>基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建；</li>
<li>动态路由: 能够匹配任何请求属性；</li>
<li>可以对路由指定Predicate (断言)和Filter(过滤器)；</li>
<li>集成Hystrix的断路器功能；</li>
<li>集成Spring Cloud 服务发现功能；</li>
<li>易于编写的Predicate (断言)和Filter (过滤器)；</li>
<li>请求限流功能；</li>
<li>支持路径重写。</li>
</ul>
</li>
<li>SpringCloud Gateway与Zuul的区别<ul>
<li>在SpringCloud Finchley正式版之前，Spring Cloud推荐的网关是Netflix提供的Zuul。</li>
<li>Zuul 1.x，是一个基于阻塞I/O的API Gateway。</li>
<li>Zuul 1.x基于Servlet 2.5使用阻塞架构它不支持任何长连接(如WebSocket)，Zuul的设计模式和Nginx较像，每次I/О操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身会有第一次加载较慢的情况，使得Zuul的性能相对较差。</li>
<li>Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul .x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS(每秒请求数)是Zuul的1.6倍。</li>
<li>Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot2之上，使用非阻塞API。</li>
<li>Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验</li>
</ul>
</li>
<li><strong>Zuul1.x模型</strong><ul>
<li>Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Serviet IO处理模型。</li>
<li>上述模式的<strong>缺点</strong>:<ul>
<li>Servlet是一个简单的网络IO模型，当请求进入Servlet container时，Servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的。但是一旦高并发(如抽风用Jmeter压)，线程数量就会上涨，而线程资源代价是昂贵的(上线文切换，内存消耗大)严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势。</li>
<li>所以Zuul 1.X是基于servlet之上的一个阻塞式处理模型，即Spring实现了处理所有request请求的一个servlet (DispatcherServlet)，并由该servlet阻塞式处理请求。所以SpringCloud Zuul无法摆脱servlet模型的弊端。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Gateway模型</strong><ul>
<li>传统的Web框架，比如说: Struts2，SpringMVC等都是基于Servlet APl与Servlet容器基础之上运行的。</li>
<li>但是在Servlet3.1之后有了异步非阻塞的支持。而<strong>WebFlux是一个典型非阻塞异步的框架</strong>，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程(Spring 5必须让你使用Java 8)。</li>
<li>Spring WebFlux是Spring 5.0 引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet APl，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。</li>
</ul>
</li>
</ul>
<h3 id="2-3-Gateway工作流程"><a href="#2-3-Gateway工作流程" class="headerlink" title="2.3 Gateway工作流程"></a>2.3 Gateway工作流程</h3><ul>
<li><strong>三大核心概念</strong><ul>
<li>Route(路由) - 路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如断言为true则匹配该路由</li>
<li>Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由</li>
<li>Filter(过滤) - 指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220730164442245.png" alt="image-20220730164442245"></p>
<ul>
<li><p>web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。</p>
</li>
<li><p>predicate就是我们的匹配条件；而fliter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了</p>
</li>
<li><p><strong>Gateway工作流程</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220730164513367.png" alt="image-20220730164513367"></p>
<ul>
<li>客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。</li>
<li>Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</li>
<li>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post”)执行业务逻辑。</li>
<li>Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</li>
</ul>
</li>
<li><p><strong>核心逻辑</strong>: 路由转发 + 执行过滤器链。</p>
</li>
</ul>
<h3 id="2-4-Gateway9527搭建"><a href="#2-4-Gateway9527搭建" class="headerlink" title="2.4 Gateway9527搭建"></a>2.4 Gateway9527搭建</h3><ol>
<li><p>新建Module   cloud08-gateway-gateway9527</p>
</li>
<li><p>POM: 添加gateway，删除web</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>LearnCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-gateway-gateway9527<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--gateway--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--eureka-client--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--一般基础配置类--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh</span> <span class="hljs-comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8001</span>          <span class="hljs-comment">#匹配后提供服务的路由地址</span><br>          <span class="hljs-comment">#uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/get/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span><br><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh2</span> <span class="hljs-comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8001</span>          <span class="hljs-comment">#匹配后提供服务的路由地址</span><br>          <span class="hljs-comment">#uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/lb/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">cloud-gateway-service</span><br>  <span class="hljs-attr">client:</span> <span class="hljs-comment">#服务提供者provider注册进eureka服务列表内</span><br>  	<span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GateWayMain9527</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(GateWayMain9527.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<ul>
<li>添加网关前 - <a target="_blank" rel="noopener" href="http://localhost:8001/payment/get/1">http://localhost:8001/payment/get/1</a></li>
<li>添加网关后 - <a target="_blank" rel="noopener" href="http://localhost:9527/payment/get/1">http://localhost:9527/payment/get/1</a></li>
<li>两者访问成功，返回相同结果</li>
</ul>
</li>
</ol>
<h3 id="2-5-Gateway配置路由的两种方式"><a href="#2-5-Gateway配置路由的两种方式" class="headerlink" title="2.5 Gateway配置路由的两种方式"></a>2.5 Gateway配置路由的两种方式</h3><ul>
<li><strong>在配置文件yml中配置，见上一章节</strong></li>
<li><strong>代码中注入RouteLocator的Bean</strong></li>
</ul>
<h3 id="2-6-GateWay配置动态路由"><a href="#2-6-GateWay配置动态路由" class="headerlink" title="2.6 GateWay配置动态路由"></a>2.6 GateWay配置动态路由</h3><p>默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建<strong>动态路由进行转发，从而实现动态路由的功能</strong>(不写死一个地址)。</p>
<ul>
<li><p>启动eureka7001，payment8001/8002</p>
</li>
<li><p>YAML</p>
<ul>
<li>需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。</li>
<li>lb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh</span> <span class="hljs-comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br>          <span class="hljs-comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cloud-payment-service</span> <span class="hljs-comment">#匹配后提供服务的路由地址</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/get/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span><br><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh2</span> <span class="hljs-comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br>          <span class="hljs-comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cloud-payment-service</span> <span class="hljs-comment">#匹配后提供服务的路由地址</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/lb/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>测试</strong></p>
<ul>
<li>浏览器输入 - <a target="_blank" rel="noopener" href="http://localhost:9527/payment/lb">http://localhost:9527/payment/lb</a></li>
<li>不停刷新页面，8001/8002两个端口切换。</li>
</ul>
</li>
</ul>
<h3 id="2-7-GateWay常用的Predicate"><a href="#2-7-GateWay常用的Predicate" class="headerlink" title="2.7 GateWay常用的Predicate"></a>2.7 GateWay常用的Predicate</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/18/SpringCloud-4-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/18/SpringCloud-4-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/" class="post-title-link" itemprop="url">SpringCloud(4) 服务降级</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 14:20:16" itemprop="dateCreated datePublished" datetime="2022-11-18T14:20:16+08:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><h2 id="1-Hystrix"><a href="#1-Hystrix" class="headerlink" title="1 Hystrix"></a>1 Hystrix</h2><h3 id="1-1-Hystrix是什么"><a href="#1-1-Hystrix是什么" class="headerlink" title="1.1 Hystrix是什么"></a>1.1 Hystrix是什么</h3><ul>
<li><strong>分布式系统面临的问题</strong><ul>
<li>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</li>
</ul>
</li>
<li><strong>服务雪崩</strong><ul>
<li>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.</li>
<li>对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</li>
<li>所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。</li>
</ul>
</li>
<li><strong>Hystrix是什么</strong><ul>
<li>Hystrix是一个用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，<strong>不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</strong>。</li>
<li>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控<strong>(类似熔断保险丝)</strong>，向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</li>
</ul>
</li>
</ul>
<h3 id="1-2-服务降级、熔断、限流概念"><a href="#1-2-服务降级、熔断、限流概念" class="headerlink" title="1.2 服务降级、熔断、限流概念"></a>1.2 服务降级、熔断、限流概念</h3><p><strong>服务降级</strong></p>
<ul>
<li><p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示。fallback</p>
</li>
<li><p><strong>哪些情况会触发降级</strong></p>
<ul>
<li><p>程序运行导常</p>
</li>
<li><p>超时</p>
</li>
<li><p>服务熔断触发服务降级</p>
</li>
<li><p>线程池/信号量打满也会导致服务降级</p>
</li>
</ul>
</li>
</ul>
<p><strong>服务熔断</strong></p>
<ul>
<li><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。break</p>
</li>
<li><p>服务的降级 -&gt; 进而熔断 -&gt; 恢复调用链路</p>
</li>
</ul>
<p><strong>服务限流</strong></p>
<ul>
<li>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。flowlimit</li>
</ul>
<h3 id="1-3-Hystrix支付微服务构建"><a href="#1-3-Hystrix支付微服务构建" class="headerlink" title="1.3 Hystrix支付微服务构建"></a>1.3 Hystrix支付微服务构建</h3><p>将cloud-eureka-server7001改配置成单机版</p>
<ol>
<li><p>新建cloud-provider-hygtrix-payment8001</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-provider-hystrix-payment</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment">#defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentHystrixMain8001</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            SpringApplication.run(PaymentHystrixMain8001.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>业务类</p>
<p>service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">paymentInfo_OK</span><span class="hljs-params">(Integer id)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;  paymentInfo_OK,id:  &quot;</span>+id+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;O(∩_∩)O哈哈~&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">paymentInfo_TimeOut</span><span class="hljs-params">(Integer id)</span><br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">3000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; id:  &quot;</span>+id+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;O(∩_∩)O哈哈~&quot;</span>+<span class="hljs-string">&quot;  耗时(秒): 3&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentController</span><br>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PaymentService paymentService;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String serverPort;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">paymentInfo_OK</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span><br>    &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> paymentService.paymentInfo_OK(id);<br>        log.info(<span class="hljs-string">&quot;*****result: &quot;</span>+result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">paymentInfo_TimeOut</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span><br>    &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> paymentService.paymentInfo_TimeOut(id);<br>        log.info(<span class="hljs-string">&quot;*****result: &quot;</span>+result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p>启动eureka7001</p>
<p>启动cloud-provider-hystrix-payment8001</p>
<p>访问</p>
<p>success的方法 - <a target="_blank" rel="noopener" href="http://localhost:8001/payment/hystrix/ok/1">http://localhost:8001/payment/hystrix/ok/1</a><br>每次调用耗费5秒钟 - <a target="_blank" rel="noopener" href="http://localhost:8001/payment/hystrix/timeout/1">http://localhost:8001/payment/hystrix/timeout/1</a></p>
<p>上述module均OK</p>
<p>以上述为根基平台，从正确 -&gt; 错误 -&gt; 降级熔断 -&gt; 恢复。</p>
</li>
</ol>
<h3 id="1-4-JMeter高并发压测后卡顿"><a href="#1-4-JMeter高并发压测后卡顿" class="headerlink" title="1.4 JMeter高并发压测后卡顿"></a>1.4 JMeter高并发压测后卡顿</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/18/SpringCloud-3-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/18/SpringCloud-3-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">SpringCloud(3) 服务调用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 14:17:49" itemprop="dateCreated datePublished" datetime="2022-11-18T14:17:49+08:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h1><h2 id="1-RestTemplate"><a href="#1-RestTemplate" class="headerlink" title="1 RestTemplate"></a>1 RestTemplate</h2><ul>
<li><p>ribbon + restTemplate</p>
</li>
<li><p>见前两章代码使用</p>
</li>
</ul>
<h2 id="2-OpenFeign"><a href="#2-OpenFeign" class="headerlink" title="2 OpenFeign"></a>2 OpenFeign</h2><ul>
<li>官方文档: <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/</a></li>
</ul>
<h3 id="2-1-OpenFeign是什么"><a href="#2-1-OpenFeign是什么" class="headerlink" title="2.1 OpenFeign是什么"></a>2.1 OpenFeign是什么</h3><blockquote>
<p>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。</p>
</blockquote>
<ul>
<li><p><strong>Feign能干什么</strong></p>
<ul>
<li>Feign旨在使编写Java Http客户端变得更容易。</li>
<li>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。</li>
</ul>
</li>
<li><p><strong>Feign集成了Ribbon</strong></p>
<ul>
<li>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，<strong>通过Feign只需要定义服务绑定接口且以声明式的方法</strong>，优雅而简单的实现了服务调用。</li>
</ul>
</li>
<li><p><strong>Feign和OpenFeign两者区别</strong></p>
<ul>
<li><p><strong>Feign</strong>是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是: 使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>OpenFeign</strong>是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@Feignclient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-OpenFeign服务调用"><a href="#2-2-OpenFeign服务调用" class="headerlink" title="2.2 OpenFeign服务调用"></a>2.2 OpenFeign服务调用</h3><p><strong>接口+注解: 微服务调用接口 + @FeignClient</strong></p>
<ol>
<li><p>新建cloud07-consumer-feign-order80</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--openfeign--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment"># 不需要注册到eureka</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFeignMain80</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OrderFeignMain80.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>业务类</p>
<p><strong>业务逻辑接口+@FeignClient配置调用provider服务</strong></p>
<p>新建PaymentFeignService接口并新增注解@FeignClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaymentFeignService</span>&#123;<br>    <span class="hljs-meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title function_">getPaymentById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>控制层Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFeignController</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PaymentFeignService paymentFeignService;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title function_">getPaymentById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;<br>        <span class="hljs-keyword">return</span> paymentFeignService.getPaymentById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<ul>
<li><p>先启动2个eureka集群7001/7002</p>
</li>
<li><p>再启动2个微服务8001/8002</p>
</li>
<li><p>启动OpenFeign启动</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></p>
</li>
<li><p>Feign自带负载均衡配置项</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-3-OpenFeign超时控制"><a href="#2-3-OpenFeign超时控制" class="headerlink" title="2.3 OpenFeign超时控制"></a>2.3 OpenFeign超时控制</h3><ol>
<li><p>服务提供方8001/8002故意写暂停程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentController</span> &#123;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String serverPort;<br>   <br>    <span class="hljs-meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">paymentFeignTimeout</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 业务逻辑处理正确，但是需要耗费3秒钟</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> serverPort;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>服务消费方80添加超时方法PaymentFeignService</p>
</li>
<li><p>服务消费方80添加超时方法OrderFeignController</p>
</li>
</ol>
<p><strong>YML文件里设置OpenFeign客户端超时控制</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span><br>      	<span class="hljs-comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间,单位毫秒</span><br>        <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">5000</span><br>        <span class="hljs-comment">#指的是建立连接后从服务器读取到可用资源所用的时间,单位毫秒</span><br>        <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure>
<h3 id="2-4-OpenFeign日志增强"><a href="#2-4-OpenFeign日志增强" class="headerlink" title="2.4 OpenFeign日志增强"></a>2.4 OpenFeign日志增强</h3><ul>
<li><p><strong>日志打印功能</strong></p>
<ul>
<li>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http请求的细节。</li>
<li>说白了就是对Feign接口的调用情况进行监控和输出</li>
</ul>
</li>
<li><p><strong>日志级别</strong></p>
<ul>
<li>NONE: 默认的，不显示任何日志;</li>
<li>BASIC: 仅记录请求方法、URL、响应状态码及执行时间;</li>
<li>HEADERS: 除了BASIC中定义的信息之外，还有请求和响应的头信息;</li>
<li>FULL: 除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li>
</ul>
</li>
<li><p><strong>配置日志bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span><br>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.FULL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>或者在yml中配置</li>
</ul>
</li>
<li><p><strong>YML文件里需要开启日志的Feign客户端</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-comment"># feign日志以什么级别监控哪个接口</span><br>    <span class="hljs-attr">com.lun.springcloud.service.PaymentFeignService:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/17/SpringCloud-2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/17/SpringCloud-2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">SpringCloud(2) 负载均衡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-17 13:29:13" itemprop="dateCreated datePublished" datetime="2022-11-17T13:29:13+08:00">2022-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="1-Ribbon"><a href="#1-Ribbon" class="headerlink" title="1 Ribbon"></a>1 Ribbon</h2><ul>
<li>在2020年前的SpringCloud版本是采用Ribbon作为负载均衡实现，但是2020年的版本之后SpringCloud把Ribbon移除了，进而用自己编写的LoadBalancer替代。</li>
</ul>
<h3 id="1-1-Ribbon入门介绍"><a href="#1-1-Ribbon入门介绍" class="headerlink" title="1.1 Ribbon入门介绍"></a>1.1 Ribbon入门介绍</h3><ul>
<li><p>入门介绍</p>
<ul>
<li><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡的工具。</strong></p>
</li>
<li><p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供<strong>客户端的软件负载均衡算法和服务调用</strong>。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。</p>
</li>
<li><p>简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p>
</li>
<li><p>Ribbon目前也进入维护模式。未来可能被Spring Cloud LoadBalacer替代。</p>
</li>
</ul>
</li>
<li><p><strong>LB负载均衡(Load Balance)是什么</strong></p>
<ul>
<li><p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。</p>
</li>
<li><p>常见的负载均衡有软件Nginx，LVS，硬件F5等。</p>
</li>
</ul>
</li>
<li><p><strong>Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别</strong></p>
<ul>
<li>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。</li>
<li>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</li>
</ul>
</li>
<li><p><strong>集中式LB</strong></p>
<ul>
<li>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方</li>
</ul>
</li>
<li><p><strong>进程内LB</strong></p>
<ul>
<li><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p>
</li>
<li><p>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>
</li>
</ul>
</li>
<li><p><strong>一句话</strong></p>
<ul>
<li>负载均衡 + RestTemplate调用</li>
</ul>
</li>
</ul>
<h3 id="1-2-Ribbon的负载均衡和Rest调用"><a href="#1-2-Ribbon的负载均衡和Rest调用" class="headerlink" title="1.2 Ribbon的负载均衡和Rest调用"></a>1.2 Ribbon的负载均衡和Rest调用</h3><ul>
<li><strong>架构说明</strong><ul>
<li>Ribbon其实就是一个软负载均衡的客户端组件，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220727210326832.png" alt="image-20220727210326832"></p>
<ul>
<li><p>Ribbon在工作时分成两步: </p>
<ul>
<li>第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server。</li>
<li>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。</li>
</ul>
<p>其中Ribbon提供了多种策略: 比如轮询、随机和根据响应时间加权。</p>
</li>
<li><p>POM</p>
<ul>
<li><p>先前工程项目没有引入spring-cloud-starter-ribbon也可以使用ribbon。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>这是因为spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter-ribbon引用。</p>
</li>
</ul>
</li>
<li><p>RestTemplate的调用</p>
</li>
</ul>
<h3 id="1-3-Ribbon负载规则替换"><a href="#1-3-Ribbon负载规则替换" class="headerlink" title="1.3 Ribbon负载规则替换"></a>1.3 Ribbon负载规则替换</h3><ul>
<li><p><strong>Ribbon默认自带的负载规则</strong></p>
<ul>
<li><p>IRule: 根据特定算法中从服务列表中选取一个要访问的服务</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220728111338080.png" alt="image-20220728111338080"></p>
</li>
<li><p><code>RoundRobinRule</code>: 轮询</p>
</li>
<li><code>RandomRule</code>: 随机</li>
<li><code>RetryRule</code>: 先按照<code>RoundRobinRule</code>的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务</li>
<li><code>WeightedResponseTimeRule</code>: 对<code>RoundRobinRule</code>的扩展，响应速度越快的实例选择权重越大，越容易被选择</li>
<li><code>BestAvailableRule</code>: 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li>
<li><code>AvailabilityFilteringRule</code>: 先过滤掉故障实例，再选择并发较小的实例</li>
<li><code>ZoneAvoidanceRule</code>: 默认规则，复合判断server所在区域的性能和server的可用性选择服务器</li>
</ul>
</li>
<li><p><strong>Ribbon负载规则替换</strong></p>
<ul>
<li>修改cloud-consumer-order80</li>
<li><p>注意配置细节</p>
<ul>
<li>官方文档明确给出了警告: </li>
<li>这个自定义配置类不能放在<code>@ComponentScan</code>所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。</li>
<li>(<strong>也就是说不要将Ribbon配置类与主启动类同包</strong>)</li>
</ul>
</li>
<li><p>新建package - com.whale.myrule</p>
</li>
<li><p>在com.whale.myrule下新建MySelfRule规则类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySelfRule</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">myRule</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>主启动类添加@RibbonClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerOrder80</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(CustomerOrder80.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-4-Ribbon默认负载轮询算法原理"><a href="#1-4-Ribbon默认负载轮询算法原理" class="headerlink" title="1.4 Ribbon默认负载轮询算法原理"></a>1.4 Ribbon默认负载轮询算法原理</h3><p><strong>默认负载轮询算法: rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始</strong>。</p>
<h3 id="1-5-Ribbon之手写轮询算法"><a href="#1-5-Ribbon之手写轮询算法" class="headerlink" title="1.5 Ribbon之手写轮询算法"></a>1.5 Ribbon之手写轮询算法</h3><ul>
<li><p>7001/7002集群启动</p>
</li>
<li><p>8001/8002微服务改造- controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/lb&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPaymentLB</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> serverPort;<span class="hljs-comment">//返回服务接口</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>80订单微服务改造</p>
<ul>
<li><p>ApplicationContextConfig去掉注解@LoadBalanced，OrderMain80去掉注解@RibbonClient</p>
</li>
<li><p>创建LoadBalancer接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoadBalancer</span>&#123;<br>    ServiceInstance <span class="hljs-title function_">instances</span><span class="hljs-params">(List&lt;ServiceInstance&gt; serviceInstances)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>MyLB实现LoadBalancer接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-comment">//需要跟主启动类同包，或者在其子孙包下。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancer</span><br>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">int</span> current;<br>        <span class="hljs-type">int</span> next;<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            current = <span class="hljs-built_in">this</span>.atomicInteger.get();<br>            next = current &gt;= <span class="hljs-number">2147483647</span> ? <span class="hljs-number">0</span> : current + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.atomicInteger.compareAndSet(current,next));<br>        System.out.println(<span class="hljs-string">&quot;*****第几次访问，次数next: &quot;</span>+next);<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-comment">//负载均衡算法: rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标  ，每次服务重启动后rest接口计数从1开始。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServiceInstance <span class="hljs-title function_">instances</span><span class="hljs-params">(List&lt;ServiceInstance&gt; serviceInstances)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> getAndIncrement() % serviceInstances.size();<br><br>        <span class="hljs-keyword">return</span> serviceInstances.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>OrderController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-comment">//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PAYMENT_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;<br><br>    ...<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> LoadBalancer loadBalancer;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><br>    ...<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/consumer/payment/lb&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPaymentLB</span><span class="hljs-params">()</span><br>    &#123;<br>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(instances == <span class="hljs-literal">null</span> || instances.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> loadBalancer.instances(instances);<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> serviceInstance.getUri();<br><br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(uri+<span class="hljs-string">&quot;/payment/lb&quot;</span>,String.class);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试 不停地刷新<a target="_blank" rel="noopener" href="http://localhost/consumer/payment/lb，可以看到8001/8002交替出现。">http://localhost/consumer/payment/lb，可以看到8001/8002交替出现。</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-LoadBalancer"><a href="#2-LoadBalancer" class="headerlink" title="2 LoadBalancer"></a>2 LoadBalancer</h2><h3 id="2-1-负载均衡"><a href="#2-1-负载均衡" class="headerlink" title="2.1 负载均衡"></a>2.1 负载均衡</h3><p>实际上，在添加<code>@LoadBalanced</code>注解之后，会启用拦截器对我们发起的服务调用请求进行拦截(注意这里是针对我们发起的请求进行拦截)，叫做<code>LoadBalancerInterceptor</code>，它实现<code>ClientHttpRequestInterceptor</code>接口: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClientHttpRequestInterceptor</span> &#123;<br>    ClientHttpResponse <span class="hljs-title function_">intercept</span><span class="hljs-params">(HttpRequest request, <span class="hljs-type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要是对<code>intercept</code>方法的实现: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title function_">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] body, <span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">URI</span> <span class="hljs-variable">originalUri</span> <span class="hljs-operator">=</span> request.getURI();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> originalUri.getHost();<br>    Assert.state(serviceName != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);<br>    <span class="hljs-keyword">return</span> (ClientHttpResponse)<span class="hljs-built_in">this</span>.loadBalancer.execute(serviceName, <span class="hljs-built_in">this</span>.requestFactory.createRequest(request, body, execution));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以打个断点看看实际是怎么在执行的，可以看到服务端会在发起请求时执行这些拦截器。</p>
<p>那么这个拦截器做了什么事情呢，首先我们要明确，我们给过来的请求地址，并不是一个有效的主机名称，而是服务名称，那么怎么才能得到真正需要访问的主机名称呢，肯定是得找Eureka获取的。</p>
<p>我们来看看<code>loadBalancer.execute()</code>做了什么，它的具体实现为<code>BlockingLoadBalancerClient</code>: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从上面给进来了服务的名称和具体的请求实体</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">hint</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getHint(serviceId);<br>    LoadBalancerRequestAdapter&lt;T, DefaultRequestContext&gt; lbRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerRequestAdapter</span>(request, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRequestContext</span>(request, hint));<br>    Set&lt;LoadBalancerLifecycle&gt; supportedLifecycleProcessors = <span class="hljs-built_in">this</span>.getSupportedLifecycleProcessors(serviceId);<br>    supportedLifecycleProcessors.forEach((lifecycle) -&gt; &#123;<br>        lifecycle.onStart(lbRequest);<br>    &#125;);<br>  	<span class="hljs-comment">//可以看到在这里会调用choose方法自动获取对应的服务实例信息</span><br>    <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.choose(serviceId, lbRequest);<br>    <span class="hljs-keyword">if</span> (serviceInstance == <span class="hljs-literal">null</span>) &#123;<br>        supportedLifecycleProcessors.forEach((lifecycle) -&gt; &#123;<br>            lifecycle.onComplete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionContext</span>(Status.DISCARD, lbRequest, <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyResponse</span>()));<br>        &#125;);<br>      	<span class="hljs-comment">//没有发现任何此服务的实例就抛异常(之前的测试中可能已经遇到了)</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No instances available for &quot;</span> + serviceId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">//成功获取到对应服务的实例，这时就可以发起HTTP请求获取信息了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.execute(serviceId, serviceInstance, lbRequest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以，实际上在进行负载均衡的时候，会向Eureka发起请求，选择一个可用的对应服务，然后会返回此服务的主机地址等信息</p>
<h3 id="2-2-自定义负载均衡策略"><a href="#2-2-自定义负载均衡策略" class="headerlink" title="2.2 自定义负载均衡策略"></a>2.2 自定义负载均衡策略</h3><p>LoadBalancer默认提供了两种负载均衡策略: </p>
<ul>
<li>RandomLoadBalancer - 随机分配策略</li>
<li><strong>(默认)</strong> RoundRobinLoadBalancer - 轮询分配策略</li>
</ul>
<p>现在我们希望修改默认的负载均衡策略，可以进行指定，比如我们现在希望用户服务采用随机分配策略，我们需要先创建随机分配策略的配置类(不用加<code>@Configuration</code>): </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadBalancerConfig</span> &#123;<br>  	<span class="hljs-comment">//将官方提供的 RandomLoadBalancer 注册为Bean</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="hljs-title function_">randomLoadBalancer</span><span class="hljs-params">(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着我们需要为对应的服务指定负载均衡策略，直接使用注解即可: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@LoadBalancerClient(value = &quot;userservice&quot;,      //指定为 userservice 服务，只要是调用此服务都会使用我们指定的策略</span><br><span class="hljs-meta">                    configuration = LoadBalancerConfig.class)</span>   <span class="hljs-comment">//指定我们刚刚定义好的配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    RestTemplate <span class="hljs-title function_">template</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着我们在<code>BlockingLoadBalancerClient</code>中添加断点，观察是否采用我们指定的策略进行请求</p>
<p>发现访问userservice服务的策略已经更改为我们指定的策略了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Whale-lyi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Whale-lyi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
