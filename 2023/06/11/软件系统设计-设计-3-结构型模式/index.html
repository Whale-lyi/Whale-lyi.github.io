<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="南京大学软件学院大三在读" />
  
  
  <title>
    
      软件系统设计-设计(3) 结构型模式 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">软件系统设计-设计(3) 结构型模式</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-08-09 14:53:19
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/NJU/" title="NJU">
                    <b>#</b> NJU
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="软件系统设计">
                    <b>#</b> 软件系统设计
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="1-类-适配器模式与-对象-适配器模式"><a href="#1-类-适配器模式与-对象-适配器模式" class="headerlink" title="1. (类)适配器模式与(对象)适配器模式"></a>1. (类)适配器模式与(对象)适配器模式</h2><h3 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1 模式动机"></a>1.1 模式动机</h3><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612095510933.png" alt="image-20230612095510933" style="zoom:80%;" />

<ol>
<li>在软件开发中采用类似于电源适配器的设计和编码技巧被称为<strong>适配器模式</strong>。</li>
<li>通常情况下，<strong>客户端可以通过目标类的接口访问它所提供的服务</strong>。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li>
<li>在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</li>
<li>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是**适配器(Adapter)<strong>，它所包装的对象就是</strong>适配者(Adaptee)**，即被适配的类。</li>
<li>适配器提供客户类需要的接口，<strong>适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用</strong>。也就是说：<strong>当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类</strong>。因此，<strong>适配器可以使由于接口不兼容而不能交互的类可以一起工作</strong>。这就是适配器模式的模式动机。</li>
</ol>
<h3 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2 模式定义"></a>1.2 模式定义</h3><ol>
<li>适配器模式(Adapter Pattern) ：<strong>将一个接口转换成客户希望的另一个接口</strong>，适配器模式使<strong>接口不兼容的那些类可以一起工作</strong>，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li>
<li>Adapter Pattern: <strong>Convert the interface of a  class into another interface clients expect</strong>.  Adapter lets classes work together that  couldn’t otherwise because of incompatible  interfaces.</li>
</ol>
<h3 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3 模式结构"></a>1.3 模式结构</h3><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612095709256.png" alt="image-20230612095709256" style="zoom:80%;" />

<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612095817460.png" alt="image-20230612095817460" style="zoom:80%;" />

<p>适配器模式包含如下角色：</p>
<ol>
<li>Target：目标抽象类</li>
<li>Adapter：适配器类</li>
<li>Adaptee：适配者类</li>
<li>Client：客户类</li>
</ol>
<h3 id="1-4-模式分析"><a href="#1-4-模式分析" class="headerlink" title="1.4 模式分析"></a>1.4 模式分析</h3><ol>
<li>典型的类适配器代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>    specificRequest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>典型的对象适配器代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span>&#123;<br>  <span class="hljs-keyword">private</span> Adaptee adaptee;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span>&#123;<br>    <span class="hljs-built_in">this</span>.adaptee=adaptee;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>&#123;<br>    adaptee.specificRequest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-5-适配器模式实例与解析"><a href="#1-5-适配器模式实例与解析" class="headerlink" title="1.5 适配器模式实例与解析"></a>1.5 适配器模式实例与解析</h3><p>实例一：仿生机器人</p>
<p>现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法cry()、机器人移动方法move()等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑，使用适配器模式进行系统设计。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612100106413.png" alt="image-20230612100106413" style="zoom:80%;" />

<p>实例二：加密适配器</p>
<p>某系统需要提供一个加密模块，将用户信息（如密码等机密信息）加密之后再存储在数据库中，系统已经定义好了数据库操作类。为了提高开发效率，现需要重用已有的加密算法，这些算法封装在一些由第三方提供的类中，有些甚至没有源代码。使用适配器模式设计该加密模块，实现在不修改现有类的基础上重用第三方加密方法。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612100259747.png" alt="image-20230612100259747" style="zoom:80%;" />

<h3 id="1-6-模式优缺点"><a href="#1-6-模式优缺点" class="headerlink" title="1.6 模式优缺点"></a>1.6 模式优缺点</h3><p><strong>适配器模式的优点</strong></p>
<ol>
<li><strong>将目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
<li><strong>增加了类的透明性和复用性</strong>，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li><strong>灵活性和扩展性都非常好</strong>，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合”开闭原则”。</li>
</ol>
<p><strong>类适配器模式的优点</strong></p>
<ol>
<li>由于适配器类是适配者类的子类，因此<strong>可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</strong>。</li>
</ol>
<p><strong>类适配器模式的缺点</strong></p>
<ol>
<li>对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，<strong>其使用有一定的局限性</strong>，不能将一个适配者类和它的子类都适配到目标接口。</li>
</ol>
<p><strong>对象适配器模式的优点</strong></p>
<ol>
<li>一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，<strong>同一个适配器可以把适配者类和它的子类都适配到目标接口</strong>。</li>
</ol>
<p><strong>对象适配器模式的缺点</strong></p>
<ol>
<li>与类适配器模式相比，要想<strong>置换适配者类的方法就不容易</strong>。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>
</ol>
<h3 id="1-7-模式适用环境"><a href="#1-7-模式适用环境" class="headerlink" title="1.7 模式适用环境"></a>1.7 模式适用环境</h3><p>在以下情况下可以使用适配器模式：</p>
<ol>
<li>系统<strong>需要使用现有的类</strong>，而这些类的接口不符合系统的需要。</li>
<li><strong>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类</strong>，包括一些可能在将来引进的类<strong>一起工作</strong>。</li>
</ol>
<h3 id="1-8-模式应用"><a href="#1-8-模式应用" class="headerlink" title="1.8 模式应用"></a>1.8 模式应用</h3><ol>
<li>Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。<strong>JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎</strong>（如SQL Server、Oracle、MySQL等）<strong>的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件</strong>。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的<strong>驱动程序</strong>。</li>
</ol>
<h3 id="1-9-模式应用"><a href="#1-9-模式应用" class="headerlink" title="1.9 模式应用"></a>1.9 模式应用</h3><p><strong>JDK类库中的适配器类</strong></p>
<p>如在com.sun.imageio.plugins.common包中定义的<strong>InputStreamAdapter</strong>类，用于包装ImageInputStream接口及其子类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span>&#123;<br>  ImageInputStream stream;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamAdapter</span><span class="hljs-params">(ImageInputStream stream)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.stream = stream;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> stream.read();<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> stream.read(b, off, len);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>默认适配器模式(Default Adapter Pattern)或缺省适配器模式</strong></p>
<p>当不需要全部实现接口提供的方法时，可先设计一个<strong>抽象类实现接口</strong>，并<strong>为该接口中每个方法提供一个默认实现</strong>（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它<strong>适用于一个接口不想使用其所有的方法的情况</strong>。因此也称为<strong>单接口适配器模式</strong>。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612100912991.png" alt="image-20230612100912991" style="zoom:80%;" />
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612100934239.png" alt="image-20230612100934239" style="zoom:80%;" />

<p><strong>双向适配器</strong></p>
<p>在对象适配器的使用过程中，如果<strong>在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法</strong>，那么该适配器就是一个<strong>双向适配器</strong>。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612101107369.png" alt="image-20230612101107369" style="zoom:80%;" />

<h3 id="1-10-适配器小结"><a href="#1-10-适配器小结" class="headerlink" title="1.10 适配器小结"></a>1.10 适配器小结</h3><ol>
<li>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</li>
<li>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li>
<li>适配器模式包含四个角色<ol>
<li>目标抽象类定义客户要用的特定领域的接口</li>
<li>适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心</li>
<li>适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配</li>
<li>在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li>
</ol>
</li>
<li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li>
<li>适配器模式<ol>
<li>主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合”开闭原则”</li>
<li>类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类</li>
<li>对象适配器模式的缺点是很难置换适配者类的方法。</li>
</ol>
</li>
<li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li>
</ol>
<h2 id="2-组合模式-对象"><a href="#2-组合模式-对象" class="headerlink" title="2. 组合模式(对象)"></a>2. 组合模式(对象)</h2><h3 id="2-1-模式动机"><a href="#2-1-模式动机" class="headerlink" title="2.1 模式动机"></a>2.1 模式动机</h3><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612102923937.png" alt="image-20230612102923937" style="zoom:80%;" />

<ol>
<li>对于<strong>树形结构</strong>，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，如子文件夹和文件）并调用执行。<strong>（递归调用）</strong></li>
<li>由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须<strong>有区别地对待容器对象和叶子对象</strong>，而实际上<strong>大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂</strong>。</li>
<li>组合模式描述了<strong>如何将容器对象和叶子对象进行递归组合</strong>，使得<strong>用户在使用时无须对它们进行区分</strong>，可以<strong>一致地对待容器对象和叶子对象</strong>，这就是组合模式的模式动机。</li>
</ol>
<h3 id="2-2-模式定义"><a href="#2-2-模式定义" class="headerlink" title="2.2 模式定义"></a>2.2 模式定义</h3><ol>
<li>组合模式(Composite Pattern)：组合多个对象形成<strong>树形结构</strong>以<strong>表示”整体-部分”的结构层次</strong>。组合模式对<strong>单个对象（即叶子对象）</strong>和<strong>组合对象（即容器对象）</strong>的<strong>使用具有一致性</strong>。</li>
<li>组合模式又可以称为<strong>整体-部分(Part-Whole)模式</strong>，属于对象的结构模式，它<strong>将对象组织到树结构中，可以用来描述整体与部分的关系</strong>。</li>
<li>Composite Pattern: Compose objects into tree  structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</li>
</ol>
<h3 id="2-3-模式结构"><a href="#2-3-模式结构" class="headerlink" title="2.3 模式结构"></a>2.3 模式结构</h3><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612103906865.png" alt="image-20230612103906865" style="zoom:80%;" />

<p>组合模式包含如下角色：</p>
<ol>
<li>Component: 抽象构件</li>
<li>Leaf: 叶子构件</li>
<li>Composite: 容器构件</li>
<li>Client: 客户类</li>
</ol>
<h3 id="2-4-模式分析"><a href="#2-4-模式分析" class="headerlink" title="2.4 模式分析"></a>2.4 模式分析</h3><ol>
<li>组合模式的关键是<strong>定义了一个抽象构件类</strong>，它既可以代表叶子，又可以代表容器，而<strong>客户端针对该抽象构件类进行编程</strong>，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</li>
<li>同时<strong>容器对象与抽象构件类之间还建立一个聚合关联关系</strong>，在容器对象中既可以包含叶子，也可以包含容器，以此<strong>实现递归组合，形成一个树形结构</strong>。</li>
<li>文件系统组合模式结构图：</li>
</ol>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104101339.png" alt="image-20230612104101339" style="zoom:80%;" />

<ol start="4">
<li>典型的抽象构件角色代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>典型的叶子构件角色代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>  &#123; <span class="hljs-comment">//异常处理或错误提示 </span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span><br>  &#123; <span class="hljs-comment">//实现代码</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>典型的容器构件角色代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span><br>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span> &#123;<br>    list.add(c);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span> &#123;<br>    list.remove(c);<br>  &#125;<br>  <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> (Component)list.get(i);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(Object obj:list) &#123;<br>      ((Component)obj).operation();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-5-组合模式实例与解析"><a href="#2-5-组合模式实例与解析" class="headerlink" title="2.5 组合模式实例与解析"></a>2.5 组合模式实例与解析</h3><p>实例一：水果盘</p>
<p>在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行”吃”方法，实际上就是吃其中的水果。使用组合模式模拟该场景。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104406439.png" alt="image-20230612104406439" style="zoom:80%;" />

<p>实例二：文件浏览</p>
<p>文件有不同类型，不同类型的文件其浏览方式有所区别，如文本文件和图片文件的浏览方式就不相同。对文件夹的浏览实际上就是对其中所包含文件的浏览，而客户端可以一致地对文件和文件夹进行操作，无须关心它们的区别。使用组合模式来模拟文件的浏览操作。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104525305.png" alt="image-20230612104525305"></p>
<h3 id="2-6-模式优缺点"><a href="#2-6-模式优缺点" class="headerlink" title="2.6 模式优缺点"></a>2.6 模式优缺点</h3><p>组合模式的优点</p>
<ol>
<li>可以清楚地定义<strong>分层次的复杂对象</strong>，表示对象的全部或部分层次，使得增加新构件也更容易。</li>
<li>客户端调用简单，<strong>客户端可以一致的使用组合结构或其中单个对象</strong>。</li>
<li>定义了包含叶子对象和容器对象的<strong>类层次结构</strong>，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，<strong>可以形成复杂的树形结构</strong>。</li>
<li><strong>更容易在组合体内加入对象构件</strong>，客户端不必因为加入了新的对象构件而更改原有代码。组合模式</li>
</ol>
<p>组合模式的缺点</p>
<ol>
<li><strong>使设计变得更加抽象</strong>，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。</li>
<li>增加新构件时可能会产生一些问题，<strong>很难对容器中的构件类型进行限制</strong>。</li>
</ol>
<h3 id="2-7-模式适用环境"><a href="#2-7-模式适用环境" class="headerlink" title="2.7 模式适用环境"></a>2.7 模式适用环境</h3><p>在以下情况下可以使用组合模式：</p>
<ol>
<li>需要表示一个<strong>对象整体或部分层次</strong>，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。</li>
<li>让客户能够忽略不同对象层次的变化，<strong>客户端可以针对抽象构件编程，无须关心对象层次结构的细节</strong>。</li>
<li><strong>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们</strong>。</li>
</ol>
<h3 id="2-8-模式应用"><a href="#2-8-模式应用" class="headerlink" title="2.8 模式应用"></a>2.8 模式应用</h3><ol>
<li>XML文档解析</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">books</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Carson<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">price</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dollar&quot;</span>&gt;</span>31.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pubdate</span>&gt;</span>05/01/2001<span class="hljs-tag">&lt;/<span class="hljs-name">pubdate</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pubinfo</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">publisher</span>&gt;</span>MSPress<span class="hljs-tag">&lt;/<span class="hljs-name">publisher</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">state</span>&gt;</span>WA<span class="hljs-tag">&lt;/<span class="hljs-name">state</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pubinfo</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">books</span>&gt;</span><br></code></pre></td></tr></table></figure>

<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104708064.png" alt="image-20230612104708064" style="zoom:80%;" />

<ol start="2">
<li><strong>操作系统中的目录结构</strong>是一个树形结构，因此在对文件和文件夹进行操作时可以应用组合模式，例如杀毒软件在查毒或杀毒时，既可以针对一个具体文件，也可以针对一个目录。如果是对目录查毒或杀毒，将递归处理目录中的每一个子目录和文件。</li>
<li>JDK的<strong>AWT&#x2F;Swing</strong>是组合模式在Java类库中的一个典型实际应用。</li>
</ol>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104736113.png" alt="image-20230612104736113" style="zoom:80%;" />

<h3 id="2-9-模式扩展"><a href="#2-9-模式扩展" class="headerlink" title="2.9 模式扩展"></a>2.9 模式扩展</h3><h4 id="更复杂的组合模式"><a href="#更复杂的组合模式" class="headerlink" title="更复杂的组合模式"></a>更复杂的组合模式</h4><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104808582.png" alt="image-20230612104808582" style="zoom:80%;" />

<h4 id="透明组合模式"><a href="#透明组合模式" class="headerlink" title="透明组合模式"></a>透明组合模式</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104847480.png" alt="image-20230612104847480"></p>
<h4 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h4><ul>
<li>违反了里氏代换原则</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612104908637.png" alt="image-20230612104908637"></p>
<h3 id="2-10-组合小结"><a href="#2-10-组合小结" class="headerlink" title="2.10 组合小结"></a>2.10 组合小结</h3><ol>
<li>组合模式用于组合多个对象形成树形结构以表示”整体-部分”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。组合模式又可以称为”整体-部分”模式，属于对象的结构模式，它将对象组织到树结构中，可以用来描述整体与部分的关系。</li>
<li>组合模式包含三个角色<ol>
<li>抽象构件为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现</li>
<li>叶子构件在组合结构中表示叶子节点对象，叶子节点没有子节点</li>
<li>容器构件在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为。</li>
</ol>
</li>
<li>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</li>
<li>组合模式<ol>
<li>主要优点在于可以方便地对层次结构进行控制，客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关心自己处理的是单个对象还是整个组合结构，简化了客户端代码</li>
<li>缺点在于使设计变得更加抽象，且增加新构件时可能会产生一些问题，而且很难对容器中的构件类型进行限制。</li>
</ol>
</li>
<li>组合模式适用情况包括<ol>
<li>需要表示一个对象整体或部分层次</li>
<li>让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节</li>
<li>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。</li>
</ol>
</li>
<li>组合模式根据抽象构件类的定义形式，又可以分为透明组合模式和安全组合模式。</li>
</ol>
<h2 id="3-装饰模式-对象"><a href="#3-装饰模式-对象" class="headerlink" title="3. 装饰模式(对象)"></a>3. 装饰模式(对象)</h2><h3 id="3-1-模式动机"><a href="#3-1-模式动机" class="headerlink" title="3.1 模式动机"></a>3.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612105355434.png" alt="image-20230612105355434"></p>
<ol>
<li>一般有两种方式可以实现给一个类或对象增加行为：<ol>
<li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li>
<li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为。</li>
</ol>
</li>
<li>装饰模式以<strong>对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在<strong>不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</li>
</ol>
<h3 id="3-2-模式定义"><a href="#3-2-模式定义" class="headerlink" title="3.2 模式定义"></a>3.2 模式定义</h3><ol>
<li>装饰模式(Decorator Pattern) ：<strong>动态地给一个对象增加一些额外的职责</strong>(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为<strong>包装器</strong>(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为”油漆工模式”，它是一种<strong>对象结构型模式</strong>。</li>
<li>Decorator Pattern: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to  subclassing for extending functionality.</li>
</ol>
<h3 id="3-3-模式结构"><a href="#3-3-模式结构" class="headerlink" title="3.3 模式结构"></a>3.3 模式结构</h3><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612105517641.png" alt="image-20230612105517641" style="zoom:80%;" />

<p>装饰模式包含如下角色：</p>
<ol>
<li>Component: 抽象构件</li>
<li>ConcreteComponent: 具体构件</li>
<li>Decorator: 抽象装饰类</li>
<li>ConcreteDecorator: 具体装饰类</li>
</ol>
<h3 id="3-4-模式分析"><a href="#3-4-模式分析" class="headerlink" title="3.4 模式分析"></a>3.4 模式分析</h3><ol>
<li>与继承关系相比，关联关系的主要优势在于<strong>不会破坏类的封装性</strong>，而且<strong>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得<strong>系统更加容易维护</strong>。当然，关联关系的缺点是<strong>比继承关系要创建更多的对象</strong>。</li>
<li>使用装饰模式来实现扩展比继承更加灵活，<strong>它以对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li>
<li>典型的抽象装饰类代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>  	<span class="hljs-keyword">private</span> Component component;<br>  	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Component component)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.component=component;<br>  	&#125;<br>  	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>   		component.operation();<br>   	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>典型的具体装饰类代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator</span><span class="hljs-params">(Component component)</span> &#123;<br>    	<span class="hljs-built_in">super</span>(component);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.operation();<br>        addedBehavior();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addedBehavior</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//新增方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-5-装饰模式实例与解析"><a href="#3-5-装饰模式实例与解析" class="headerlink" title="3.5 装饰模式实例与解析"></a>3.5 装饰模式实例与解析</h3><p>实例一：变形金刚</p>
<p>变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612110030272.png" alt="image-20230612110030272" style="zoom:80%;" />

<p>实例二：多重加密系统</p>
<p>某系统提供了一个数据加密功能，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。现使用装饰模式设计该多重加密系统。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612110111263.png" alt="image-20230612110111263"></p>
<h3 id="3-6-模式优缺点"><a href="#3-6-模式优缺点" class="headerlink" title="3.6 模式优缺点"></a>3.6 模式优缺点</h3><p>装饰模式的优点</p>
<ol>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是<strong>装饰模式可以提供比继承更多的灵活性</strong>。</li>
<li>可以<strong>通过一种动态的方式来扩展一个对象的功能</strong>，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li>
<li><strong>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合</strong>。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li>
<li><strong>具体构件类与具体装饰类可以独立变化</strong>，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合”开闭原则”。</li>
</ol>
<p>装饰模式的缺点</p>
<ol>
<li>使用装饰模式进行系统设计时将<strong>产生很多小对象</strong>，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li>
<li>这种比继承更加灵活机动的特性，也同时意味着<strong>装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐</strong>。</li>
</ol>
<h3 id="3-7-模式适用环境"><a href="#3-7-模式适用环境" class="headerlink" title="3.7 模式适用环境"></a>3.7 模式适用环境</h3><p>在以下情况下可以使用装饰模式：</p>
<ol>
<li>在不影响其他对象的情况下，<strong>以动态、透明的方式给单个对象添加职责</strong>。</li>
<li>需要<strong>动态地给一个对象增加功能</strong>，这些功能也可以<strong>动态地被撤销</strong>。</li>
<li><strong>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时</strong>。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li>
</ol>
<h3 id="3-8-模式应用"><a href="#3-8-模式应用" class="headerlink" title="3.8 模式应用"></a>3.8 模式应用</h3><p>在javax.swing包中，可以通过装饰模式动态给一些构件增加新的行为或改善其外观显示。</p>
<ul>
<li>如JList构件本身并不支持直接滚动，即没有滚动条，要创建可以滚动的列表，可以使用如下代码实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">JList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JList</span>();<br><span class="hljs-type">JScrollPane</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JScrollPane</span>(list);<br></code></pre></td></tr></table></figure>

<p>装饰模式在JDK中最经典的实例是Java IO。</p>
<ul>
<li>以 <code>InputStream</code> 为例：</li>
</ul>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612110315912.png" alt="image-20230612110315912" style="zoom:80%;" />

<ul>
<li>抽象装饰类：<code>FilterInputStream</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">FilterInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>	<span class="hljs-built_in">this</span>.in = in;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>角色分配：</p>
<ul>
<li>抽象构件类：InputStream</li>
<li>具体构件类：FileInputStream、ByteArrayInputStream等</li>
<li>抽象装饰类：FilterInputStream</li>
<li>具体装饰类：BufferedInputStream、DataInputStream等</li>
</ul>
</li>
<li><p>客户端使用：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inFS</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;temp/fileSrc.txt&quot;</span>);<br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">inBS</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(inFS);<br><span class="hljs-comment">//定义一个字节数组，用于存放缓冲数据</span><br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>inBS.read(data);<br></code></pre></td></tr></table></figure>

<h3 id="3-9-模式扩展"><a href="#3-9-模式扩展" class="headerlink" title="3.9 模式扩展"></a>3.9 模式扩展</h3><h4 id="装饰模式的简化"><a href="#装饰模式的简化" class="headerlink" title="装饰模式的简化"></a>装饰模式的简化</h4><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612110713084.png" alt="image-20230612110713084" style="zoom:80%;" />

<p>需要注意的问题</p>
<ul>
<li><strong>一个装饰类的接口必须与被装饰类的接口保持相同</strong>，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li>
<li>尽量保持具体构件类Component作为一个”轻”类，也就是说<strong>不要把太多的逻辑和状态放在具体构件类中</strong>，可以通过装饰类对其进行扩展。</li>
<li><strong>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类</strong>。</li>
</ul>
<h4 id="透明装饰模式（多重加密系统）"><a href="#透明装饰模式（多重加密系统）" class="headerlink" title="透明装饰模式（多重加密系统）"></a>透明装饰模式（多重加密系统）</h4><ol>
<li>在透明装饰模式中，要求<strong>客户端完全针对抽象编程</strong>，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Cipher sc,cc,ac;<br>sc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleCipher</span>();<br>cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComplexCipher</span>(sc);<br>ac = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvancedCipher</span>(cc);<br></code></pre></td></tr></table></figure>

<h4 id="半透明装饰模式（变形金刚）"><a href="#半透明装饰模式（变形金刚）" class="headerlink" title="半透明装饰模式（变形金刚）"></a>半透明装饰模式（变形金刚）</h4><ol>
<li>**半透明(semi-transparent)**的装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Transform camaro;<br>camaro=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>camaro.move();<br><span class="hljs-type">Robot</span> <span class="hljs-variable">bumblebee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Robot</span>(camaro);<br>bumblebee.move();<br>bumblebee.say();<br></code></pre></td></tr></table></figure>

<h3 id="3-10-小结"><a href="#3-10-小结" class="headerlink" title="3.10 小结"></a>3.10 小结</h3><ol>
<li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li>
<li>装饰模式包含四个角色<ol>
<li>抽象构件定义了对象的接口，可以给这些对象动态增加职责（方法）</li>
<li>具体构件定义了具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）</li>
<li>抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现</li>
<li>具体装饰类是抽象装饰类的子类，负责向构件添加新的职责。</li>
</ol>
</li>
<li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li>
<li>装饰模式<ol>
<li>主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类</li>
<li>主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li>
</ol>
</li>
<li>装饰模式适用情况包括<ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li>
<li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销</li>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</li>
</ol>
</li>
<li>装饰模式可分为透明装饰模式和半透明装饰模式<ol>
<li>在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型</li>
<li>半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li>
</ol>
</li>
</ol>
<h2 id="4-外观模式-对象"><a href="#4-外观模式-对象" class="headerlink" title="4. 外观模式(对象)"></a>4. 外观模式(对象)</h2><h3 id="4-1-模式动机"><a href="#4-1-模式动机" class="headerlink" title="4.1 模式动机"></a>4.1 模式动机</h3><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612111836731.png" alt="image-20230612111836731" style="zoom:80%;" />

<p>引入外观角色之后，<strong>用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现</strong>，从而降低了系统的耦合度。</p>
<h3 id="4-2-模式定义"><a href="#4-2-模式定义" class="headerlink" title="4.2 模式定义"></a>4.2 模式定义</h3><ol>
<li>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个<strong>统一的外观对象</strong>进行，为子系统中的一组接口<strong>提供一个一致的界面</strong>，外观模式定义了一个高层接口，这个接口<strong>使得这一子系统更加容易使用</strong>。外观模式又称为<strong>门面模式</strong>，它是一种<strong>对象结构型模式</strong>。<ol>
<li>简化了接口</li>
<li>接口相关模式：适配器模式、外观模式，变化决定了要使用哪个模式</li>
</ol>
</li>
<li>Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</li>
</ol>
<h3 id="4-3-模式结构"><a href="#4-3-模式结构" class="headerlink" title="4.3 模式结构"></a>4.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612112036071.png" alt="image-20230612112036071"></p>
<ul>
<li>外观模式包含如下角色：<ol>
<li>Facade: 外观角色</li>
<li>SubSystem:子系统角色</li>
</ol>
</li>
<li>使用的设计思想：迪米特法则</li>
</ul>
<h3 id="4-4-模式分析"><a href="#4-4-模式分析" class="headerlink" title="4.4 模式分析"></a>4.4 模式分析</h3><ol>
<li>根据“单一职责原则”，<strong>在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性</strong>，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是<strong>引入一个外观对象</strong>，它<strong>为子系统的访问提供了一个简单而单一的入口</strong>。</li>
<li>外观模式也是“迪米特法则”的体现，<strong>通过引入一个新的外观类可以降低原有系统的复杂度</strong>，同时<strong>降低客户类与子系统类的耦合度</strong>。</li>
<li>外观模式要求一个子系统的外部与其内部的通信<strong>通过一个统一的外观对象进行</strong>，外观类将客户端与子系统的内部复杂性分隔开，使得<strong>客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道</strong>。</li>
<li>外观模式的目的在于<strong>降低系统的复杂程度</strong>。</li>
<li>外观模式从很大程度上<strong>提高了客户端使用的便捷性</strong>，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li>
<li>典型的外观角色代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemA</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemA</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemB</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemB</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemC</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemC</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    obj1.method();<br>    obj2.method();<br>    obj3.method();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-5-外观模式实例与解析"><a href="#4-5-外观模式实例与解析" class="headerlink" title="4.5 外观模式实例与解析"></a>4.5 外观模式实例与解析</h3><p>实例一：电源总开关</p>
<p>现在考察一个电源总开关的例子，以便进一步说明外观模式。为了使用方便，一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。通过该电源总开关可以同时控制上述所有电器设备，使用外观模式设计该系统。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612112647563.png" alt="image-20230612112647563"></p>
<p>实例二：文件加密</p>
<p>某系统需要提供一个文件加密模块，加密流程包括三个操作，分别是读取源文件、加密、保存加密之后的文件。读取文件和保存文件使用流来实现，这三个操作相对独立，其业务代码封装在三个不同的类中。现在需要提供一个统一的加密外观类，用户可以直接使用该加密外观类完成文件的读取、加密和保存三个操作，而不需要与每一个类进行交互，使用外观模式设计该加密模块。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612112820640.png" alt="image-20230612112820640"></p>
<p>可以使用模板方法模式实现嘛？子类提供不同的实现，复用父类方法的步骤</p>
<p>什么时候外观？如果每一个部分都不变，只是提供接口</p>
<h3 id="4-6-模式优缺点"><a href="#4-6-模式优缺点" class="headerlink" title="4.6 模式优缺点"></a>4.6 模式优缺点</h3><p>外观模式的优点</p>
<ol>
<li><strong>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易</strong>。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li>
<li><strong>实现了子系统与客户之间的松耦合关系</strong>，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li>
<li><strong>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</strong>，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li>
<li><strong>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</strong>。</li>
</ol>
<p>外观模式的缺点</p>
<ol>
<li><strong>不能很好地限制客户使用子系统类</strong>，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>在不引入<strong>抽象外观类</strong>的情况下，<strong>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</strong>。</li>
</ol>
<h3 id="4-7-模式适用环境"><a href="#4-7-模式适用环境" class="headerlink" title="4.7 模式适用环境"></a>4.7 模式适用环境</h3><p>在以下情况下可以使用外观模式：</p>
<ol>
<li><strong>当要为一个复杂子系统提供一个简单接口时可以使用外观模式</strong>。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li>
<li><strong>客户程序与多个子系统之间存在很大的依赖性</strong>。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以<strong>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度</strong>。</li>
</ol>
<h3 id="4-8-模式应用"><a href="#4-8-模式应用" class="headerlink" title="4.8 模式应用"></a>4.8 模式应用</h3><p>外观模式应用于JDBC数据库操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCFacade</span> &#123;<br>  <span class="hljs-keyword">private</span> Connection conn=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">private</span> Statement statement=<span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">(String driver,String jdbcUrl,String userName,String userPwd)</span> &#123;<br>  	......<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">executeUpdate</span><span class="hljs-params">(String sql)</span> &#123;<br>  	......<br>  &#125;<br>  <span class="hljs-keyword">public</span> ResultSet <span class="hljs-title function_">executeQuery</span><span class="hljs-params">(String sql)</span> &#123;<br>  	......<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>  	......<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Session外观模式是外观模式在Java EE框架中的应用。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612113443164.png" alt="image-20230612113443164" style="zoom:80%;" />

<h3 id="4-9-模式扩展"><a href="#4-9-模式扩展" class="headerlink" title="4.9 模式扩展"></a>4.9 模式扩展</h3><h4 id="一个系统有多个外观类"><a href="#一个系统有多个外观类" class="headerlink" title="一个系统有多个外观类"></a>一个系统有多个外观类</h4><p>在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个<strong>单例类</strong>。<strong>在很多情况下为了节约系统资源，一般将外观类设计为单例类</strong>。当然这并不意味着在整个系统里只能有一个外观类，<strong>在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互</strong>，向用户提供相应的业务功能。</p>
<h4 id="不要试图通过外观类为子系统增加新行为"><a href="#不要试图通过外观类为子系统增加新行为" class="headerlink" title="不要试图通过外观类为子系统增加新行为"></a>不要试图通过外观类为子系统增加新行为</h4><p><strong>不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。</strong>外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。</p>
<h4 id="外观模式与迪米特法则"><a href="#外观模式与迪米特法则" class="headerlink" title="外观模式与迪米特法则"></a>外观模式与迪米特法则</h4><p><strong>外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代</strong>。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。</p>
<h4 id="抽象外观类的引入"><a href="#抽象外观类的引入" class="headerlink" title="抽象外观类的引入"></a>抽象外观类的引入</h4><p>外观模式最大的缺点在于违背了“开闭原则”，<strong>当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程</strong>。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612113636474.png" alt="image-20230612113636474" style="zoom:80%;" />

<h3 id="4-10-小结"><a href="#4-10-小结" class="headerlink" title="4.10 小结"></a>4.10 小结</h3><ol>
<li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li>
<li>外观模式包含两个角色<ol>
<li>外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</li>
<li>在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li>
</ol>
</li>
<li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li>
<li>外观模式<ol>
<li>主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程</li>
<li>其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
</li>
<li>外观模式适用情况包括<ol>
<li>要为一个复杂子系统提供一个简单接口</li>
<li>客户程序与多个子系统之间存在很大的依赖性</li>
<li>在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li>
</ol>
</li>
</ol>
<h2 id="5-代理模式-对象"><a href="#5-代理模式-对象" class="headerlink" title="5. 代理模式(对象)"></a>5. 代理模式(对象)</h2><h3 id="5-1-模式动机"><a href="#5-1-模式动机" class="headerlink" title="5.1 模式动机"></a>5.1 模式动机</h3><p>在某些情况下，<strong>一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用</strong>。代理对象可以在<strong>客户端和目标对象之间起到中介的作用</strong>，并且可以<strong>通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务</strong>。</p>
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114233046.png" alt="image-20230612114233046"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114245067.png" alt="image-20230612114245067"></th>
</tr>
</thead>
</table>
<p>通过<strong>引入一个新的对象</strong>（如小图片和远程代理对象）<strong>来实现对真实对象的操作或者将新的对象作为真实对象的一个替身</strong>，这种实现机制即为代理模式，<strong>通过引入代理对象来间接访问一个对象</strong>，这就是代理模式的模式动机。</p>
<h3 id="5-2-模式定义"><a href="#5-2-模式定义" class="headerlink" title="5.2 模式定义"></a>5.2 模式定义</h3><ol>
<li>代理模式(Proxy Pattern) ：给某一个对象<strong>提供一个代理</strong>，并<strong>由代理对象控制对原对象的引用</strong>。代理模式的英文叫做<strong>Proxy或Surrogate</strong>，它是一种<strong>对象结构型模式</strong>。</li>
<li>Proxy Pattern: Provide a surrogate or placeholder for another object to control access to it.</li>
<li>思想简单，但是变体很多</li>
</ol>
<h3 id="5-3-模式结构"><a href="#5-3-模式结构" class="headerlink" title="5.3 模式结构"></a>5.3 模式结构</h3><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114401259.png" alt="image-20230612114401259" style="zoom:80%;" />

<ol>
<li>代理模式包含如下角色：<ol>
<li>Subject: 抽象主题角色</li>
<li>Proxy: 代理主题角色</li>
<li>RealSubject: 真实主题角色</li>
</ol>
</li>
<li>Proxy是符合迪米特法则的。</li>
</ol>
<h3 id="5-4-模式分析"><a href="#5-4-模式分析" class="headerlink" title="5.4 模式分析"></a>5.4 模式分析</h3><ol>
<li>代理模式示意结构图比较简单，一般可以简化为如下图所示，但是在现实中要复杂很多。</li>
</ol>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114500888.png" alt="image-20230612114500888" style="zoom:80%;" />

<ol>
<li>典型的代理类实现代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">RealSubject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preRequest</span><span class="hljs-params">()</span> &#123;......&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>    preRequest();<br>    realSubject.request();<br>    postRequest();<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postRequest</span><span class="hljs-params">()</span> &#123;......&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-5-代理模式实例与解析"><a href="#5-5-代理模式实例与解析" class="headerlink" title="5.5 代理模式实例与解析"></a>5.5 代理模式实例与解析</h3><p>实例一：论坛权限控制代理</p>
<ol>
<li>在一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖、修改自己的注册信息、修改自己的帖子等功能；而游客只能看到别人发的帖子，没有其他权限。使用代理模式来设计该权限管理模块。</li>
<li>在本实例中我们使用代理模式中的保护代理，该代理用于控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114629895.png" alt="image-20230612114629895"></p>
<p>实例二：数学运算代理</p>
<p>模拟应用远程代理来访问另外一个应用程序域中的对象，如果在远程实现了加减乘除等运算，在本地需要调用，那么可以考虑在本地设置一个代理。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114715673.png" alt="image-20230612114715673"></p>
<h3 id="5-6-模式优缺点"><a href="#5-6-模式优缺点" class="headerlink" title="5.6 模式优缺点"></a>5.6 模式优缺点</h3><p>代理模式的优点</p>
<ol>
<li>代理模式能够<strong>协调调用者和被调用者</strong>，在一定程度上降低了系统的耦合度。</li>
<li><strong>远程代理使得客户端可以访问在远程机器上的对象</strong>，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li><strong>虚拟代理</strong>通过使用一个小对象来代表一个大对象，<strong>可以减少系统资源的消耗，对系统进行优化并提高运行速度。</strong></li>
<li><strong>保护代理可以控制对真实对象的使用权限。</strong></li>
<li>C++：智能指针代理</li>
</ol>
<p>代理模式的缺点</p>
<ol>
<li>由于在客户端和真实主题之间增加了代理对象，因此<strong>有些类型的代理模式可能会造成请求的处理速度变慢</strong>。</li>
<li><strong>实现代理模式需要额外的工作，有些代理模式的实现非常复杂</strong>。</li>
</ol>
<h3 id="5-7-模式适用环境"><a href="#5-7-模式适用环境" class="headerlink" title="5.7 模式适用环境"></a>5.7 模式适用环境</h3><ol>
<li>根据代理模式的使用目的，常见的代理模式有以下几种类型：<ol>
<li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li>
<li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li><strong>Copy-on-Write代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
</ol>
</li>
<li>根据代理模式的使用目的，代理模式有以下几种类型（续）：<ol>
<li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li>
<li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li>
</ol>
</li>
</ol>
<h3 id="5-8-模式应用"><a href="#5-8-模式应用" class="headerlink" title="5.8 模式应用"></a>5.8 模式应用</h3><ol>
<li>Java RMI (Remote Method Invocation，远程方法调用)。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612114851066.png" alt="image-20230612114851066"></p>
<ol start="2">
<li><strong>EJB、Web Service等分布式技术都是代理模式的应用</strong>。在EJB中使用了RMI机制，远程服务器中的企业级Bean在本地有一个桩代理，客户端通过桩来调用远程对象中定义的方法，而无须直接与远程对象交互。在EJB的使用中需要提供一个公共的接口，客户端针对该接口进行编程，无须知道桩以及远程EJB的实现细节。</li>
</ol>
<h3 id="5-9-模式扩展"><a href="#5-9-模式扩展" class="headerlink" title="5.9 模式扩展"></a>5.9 模式扩展</h3><p>几种常用的代理模式</p>
<h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><p>远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612115001201.png" alt="image-20230612115001201"></p>
<h4 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h4><ol>
<li><p>当一个对象的加载十分耗费资源的时候，虚拟代理的优势就非常明显地体现出来了。<strong>虚拟代理模式是一种内存节省技术</strong>，那些占用大量内存或处理复杂的对象将推迟到使用它的时候才创建。</p>
</li>
<li><p>在应用程序启动的时候，可以用代理对象代替真实对象初始化，节省了内存的占用，并大大加速了系统的启动时间。</p>
</li>
<li><p>一个很常见的代理模式的应用实例就是<strong>对大图浏览的控制</strong>。</p>
</li>
<li><p>用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，<strong>先使用一个线程向客户端浏览器加载一个小图片</strong>，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。<strong>通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览</strong>。</p>
</li>
</ol>
<h3 id="5-10-小结"><a href="#5-10-小结" class="headerlink" title="5.10 小结"></a>5.10 小结</h3><ol>
<li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</li>
<li>代理模式包含三个角色<ol>
<li>抽象主题角色声明了真实主题和代理主题的共同接口</li>
<li>代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象</li>
<li>真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li>
</ol>
</li>
<li>代理模式<ol>
<li>优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li>
<li>缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ol>
</li>
<li>远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
</ol>
<h2 id="6-桥接模式-对象"><a href="#6-桥接模式-对象" class="headerlink" title="6. 桥接模式(对象)"></a>6. 桥接模式(对象)</h2><h3 id="6-1-模式动机"><a href="#6-1-模式动机" class="headerlink" title="6.1 模式动机"></a>6.1 模式动机</h3><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p>
<ol>
<li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li>
<li>第二种设计方案是根据实际需要对形状和颜色进行组合。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627215938461.png" alt="image-20230627215938461">对于有<strong>两个变化维度（即两个变化的原因)<strong>的系统，采用</strong>方案二</strong>来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式<strong>将继承关系转换为关联关系</strong>，从而<strong>降低了类与类之间的耦合，减少了代码编写量</strong>。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627220126858.png" alt="image-20230627220126858"></p>
<h3 id="6-2-模式定义"><a href="#6-2-模式定义" class="headerlink" title="6.2 模式定义"></a>6.2 模式定义</h3><ol>
<li>桥接模式(Bridge Pattern)：<strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化</strong>。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</li>
<li>Bridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.</li>
</ol>
<h3 id="6-3-模式结构"><a href="#6-3-模式结构" class="headerlink" title="6.3 模式结构"></a>6.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627220159169.png" alt="image-20230627220159169"></p>
<p>桥接模式包含如下角色：</p>
<ol>
<li>Abstraction：抽象类</li>
<li>RefinedAbstraction：扩充抽象类</li>
<li>Implementor：实现类接口</li>
<li>ConcreteImplementor：具体实现类</li>
</ol>
<h3 id="6-4-模式分析"><a href="#6-4-模式分析" class="headerlink" title="6.4 模式分析"></a>6.4 模式分析</h3><p>理解桥接模式，重点需要理解如何将<strong>抽象化(Abstraction)与实现化(Implementation)脱耦</strong>，使得二者可以独立地变化。</p>
<ol>
<li><strong>抽象化</strong>：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，<strong>将对象的共同性质抽取出来形成类的过程即为抽象化的过程</strong>。</li>
<li><strong>实现化</strong>：<strong>针对抽象化给出的具体实现，就是实现化</strong>，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li>
<li><strong>脱耦</strong>：脱耦就是<strong>将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系</strong>。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</li>
</ol>
<p>典型的实现类接口代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Implementor</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationImpl</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>典型的抽象类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span>&#123;<br>    <span class="hljs-keyword">protected</span> Implementor impl;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImpl</span><span class="hljs-params">(Implementor impl)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.impl=impl;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>典型的扩充抽象类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//代码</span><br>        impl.operationImpl();<br>        <span class="hljs-comment">//代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-5-桥接模式实例与解析"><a href="#6-5-桥接模式实例与解析" class="headerlink" title="6.5 桥接模式实例与解析"></a>6.5 桥接模式实例与解析</h3><p>实例一：模拟毛笔</p>
<p>现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5&#x3D;15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5&#x3D;8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627220431701.png" alt="image-20230627220431701"></p>
<p>实例二：跨平台视频播放器</p>
<p>如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627220841600.png" alt="image-20230627220841600"></p>
<h3 id="6-6-模式优缺点"><a href="#6-6-模式优缺点" class="headerlink" title="6.6 模式优缺点"></a>6.6 模式优缺点</h3><p>桥接模式的优点</p>
<ol>
<li><strong>分离抽象接口及其实现部分。</strong></li>
<li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，<strong>桥接模式是比多继承方案更好的解决方法</strong>。</li>
<li>桥接模式<strong>提高了系统的可扩充性</strong>，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li>
<li><strong>实现细节对客户透明，可以对用户隐藏实现细节。</strong></li>
</ol>
<p>桥接模式的缺点</p>
<ol>
<li>桥接模式的引入会<strong>增加系统的理解与设计难度</strong>，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此<strong>其使用范围具有一定的局限性</strong>。</li>
</ol>
<h3 id="6-7-模式适用环境"><a href="#6-7-模式适用环境" class="headerlink" title="6.7 模式适用环境"></a>6.7 模式适用环境</h3><p>在以下情况下可以使用桥接模式：</p>
<ol>
<li>如果一个系统<strong>需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系</strong>，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
<li><strong>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响</strong>，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li>
<li>一个类<strong>存在两个独立变化的维度</strong>，且这两个维度都需要进行扩展。</li>
<li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li>
<li>对于那些<strong>不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统</strong>，桥接模式尤为适用。</li>
</ol>
<h3 id="6-8-模式应用"><a href="#6-8-模式应用" class="headerlink" title="6.8 模式应用"></a>6.8 模式应用</h3><ol>
<li>Java语言通过Java虚拟机实现了平台的无关性。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627221049267.png" alt="image-20230627221049267"></p>
<ol start="2">
<li><p>一个 Java桌面软件总是带有所在操作系统的视感(<strong>LookAndFeel</strong>)，如果一个Java软件是在Unix系统上开发的，那么开发人员看到的是Motif用户界面的视感；在Windows上面使用这个系统的用户看到的是Windows用户界面的视感；而一个在Macintosh上面使用的用户看到的则是Macintosh用户界面的视感，Java语言是通过所谓的Peer架构做到这一点的。Java为AWT中的每一个GUI构件都提供了一个Peer构件，<strong>在AWT中的Peer架构就使用了桥接模式</strong>。</p>
</li>
<li><p>JDBC驱动程序也是桥接模式的应用之一。使用JDBC驱动程序的应用系统就是抽象角色，而所使用的数据库是实现角色。<strong>一个JDBC驱动程序可以动态地将一个特定类型的数据库与一个Java应用程序绑定在一起，从而实现抽象角色与实现角色的动态耦合</strong>。</p>
</li>
</ol>
<h3 id="6-9-模式扩展"><a href="#6-9-模式扩展" class="headerlink" title="6.9 模式扩展"></a>6.9 模式扩展</h3><h4 id="适配器模式与桥接模式的联用"><a href="#适配器模式与桥接模式的联用" class="headerlink" title="适配器模式与桥接模式的联用"></a>适配器模式与桥接模式的联用</h4><ol>
<li>桥接模式和适配器模式用于设计的不同阶段，<strong>桥接模式用于系统的初步设计</strong>，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式</strong>。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627221147628.png" alt="image-20230627221147628"></p>
<h3 id="6-10-小结"><a href="#6-10-小结" class="headerlink" title="6.10 小结"></a>6.10 小结</h3><ol>
<li>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</li>
<li>桥接模式包含如下四个角色：<ol>
<li>抽象类中定义了一个实现类接口类型的对象并可以维护该对象</li>
<li>扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法</li>
<li>实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作</li>
<li>具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</li>
</ol>
</li>
<li>在桥接模式中，抽象化(Abstraction)与实现化(Implementation)脱耦，它们可以沿着各自的维度独立变化。</li>
<li>桥接模式<ol>
<li>主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节</li>
<li>主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情</li>
</ol>
</li>
<li>桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。</li>
</ol>
<h2 id="7-享元模式-对象"><a href="#7-享元模式-对象" class="headerlink" title="7. 享元模式(对象)"></a>7. 享元模式(对象)</h2><h3 id="7-1-模式动机"><a href="#7-1-模式动机" class="headerlink" title="7.1 模式动机"></a>7.1 模式动机</h3><ul>
<li><p>面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。<strong>当对象数量太多时，将导致运行代价过高，带来性能下降等问题</strong>。</p>
</li>
<li><p><strong>享元模式</strong>正是为解决这一类问题而诞生的。<strong>享元模式通过共享技术实现相同或相似对象的重用</strong>。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627202717629.png" alt="image-20230627202717629"></p>
<ul>
<li>在享元模式中<strong>可以共享的相同内容称为内部状态</strong>(Intrinsic State)，而那些<strong>需要外部环境来设置的不能共享的内容称为外部状态</strong>(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。</li>
<li>在享元模式中通常会出现工厂模式，需要<strong>创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象</strong>。</li>
<li>在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此<strong>享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用</strong>。</li>
</ul>
<h3 id="7-2-模式定义"><a href="#7-2-模式定义" class="headerlink" title="7.2 模式定义"></a>7.2 模式定义</h3><ol>
<li>享元模式(Flyweight Pattern)：运用<strong>共享技术</strong>有效地支持大量<strong>细粒度对象</strong>的复用。系统只使用少量的对象，<strong>而这些对象都很相似，状态变化很小</strong>，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为<strong>轻量级模式</strong>，它是一种<strong>对象结构型模式</strong>。</li>
<li>Flyweight Pattern: Use sharing to support large numbers of fine-grained objects efficiently.</li>
</ol>
<h3 id="7-3-模式结构"><a href="#7-3-模式结构" class="headerlink" title="7.3 模式结构"></a>7.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210428493.png" alt="image-20230627210428493"></p>
<ul>
<li><p>享元工厂和原型管理器非常相似</p>
</li>
<li><p>享元模式包含如下角色：</p>
<ul>
<li>Flyweight: 抽象享元类</li>
<li>ConcreteFlyweight: 具体享元类</li>
<li>UnsharedConcreteFlyweight: 非共享具体享元类</li>
<li>FlyweightFactory: 享元工厂类</li>
</ul>
</li>
<li><p>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。</p>
</li>
</ul>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210554872.png" alt="image-20230627210554872" style="zoom:80%;" />

<h3 id="7-4-模式分析"><a href="#7-4-模式分析" class="headerlink" title="7.4 模式分析"></a>7.4 模式分析</h3><ul>
<li><p>享元模式的核心在于<strong>享元工厂类</strong>，<strong>享元工厂类的作用在于提供一个用于存储享元对象的享元池</strong>，用户需要对象时，首先从享元池中获取，<strong>如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象</strong>。</p>
</li>
<li><p>比较原型管理模式和享元工厂模型</p>
</li>
<li><p>典型的享元工厂类代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HashMap</span> <span class="hljs-variable">flyweights</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <span class="hljs-keyword">public</span> Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(flyweights.containsKey(key)) &#123;<br>        	<span class="hljs-keyword">return</span> (Flyweight)flyweights.get(key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Flyweight</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>();<br>            flyweights.put(key,fw);<br>            <span class="hljs-keyword">return</span> fw;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。</p>
<ul>
<li><p><strong>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态</strong>，因此内部状态可以共享。</p>
</li>
<li><p><strong>外部状态是随环境改变而改变的</strong>、<strong>不可以共享的状态</strong>。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。</p>
</li>
</ul>
</li>
<li><p>典型的享元类代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>    <span class="hljs-comment">//内部状态作为成员属性</span><br>    <span class="hljs-keyword">private</span> String intrinsicState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Flyweight</span><span class="hljs-params">(String intrinsicState)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.intrinsicState = intrinsicState;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(String extrinsicState)</span> &#123;<br>    	......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-5-享元模式实例与解析"><a href="#7-5-享元模式实例与解析" class="headerlink" title="7.5 享元模式实例与解析"></a>7.5 享元模式实例与解析</h3><p>实例一：共享网络设备（无外部状态）</p>
<p>很多网络设备都是支持共享的，如交换机、集线器等，多台终端计算机可以连接同一台网络设备，并通过该网络设备进行数据转发，如图所示，现用享元模式模拟共享网络设备的设计原理。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210852187.png" alt="image-20230627210852187"><br><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210918202.png" alt="image-20230627210918202"></p>
<p>实例二：共享网络设备（有外部状态）</p>
<p>虽然网络设备可以共享，但是分配给每一个终端计算机的端口(Port)是不同的，因此多台计算机虽然可以共享同一个网络设备，但必须使用不同的端口。我们可以将端口从网络设备中抽取出来作为外部状态，需要时再进行设置。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627210952014.png" alt="image-20230627210952014"></p>
<h3 id="7-6-模式优缺点"><a href="#7-6-模式优缺点" class="headerlink" title="7.6 模式优缺点"></a>7.6 模式优缺点</h3><p>享元模式的优点</p>
<ol>
<li>享元模式的优点在于它可以<strong>极大减少内存中对象的数量</strong>，使得相同对象或相似对象在内存中只保存一份。</li>
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得<strong>享元对象可以在不同的环境中被共享</strong>。</li>
</ol>
<p>享元模式的缺点</p>
<ol>
<li>享元模式使得系统更加复杂，需要<strong>分离出内部状态和外部状态，这使得程序的逻辑复杂化</strong>。</li>
<li>为了使对象可以共享，享元模式<strong>需要将享元对象的状态外部化，而读取外部状态使得运行时间变长</strong>。</li>
</ol>
<h3 id="7-7-模式适用环境"><a href="#7-7-模式适用环境" class="headerlink" title="7.7 模式适用环境"></a>7.7 模式适用环境</h3><p>在以下情况下可以使用享元模式：</p>
<ol>
<li>一个系统有<strong>大量相同或者相似的对象</strong>，由于这类对象的大量使用，造成内存的大量耗费。</li>
<li>对象的<strong>大部分状态都可以外部化</strong>，可以将这些外部状态传入对象中。</li>
<li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，<strong>应当在多次重复使用享元对象时才值得使用享元模式</strong>。</li>
</ol>
<h3 id="7-8-模式应用"><a href="#7-8-模式应用" class="headerlink" title="7.8 模式应用"></a>7.8 模式应用</h3><ol>
<li>享元模式在<strong>编辑器软件</strong>中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</li>
<li>在JDK类库中定义的String类使用了享元模式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-string">&quot;cd&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        str4 += <span class="hljs-string">&quot;cd&quot;</span>;<br>        System.out.println(str1 == str2);<span class="hljs-comment">// T</span><br>        System.out.println(str1 == str3);<span class="hljs-comment">// T</span><br>        System.out.println(str1 == str4);<span class="hljs-comment">// F</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-9-模式扩展"><a href="#7-9-模式扩展" class="headerlink" title="7.9 模式扩展"></a>7.9 模式扩展</h3><h4 id="单纯享元模式和复合享元模式"><a href="#单纯享元模式和复合享元模式" class="headerlink" title="单纯享元模式和复合享元模式"></a>单纯享元模式和复合享元模式</h4><p><strong>单纯享元模式</strong>：在单纯享元模式中，<strong>所有的享元对象都是可以共享的</strong>，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627211404485.png" alt="image-20230627211404485"></p>
<p><strong>复合享元模式</strong>：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627211422141.png" alt="image-20230627211422141"></p>
<h4 id="享元模式与其他模式的联用"><a href="#享元模式与其他模式的联用" class="headerlink" title="享元模式与其他模式的联用"></a>享元模式与其他模式的联用</h4><ol>
<li>在享元模式的享元工厂类中通常<strong>提供一个静态的工厂方法用于返回享元对象</strong>，使用简单工厂模式来生成享元对象。</li>
<li>在一个系统中，通常只有唯一一个享元工厂，因此<strong>享元工厂类可以使用单例模式进行设计</strong>。</li>
<li>享元模式可以结合组合模式形成<strong>复合享元模式</strong>，统一对享元对象设置外部状态。</li>
</ol>
<h3 id="7-10-小结"><a href="#7-10-小结" class="headerlink" title="7.10 小结"></a>7.10 小结</h3><ol>
<li>享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用，它是一种对象结构型模式。</li>
<li>享元模式包含四个角色<ol>
<li>抽象享元类声明一个接口，通过它可以接受并作用于外部状态</li>
<li>具体享元类实现了抽象享元接口，其实例称为享元对象；非共享具体享元是不能被共享的抽象享元类的子类</li>
<li>享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。</li>
</ol>
</li>
<li>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态和外部状态。其中内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享；外部状态是随环境改变而改变的、不可以共享的状态。</li>
<li>享元模式<ol>
<li>主要优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份</li>
<li>其缺点是使得系统更加复杂，并且需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li>
</ol>
</li>
<li>享元模式适用情况包括<ol>
<li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；多次重复使用享元对象。</li>
</ol>
</li>
</ol>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/06/10/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-2-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-08-09 14:53:19
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/" title="NJU">
                        <b>#</b> NJU
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="软件系统设计">
                        <b>#</b> 软件系统设计
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9E%B6%E6%9E%84-5-%E8%AE%B0%E5%BD%95%E6%9E%B6%E6%9E%84/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E-%E5%AF%B9%E8%B1%A1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">1. (类)适配器模式与(对象)适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">1.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">1.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">1.3 模式结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">对象适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">类适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">1.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">1.5 适配器模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">1.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">1.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">1.9 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E9%80%82%E9%85%8D%E5%99%A8%E5%B0%8F%E7%BB%93"><span class="toc-text">1.10 适配器小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. 组合模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">2.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">2.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">2.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">2.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">2.5 组合模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">2.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">2.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">2.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">更复杂的组合模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">透明组合模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">安全组合模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-%E7%BB%84%E5%90%88%E5%B0%8F%E7%BB%93"><span class="toc-text">2.10 组合小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 装饰模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">3.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">3.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">3.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">3.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">3.5 装饰模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">3.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">3.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">3.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96"><span class="toc-text">装饰模式的简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%A4%9A%E9%87%8D%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-text">透明装饰模式（多重加密系统）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E9%80%8F%E6%98%8E%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A%EF%BC%89"><span class="toc-text">半透明装饰模式（变形金刚）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">4. 外观模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">4.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">4.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">4.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">4.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">4.5 外观模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">4.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">4.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">4.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%A4%96%E8%A7%82%E7%B1%BB"><span class="toc-text">一个系统有多个外观类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E8%AF%95%E5%9B%BE%E9%80%9A%E8%BF%87%E5%A4%96%E8%A7%82%E7%B1%BB%E4%B8%BA%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%A2%9E%E5%8A%A0%E6%96%B0%E8%A1%8C%E4%B8%BA"><span class="toc-text">不要试图通过外观类为子系统增加新行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-text">外观模式与迪米特法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-text">抽象外观类的引入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">4.10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">5. 代理模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">5.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">5.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">5.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">5.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">5.5 代理模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">5.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">5.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">5.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">5.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86"><span class="toc-text">远程代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86"><span class="toc-text">虚拟代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">5.10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">6. 桥接模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">6.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">6.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">6.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">6.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">6.5 桥接模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">6.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">6.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">6.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">6.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%81%94%E7%94%A8"><span class="toc-text">适配器模式与桥接模式的联用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">6.10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">7. 享元模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">7.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">7.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">7.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">7.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">7.5 享元模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">7.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">7.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">7.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">7.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%AF%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">单纯享元模式和复合享元模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%81%94%E7%94%A8"><span class="toc-text">享元模式与其他模式的联用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">7.10 小结</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1(3)%20%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2023%2F06%2F11%2F%25E8%25BD%25AF%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F%25E8%25AE%25BE%25E8%25AE%25A1-%25E8%25AE%25BE%25E8%25AE%25A1-3-%25E7%25BB%2593%25E6%259E%2584%25E5%259E%258B%25E6%25A8%25A1%25E5%25BC%258F%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2023/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-3-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
