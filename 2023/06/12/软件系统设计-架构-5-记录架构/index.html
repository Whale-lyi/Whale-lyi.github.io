<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>软件系统设计-架构(5) 架构文档化 | Whale&#39;s Blog | Stay hungry, Stay foolish</title>

  
  <meta name="author" content="Whale">
  

  
  <meta name="description" content="码农预备役">
  

  
  
  <meta name="keywords" content="软件架构">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="软件系统设计-架构(5) 架构文档化"/>

  <meta property="og:site_name" content="Whale&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whale&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Whale&#39;s Blog</a>
    </h1>
    <p class="site-description">Stay hungry, Stay foolish</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>软件系统设计-架构(5) 架构文档化</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/06/12/软件系统设计-架构-5-记录架构/" rel="bookmark">
        <time class="entry-date published" datetime="2023-06-12T08:38:00.000Z">
          2023-06-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-架构文档化-Documenting-Architecture"><a href="#1-架构文档化-Documenting-Architecture" class="headerlink" title="1. 架构文档化 Documenting Architecture"></a>1. 架构文档化 Documenting Architecture</h2><h3 id="1-1-为什么要记录软件架构？-Why-to-document-software-architecture"><a href="#1-1-为什么要记录软件架构？-Why-to-document-software-architecture" class="headerlink" title="1.1 为什么要记录软件架构？ Why to document software architecture?"></a>1.1 为什么要记录软件架构？ Why to document software architecture?</h3><ol>
<li>这是记录软件架构的几个很好的理由，例如：There are several good reasons for documenting software architecture such as:<ol>
<li>交流和社交化架构设计决策 Communicating and socialising architecture design decisions</li>
<li>帮助理解和评估架构设计决策 Helping understand and assess architecture designdecisions</li>
<li>刷新设计师对某些决策的记忆 Refreshing designers’ memories about certain decisions</li>
<li>培训架构设计人员 Training people in designing architecture</li>
<li>支持地理位置分散的团队 Supporting geographically ditributed teams</li>
</ol>
</li>
<li>架构文档用于以下活动：Architecture documentation is used for several activities:<ol>
<li>架构设计分析 Architecture design analysis.</li>
<li>工作分解和分配 Work breakdown and assignment.</li>
<li>部署后维护 Post-deployment maintenance.</li>
</ol>
</li>
<li>软件架构文档提供了维护和修改决策的框架 Software architecture documentation provides a framework for maintenance and modification decisions.</li>
</ol>
<h3 id="1-2-记录架构的挑战-Challenges-in-documenting-architecture"><a href="#1-2-记录架构的挑战-Challenges-in-documenting-architecture" class="headerlink" title="1.2 记录架构的挑战 Challenges in documenting architecture"></a>1.2 记录架构的挑战 Challenges in documenting architecture</h3><ol>
<li><strong>没有</strong>普遍接受的记录软件架构的<strong>标准</strong>或方法。No universally accepted standard or method of documenting software architecture.</li>
<li>记录大型系统的架构可能是一项<strong>耗时</strong>且重要的任务。 Documenting architecture of large-scale system can be time consuming and non-trivial task.</li>
<li>对用于记录架构的视图的<strong>数量和性质没有达成共识</strong> - 资源密集型活动。No consensus on the number and nature ofviews used to document architecture - resource intensive activity.</li>
<li>迫在眉睫的最后期限和不断发展的架构性质不利于架构文档的流通。Looming deadlines and evolving nature of architecture are detrimental to the currency of architecture documentation.</li>
<li>缺乏全面的<strong>符号和工具</strong>。Absence of a comprehensive notation and tooling.</li>
</ol>
<h3 id="1-3-记录什么-What-to-document"><a href="#1-3-记录什么-What-to-document" class="headerlink" title="1.3 记录什么? What to document?"></a>1.3 记录什么? What to document?</h3><ol>
<li>许多值得记录的事情，例如：Many things worth of documenting such as:<ol>
<li>组件<strong>接口</strong>和<strong>依赖项</strong> Component interfaces and dependencies</li>
<li>子系统<strong>约束</strong> Subsystems constraints</li>
<li><strong>测试场景</strong> Test scenarios</li>
<li>围绕设计决策的<strong>上下文</strong>信息 Contextual information surrounding design decisions</li>
</ol>
</li>
<li>有几个因素会影响对记录内容的决定 Several factors affect the decision of what to document:<ol>
<li>被记录的架构的<strong>复杂性</strong> Complexity of the architecture being documented</li>
<li>应用程序的<strong>寿命</strong> Longevity of an application</li>
<li>基于<strong>涉众</strong>对文档的预期使用 Based on the expected use of documentation by stakeholders</li>
</ol>
</li>
</ol>
<h3 id="1-4-架构文档的-7-条规则-7-Rules-for-Architecture-Documentation"><a href="#1-4-架构文档的-7-条规则-7-Rules-for-Architecture-Documentation" class="headerlink" title="1.4 架构文档的 7 条规则 7 Rules for Architecture Documentation"></a>1.4 架构文档的 7 条规则 7 Rules for Architecture Documentation</h3><ol>
<li>从<strong>读者的角度</strong>撰写文档 Write documentation from the reader’s point of view</li>
<li>避免没有意义的<strong>重复</strong> Avoid unnecessary repetition.</li>
<li>避免<strong>模糊性</strong> Avoid ambiguity.</li>
<li>使用<strong>标准</strong>的文档组织方式 Use a standard organization.</li>
<li>记录<strong>理由</strong> Record rationale.</li>
<li>保持文档<strong>最新</strong>但不要太最新 Keep documentation current but not too current</li>
<li><strong>审查</strong>文件是否适合<strong>用途</strong> Review documentation for fitness of purpose</li>
</ol>
<h2 id="2-视图-Views"><a href="#2-视图-Views" class="headerlink" title="2. 视图 Views"></a>2. 视图 Views</h2><h3 id="2-1-Styles-and-Views-样式和视图"><a href="#2-1-Styles-and-Views-样式和视图" class="headerlink" title="2.1 Styles and Views 样式和视图"></a>2.1 Styles and Views 样式和视图</h3><h4 id="2-1-1-三类风格-Three-Categories-of-Styles"><a href="#2-1-1-三类风格-Three-Categories-of-Styles" class="headerlink" title="2.1.1 三类风格 Three Categories of Styles"></a>2.1.1 三类风格 Three Categories of Styles</h4><ol>
<li>模块风格: 它是如何构建为一组实现单元的？How it is structured as a set of implementation units? Module styles</li>
<li>组件连接器 (C&amp;C) 风格: 它是如何构建为一组具有运行时行为和交互的元素的？How it is structured as a set of elements that have runtime behavior and interactions? Component-connector(C&amp;C) styles</li>
<li>分配风格: 它与环境中的非软件结构有何关系？How it relates to non-software structures in its environment? Allocation style</li>
</ol>
<h4 id="2-1-2-架构风格-和-架构模式-Styles-Vs-Patterns"><a href="#2-1-2-架构风格-和-架构模式-Styles-Vs-Patterns" class="headerlink" title="2.1.2 架构风格 和 架构模式 Styles Vs. Patterns"></a>2.1.2 架构风格 和 架构模式 Styles Vs. Patterns</h4><ol>
<li><strong>架构风格</strong>是元素和关系类型的特殊化，以及关于如何使用它们的一组约束 An architecture style is a <em>“specialization of element and relation types, together with a set of constraints on how they can be used”</em> (Bass, Clements, and Kazman 2003)</li>
<li><strong>架构模式</strong>表达了软件系统的基本结构组织模式 An architecture pattern <em>“expresses a fundamental structural organization schema for software systems”</em> (Buschmann et al. 1996)</li>
<li>架构模式的一个重要部分是关注问题和上下文，以及如何在该上下文中解决问题。An essential part of an architecture pattern is its focus on the problem and context as well as how to solve the problem in that context.</li>
<li>架构风格侧重于架构方法，对特定风格何时有用或无用提供更轻量级的指导。An architecture style focuses on the architecture approach, with more lightweight guidance on when a particular style may or may not be useful.</li>
<li>架构模式：{问题，上下文} —&gt; 架构方法<br>Architecture pattern: {problem, context} —&gt; architecture approach</li>
<li>架构风格：架构方式 Architecture style: architecture approach</li>
<li>风格描述通常不包括详细的问题/上下文信息；架构模式可以。A style description does not generally include detailed problem/context information; architecture patterns do.</li>
<li>微服务知识定义了element，和element通过什么方式进行交互。</li>
</ol>
<h4 id="2-1-3-架构视图-Architectural-Views"><a href="#2-1-3-架构视图-Architectural-Views" class="headerlink" title="2.1.3 架构视图 Architectural Views"></a>2.1.3 架构视图 Architectural Views</h4><ol>
<li>视图是一组系统元素和它们之间关系的表示——不是所有的系统元素，而是特定类型的那些元素 A view is a representation of a set of system elements and relations among them - not all system elements, but those of a particular type.</li>
<li>视图让我们将系统的实体划分为有趣且易于管理的系统表示 Views let us divide the system’s entity into interesting and manageable representations of the system.</li>
<li>不同的视图支持不同的目标和用户，突出不同的系统元素和关系 Different views support different goals and users, and highlight different system elements and relations</li>
<li>不同的视图在不同程度上暴露了不同的质量属性。Different views expose different quality attributes to different degrees.</li>
</ol>
<h3 id="2-2-结构视图-Structural-Views"><a href="#2-2-结构视图-Structural-Views" class="headerlink" title="2.2 结构视图 Structural Views"></a>2.2 结构视图 Structural Views</h3><h4 id="2-2-1-模块视图-Module-Views"><a href="#2-2-1-模块视图-Module-Views" class="headerlink" title="2.2.1 模块视图 Module Views"></a>2.2.1 模块视图 Module Views</h4><ol>
<li>模块是提供一组连贯职责的实现单元 A module is an implementation unit that provides a coherent set of responsibility.</li>
<li>没有至少一个模块视图，任何软件架构的文档都不可能是完整的 It is unlikely that the documentation of any software architecture can be complete without at least one module view.</li>
<li><p>视图示例</p>
<ol>
<li>分解视图 Decomposition view</li>
<li>使用视图 Uses view</li>
<li>泛化视图 Generalization view</li>
<li>分层视图 Layered view</li>
<li>领域视图 Aspects View</li>
<li>数据模型视图 Data model view</li>
</ol>
</li>
<li><p>Summary of Module Views</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612185439945.png" alt="image-20230612185439945"></p>
<h4 id="2-2-2-组件连接器视图-Component-Connector-Views"><a href="#2-2-2-组件连接器视图-Component-Connector-Views" class="headerlink" title="2.2.2 组件连接器视图 Component-Connector Views"></a>2.2.2 组件连接器视图 Component-Connector Views</h4><ol>
<li>组件和连接器视图显示具有某些<strong>运行时存在</strong>的元素，例如进程、对象、客户端、服务器和数据存储（称为”组件”）。<br> Component-and-connector views show elements that have some runtime presence, e.g, processes, objects, clients, servers, and data stores (being termed ‘components).</li>
<li>附件指示哪些连接器连接到哪些组件 Attachments indicate which connectors are attached to which components.</li>
<li>通过将连接器的端点连接到组件的端口来显示附件。Attachment is shown by connecting the endpoints of the connector to the ports of components.</li>
<li><p>视图示例</p>
<ol>
<li>管道和过滤器视图 Pipe-and-filter view</li>
<li>客户端-服务器视图 Client-server view</li>
<li>点对点视图 Peer-to-peer view</li>
<li>面向服务的架构 (SOA) 视图 Service-oriented architecture (SOA) view</li>
<li>发布订阅视图 Publish-subscribe view</li>
<li>共享数据视图 Shared-data view</li>
<li>多层视图 Multi-tier view</li>
</ol>
</li>
<li><p>Summary of C&amp;C Views</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612185747350.png" alt="image-20230612185747350"></p>
<h4 id="2-2-3-分配视图-Allocation-Views"><a href="#2-2-3-分配视图-Allocation-Views" class="headerlink" title="2.2.3 分配视图 Allocation Views"></a>2.2.3 分配视图 Allocation Views</h4><ol>
<li>分配视图描述了软件单元到软件开发或执行环境元素的映射 Allocation views describe the mapping of software units to elements of an environment in which the software is developed or in which it executes.</li>
<li>分配视图的通常目标是将软件元素所需的属性与环境元素提供的属性进行比较，以确定分配是否成功 The usual goal of an allocation view is to compare the properties required by the software element with the properties provided by the environmental elements to determine whether the allocation will be successful or not.</li>
<li>分配视图可以描绘静态或动态视图 Allocation views can depict static or dynamic views</li>
<li>视图实例<ol>
<li>部署视图 Deployment view</li>
<li>安装视图 Install view</li>
<li>工作分配视图 Work assignment view</li>
<li>其他分配视图 Other allocation views</li>
</ol>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612190702523.png" alt="image-20230612190702523" style="zoom:80%;" /></p>
<ol>
<li>Summary of Allocation Views</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612190315504.png" alt="image-20230612190315504"></p>
<h3 id="2-3-质量视图-Quality-Views"><a href="#2-3-质量视图-Quality-Views" class="headerlink" title="2.3 质量视图 Quality Views"></a>2.3 质量视图 Quality Views</h3><ol>
<li>安全视图 Security view</li>
<li>性能视图 Performance view</li>
<li>可靠性视图 Reliability view</li>
<li>沟通视图 Communication View</li>
<li>异常(错误处理)视图 Exception view (error-handling) view</li>
</ol>
<h3 id="2-4-文档化视图-Documenting-Views"><a href="#2-4-文档化视图-Documenting-Views" class="headerlink" title="2.4 文档化视图 Documenting Views"></a>2.4 文档化视图 Documenting Views</h3><h4 id="2-4-1-使用-3-步选择视图-3-Step-for-Choosing-Views"><a href="#2-4-1-使用-3-步选择视图-3-Step-for-Choosing-Views" class="headerlink" title="2.4.1 使用 3 步选择视图 3-Step for Choosing Views"></a>2.4.1 使用 3 步选择视图 3-Step for Choosing Views</h4><p>步骤 1：构建<strong>涉众/视图表</strong> Step-1: Build a stakeholder/view table</p>
<p>步骤 2：<strong>合并视图</strong> Step-2: Combine views</p>
<ul>
<li><p>2.1: 识别上表中的边缘视图<br>2.1: Identify marginal views in the above table</p>
</li>
<li><p>2.2: 通过关联一个视图中的元素和另一个视图中的元素，将每个边缘视图与另一个具有更强选区的视图相结合<br>2.2: Combine each marginal views with another view with stronger constituency by associating between elements in one view and elements in the other</p>
</li>
</ul>
<p>步骤 3：确定优先级和阶段 Step-3: Prioritize and stage</p>
<ul>
<li>分解视图 decomposition view</li>
<li>80/20原则 80/20 principle</li>
<li>按顺序完成所有视图？complete all views in sequence?</li>
</ul>
<h4 id="2-4-2-涉众和文档-Stakeholder-and-Documentation"><a href="#2-4-2-涉众和文档-Stakeholder-and-Documentation" class="headerlink" title="2.4.2 涉众和文档 Stakeholder and Documentation"></a>2.4.2 涉众和文档 Stakeholder and Documentation</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191431955.png" alt="image-20230612191431955"></p>
<h4 id="2-4-3-涉众视图表-Stackholder-View-Table"><a href="#2-4-3-涉众视图表-Stackholder-View-Table" class="headerlink" title="2.4.3 涉众视图表 Stackholder-View Table"></a>2.4.3 涉众视图表 Stackholder-View Table</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191448333.png" alt="image-20230612191448333"></p>
<ul>
<li>上图中每一个格子是指涉众对某一个部分的细节了解程度。</li>
</ul>
<h3 id="2-5-组合视图-Combining-Views"><a href="#2-5-组合视图-Combining-Views" class="headerlink" title="2.5 组合视图 Combining Views"></a>2.5 组合视图 Combining Views</h3><ol>
<li>各种 C&amp;C 视图 Various C&amp;C view</li>
<li>带有 SOA 或通信进程视图的部署视图 Deployment view with either SOA or communicating- process Views</li>
<li>分解视图和任何工作分配、实施、使用或分层视图 Decomposition view and any of work assignment, implementation, uses, or layered views</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191540749.png" alt="image-20230612191540749"></p>
<ul>
<li>使用一张视图说明整个系统的部署信息</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191553295.png" alt="image-20230612191553295"></p>
<ul>
<li>描述了component之间的关系</li>
</ul>
<h3 id="2-6-视图模板-View-Template"><a href="#2-6-视图模板-View-Template" class="headerlink" title="2.6 视图模板 View Template"></a>2.6 视图模板 View Template</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191632502.png" alt="image-20230612191632502"></p>
<ol>
<li>第1部分：主要介绍 Section-1: The Primary Presentation<ol>
<li>显示视图的元素和关系 shows the elements and relations of the view</li>
<li>通常是带有键的图形 often graphical with a key</li>
</ol>
</li>
<li>第2部分：<strong>元素目录</strong> Section-2: The <strong>Element Catalog</strong><ol>
<li>详细介绍了第1节中描述的元素。details the elements depicted in Sect.1</li>
<li>元素及其属性 Elements and their properties</li>
<li>关系及其属性 Relations and their properties</li>
<li>元素接口和行为 Element interfaces and behavior</li>
</ol>
</li>
<li>第3部分：<strong>上下文图</strong> Section-3: <strong>Context Diagram</strong><ol>
<li>系统或其部分如何与其环境相关 how the system or its portion relates to its envlronment</li>
</ol>
</li>
<li>第4部分：<strong>可变性</strong>指南 Section-4: <strong>Variability</strong> Guide<ol>
<li>如何在此视图中练习架构的任何变化点 how to exercise any variation points of the architecture in this view</li>
</ol>
</li>
<li>第5部分：<strong>解释</strong> Section-5: <strong>Rationale</strong><ol>
<li>为什么设计反映在视图中 why the design reflected in the view</li>
<li>提供了一个令人信服的论据，证明它是合理的。 provides a convincing argument that it is sound.</li>
</ol>
</li>
</ol>
<h4 id="2-6-1-上下文图-Context-Diagram"><a href="#2-6-1-上下文图-Context-Diagram" class="headerlink" title="2.6.1 上下文图 Context Diagram"></a>2.6.1 上下文图 Context Diagram</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612191909970.png" alt="image-20230612191909970"></p>
<h2 id="3-超越（超越视图的信息）Beyond-Information-Beyond-Views"><a href="#3-超越（超越视图的信息）Beyond-Information-Beyond-Views" class="headerlink" title="3. 超越（超越视图的信息）Beyond(Information Beyond Views)"></a>3. 超越（超越视图的信息）Beyond(Information Beyond Views)</h2><h3 id="3-1-视图之外的文档-Documentation-Beyond-Views"><a href="#3-1-视图之外的文档-Documentation-Beyond-Views" class="headerlink" title="3.1 视图之外的文档 Documentation Beyond Views"></a>3.1 视图之外的文档 Documentation Beyond Views</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192030553.png" alt="image-20230612192030553"></p>
<p>第1部分：文档路线图说明文档中的信息以及在哪里可以找到它 Section-1: Documentation Roadmap tells what in formation is in the documentation and where to find it</p>
<ol>
<li>范围和总结 Scope and summary</li>
<li>文档的组织方式 How the documentation is organized<ol>
<li>简短的概要 short synopsis</li>
<li>带注释的目录 annotated table of contents</li>
</ol>
</li>
<li>查看概览 View overview</li>
<li>利益相关者如何使用文档 How stakeholders can use the documentation</li>
</ol>
<h3 id="3-2-文档控制信息-Document-Control-information"><a href="#3-2-文档控制信息-Document-Control-information" class="headerlink" title="3.2 文档控制信息 Document Control information"></a>3.2 文档控制信息 Document Control information</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192054456.png" alt="image-20230612192054456"></p>
<h3 id="3-3-Mapping-between-Views"><a href="#3-3-Mapping-between-Views" class="headerlink" title="3.3 Mapping between Views"></a>3.3 Mapping between Views</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192257861.png" alt="image-20230612192257861"></p>
<h3 id="3-4-Documentation-Package"><a href="#3-4-Documentation-Package" class="headerlink" title="3.4 Documentation Package"></a>3.4 Documentation Package</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612192317391.png" alt="image-20230612192317391"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/NJU/">NJU</a>, <a href="/categories/NJU/软件系统设计/">软件系统设计</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件架构/">软件架构</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Whale
    
  </p>
</footer>
    
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>