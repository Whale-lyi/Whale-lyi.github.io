<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="码农预备役" />
  
  
  <title>
    
      数据管理基础 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">数据管理基础</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-08-09 14:53:19
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/NJU/" title="NJU">
                    <b>#</b> NJU
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/NJU/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" title="数据管理基础">
                    <b>#</b> 数据管理基础
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="01-绪论"><a href="#01-绪论" class="headerlink" title="01-绪论"></a>01-绪论</h1><h2 id="1-数据管理方式"><a href="#1-数据管理方式" class="headerlink" title="1. 数据管理方式"></a>1. 数据管理方式</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914210001864.png" alt="image-20220914210001750" style="zoom:80%;" /></p>
<ul>
<li>为什么需要数据库/数据有哪些管理方式，各自特点是什么</li>
</ul>
<h2 id="2-几个基本概念"><a href="#2-几个基本概念" class="headerlink" title="2. 几个基本概念"></a>2. 几个基本概念</h2><ul>
<li>数据：数据库中存储的基本对象，是描述事物的符号记录。</li>
<li><strong>数据的含义称为语义</strong>，数据与其语义是不可分的。<ul>
<li>93是数据，它可以是成绩、体重、钱数，这些是语义</li>
</ul>
</li>
<li><strong>数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。</strong></li>
<li>数据库系统的构成：数据库、数据库管理系统(DBMS，及其应用开发工具)，应用程序，数据库管理员(DBA)。</li>
</ul>
<h2 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3. 数据模型"></a>3. 数据模型</h2><ul>
<li>概念模型、逻辑模型、物理模型</li>
<li><strong>(必考)</strong>考点：概念 —&gt; E-R图 —&gt; 关系</li>
</ul>
<h3 id="3-1-概念模型"><a href="#3-1-概念模型" class="headerlink" title="3.1 概念模型"></a>3.1 概念模型</h3><ul>
<li>用于数据库设计，用 E-R 图来描述现实世界的概念模型。</li>
<li>概念：<ul>
<li>实体: 客观存在并可相互区别的事物称为实体</li>
<li>属性: 实体所具有的某一特性称为属性</li>
<li>码: 唯一标识实体的属性集称为码</li>
<li>实体型: 用实体名及其属性名集合来抽象和刻画同类实体称为实体型</li>
<li>实体集: 同一类型实体的集合称为实体集</li>
<li>联系: 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体(型)内部的联系和实体(型)之间的联系</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220616222137824.png" alt="image-20220616222137824"></p>
<h3 id="3-2-逻辑模型"><a href="#3-2-逻辑模型" class="headerlink" title="3.2 逻辑模型"></a>3.2 逻辑模型</h3><blockquote>
<p>问题：如何”多快好省”地将信息世界转换为机器世界？</p>
<p>方案 1：尽量独立于应用层，采用”中立”的方式表达概念模型，体现为<strong>关系数据库</strong></p>
<p>方案 2：在应用层中，使用特定数据结构，并在逻辑模型中高效支持这一数据结构，体现为 NoSQL 数据库</p>
<p>方案 *：通用数据结构采用方案 1，关键性数据结构采用方案2</p>
</blockquote>
<h4 id="3-2-1-关系模型的数据结构"><a href="#3-2-1-关系模型的数据结构" class="headerlink" title="3.2.1 关系模型的数据结构"></a>3.2.1 关系模型的数据结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211035926.png" alt="image-20220914211035814"></p>
<ul>
<li>规范条件：关系必须是规范化的，满足一定的规范条件。</li>
<li>最基本的规范条件(1NF)：关系的每一个分量必须是一个<strong>不可分</strong>的数据项，<strong>不允许表中还有表</strong>。</li>
<li>关系的完整性约束条件：<strong>实体完整性、参照完整性、用户定义的完整性</strong>。</li>
</ul>
<h4 id="3-2-2-关系模型的优缺点"><a href="#3-2-2-关系模型的优缺点" class="headerlink" title="3.2.2 关系模型的优缺点"></a>3.2.2 关系模型的优缺点</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220616223641721.png" alt="image-20220616223641721"></p>
<h4 id="3-2-3-NoSQL"><a href="#3-2-3-NoSQL" class="headerlink" title="3.2.3 NoSQL"></a>3.2.3 NoSQL</h4><ul>
<li>基于Key-Value存储模型</li>
<li>BigTable 模型：<code>(row:string, column:string, time:int64) ==&gt; string</code></li>
<li>基于文档模型</li>
<li>基于图模型：记为 G(V,E)，V 为结点集合，每个结点具有若干属性，E 为边集合，也可以具有若干属性。</li>
</ul>
<h2 id="4-数据库系统的结构"><a href="#4-数据库系统的结构" class="headerlink" title="4. 数据库系统的结构"></a>4. 数据库系统的结构</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220616224445417.png" alt="image-20220616224445417"></p>
<p>模式（Schema）</p>
<ul>
<li>数据库逻辑结构和特征的描述</li>
<li><p>是型的描述，不涉及具体值</p>
<ul>
<li>反映的是数据的结构及其联系</li>
</ul>
</li>
<li><p>模式是相对稳定的</p>
</li>
</ul>
<p>实例（Instance）</p>
<ul>
<li><p>反映数据库某一时刻的状态</p>
<ul>
<li>模式的一个具体值</li>
</ul>
</li>
<li><p>同一个模式可以有很多实例</p>
</li>
<li><p>实例随数据库中的数据的更新而变动</p>
</li>
</ul>
<h3 id="4-1-模式-逻辑模式"><a href="#4-1-模式-逻辑模式" class="headerlink" title="4.1 模式(逻辑模式)"></a>4.1 模式(逻辑模式)</h3><ul>
<li>一个数据库只有一个模式：数据库中全体数据的逻辑结构和特征的描述</li>
<li>模式的地位：是数据库系统模式结构的中间层<ul>
<li>与数据的物理存储细节和硬件环境无关</li>
<li>与具体的应用程序、开发工具及高级程序设计语言无关</li>
</ul>
</li>
<li>模式的定义<ul>
<li>数据的逻辑结构(数据项的名字、类型、取值范围等)</li>
<li>数据之间的联系</li>
<li>数据有关的安全性、完整性要求</li>
</ul>
</li>
</ul>
<h3 id="4-2-外模式-用户模式、子模式"><a href="#4-2-外模式-用户模式、子模式" class="headerlink" title="4.2 外模式(用户模式、子模式)"></a>4.2 外模式(用户模式、子模式)</h3><ul>
<li>数据库用户(包括应用程序员和最终用户)使用的局部数据的逻辑结构和特征的描述</li>
<li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li>
<li>外模式的用途<ul>
<li>保证数据库安全性的一个有力措施</li>
<li>每个用户只能看见和访问所对应的外模式中的数据</li>
</ul>
</li>
</ul>
<h3 id="4-3-内模式-存储模式"><a href="#4-3-内模式-存储模式" class="headerlink" title="4.3 内模式(存储模式)"></a>4.3 内模式(存储模式)</h3><ul>
<li>是数据物理结构和存储方式的描述</li>
<li>是数据在数据库内部的表示方式</li>
<li>一个数据库只有一个内模式</li>
</ul>
<h3 id="4-4-外模式-模式映像"><a href="#4-4-外模式-模式映像" class="headerlink" title="4.4 外模式/模式映像"></a>4.4 外模式/模式映像</h3><ul>
<li>同一个模式可以有任意多个外模式 </li>
<li>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</li>
<li>映象定义通常包含在各自外模式的描述中</li>
<li>保证数据的逻辑独立性<ul>
<li>当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变</li>
<li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li>
</ul>
</li>
</ul>
<h3 id="4-5-模式-内模式映像"><a href="#4-5-模式-内模式映像" class="headerlink" title="4.5 模式/内模式映像"></a>4.5 模式/内模式映像</h3><ul>
<li>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。<ul>
<li>例如，说明逻辑记录和字段在内部是如何表示的</li>
</ul>
</li>
<li>数据库中模式／内模式映象是唯一的</li>
<li>保证数据的物理独立性<ul>
<li>当数据库的存储结构改变了(例如选用了另一种存储结构)，数据库管理员修改模式／内模式映象，使模式保持不变。</li>
<li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li>
</ul>
</li>
</ul>
<h2 id="5-数据库系统的组成"><a href="#5-数据库系统的组成" class="headerlink" title="5. 数据库系统的组成"></a>5. 数据库系统的组成</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211054979.png" alt="image-20220914211054979"></p>
<h1 id="02-关系型数据库"><a href="#02-关系型数据库" class="headerlink" title="02-关系型数据库"></a>02-关系型数据库</h1><ul>
<li><p>域(D)、笛卡尔积(D*D)、元组((d1,d2,d3))、关系、属性、码</p>
</li>
<li><p><strong>候选码</strong>：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为<strong>候选码</strong>。</p>
<ul>
<li>关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li>
</ul>
</li>
<li><p><strong>主码</strong>：若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。</p>
</li>
<li><p><strong>主属性与非主属性</strong>：<strong>候选码的诸属性称为主属性</strong>。不包含在任何侯选码中的属性称为<strong>非主属性或非码属性</strong>。</p>
</li>
</ul>
<h2 id="1-关系"><a href="#1-关系" class="headerlink" title="1. 关系"></a>1. 关系</h2><h3 id="1-1-关系的类别"><a href="#1-1-关系的类别" class="headerlink" title="1.1 关系的类别"></a>1.1 关系的类别</h3><p>基本关系(基本表或基表)</p>
<ul>
<li>实际存在的表，是实际存储数据的逻辑表示</li>
</ul>
<p>查询表</p>
<ul>
<li>查询结果对应的表</li>
</ul>
<p>视图表</p>
<ul>
<li>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li>
</ul>
<h3 id="1-2-基本关系的性质"><a href="#1-2-基本关系的性质" class="headerlink" title="1.2 基本关系的性质"></a>1.2 基本关系的性质</h3><ul>
<li><p>列是同质的（Homogeneous）</p>
<ul>
<li>每一列中的分量是同一类型的数据，来自同一个域</li>
</ul>
</li>
<li><p>不同的列可出自同一个域</p>
</li>
<li><p>列的次序可以任意交换</p>
</li>
<li><p>任意两个元组的候选码不能相同</p>
</li>
<li><p>行的次序可以任意交换</p>
</li>
<li><p>分量必须取原子值</p>
</li>
</ul>
<h3 id="1-3-关系模式"><a href="#1-3-关系模式" class="headerlink" title="1.3 关系模式"></a>1.3 关系模式</h3><ul>
<li><p>关系模式（Relation Schema）是型，关系是值</p>
</li>
<li><p>关系模式是对关系的描述</p>
<ul>
<li><p>元组集合的结构</p>
</li>
<li><p>完整性约束条件</p>
</li>
</ul>
</li>
<li><p>关系模式可以形式化地表示为：$R(U,D,DOM,F)$</p>
<ul>
<li>$R$：关系名 </li>
<li>$U$：组成该关系的属性名集合</li>
<li>$D$：$U$中属性所来自的域</li>
<li>$DOM$：属性向域的映象集合</li>
<li>$F$：属性间数据的依赖关系的集合</li>
</ul>
</li>
<li><p>关系模式通常可以简记为 $R(U)$ 或 $R(A_1, A_2, …, A_n)$</p>
<ul>
<li>$A$: 属性名</li>
<li>注：域名及属性向域的映象常常直接说明为属性的类型、长度</li>
</ul>
</li>
<li><p>关系模式和关系往往笼统称为关系, 通过上下文加以区别</p>
</li>
</ul>
<h2 id="2-数据库完整性"><a href="#2-数据库完整性" class="headerlink" title="2. 数据库完整性"></a>2. 数据库完整性</h2><ul>
<li><p>实体完整性：主属性不为空</p>
</li>
<li><p>参照完整性：外码为空或者等于相应的某个主码</p>
</li>
<li><p>用户定义完整性：</p>
<p>例：课程(课程号，课程名，学分)</p>
<ul>
<li><p>“课程名”属性必须取唯一值</p>
</li>
<li><p>非主属性”课程名”也不能取空值</p>
</li>
<li><p>“学分”属性只能取值{1，2，3，4}</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-关系代数"><a href="#3-关系代数" class="headerlink" title="3. 关系代数"></a>3. 关系代数</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707092725928.png" alt="image-20230707092725928"></p>
<h3 id="3-1-传统的集合操作"><a href="#3-1-传统的集合操作" class="headerlink" title="3.1 传统的集合操作"></a>3.1 传统的集合操作</h3><ul>
<li><p><strong>基本操作：并、差、交、(广义)笛卡尔积</strong></p>
<ul>
<li>进行 并、交、差 操作的关系应具有相同的目(即两个关系都有n个属性)且相应属性取自同一个域</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095153880.png" alt="image-20230707095153880"></p>
<ul>
<li><p>笛卡尔积：$R \times S$, $m+n$列, $k_1 \times k_2$个元组</p>
<ul>
<li><p>$R$: $n$目关系, $k_1$个元组</p>
</li>
<li><p>$S$: $m$目关系, $k_2$个元组</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095238550.png" alt="image-20230707095238550"></p>
<h3 id="3-2-使用的记号"><a href="#3-2-使用的记号" class="headerlink" title="3.2 使用的记号"></a>3.2 使用的记号</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095023441.png" alt="image-20230707095023441"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707093726034.png" alt="image-20230707093726034" style="zoom:80%;" /></p>
<h3 id="3-3-专门的关系运算"><a href="#3-3-专门的关系运算" class="headerlink" title="3.3 专门的关系运算"></a>3.3 专门的关系运算</h3><p><strong>选择</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095444581.png" alt="image-20230707095444581"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095453321.png" alt="image-20230707095453321"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>投影</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095525948.png" alt="image-20230707095525948"></p>
<p><strong>连接</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707095631079.png" alt="image-20230707095631079"></p>
<ul>
<li>$\theta$ 为 “=” 的连接运算称为<strong>等值连接</strong></li>
<li><strong>自然连接</strong>是一种特殊的等值连接，要求比较的分量必须是同名的属性组，并将结果中重复的属性列去掉</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707100140151.png" alt="image-20230707100140151"></p>
<ul>
<li>悬浮元组、外连接</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707100440461.png" alt="image-20230707100440461"></p>
<p><strong>除</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707102247390.png" alt="image-20230707102247390"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707102435112.png" alt="image-20230707102435112"></p>
<h1 id="03-关系数据库标准语言SQL"><a href="#03-关系数据库标准语言SQL" class="headerlink" title="03-关系数据库标准语言SQL"></a>03-关系数据库标准语言SQL</h1><ul>
<li>SQL 结构化查询语言，是关系数据库的标准语言。集数据定义语言(DDL)，数据操纵语言(DML)，数据控制语言(DCL)功能于一体。</li>
<li>仅有 9 个动词：<code>CREATE, DROP, ALTER, SELECT, INSERT, UPDATE, DELETE, GRANT, REVOKE</code></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707102845313.png" alt="image-20230707102845313"></p>
<h2 id="1-SQL数据定义"><a href="#1-SQL数据定义" class="headerlink" title="1. SQL数据定义"></a>1. SQL数据定义</h2><h3 id="1-1-层次化的数据库对象命名机制"><a href="#1-1-层次化的数据库对象命名机制" class="headerlink" title="1.1 层次化的数据库对象命名机制"></a>1.1 层次化的数据库对象命名机制</h3><ul>
<li>一个关系数据库管理系统的实例(Instance)中可以建立多个数据库(database)</li>
<li>一个数据库中可以建立多个模式(schema)</li>
<li>一个模式下通常包括多个表(table)、视图(view)和索引(index)等数据库对象</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211108258.png" alt="image-20220914211108258"></p>
<h3 id="1-2-数据定义"><a href="#1-2-数据定义" class="headerlink" title="1.2 数据定义"></a>1.2 数据定义</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707110148151.png" alt="image-20230707110148151"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>表定义子句<span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-operator">&lt;</span>视图定义子句<span class="hljs-operator">&gt;</span><span class="hljs-operator">|</span><span class="hljs-operator">&lt;</span>授权定义子句<span class="hljs-operator">&gt;</span>]<br><br><span class="hljs-keyword">DROP</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>CASCADE<span class="hljs-operator">|</span>RESTRICT<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>      (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]<br>      [,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]] <br>      [,<span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span>]);<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>［RESTRICT<span class="hljs-operator">|</span>CASCADE］;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br>    [<span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [完整性约束]]<br>    [<span class="hljs-keyword">ADD</span> <span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>    [<span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [CASCADE<span class="hljs-operator">|</span>RESTRICT]]<br>    [<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span> [RESTRICT<span class="hljs-operator">|</span>CASCADE]]<br>    [<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure>
<ul>
<li><p>RESTRICT：删除表是有限制的。</p>
<ul>
<li><p>欲删除的基本表不能被其他表的约束所引用</p>
</li>
<li><p>如果存在依赖该表的对象，则此表不能被删除</p>
</li>
</ul>
</li>
<li><p>CASCADE：删除该表没有限制。</p>
<ul>
<li>在删除基本表的同时，相关的依赖对象一起删除</li>
</ul>
</li>
</ul>
<h3 id="1-3-索引"><a href="#1-3-索引" class="headerlink" title="1.3 索引"></a>1.3 索引</h3><ul>
<li><p>建立索引的目的：加快查询速度</p>
</li>
<li><p>关系数据库管理系统中常见索引</p>
<ul>
<li><p>顺序文件上的索引</p>
</li>
<li><p>B+树索引</p>
</li>
<li><p>散列（hash）索引</p>
</li>
<li><p>位图索引</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>][,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>]]...);<br><br><span class="hljs-keyword">ALTER</span> INDEX <span class="hljs-operator">&lt;</span>旧索引名<span class="hljs-operator">&gt;</span> RENAME <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>新索引名<span class="hljs-operator">&gt;</span>;<br><br><span class="hljs-keyword">DROP</span> INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔</li>
<li>次序：指定索引值的排列次序，升序：ASC，降序：DESC, 缺省值：ASC</li>
<li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li>
<li>CLUSTER：表示要建立的索引是聚簇索引</li>
</ul>
<h3 id="1-4-数据字典"><a href="#1-4-数据字典" class="headerlink" title="1.4 数据字典"></a>1.4 数据字典</h3><ul>
<li><p>数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：</p>
<ul>
<li>关系模式定义</li>
<li>视图定义</li>
<li>索引定义</li>
<li>完整性约束定义</li>
<li>各类用户对数据库的操作权限</li>
<li>统计信息等</li>
</ul>
</li>
<li><p>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。</p>
</li>
</ul>
<h2 id="2-SQL数据查询"><a href="#2-SQL数据查询" class="headerlink" title="2. SQL数据查询"></a>2. SQL数据查询</h2><h3 id="2-1-单表查询"><a href="#2-1-单表查询" class="headerlink" title="2.1 单表查询"></a>2.1 单表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DISTINCT</span>] <span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span>] ...<br>	<span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>tableName<span class="hljs-operator">&gt;</span>] ... <span class="hljs-operator">|</span> (<span class="hljs-operator">&lt;</span>select_caluse<span class="hljs-operator">&gt;</span>)<br>	[<span class="hljs-keyword">AS</span>] <span class="hljs-operator">&lt;</span>alias<span class="hljs-operator">&gt;</span><br>	[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>conditional_expression<span class="hljs-operator">&gt;</span>]<br>	[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>colName<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>conditional_expression<span class="hljs-operator">&gt;</span>]]<br>	[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>colName<span class="hljs-operator">&gt;</span>] [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]];<br>	<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果未对查询结果分组，聚集函数将作用于整个查询结果</span><br><span class="hljs-comment">HAVING短语与WHERE子句的区别：作用对象不同</span><br><span class="hljs-comment">- WHERE子句作用于基表或视图，从中选择满足条件的元组</span><br><span class="hljs-comment">- HAVING短语作用于组，从中选择满足条件的组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> Sno <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">SELECT</span> Sno, <span class="hljs-built_in">AVG</span>(Grade) <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(Grade) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">90</span>;<br><br>谓词： [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;&lt;匹配串&gt;&#x27;</span> [<span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;&lt;换码字符&gt;&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211119795.png" alt="image-20220914211119795"></p>
<ul>
<li><p>通配符 % 表示任意长度(包括0), ‘_’ 表示任意单个字符</p>
</li>
<li><p>聚集函数：COUNT, SUM, AVG, MAX, MIN</p>
</li>
</ul>
<h3 id="2-2-连接查询"><a href="#2-2-连接查询" class="headerlink" title="2.2 连接查询"></a>2.2 连接查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/* [例 3.49] 查询每个学生及其选修课程的情况 */</span><br><span class="hljs-keyword">SELECT</span> Student.<span class="hljs-operator">*</span>, SC.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student, SC<br><span class="hljs-keyword">WHERE</span> Student.Sno <span class="hljs-operator">=</span> SC.Sno;<br><br><span class="hljs-comment">/* 对上例使用自然连接 */</span><br><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade<br><span class="hljs-keyword">FROM</span> Student, SC<br><span class="hljs-keyword">WHERE</span> Student.Sno <span class="hljs-operator">=</span> SC.Sno;<br><br><span class="hljs-comment">/* [例 3.53] 改写 [例 3.49] </span><br><span class="hljs-comment">	左外连接：列出左表中所有的元组 */</span><br><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUT</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> (Student.Sno<span class="hljs-operator">=</span>SC.Sno);<br><br><span class="hljs-comment">/* [例3.54]查询每个学生的学号、姓名、选修 的课程名及成绩 */</span><br><span class="hljs-keyword">SELECT</span> Student.Sno, Sname, Cname, Grade<br><span class="hljs-keyword">FROM</span> Student, SC, Course <span class="hljs-comment">/*多表连接*/</span><br><span class="hljs-keyword">WHERE</span> Student.Sno <span class="hljs-operator">=</span> SC.Sno<br><span class="hljs-keyword">AND</span> SC.Cno <span class="hljs-operator">=</span> Course.Cno;<br><br># 自身连接<br><span class="hljs-keyword">SELECT</span> FIRST.Cno, SECOND.Cpno<br><span class="hljs-keyword">FROM</span> Course <span class="hljs-keyword">FIRST</span>, Course <span class="hljs-keyword">SECOND</span><br><span class="hljs-keyword">WHERE</span> FIRST.Cpno <span class="hljs-operator">=</span> SECOND.Cno;<br><br></code></pre></td></tr></table></figure>
<h3 id="2-3-嵌套查询"><a href="#2-3-嵌套查询" class="headerlink" title="2.3 嵌套查询"></a>2.3 嵌套查询</h3><ul>
<li>将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为嵌套查询</li>
<li>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt;&gt;）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname	     <span class="hljs-comment">/*外层查询/父查询*/</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sno <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> Sno       <span class="hljs-comment">/*内层查询/子查询*/</span><br>	<span class="hljs-keyword">FROM</span> SC<br>	<span class="hljs-keyword">WHERE</span> Cno<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2&#x27;</span><br>);<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707120633946.png" alt="image-20230707120633946"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707125025133.png" alt="image-20230707125025133"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄<br><span class="hljs-keyword">SELECT</span> Sname,Sage<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage <span class="hljs-operator">&lt;</span> <span class="hljs-keyword">ANY</span> (<br>    <span class="hljs-keyword">SELECT</span> Sage<br>    <span class="hljs-keyword">FROM</span> Student<br>    <span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span><br>) <span class="hljs-keyword">AND</span> Sdept <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;CS&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p>带有<strong>EXISTS</strong>谓词的子查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询所有选修了<span class="hljs-number">1</span>号课程的学生姓名<br><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>(<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>	<span class="hljs-keyword">FROM</span> SC<br>	<span class="hljs-keyword">WHERE</span> Sno <span class="hljs-operator">=</span> Student.Sno <span class="hljs-keyword">AND</span> Cno<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br>);<br><br># 查询与&quot;刘晨&quot;在同一个系学习的学生<br><span class="hljs-keyword">SELECT</span> Sno,Sname,Sdept<br><span class="hljs-keyword">FROM</span> Student S1<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> Student S2<br>    <span class="hljs-keyword">WHERE</span> S2.Sdept <span class="hljs-operator">=</span> S1.Sdept <span class="hljs-keyword">AND</span> S2.Sname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;刘晨&#x27;</span><br>);<br><br># 查询选修了全部课程的学生姓名<br><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> Course<br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> SC<br>        <span class="hljs-keyword">WHERE</span> Sno<span class="hljs-operator">=</span> Student.Sno <span class="hljs-keyword">AND</span> Cno<span class="hljs-operator">=</span> Course.Cno<br>    )<br>);<br></code></pre></td></tr></table></figure>
<h3 id="2-4-集合查询"><a href="#2-4-集合查询" class="headerlink" title="2.4 集合查询"></a>2.4 集合查询</h3><ul>
<li>并操作 UNION<ul>
<li>将多个查询结果合并起来时，系统自动去掉重复元组</li>
<li>UNION ALL：将多个查询结果合并起来时，保留重复元组 </li>
</ul>
</li>
<li>交操作 INTERSECT</li>
<li>差操作 EXCEPT</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"># [例 <span class="hljs-number">3.64</span>] 查询计算机科学系的学生及年龄不大于<span class="hljs-number">19</span>岁的学生。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage <span class="hljs-operator">&lt;=</span> <span class="hljs-number">19</span>;<br><br># [例<span class="hljs-number">3.66</span>] 查询计算机科学系的学生与年龄不大于<span class="hljs-number">19</span>岁的学生的交集。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS&#x27;</span> <br><span class="hljs-keyword">INTERSECT</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage <span class="hljs-operator">&lt;=</span> <span class="hljs-number">19</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;CS&#x27;</span><br><span class="hljs-keyword">EXCEPT</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sage <span class="hljs-operator">&lt;=</span><span class="hljs-number">19</span>;<br></code></pre></td></tr></table></figure>
<h3 id="2-5-基于派生表的查询"><a href="#2-5-基于派生表的查询" class="headerlink" title="2.5 基于派生表的查询"></a>2.5 基于派生表的查询</h3><p>子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这时子查询生成的临时派生表成为主查询的查询对象</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sno, Cno<br><span class="hljs-keyword">FROM</span> SC, (<br>    <span class="hljs-keyword">SELECT</span> Sno, <span class="hljs-built_in">Avg</span>(Grade) <br>    <span class="hljs-keyword">FROM</span> SC<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br>) <span class="hljs-keyword">AS</span> Avg_sc(avg_sno,avg_grade)<br><span class="hljs-keyword">WHERE</span> SC.Sno <span class="hljs-operator">=</span> Avg_sc.avg_sno <span class="hljs-keyword">and</span> SC.Grade <span class="hljs-operator">&gt;=</span> Avg_sc.avg_grade<br></code></pre></td></tr></table></figure>
<p>如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属性</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname<br><span class="hljs-keyword">FROM</span> Student, (<br>    <span class="hljs-keyword">SELECT</span> Sno<br>    <span class="hljs-keyword">FROM</span> SC<br>    <span class="hljs-keyword">WHERE</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br>) <span class="hljs-keyword">AS</span> SC1<br><span class="hljs-keyword">WHERE</span> Student.Sno<span class="hljs-operator">=</span>SC1.Sno;<br></code></pre></td></tr></table></figure>
<h2 id="3-数据更新"><a href="#3-数据更新" class="headerlink" title="3. 数据更新"></a>3. 数据更新</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[, <span class="hljs-operator">&lt;</span>属性列<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>...)]<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-operator">&lt;</span>常量<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[, <span class="hljs-operator">&lt;</span>常量<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]... );<br><br># 插入子查询结果<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Dept_age(Sdept,Avg_age)<br>    <span class="hljs-keyword">SELECT</span> Sdept，<span class="hljs-built_in">AVG</span>(Sage)<br>    <span class="hljs-keyword">FROM</span> Student<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sdept;<br><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">SET</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>[, <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span>表达式<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>];<br><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure>
<h2 id="4-SQL中的空值"><a href="#4-SQL中的空值" class="headerlink" title="4. SQL中的空值"></a>4. SQL中的空值</h2><ul>
<li>判断空值用 <code>IS NULL</code> 或 <code>IS NOT NULL</code>。</li>
<li>有<code>NOT NULL</code>、<code>UNIQUE</code>限制的属性不能为空值，码不能为空值。</li>
<li>空值与其他值的算术运算结果为空值，空值与其他值的比较运算结果为 <code>UNKNOWN</code></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211132547.png" alt="image-20220914211132547"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"># [例 <span class="hljs-number">3.83</span>] 选出选修<span class="hljs-number">1</span>号课程的不及格的学生以及缺考的学生。<br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Grade <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span><br>  <span class="hljs-keyword">AND</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Grade <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br>  <span class="hljs-keyword">AND</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br><br># 或者<br><span class="hljs-keyword">SELECT</span> Sno<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">WHERE</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br>  <span class="hljs-keyword">AND</span> (Grade <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span> <span class="hljs-keyword">OR</span> Grade <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>);<br></code></pre></td></tr></table></figure>
<h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5. 视图"></a>5. 视图</h2><ul>
<li><p>从一个或几个基本表(或视图)导出的表，是一个虚表。数据库中只存放视图的定义，不存放视图对应的数据。</p>
</li>
<li><p>基表中的数据发生变化，从视图中查询出的数据也随之改变</p>
</li>
<li><p><strong>视图的作用：</strong></p>
<ol>
<li>视图能够简化用户的操作</li>
<li>使用户能够以多种角度看待同一数据</li>
<li>提供了一定程度的逻辑独立性</li>
<li>提供安全保护</li>
<li>可以更清晰地表达查询</li>
</ol>
</li>
</ul>
<h3 id="5-1-定义视图"><a href="#5-1-定义视图" class="headerlink" title="5.1 定义视图"></a>5.1 定义视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>]...)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br><br># 建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> IS_Student <span class="hljs-keyword">AS</span> <br>    <span class="hljs-keyword">SELECT</span> Sno,Sname,Sage<br>    <span class="hljs-keyword">FROM</span>  Student<br>    <span class="hljs-keyword">WHERE</span>  Sdept<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;IS&#x27;</span><br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为行列子集视图</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>WITH CKECK OPTION：表示对视图进行更新操作时要保证<strong>更新后的行满足谓词条件</strong>(即子查询中的条件)</li>
<li>组成视图的属性列名：全部省略或全部指定</li>
<li>关系数据库管理系统执行 CREATE VIEW 语句时只是把视图定义存入数据字典，并不执行其中的 SELECT 语句。</li>
<li>在对视图查询时，按视图的定义从基本表中将数据查出</li>
</ul>
<h3 id="5-2-删除视图"><a href="#5-2-删除视图" class="headerlink" title="5.2 删除视图"></a>5.2 删除视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [CASCADE];<br># 如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除<br></code></pre></td></tr></table></figure>
<h3 id="5-3-查询视图"><a href="#5-3-查询视图" class="headerlink" title="5.3 查询视图"></a>5.3 查询视图</h3><ul>
<li>用户角度：查询视图与查询基本表相同</li>
<li>关系数据库管理系统实现视图查询的方法<ul>
<li>视图消解法（View Resolution）<ul>
<li>进行有效性检查</li>
<li>转换成等价的对基本表的查询</li>
<li>执行修正后的查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 在信息系学生的视图中找出年龄小于<span class="hljs-number">20</span>岁的学生。<br><span class="hljs-keyword">SELECT</span> Sno,Sage<br><span class="hljs-keyword">FROM</span> IS_Student<br><span class="hljs-keyword">WHERE</span> Sage<span class="hljs-operator">&lt;</span><span class="hljs-number">20</span>;<br><br># 视图消解转换后的查询语句为：<br><span class="hljs-keyword">SELECT</span> Sno,Sage       <br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Sdept<span class="hljs-operator">=</span><span class="hljs-string">&#x27;IS&#x27;</span> <span class="hljs-keyword">AND</span> Sage<span class="hljs-operator">&lt;</span><span class="hljs-number">20</span>;<br><br># 有些情况下，视图消解法不能生成正确的查询。<br># 例如：在S_G视图中查询平均成绩在<span class="hljs-number">90</span>分以上的学生学号和平均成绩<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> S_G<br><span class="hljs-keyword">WHERE</span> Gavg<span class="hljs-operator">&gt;=</span><span class="hljs-number">90</span>;<br><br># 正确的消解转换后<br><span class="hljs-keyword">SELECT</span> Sno, <span class="hljs-built_in">AVG</span>(Grade)<br><span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sno<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(Grade)<span class="hljs-operator">&gt;=</span><span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure>
<h3 id="5-更新视图"><a href="#5-更新视图" class="headerlink" title="5. 更新视图"></a>5. 更新视图</h3><ul>
<li>转换为对基本表的更新</li>
<li>允许对行列子集视图进行更新</li>
<li>对其他类型视图的更新不同系统有不同限制。<ul>
<li>一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新。</li>
<li>一个不允许更新的视图上定义的视图也不允许更新。</li>
</ul>
</li>
</ul>
<h1 id="04-数据库安全性"><a href="#04-数据库安全性" class="headerlink" title="04-数据库安全性"></a>04-数据库安全性</h1><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707143008735.png" alt="image-20230707143008735"></p>
<h2 id="1-自主存取控制"><a href="#1-自主存取控制" class="headerlink" title="1. 自主存取控制"></a>1. 自主存取控制</h2><ul>
<li><p>自主存取控制，简称<strong>DAC</strong></p>
</li>
<li><p>C2级</p>
</li>
<li><p><strong>缺点：可能存在数据的无意泄露</strong></p>
<ul>
<li>原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</li>
<li>解决：对系统控制下的所有主客体实施强制存取控制策略</li>
</ul>
</li>
</ul>
<h3 id="1-1-GRANT"><a href="#1-1-GRANT" class="headerlink" title="1.1 GRANT"></a>1.1 GRANT</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211142564.png" alt="image-20220914211142564"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION ];<br># <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION 子句：可以再授予其他用户，不允许循环授权<br><br># [例<span class="hljs-number">4.1</span>] 把查询 Student 表和修改学生学号权限授给用户 U1<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">UPDATE</span>(Sno), <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">TO</span> U1;<br><br># [例<span class="hljs-number">4.2</span>] 把对Student表和Course表的全部权限授予所有用户<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILIGES <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student, Course<br><span class="hljs-keyword">TO</span> PUBLIC;<br></code></pre></td></tr></table></figure>
<h3 id="1-2-REVOKE"><a href="#1-2-REVOKE" class="headerlink" title="1.2 REVOKE"></a>1.2 REVOKE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">REVOKE</span>语句的一般格式为：<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[CASCADE <span class="hljs-operator">|</span> RESTRICT];<br><br># [例<span class="hljs-number">4.8</span>] 把用户U4修改学生学号的权限收回<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">UPDATE</span>(Sno) <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">FROM</span> U4;<br><br># [例<span class="hljs-number">4.9</span>] 收回所有用户对表 SC 的查询权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> SC<br><span class="hljs-keyword">FROM</span> PUBLIC;<br><br># [例<span class="hljs-number">4.10</span>] 把用户U5对SC表的 <span class="hljs-keyword">INSERT</span>权限收回<br># 将用户U5的<span class="hljs-keyword">INSERT</span>权限收回的时候使用CASCADE，则同时收回U6或U7的<span class="hljs-keyword">INSERT</span>权限，否则拒绝执行该语句<br># 如果U6或U7还从其他用户处获得对SC表的<span class="hljs-keyword">INSERT</span>权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">INSERT</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> SC<br><span class="hljs-keyword">FROM</span> U5 <br>CASCADE;<br></code></pre></td></tr></table></figure>
<h3 id="1-3-创建数据库模式的权限"><a href="#1-3-创建数据库模式的权限" class="headerlink" title="1.3 创建数据库模式的权限"></a>1.3 创建数据库模式的权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"># 该命令不是 <span class="hljs-keyword">SQL</span> 标准<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-operator">&lt;</span>username<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span>] [DBA <span class="hljs-operator">|</span> RESOURCE <span class="hljs-operator">|</span> <span class="hljs-keyword">CONNECT</span>];<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211153494.png" alt="image-20220914211153494"></p>
<h3 id="1-4-数据库角色"><a href="#1-4-数据库角色" class="headerlink" title="1.4 数据库角色"></a>1.4 数据库角色</h3><ul>
<li>数据库角色：被命名的一组与数据库操作相关的权限<ul>
<li>角色是权限的集合</li>
<li>可以为一组具有相同权限的用户创建一个角色</li>
<li>简化授权的过程</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 角色的创建<br><span class="hljs-keyword">CREATE</span> ROLE <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span>;<br># 给角色授权<br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span>对象名 <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br># 将一个角色授予其他的角色或用户<br># 该语句把角色授予某用户，或授予另一个角色<br># 授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION<br># 指定了<span class="hljs-keyword">WITH</span> ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色<br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]... <span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色或用户<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色或用户<span class="hljs-operator">&gt;</span>]... [<span class="hljs-keyword">WITH</span> ADMIN OPTION];<br><br># 角色权限的收回<br># 用户可以回收角色的权限，从而修改角色拥有的权限<br># <span class="hljs-keyword">REVOKE</span>执行者是角色的创建者或拥有在这个(些)角色上的ADMIN OPTION<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]... <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>[,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br># [例<span class="hljs-number">4.11</span>] 通过角色来实现将一组权限授予一个用户。<br><span class="hljs-keyword">CREATE</span> ROLE R1;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">UPDATE</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">TO</span> R1;<br><span class="hljs-keyword">GRANT</span> R1 <span class="hljs-keyword">TO</span> 王平,张明,赵玲;<br><span class="hljs-keyword">REVOKE</span> R1 <span class="hljs-keyword">FROM</span> 王平;<br># 角色的权限修改<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">TO</span> R1;<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> Student <span class="hljs-keyword">FROM</span> R1;<br></code></pre></td></tr></table></figure>
<h2 id="2-强制存取控制"><a href="#2-强制存取控制" class="headerlink" title="2. 强制存取控制"></a>2. 强制存取控制</h2><ul>
<li><p>强制存取控制，简称<strong>MAC</strong></p>
<ul>
<li>每一个数据对象被标以一定的密级</li>
<li>每一个用户也被授予某一个级别的许可证</li>
<li>对于任意一个对象，只有具有合法许可证的用户才可以存取</li>
</ul>
</li>
<li><p>B1级</p>
</li>
<li><p>主体的敏感度标记称为许可证级别(Clearance Level)，客体的敏感度标记称为密级(Classification Level)。</p>
</li>
<li><p>敏感度标记分成若干级别</p>
<ul>
<li>绝密(Top Secret，TS)</li>
<li>机密(Secret，S)</li>
<li>可信(Confidential，C)</li>
<li>公开(Public，P)</li>
<li>TS&gt;=S&gt;=C&gt;=P</li>
</ul>
</li>
<li><p><strong>强制存取控制规则：</strong></p>
<ul>
<li>仅当主体的许可证级别<strong>大于或等于</strong>客体的密级时， 该主体才能<strong>读取</strong>相应的客体</li>
<li>仅当主体的许可证级别<strong>小于或等于</strong>客体的密级时，该主体才能<strong>写</strong>相应的客体</li>
</ul>
</li>
</ul>
<blockquote>
<p>规则 1 的必要性是明显的。</p>
<p>规则 2 是为了防止把数据的密级从高流向低。如许可证级别为 TS 的主体读取密级为 TS 的客体并以密级 P 写回，造成数据泄露。在规则 2 下，用户可以把写入的对象赋予高于自己许可证级别的密级，一旦数据被写入，该用户自己也不能读取该数据了。</p>
<p>规则 2 应该理解为：主体写入的客体内容<strong>可以被赋予高于主体许可证级别的密级</strong>，而不是：主体可以修改密级高于该主体许可证级别的客体。</p>
</blockquote>
<ul>
<li>实现强制存取控制时要首先实现自主存取控制<ul>
<li>原因：较高安全性级别提供的安全保护要包含较低级别的所有保护</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211205087.png" alt="image-20220914211205087"></p>
<h2 id="3-视图、审计、数据加密及其他"><a href="#3-视图、审计、数据加密及其他" class="headerlink" title="3. 视图、审计、数据加密及其他"></a>3. 视图、审计、数据加密及其他</h2><h3 id="3-1-视图机制"><a href="#3-1-视图机制" class="headerlink" title="3.1 视图机制"></a>3.1 视图机制</h3><p>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707145256935.png" alt="image-20230707145256935"></p>
<h3 id="3-2-审计"><a href="#3-2-审计" class="headerlink" title="3.2 审计"></a>3.2 审计</h3><ul>
<li>启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面</li>
<li>审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容</li>
<li>C2以上安全级别的DBMS必须具有审计功能</li>
<li>审计很费时间和空间</li>
<li>DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能</li>
<li>审计功能主要用于安全性要求较高的部门</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 对修改SC表结构或修改SC表数据的操作进行审计<br>AUDIT <span class="hljs-keyword">ALTER</span>, <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> SC;<br><br># 取消对SC表的一切审计<br>NOAUDIT <span class="hljs-keyword">ALTER</span>,<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> SC;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-数据加密"><a href="#3-3-数据加密" class="headerlink" title="3.3 数据加密"></a>3.3 数据加密</h3><ul>
<li><p>防止数据库中数据在存储和传输中失密的有效手段</p>
</li>
<li><p>加密方法</p>
<ul>
<li>存储加密</li>
<li>传输加密</li>
</ul>
</li>
<li><p>透明存储加密</p>
<ul>
<li><p>内核级加密保护方式，对用户完全透明</p>
</li>
<li><p>将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密</p>
</li>
<li><p>数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可</p>
</li>
<li><p>内核级加密方法: 性能较好，安全完备性较高</p>
</li>
</ul>
</li>
<li><p>非透明存储加密</p>
<ul>
<li>通过多个加密函数实现</li>
</ul>
</li>
<li><p>链路加密</p>
<ul>
<li><p>在链路层进行加密</p>
</li>
<li><p>传输信息由报头和报文两部分组成</p>
</li>
<li><p>报文和报头均加密</p>
</li>
</ul>
</li>
<li><p>端到端加密</p>
<ul>
<li><p>在发送端加密，接收端解密</p>
</li>
<li><p>只加密报文不加密报头</p>
</li>
<li><p>所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-其他安全性保护"><a href="#3-4-其他安全性保护" class="headerlink" title="3.4 其他安全性保护"></a>3.4 其他安全性保护</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707145610596.png" alt="image-20230707145610596"></p>
<h1 id="05-数据库完整性"><a href="#05-数据库完整性" class="headerlink" title="05-数据库完整性"></a>05-数据库完整性</h1><ul>
<li>数据的完整性：防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li>
</ul>
<h2 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1. 实体完整性"></a>1. 实体完整性</h2><ul>
<li><p><code>CREATE TABLE</code>中用<code>PRIMARY KEY</code>定义</p>
</li>
<li><p>单属性构成的码有两种说明方法 </p>
<ul>
<li><p>定义为列级约束条件</p>
</li>
<li><p>定义为表级约束条件</p>
</li>
</ul>
</li>
<li><p>对多个属性构成的码只有一种说明方法</p>
<ul>
<li>定义为表级约束条件</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 在列级定义主码<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student<br>    (  Sno  <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>)  <span class="hljs-keyword">PRIMARY</span> KEY,<br>      Sname  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,     <br>      Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>),<br>      Sage  <span class="hljs-type">SMALLINT</span>,<br>      Sdept  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br>    );<br><br># 在表级定义主码<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student<br>    (  Sno  <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>),  <br>       Sname  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>       Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>),<br>       Sage  <span class="hljs-type">SMALLINT</span>,<br>       Sdept  <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>),<br>       <span class="hljs-keyword">PRIMARY</span> KEY (Sno)<br>     ); <br></code></pre></td></tr></table></figure>
<p>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：</p>
<ul>
<li><p>检查主码值是否唯一，如果不唯一则拒绝插入或修改</p>
<ul>
<li>检查记录中主码值是否唯一的一种方法是进行全表扫描<ul>
<li>十分耗时</li>
</ul>
</li>
<li>为避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，如B+树索引</li>
</ul>
</li>
<li><p>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</p>
</li>
</ul>
<h2 id="2-参照完整性"><a href="#2-参照完整性" class="headerlink" title="2. 参照完整性"></a>2. 参照完整性</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620141341336.png" alt="image-20220620141341336"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 定义SC中的参照完整性<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SC (<br>    Sno  <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>	Cno  <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <br>	Grade  <span class="hljs-type">SMALLINT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno, Cno),   <span class="hljs-comment">/*在表级定义实体完整性*/</span><br>    <span class="hljs-keyword">FOREIGN</span> KEY (Sno) <span class="hljs-keyword">REFERENCES</span> Student(Sno), <span class="hljs-comment">/*在表级定义参照完整性*/</span><br>    <span class="hljs-keyword">FOREIGN</span> KEY (Cno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)  <span class="hljs-comment">/*在表级定义参照完整性*/</span><br>);<br><br># 显式说明参照完整性的违约处理示例<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> (<br>    Sno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>，<br>    Cno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>，<br>    Grade  <span class="hljs-type">SMALLINT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno,Cno)， 			<br>    <span class="hljs-keyword">FOREIGN</span> KEY (Sno) <span class="hljs-keyword">REFERENCES</span> Student(Sno) <br>    	<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE       <span class="hljs-comment">/*级联删除SC表中相应的元组*/</span><br>    	<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE,      <span class="hljs-comment">/*级联更新SC表中相应的元组*/</span><br>    <span class="hljs-keyword">FOREIGN</span> KEY (Cno) <span class="hljs-keyword">REFERENCES</span> Course(Cno)	                    <br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">NO</span> ACTION     <br>    	<span class="hljs-comment">/*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/</span><br>        <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE   <br>    	<span class="hljs-comment">/*当更新course表中的cno时，级联更新SC表中相应的元组*/</span><br>);<br></code></pre></td></tr></table></figure>
<h2 id="3-用户定义完整性"><a href="#3-用户定义完整性" class="headerlink" title="3. 用户定义完整性"></a>3. 用户定义完整性</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs sql"># [例 <span class="hljs-number">5.7</span>] Student 表的 Ssex 只允许取“男”或“女”。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student (<br>    Sno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>)), <span class="hljs-comment">/*性别属性 Ssex 只允许取&#x27;男&#x27;或&#x27;女&#x27; */</span><br>    Sage  <span class="hljs-type">SMALLINT</span>,<br>    Sdept <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br>);<br><br># [例 <span class="hljs-number">5.8</span>] SC 表的 Grade 的值应该在 <span class="hljs-number">0</span> 和 <span class="hljs-number">100</span> 之间。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SC (<br>    Sno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>),<br>    Cno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>),<br>    Grade <span class="hljs-type">SMALLINT</span> <span class="hljs-keyword">CHECK</span> (Grade <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> Grade <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100</span>), <span class="hljs-comment">/*Grade 取值范围是 0 到 100*/</span><br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno, Cno),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (Sno) <span class="hljs-keyword">REFERENCES</span> Student (Sno),<br>    <span class="hljs-keyword">FOREIGN</span> KEY (Cno) <span class="hljs-keyword">REFERENCES</span> Course (Cno)<br>);<br><br># [例 <span class="hljs-number">5.9</span>]当学生的性别是男时，其名字不能以 Ms.打头。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student (<br>    Sno   <span class="hljs-type">CHAR</span>(<span class="hljs-number">9</span>),<br>    Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>)),<br>    Sage  <span class="hljs-type">SMALLINT</span>,<br>    Sdept <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno),<br>    <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">OR</span> Sname <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Ms.%&#x27;</span>) <span class="hljs-comment">/*定义了元组中 Sname 和 Ssex 两个属性值之间的约束条件*/</span><br>);<br><br># [例 <span class="hljs-number">5.10</span>]建立学生登记表 Student，要求学号在 <span class="hljs-number">90000</span><span class="hljs-operator">~</span><span class="hljs-number">99999</span> 之间，姓名不能取空值，年龄小于 <span class="hljs-number">30</span>，性别只能是“男”或“女”。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student (<br>    Sno   <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">99999</span>),<br>    Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">CONSTRAINT</span> C2 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    Sage  <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>),<br>    Ssex  <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CONSTRAINT</span> C4 <span class="hljs-keyword">CHECK</span> (Ssex <span class="hljs-keyword">IN</span> ( ‘男’,<span class="hljs-string">&#x27;女&#x27;</span>)),<br>    <span class="hljs-keyword">CONSTRAINT</span> StudentKey <span class="hljs-keyword">PRIMARY</span> KEY (Sno)<br>);<br><br># [例 <span class="hljs-number">5.11</span>]建立教师表 TEACHER，要求每个教师的应发工资不低于 <span class="hljs-number">3000</span> 元。应发工资是工资列 Sal 与扣除项 Deduct 之和。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> TEACHER (<br>    Eno    <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">PRIMARY</span> KEY, <span class="hljs-comment">/*在列级定义主码*/</span><br>    Ename  <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    Job    <span class="hljs-type">CHAR</span>(<span class="hljs-number">8</span>),<br>    Sal    <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>),<br>    Deduct <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>),<br>    Deptno <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">2</span>),<br>    <span class="hljs-keyword">CONSTRAINT</span> TEACHERFKey <span class="hljs-keyword">FOREIGN</span> KEY (Deptno)<br>        <span class="hljs-keyword">REFERENCES</span> DEPT (Deptno),<br>    <span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sal <span class="hljs-operator">+</span> Deduct <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3000</span>)<br>);<br><br># [例 <span class="hljs-number">5.12</span>]去掉例 <span class="hljs-number">5.10</span> Student 表中对性别的限制。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C4;<br><br># [例 <span class="hljs-number">5.13</span>] 修改表 Student 中的约束条件，要求学号改为在 <span class="hljs-number">900000</span><span class="hljs-operator">~</span><span class="hljs-number">999999</span> 之间，年龄由小于 <span class="hljs-number">30</span> 改为小于 <span class="hljs-number">40</span> 可以先删除原来的约束条件，再增加新的约束条件<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C1;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">900000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">999999</span>);<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C3;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br>    <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure>
<h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><ul>
<li>SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。</li>
<li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</li>
<li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行</li>
<li>如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">CHECK</span>子句<span class="hljs-operator">&gt;</span>;<br><span class="hljs-keyword">DROP</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span>;<br><br># 限制数据库课程最多<span class="hljs-number">60</span>名学生选修<br><span class="hljs-keyword">CREATE</span> ASSERTION ASSE_SC_DB_NUM<br><span class="hljs-keyword">CHECK</span> (<span class="hljs-number">60</span> <span class="hljs-operator">&gt;=</span> (<br>    <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-comment">/*此断言的谓词涉及聚集操作count的SQL语句*/</span><br>    <span class="hljs-keyword">From</span> Course, SC<br>    <span class="hljs-keyword">Where</span> SC.Cno<span class="hljs-operator">=</span>Course.Cno <span class="hljs-keyword">and</span> Course.Cname <span class="hljs-operator">=</span><span class="hljs-string">&#x27;数据库&#x27;</span>)<br>);<br><br># 限制每个学期每一门课程最多<span class="hljs-number">60</span>名学生选修<br><span class="hljs-keyword">CREATE</span> ASSERTION ASSE_SC_CNUM<br><span class="hljs-keyword">CHECK</span> (<span class="hljs-number">60</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-keyword">ALL</span> (<br>    <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br>    <span class="hljs-comment">/*此断言的谓词涉及聚集操作 count 和分组函数group by的SQL语句*/</span><br>    <span class="hljs-keyword">From</span> SC<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cno, TERM)<br>);<br></code></pre></td></tr></table></figure>
<h2 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5. 触发器"></a>5. 触发器</h2><ul>
<li><p>触发器保存在数据库服务器中(远端)</p>
</li>
<li><p>任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</p>
</li>
<li><p>触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力</p>
</li>
<li><p>触发器类型</p>
<ul>
<li>行级触发器(FOR EACH ROW)</li>
<li>语句级触发器(FOR EACH STATEMENT)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 例如,在TEACHER表上创建一个AFTER <span class="hljs-keyword">UPDATE</span>触发器，触发事件是<span class="hljs-keyword">UPDATE</span>语句<br><span class="hljs-keyword">UPDATE</span> TEACHER <span class="hljs-keyword">SET</span> Deptno<span class="hljs-operator">=</span><span class="hljs-number">5</span>;<br># 假设表TEACHER有<span class="hljs-number">1000</span>行  <br># 如果是语句级触发器，那么执行完该语句后，触发动作只发生一次<br># 如果是行级触发器，触发动作将执行<span class="hljs-number">1000</span>次<br></code></pre></td></tr></table></figure>
</li>
<li><p>执行顺序</p>
<ul>
<li>执行该表上的BEFORE触发器;</li>
<li>激活触发器的SQL语句;</li>
<li>执行该表上的AFTER触发器。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 语法格式<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span>  <br>&#123;BEFORE <span class="hljs-operator">|</span> AFTER&#125; <span class="hljs-operator">&lt;</span>触发事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span><span class="hljs-operator">|</span><span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>变量<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> &#123;<span class="hljs-type">ROW</span> <span class="hljs-operator">|</span> STATEMENT&#125;<br>[<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>] <span class="hljs-operator">&lt;</span>触发动作体<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br><br># 当对表SC的Grade属性进行修改时，若分数增加了<span class="hljs-number">10</span><span class="hljs-operator">%</span>则将此次操作记录到下面表中：SC_U（Sno,Cno,Oldgrade,Newgrade）其中Oldgrade是修改前的分数，Newgrade是修改后的分数<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span>  SC_T		<br>AFTER <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OF</span> Grade <span class="hljs-keyword">ON</span> SC<br><span class="hljs-keyword">REFERENCING</span><br>	<span class="hljs-keyword">OLD</span> <span class="hljs-type">row</span> <span class="hljs-keyword">AS</span> OldTuple,<br>	<span class="hljs-keyword">NEW</span> <span class="hljs-type">row</span> <span class="hljs-keyword">AS</span> NewTuple<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> 	<br><span class="hljs-keyword">WHEN</span> (NewTuple.Grade <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1.1</span> <span class="hljs-operator">*</span> OldTuple.Grade)<br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SC_U(Sno,Cno,OldGrade,NewGrade)  <br>    <span class="hljs-keyword">VALUES</span>(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)<br><br># 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> Student_Count<br>AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> Student<br><span class="hljs-keyword">REFERENCING</span><br>	<span class="hljs-keyword">NEW</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">AS</span> DELTA<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> STATEMENT<br>	<span class="hljs-comment">/*语句级触发器, 即执行完INSERT语句后下面的触发动作体才执行一次*/</span><br>	<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentInsertLog (Numbers)<br>   	<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> DELTA<br>   	<br># 定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于<span class="hljs-number">4000</span>元，如果低于<span class="hljs-number">4000</span>元，自动改为<span class="hljs-number">4000</span>元&quot;<br>CREATE TRIGGER Insert_Or_Update_Sal<br>BEFORE INSERT OR UPDATE ON Teacher /*触发事件是插入或更新操作*/<br>REFERENCING NEW row AS newTuple<br>FOR EACH ROW  /*行级触发器*/<br>BEGIN    /*定义触发动作体，是PL/SQL过程块*/<br>	IF (newTuple.Job=&#x27;教授&#x27;) AND (newTuple.Sal &lt; 4000)<br>     	THEN newTuple.Sal :=4000;<br> 	END IF;<br>END;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707163220219.png" alt="image-20230707163220219"></p>
<h1 id="06-关系数据理论-重点"><a href="#06-关系数据理论-重点" class="headerlink" title="06-关系数据理论(重点)"></a>06-关系数据理论(重点)</h1><h2 id="1-关系模式及范式"><a href="#1-关系模式及范式" class="headerlink" title="1. 关系模式及范式"></a>1. 关系模式及范式</h2><ul>
<li>关系模式由五部分组成，是一个五元组：$R(U, D, DOM, F)$<ul>
<li>关系名 $R$ 是符号化的元组语义</li>
<li>$U$ 为一组属性</li>
<li>$D$ 为属性组 $U$ 中的属性所来自的域</li>
<li>$DOM$ 为属性到域的映射</li>
<li>$F$ 为属性组 $U$ 上的一组数据依赖</li>
</ul>
</li>
<li>由于 $D$、$DOM$ 与模式设计关系不大，因此可以把关系模式看作一个三元组：$R\lt U,F\gt$</li>
<li>作为二维表，关系要符合一个最基本的条件：每个分量必须是<strong>不可分开</strong>的数据项。满足了这个条件的关系模式就属于第一范式(1NF)。</li>
<li>一个低一级范式的关系模式，通过模式分解(schema decomposition)可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化(normalization)。</li>
</ul>
<h2 id="2-函数依赖"><a href="#2-函数依赖" class="headerlink" title="2. 函数依赖"></a>2. 函数依赖</h2><ul>
<li><p>设 $R(U)$ 是一个属性集 $U$ 上的关系模式，$X$ 和 $Y$ 是 $U$ 的子集。若对于 $R(U)$ 的任意一个可能的关系 $r$，$r$ 中不可能存在两个元组在 $X$ 上的属性值相等，而在 $Y$ 上的属性值不等，则称” $X$ 函数确定 $Y$ “或” $Y$ <strong>函数依赖</strong>于 $X$ “，记作 $X \rightarrow Y$，$X$ 称为这个函数依赖的决定因素。</p>
</li>
<li><p>函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。</p>
</li>
<li><p>在关系模式 $R(U) $ 中，对于 $U$ 的子集 $X$ 和 $Y$：</p>
<ul>
<li>若 $X \rightarrow Y$，但 $Y \nsubseteq X$，则称 $X \rightarrow Y$ 是<strong>非平凡的函数依赖</strong>。</li>
<li>若 $X \rightarrow Y$，但 $Y \subseteq X$，则称 $X \rightarrow Y$ 是<strong>平凡的函数依赖</strong>。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620150346359.png" style="zoom: 67%;" /></p>
</li>
<li><p>在 $R(U)$ 中，如果 $X \rightarrow Y$，并且对于 $X$ 的任何一个真子集 $X’$, 都有 $X’ \nrightarrow Y$，则称 $Y$ 对 $X$ <strong>完全函数依赖</strong>，记作 $X\stackrel{F}{\rightarrow}Y$。</p>
</li>
<li><p>若 $X \rightarrow Y$，但 $Y$ 不完全函数依赖于 $X$，则称 $Y$ 对 $X$ <strong>部分函数依赖</strong>，记作$X\stackrel{P}{\rightarrow}Y$。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620150857674.png" style="zoom: 67%;" /></p>
<ul>
<li><p>在 $R(U)$ 中，如果 $X \rightarrow Y(Y \nsubseteq X)$，$Y \nrightarrow X$，$Y \rightarrow Z(Z\nsubseteq Y)$，则称 $Z$ 对 $X$ <strong>传递函数依赖</strong> 。记为$X\stackrel{传递}{\longrightarrow}Z$</p>
<ul>
<li>如果 $Y \rightarrow X$, 即 $X\leftarrow\rightarrow Y$, 则 $Z$ 直接依赖于 $X$, 而不是传递函数依赖</li>
</ul>
</li>
<li><p>设 $K$ 为 $R \lt U,F \gt$ 中的属性或属性组合。若 $K\stackrel{F}{\rightarrow}U$，则 $K$ 称为 $R$ 的一个候选码。</p>
<ul>
<li><strong>如果 $U$ 函数依赖于 $K$，即 $K\rightarrow U$，则 $K$ 称为超码。</strong>候选码是一类特殊的超码，即候选码的超集一定是超码，候选码的任意一个真子集都不是超码。</li>
</ul>
</li>
<li><p>关系模式 $R$ 中属性或属性组 $X$ 并非 $R$ 的码，但 $X$ 是另一个关系模式的码，则称 $X$ 是 $R$ 的<strong>外部码</strong>(Foreign key)也称<strong>外码</strong>。</p>
</li>
</ul>
<h2 id="3-1NF"><a href="#3-1NF" class="headerlink" title="3. 1NF"></a>3. 1NF</h2><ul>
<li><p>如果一个关系模式 $R$ 的所有属性都是<strong>不可分</strong>的基本数据项，则 $R\in1NF$</p>
</li>
<li><p>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707174656934.png" alt="image-20230707174656934"></p>
<ul>
<li><p>问题</p>
<ul>
<li><p><strong>数据冗余</strong>: 浪费大量的存储空间, 每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同</p>
</li>
<li><p><strong>更新异常</strong>: 数据冗余，更新数据时，维护数据完整性代价大, 某系更换系主任后，必须修改与该系学生有关的每一个元组</p>
</li>
<li><p><strong>插入异常</strong>: 如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库</p>
</li>
<li><p><strong>删除异常</strong>: 如果某个系的学生全部毕业了，则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-2NF"><a href="#4-2NF" class="headerlink" title="4. 2NF"></a>4. 2NF</h2><ul>
<li>若关系模式 $R∈1NF$，并且每一个非主属性都<strong>完全函数依赖</strong>于任何一个候选码，则 $R∈2NF$。</li>
<li>性质：<strong>不存在(某非主属性)部分依赖</strong>(于某一候选码)。</li>
<li>如果不是2NF，会产生的问题：<ul>
<li>插入异常<ul>
<li>如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。</li>
</ul>
</li>
<li>删除异常<ul>
<li>如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。</li>
</ul>
</li>
<li>修改复杂<ul>
<li>如果一个学生选了多门课，则Sdept，Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化。</li>
</ul>
</li>
</ul>
</li>
<li>出现这种问题的原因：例子中有两类非主属性<ul>
<li>一类如Grade，它对码完全函数依赖</li>
<li>另一类如Sdept、Sloc，它们对码不是完全函数依赖</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>1NF</th>
<th>2NF</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707183704294.png" alt="image-20230707183704294"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707183717257.png" alt="image-20230707183717257"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-3NF"><a href="#5-3NF" class="headerlink" title="5. 3NF"></a>5. 3NF</h2><ul>
<li>设关系模式 $R \lt U,F \gt \in 1NF$，若 $R$ 中不存在这样的码 $X$、属性组 $Y$ 及非主属性 $Z(Z \nsupseteq Y)$，使得 $X→Y,Y→Z$ 成立，$Y↛X$ 不成立，则称 $R \lt U,F \gt \in 3NF$。</li>
<li>性质：<strong>不存在非主属性传递依赖、部分依赖于码</strong></li>
<li><p>在 2NF 的解决方案中，SL 存在传递依赖</p>
<ul>
<li>解决方案为把 S-L 分解为 S-D 和 D-L。分解后的关系不再存在传递依赖，消除了问题 3。</li>
</ul>
</li>
<li><p>问题：可能存在主属性对码的部分依赖和传递依赖</p>
</li>
</ul>
<h2 id="6-BCNF"><a href="#6-BCNF" class="headerlink" title="6. BCNF"></a>6. BCNF</h2><ul>
<li>设关系模式 $R\lt U,F\gt \in1NF$，若 $X \rightarrow Y$ 且 $Y\nsubseteq X$ 时 $X$ 必含有码，则 $R\lt U,F\gt \in BCNF$。</li>
<li>换言之，在关系模式 $R\lt U,F\gt$ 中，如果每一个决定属性集都包含候选码，则 $R\in BCNF$</li>
<li><p>性质</p>
<ul>
<li>所有<strong>非主属性</strong>都完全函数依赖于每个码</li>
<li>所有<strong>主属性</strong>都完全函数依赖于每个不包含它的码</li>
<li><strong>每一个决定属性集都包含候选码</strong>(亦即没有任何属性完全函数依赖于非码的任何一组属性)</li>
</ul>
</li>
<li><p>一个模式中的关系模式如果都属于 BCNF，那么在函数依赖范畴内，它已实现了彻底的分离，已<strong>消除了插入和删除的异常</strong>。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707220316470.png" alt="image-20230707220316470"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707220326240.png" alt="image-20230707220326240"></p>
<h2 id="7-多值依赖"><a href="#7-多值依赖" class="headerlink" title="7. 多值依赖"></a>7. 多值依赖</h2><div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707220916334.png" alt="image-20230707220916334"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707220952865.png" alt="image-20230707220952865"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>设 $R(U)$ 是属性集 $U$ 上的一个关系模式。$X,Y,Z$ 是 $U$ 的子集，并且 $Z=U-X-Y$。关系模式 $R(U)$ 中多值依赖 $X\rightarrow\rightarrow Y$ 成立，当且仅当对 $R(U)$ 的任一关系 $r$，给定的一对 $(x,z)$ 值，有一组 $Y$ 的值，这组值仅仅决定于 $x$ 值而与 $z$ 值无关<ul>
<li>对于 $C$ 的每一个值，$T$ 有一组值与之对应，而不论 $B$ 取何值。因此 $T$ 多值依赖于 $C$，即$C\rightarrow\rightarrow T$。</li>
</ul>
</li>
<li>多值依赖的另一个等价的定义：</li>
<li>在 $R(U)$ 的任一关系 $r$ 中，如果存在元组 $t, s$ 使得 $t[X]=s[X]$，那么就必然存在元组 $w, v\in r$ ( $w, v$ 可以与 $s, t$ 相同), 使得 $w[X]=v[X]=t[X]$, 而 $w[Y]=t[Y], w[Z]=s[Z], v[Y]=s[Y], v[Z]=t[Z]$<ul>
<li>即交换 $s, t$ 元组的 $Y$ 值所得到的两个新元组必在 $r$ 中，则 $Y$ 多值依赖于 $X$, 记为 $X\rightarrow\rightarrow Y$, 这里 $X, Y$ 是 $U$ 的子集，$Z=U-X-Y$</li>
</ul>
</li>
<li>平凡多值依赖和非平凡的多值依赖<ul>
<li>若 $X\rightarrow\rightarrow Y$，而 $Z=\phi$, 则 $Z$ 为空，则称 $X\rightarrow\rightarrow Y$ 为<strong>平凡的多值依赖</strong></li>
<li>否则称 $X\rightarrow\rightarrow Y$ 为<strong>非平凡的多值依赖</strong></li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707225346465.png" alt="image-20230707225346465"></th>
<th><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707225431454.png" alt="image-20230707225431454"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>多值依赖具有对称性，如上图<ul>
<li>若 $X\rightarrow\rightarrow Y$，则 $X\rightarrow\rightarrow Z$, 其中 $Z=U-X-Y$</li>
</ul>
</li>
<li>多值依赖具有传递性<ul>
<li>若 $X\rightarrow\rightarrow Y, Y\rightarrow\rightarrow Z$，则 $X\rightarrow\rightarrow Z-Y$</li>
</ul>
</li>
</ul>
<p><strong>多值依赖与函数依赖的区别</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707225923985.png" alt="image-20230707225923985"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707225931151.png" alt="image-20230707225931151"></p>
<h2 id="8-4NF"><a href="#8-4NF" class="headerlink" title="8. 4NF"></a>8. 4NF</h2><ul>
<li>关系模式 $R\lt U, F\gt \in 1NF$, 如果对于 $R$ 的每个非平凡多值依赖 $X\rightarrow\rightarrow Y$ ($Y \nsubseteq X$), $X$ 都含有码，则 $R\lt U, F\gt \in 4NF$</li>
<li>4NF 就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF 所允许的非平凡多值依赖实际上是函数依赖。<ul>
<li>如果一个关系模式是 4NF，则必为 BCNF</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230707230441209.png" alt="image-20230707230441209"></p>
<h1 id="07-数据库设计"><a href="#07-数据库设计" class="headerlink" title="07-数据库设计"></a>07-数据库设计</h1><h2 id="1-数据库设计概述"><a href="#1-数据库设计概述" class="headerlink" title="1. 数据库设计概述"></a>1. 数据库设计概述</h2><ul>
<li>数据库设计六个阶段<ul>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
<li>数据库实施</li>
<li>数据库运行与维护</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620161145477.png" alt="image-20220620161145477"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620161200602.png" alt="image-20220620161200602"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620161259854.png" alt="image-20220620161259854"></p>
<h2 id="2-E-R-模型"><a href="#2-E-R-模型" class="headerlink" title="2. E-R 模型"></a>2. E-R 模型</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211417680.png" alt="image-20220914211417680"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620163405397.png" alt="image-20220620163405397"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620163427313.png" alt="image-20220620163427313"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620163557292.png" alt="image-20220620163557292"></p>
<h2 id="3-逻辑结构设计"><a href="#3-逻辑结构设计" class="headerlink" title="3. 逻辑结构设计"></a>3. 逻辑结构设计</h2><h3 id="3-1-转换原则"><a href="#3-1-转换原则" class="headerlink" title="3.1 转换原则"></a>3.1 转换原则</h3><ul>
<li>一个实体型转换为一个关系模式</li>
<li>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</li>
<li>一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li>
<li>一个m:n联系转换为一个关系模式</li>
<li>三个或三个以上实体间的一个多元联系转换为一个关系模式</li>
<li>具有相同码的关系模式可合并</li>
</ul>
<h3 id="3-2-水平分解"><a href="#3-2-水平分解" class="headerlink" title="3.2 水平分解"></a>3.2 水平分解</h3><ul>
<li><p>把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。</p>
</li>
<li><p>根据二八原则把经常使用的 20% 数据分解出来。</p>
</li>
</ul>
<h3 id="3-3-垂直分解"><a href="#3-3-垂直分解" class="headerlink" title="3.3 垂直分解"></a>3.3 垂直分解</h3><ul>
<li><p>把关系模式的属性分为若干子集合，形成若干个子关系模式。</p>
</li>
<li><p>原则：经常在一起使用的属性从关系中分解出来。</p>
</li>
<li>优点：提高了某些事务的效率</li>
<li>缺点：可能使另一些事务不得不执行连接操作，降低了效率</li>
</ul>
<h2 id="4-物理结构设计"><a href="#4-物理结构设计" class="headerlink" title="4. 物理结构设计"></a>4. 物理结构设计</h2><h3 id="4-1-关系模式存取方法"><a href="#4-1-关系模式存取方法" class="headerlink" title="4.1 关系模式存取方法"></a>4.1 关系模式存取方法</h3><ul>
<li>B+树索引存取方法</li>
<li>Hash索引存取方法</li>
<li>聚簇存取方法</li>
</ul>
<h3 id="4-2-聚簇"><a href="#4-2-聚簇" class="headerlink" title="4.2 聚簇"></a>4.2 聚簇</h3><ul>
<li>为了提高某个属性(或属性组)的查询速度，把这个或这些属性(称为聚簇码)上具有相同值的元组集中存放在连续的物理块中称为聚簇。</li>
<li>该属性（或属性组）称为聚簇码（cluster key）</li>
<li>选择聚簇存储方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系（一个数据库可以建立多个聚簇，一个关系只能加入一个聚簇）</li>
</ul>
<h1 id="08-数据库编程"><a href="#08-数据库编程" class="headerlink" title="08-数据库编程"></a>08-数据库编程</h1><h2 id="1-jdbc"><a href="#1-jdbc" class="headerlink" title="1. jdbc"></a>1. jdbc</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加载数据库驱动；</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">// 建立连接</span><br>conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 创建 Statement 对象，用于向数据库发送 SQL 语句；</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM `user`&quot;</span>;<br><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);<br><span class="hljs-comment">// 获取 ResultSet 对象，取出数据，此对象代表结果集；</span><br><span class="hljs-keyword">while</span> (resultSet.next()) &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(“id”); <br>    ......<br>&#125;<br><span class="hljs-comment">// 释放资源，断开与数据库的连接。</span><br>resultSet.close();	<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure>
<h2 id="2-过程化SQL"><a href="#2-过程化SQL" class="headerlink" title="2. 过程化SQL"></a>2. 过程化SQL</h2><p>定义部分</p>
<ul>
<li><p>DECLARE 变量、常量、游标、异常等</p>
<ul>
<li><p>定义的变量、常量等只能在该基本块中使用</p>
</li>
<li><p>当基本块执行结束时，定义就不再存在</p>
</li>
</ul>
</li>
</ul>
<p>执行部分</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SQL</span>语句、过程化<span class="hljs-keyword">SQL</span>的流程控制语句<br>EXCEPTION<br>    异常处理部分        		<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708101233701.png" alt="image-20230708101233701"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708101250429.png" alt="image-20230708101250429"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708101256956.png" alt="image-20230708101256956"></p>
<h2 id="3-存储过程和函数"><a href="#3-存储过程和函数" class="headerlink" title="3. 存储过程和函数"></a>3. 存储过程和函数</h2><h3 id="3-1-存储过程"><a href="#3-1-存储过程" class="headerlink" title="3.1 存储过程"></a>3.1 存储过程</h3><p>过程化SQL块类型</p>
<ul>
<li>命名块：编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块 </li>
<li>匿名块：每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建存储过程<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 过程名([参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>,...]) <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>过程化<span class="hljs-keyword">SQL</span>块<span class="hljs-operator">&gt;</span>；<br><br># 利用存储过程来实现下面的应用：从账户<span class="hljs-number">1</span>转指定数额的款项到账户<span class="hljs-number">2</span>中。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> TRANSFER(inAccount <span class="hljs-type">INT</span>, outAccount <span class="hljs-type">INT</span>, amount <span class="hljs-type">FLOAT</span>) <span class="hljs-comment">/*定义存储过程TRANSFER，其参数为转入账户、转出账户、转账额度*/</span><br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">DECLARE</span>		<span class="hljs-comment">/*定义变量*/</span><br>totalDepositOut <span class="hljs-type">Float</span>;<br>totalDepositIn <span class="hljs-type">Float</span>;<br>inAccountnum <span class="hljs-type">INT</span>;<br><span class="hljs-keyword">BEGIN</span>    <span class="hljs-comment">/*检查转出账户的余额 */</span>	                       <br>    <span class="hljs-keyword">SELECT</span> Total <span class="hljs-keyword">INTO</span> totalDepositOut <span class="hljs-keyword">FROM</span> Accout <br>    <span class="hljs-keyword">WHERE</span> accountnum <span class="hljs-operator">=</span> outAccount; <br><br>    IF totalDepositOut <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span><br>        <span class="hljs-comment">/*如果转出账户不存在或账户中没有存款*/</span><br>        <span class="hljs-keyword">ROLLBACK</span>; 	   <span class="hljs-comment">/*回滚事务*/</span><br>        <span class="hljs-keyword">RETURN</span>;<br>    <span class="hljs-keyword">END</span> IF; <br><br>    IF totalDepositOut <span class="hljs-operator">&lt;</span> amount <span class="hljs-keyword">THEN</span>    	<span class="hljs-comment">/*如果账户存款不足*/</span><br>        <span class="hljs-keyword">ROLLBACK</span>; 				<span class="hljs-comment">/*回滚事务*/</span><br>        <span class="hljs-keyword">RETURN</span>;<br>    <span class="hljs-keyword">END</span> IF;<br><br>    <span class="hljs-keyword">SELECT</span> Accountnum <span class="hljs-keyword">INTO</span> inAccountnum <span class="hljs-keyword">FROM</span> Account<br>    <span class="hljs-keyword">WHERE</span> accountnum<span class="hljs-operator">=</span>inAccount;<br><br>    IF inAccount <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span>  		<span class="hljs-comment">/*如果转入账户不存在*/</span>   <br>        <span class="hljs-keyword">ROLLBACK</span>; 	         	 		<span class="hljs-comment">/*回滚事务*/</span><br>        <span class="hljs-keyword">RETURN</span>;<br>    ENDIF;<br><br>    <span class="hljs-keyword">UPDATE</span> Account <span class="hljs-keyword">SET</span> total<span class="hljs-operator">=</span>total <span class="hljs-operator">-</span> amount<br>    <span class="hljs-keyword">WHERE</span> accountnum<span class="hljs-operator">=</span>outAccount; <span class="hljs-comment">/* 修改转出账户余额，减去转出额 */</span><br>    <span class="hljs-keyword">UPDATE</span> Account <span class="hljs-keyword">SET</span> total<span class="hljs-operator">=</span>total <span class="hljs-operator">+</span> amount <br>    <span class="hljs-keyword">WHERE</span> accountnum<span class="hljs-operator">=</span>inAccount;  <span class="hljs-comment">/* 修改转入账户余额，增加转入额 */</span><br><br>    <span class="hljs-keyword">COMMIT</span>;                      <span class="hljs-comment">/* 提交转账事务 */</span><br><span class="hljs-keyword">END</span>;<br><br># 执行存储过程<br><span class="hljs-keyword">CALL</span><span class="hljs-operator">/</span>PERFORM <span class="hljs-keyword">PROCEDURE</span> 过程名([参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>,...]);<br># 从账户<span class="hljs-number">01003815868</span>转<span class="hljs-number">10000</span>元到<span class="hljs-number">01003813828</span>账户中<br><span class="hljs-keyword">CALL</span> <span class="hljs-keyword">PROCEDURE</span> TRANSFER(<span class="hljs-number">01003813828</span>, <span class="hljs-number">01003815868</span>, <span class="hljs-number">10000</span>);<br><br># 修改存储过程<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">PROCEDURE</span> 过程名<span class="hljs-number">1</span> RENAME <span class="hljs-keyword">TO</span> 过程名<span class="hljs-number">2</span>;<br><br># 删除存储过程<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> 过程名();<br></code></pre></td></tr></table></figure>
<h3 id="3-2-函数"><a href="#3-2-函数" class="headerlink" title="3.2 函数"></a>3.2 函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 函数的定义语句格式<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> 函数名 ([参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>,...]) <span class="hljs-keyword">RETURNS</span> <span class="hljs-operator">&lt;</span>类型<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>过程化<span class="hljs-keyword">SQL</span>块<span class="hljs-operator">&gt;</span>;<br><br># 函数的执行语句格式<br><span class="hljs-keyword">CALL</span><span class="hljs-operator">/</span><span class="hljs-keyword">SELECT</span> 函数名 ([参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>,...]);<br><br># 修改函数<br># 重命名<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">FUNCTION</span> 过程名<span class="hljs-number">1</span> RENAME <span class="hljs-keyword">TO</span> 过程名<span class="hljs-number">2</span>;<br># 重新编译<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">FUNCTION</span> 过程名 COMPILE;<br></code></pre></td></tr></table></figure>
<h1 id="09-关系查询处理和查询优化"><a href="#09-关系查询处理和查询优化" class="headerlink" title="09-关系查询处理和查询优化"></a>09-关系查询处理和查询优化</h1><h2 id="1-查询处理"><a href="#1-查询处理" class="headerlink" title="1. 查询处理"></a>1. 查询处理</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708103015176.png" alt="image-20230708103015176"></p>
<ul>
<li><p>查询检查的任务</p>
<ul>
<li>合法权检查</li>
<li>视图转换</li>
<li>安全性检查</li>
<li>完整性初步检查</li>
</ul>
</li>
<li><p>检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式</p>
</li>
<li><p>查询优化分类 </p>
<ul>
<li><p>代数优化/逻辑优化：指关系代数表达式的优化</p>
</li>
<li><p>物理优化：指存取路径和底层操作算法的选择</p>
</li>
</ul>
</li>
<li><p>查询优化的选择依据</p>
<ul>
<li><p>基于规则(rule based)</p>
</li>
<li><p>基于代价(cost based)</p>
</li>
<li><p>基于语义(semantic based)</p>
</li>
</ul>
</li>
<li><p>选择操作典型实现方法：</p>
<ul>
<li>全表扫描方法 (Table Scan)</li>
<li>索引扫描方法 (Index Scan)</li>
</ul>
</li>
<li><p>连接操作是查询处理中最耗时的操作之一，只讨论等值连接(或自然连接)最常用的实现算法</p>
<ul>
<li>嵌套循环算法(nested loop join) </li>
<li>排序-合并算法(sort-merge join 或 merge join)</li>
<li>索引连接(index join)算法 </li>
<li>Hash Join算法 </li>
</ul>
</li>
</ul>
<h2 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h2><ul>
<li>优化实例</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708105857753.png" alt="image-20230708105857753"></p>
<h2 id="3-代数优化"><a href="#3-代数优化" class="headerlink" title="3. 代数优化"></a>3. 代数优化</h2><ul>
<li>代数优化策略：通过对关系代数表达式的等价变换来提高查询效率</li>
</ul>
<h3 id="3-1-常见的等价变换规则"><a href="#3-1-常见的等价变换规则" class="headerlink" title="3.1 常见的等价变换规则"></a>3.1 常见的等价变换规则</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708110154079.png" alt="image-20230708110154079"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708110200675.png" alt="image-20230708110200675"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708110209664.png" alt="image-20230708110209664"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708110229723.png" alt="image-20230708110229723"></p>
<h3 id="3-2-典型的启发式规则"><a href="#3-2-典型的启发式规则" class="headerlink" title="3.2 典型的启发式规则"></a>3.2 典型的启发式规则</h3><ul>
<li><p>选择运算应尽可能先做</p>
</li>
<li><p>把投影运算和选择运算同时进行</p>
<ul>
<li>如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。</li>
</ul>
</li>
<li><p>把投影同其前或其后的双目运算结合起来</p>
</li>
<li><p>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算</p>
<ul>
<li>连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间。 </li>
</ul>
</li>
<li><p>找出公共子表达式</p>
<ul>
<li><p>如果这种重复出现的子表达式的结果不是很大的关系，并且从外存中读入这个关系比计算该子表达式的时间少得多，则先计算一次公共子表达式并把结果写入中间文件是合算的。</p>
</li>
<li><p>当查询的是视图时，定义视图的表达式就是公共子表达式的情况</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-物理优化"><a href="#4-物理优化" class="headerlink" title="4. 物理优化"></a>4. 物理优化</h2><ul>
<li>对于一个查询语句有许多存取方案，它们的执行效率不同，仅仅进行代数优化是不够的</li>
<li>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划</li>
</ul>
<p>选择操作的启发式规则</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708111109471.png" alt="image-20230708111109471"></p>
<p>连接操作的启发式规则</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708112057124.png" alt="image-20230708112057124"></p>
<h1 id="10-数据库恢复技术"><a href="#10-数据库恢复技术" class="headerlink" title="10-数据库恢复技术"></a>10-数据库恢复技术</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><ul>
<li>事物的<strong>ACID</strong>特性<ul>
<li><strong>原子性(Atomicity)</strong></li>
<li><strong>一致性(Consistency)</strong></li>
<li><strong>隔离性(Isolation)</strong></li>
<li><strong>持续性(Durability)</strong></li>
</ul>
</li>
<li>可能的破坏原因<ul>
<li>多个事务并行运行时，不同事务的操作交叉执行</li>
<li>事务在运行过程中被强行停止</li>
</ul>
</li>
</ul>
<h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><ul>
<li>事务是数据库的逻辑工作单位</li>
<li>事务中包括的诸操作要么都做，要么都不做</li>
</ul>
<h3 id="1-2-一致性"><a href="#1-2-一致性" class="headerlink" title="1.2 一致性"></a>1.2 一致性</h3><ul>
<li>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</li>
<li>一致性状态：数据库中只包含成功事务提交的结果。</li>
<li>不一致状态：<ul>
<li>数据库系统运行中发生故障，有些事务尚未完成就被迫中断</li>
<li>这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态。</li>
</ul>
</li>
</ul>
<h3 id="1-3-隔离性"><a href="#1-3-隔离性" class="headerlink" title="1.3 隔离性"></a>1.3 隔离性</h3><ul>
<li>一个事务的执行不能被其他事务干扰</li>
<li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li>
<li>并发执行的各个事务之间不能互相干扰</li>
</ul>
<h3 id="1-4-持续性也称永久性"><a href="#1-4-持续性也称永久性" class="headerlink" title="1.4 持续性也称永久性"></a>1.4 持续性也称永久性</h3><ul>
<li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li>
<li>接下来的其他操作或故障不应该对其执行结果有任何影响。</li>
</ul>
<h2 id="2-故障和数据库恢复"><a href="#2-故障和数据库恢复" class="headerlink" title="2. 故障和数据库恢复"></a>2. 故障和数据库恢复</h2><ul>
<li><p>故障种类</p>
<ul>
<li>事物内部的故障</li>
<li>系统故障</li>
<li>介质故障</li>
<li>计算机病毒</li>
</ul>
</li>
<li><p>系统故障</p>
<ul>
<li>称为软故障，是指造成系统停止运转的任何事件(特定类型的硬件错误(如CPU故障)、操作系统故障、数据库管理系统代码错误、系统断电)，使得系统要重新启动。<ul>
<li>整个系统的正常运行突然被破坏</li>
<li>所有正在运行的事务都非正常终止</li>
<li>不破坏数据库</li>
<li>内存中数据库缓冲区的信息全部丢失</li>
</ul>
</li>
<li>发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。<ul>
<li>恢复策略：系统重新启动时，恢复程序让所有<strong>非正常终止的事务回滚，强行撤消(UNDO)所有未完成事务。</strong></li>
</ul>
</li>
<li>发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失。<ul>
<li>恢复策略：系统重新启动时，恢复程序需要<strong>重做(REDO)所有已提交的事务</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>介质故障<ul>
<li>称为硬故障，指外存故障、磁盘损坏、磁头碰撞、瞬时强磁场干扰。</li>
<li>介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。</li>
<li>介质故障比前两类故障的可能性小得多，但破坏性大得多。</li>
</ul>
</li>
</ul>
<h2 id="3-数据转储"><a href="#3-数据转储" class="headerlink" title="3. 数据转储"></a>3. 数据转储</h2><ul>
<li><p>转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。</p>
<ul>
<li>备用的数据文本称为后备副本(backup)或后援副本。</li>
</ul>
</li>
<li><p><strong>静态转储</strong>：</p>
<ol>
<li><p>在系统中无运行事务时进行的转储操作</p>
</li>
<li><p>转储开始时数据库处于一致性状态</p>
</li>
<li><p>转储期间不允许对数据库的任何存取、修改活动</p>
</li>
<li><p>得到的一定是一个数据一致性的副本</p>
</li>
</ol>
</li>
<li><p><strong>动态转储</strong>：</p>
<ol>
<li><p>转储操作与用户事务并发进行</p>
</li>
<li><p>转储期间允许对数据库进行存取或修改</p>
</li>
</ol>
<ul>
<li>利用动态转储得到的副本进行故障恢复：<ul>
<li>需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件</li>
<li>后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>海量转储</strong>：每次转储全部数据库</p>
</li>
<li><p><strong>增量转储</strong>：只转储上次转储后更新过的数据</p>
</li>
</ul>
<h2 id="4-日志文件"><a href="#4-日志文件" class="headerlink" title="4. 日志文件"></a>4. 日志文件</h2><ul>
<li>日志文件(log file)是用来记录事务对数据库的更新操作的文件。</li>
<li><p>日志文件的格式</p>
<ul>
<li><p>以记录为单位的日志文件</p>
</li>
<li><p>以数据块为单位的日志文件</p>
</li>
</ul>
</li>
<li>用途<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
</li>
</ul>
<h3 id="4-1-日志文件的作用"><a href="#4-1-日志文件的作用" class="headerlink" title="4.1 日志文件的作用"></a>4.1 日志文件的作用</h3><ul>
<li><p>事务故障恢复和系统故障恢复必须用日志文件。</p>
</li>
<li><p>在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。</p>
</li>
<li>在静态转储方式中，也可以建立日志文件。<ul>
<li>当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态</li>
<li>利用日志文件，<strong>把已完成的事务进行重做处理</strong></li>
<li>对故障发生时<strong>尚未完成的事务进行撤销处理</strong></li>
<li>不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态</li>
</ul>
</li>
</ul>
<h3 id="4-2-登记日志文件"><a href="#4-2-登记日志文件" class="headerlink" title="4.2 登记日志文件"></a>4.2 登记日志文件</h3><ul>
<li>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则：<ul>
<li>登记的次序严格按并发事务执行的时间次序</li>
<li>必须先写日志文件，后写数据库<ul>
<li>写日志文件操作：把表示这个修改的日志记录写到日志文件中</li>
<li>写数据库操作：把对数据的修改写到数据库中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-恢复策略"><a href="#5-恢复策略" class="headerlink" title="5. 恢复策略"></a>5. 恢复策略</h2><h3 id="5-1-事务故障的恢复"><a href="#5-1-事务故障的恢复" class="headerlink" title="5.1 事务故障的恢复"></a>5.1 事务故障的恢复</h3><ul>
<li>事务故障：事务在运行至正常终止点前被终止。</li>
<li>恢复方法：由恢复子系统利用日志文件撤消(UNDO)此事务已对数据库进行的修改</li>
<li>恢复步骤：<ul>
<li>反向扫描文件日志(即从最后向前扫描日志文件)，查找该事务的更新操作。</li>
<li>对该事务的更新操作执行逆操作。即将日志记录中”更新前的值” 写入数据库。</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li>
<li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li>
</ul>
</li>
</ul>
<h3 id="5-2-系统故障的恢复"><a href="#5-2-系统故障的恢复" class="headerlink" title="5.2 系统故障的恢复"></a>5.2 系统故障的恢复</h3><ul>
<li>系统故障造成数据库不一致状态的原因：<ul>
<li>未完成事务对数据库的更新可能已写入数据库</li>
<li>已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库</li>
</ul>
</li>
<li>恢复步骤：<ul>
<li>正向扫描日志文件(即从头扫描日志文件)，将故障发生前已经提交的事务标记进入<strong>重做队列</strong>，将故障发生时尚未提交的事务标记进入<strong>撤销队列</strong></li>
<li>对撤销队列中事务进行撤销处理</li>
<li>对重做队列中事务进行重做处理</li>
</ul>
</li>
</ul>
<h3 id="5-3-介质故障的恢复"><a href="#5-3-介质故障的恢复" class="headerlink" title="5.3 介质故障的恢复"></a>5.3 介质故障的恢复</h3><ul>
<li>介质故障的恢复的工作：<ul>
<li>重装数据库</li>
<li>重做已完成的事务</li>
</ul>
</li>
<li>恢复步骤：<ul>
<li>装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。<ul>
<li>对于静态转储的数据库副本，装入后数据库即处于一致性状态</li>
<li>对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法(即 REDO+UNDO )，才能将数据库恢复到一致性状态。</li>
</ul>
</li>
<li>装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。<ul>
<li>首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。</li>
<li>然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中”更新后的值”写入数据库。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-具有检查点的恢复技术"><a href="#6-具有检查点的恢复技术" class="headerlink" title="6. 具有检查点的恢复技术"></a>6. 具有检查点的恢复技术</h2><ul>
<li><p>具有检查点（checkpoint）的恢复技术</p>
<ul>
<li><p>在日志文件中增加检查点记录（checkpoint）</p>
</li>
<li><p>增加重新开始文件</p>
</li>
<li><p>恢复子系统在登录日志文件期间动态地维护日志</p>
</li>
</ul>
</li>
<li><p>检查点记录的内容</p>
<ul>
<li><p>建立检查点时刻所有正在执行的事务清单</p>
</li>
<li><p>这些事务最近一个日志记录的地址</p>
</li>
</ul>
</li>
<li><p>重新开始文件的内容</p>
<ul>
<li>记录各个检查点记录在日志文件中的地址</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708120633972.png" alt="image-20230708120633972"></p>
<h3 id="6-1-动态维护日志文件的方法"><a href="#6-1-动态维护日志文件的方法" class="headerlink" title="6.1 动态维护日志文件的方法"></a>6.1 动态维护日志文件的方法</h3><ul>
<li>周期性地执行如下操作：建立检查点，保存数据库状态。</li>
<li>具体步骤是：<ul>
<li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上</li>
<li>在日志文件中写入一个检查点记录</li>
<li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中</li>
<li>把检查点记录在日志文件中的地址写入一个重新开始文件</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211443951.png" alt="image-20220914211443951"></p>
<h3 id="6-2-利用检查点的恢复步骤"><a href="#6-2-利用检查点的恢复步骤" class="headerlink" title="6.2 利用检查点的恢复步骤"></a>6.2 利用检查点的恢复步骤</h3><ul>
<li>具体步骤</li>
<li><p>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中<strong>找到最后一个检查点记录</strong>。</p>
</li>
<li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单 ACTIVE-LIST，把 ACTIVE-LIST 暂时放入 UNDO-LIST 队列，REDO 队列暂为空。</p>
<ul>
<li>从检查点开始正向扫描日志文件，直到日志文件结束<ul>
<li>如有新开始的事务 $T_i$，把 $T_i$ 暂时放入 UNDO-LIST 队列</li>
<li>如有提交的事务 $T_i$，把 $T_i$ 从 UNDO-LIST 队列移到 REDO-LIST 队列；直到日志文件结束</li>
</ul>
</li>
</ul>
</li>
<li><p>对 UNDO-LIST 中的每个事务执行 UNDO 操作</p>
</li>
<li><p>对 REDO-LIST 中的每个事务执行 REDO 操作</p>
</li>
</ul>
<h2 id="7-数据库镜像"><a href="#7-数据库镜像" class="headerlink" title="7. 数据库镜像"></a>7. 数据库镜像</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708121111140.png" alt="image-20230708121111140"></p>
<h1 id="11-并发控制"><a href="#11-并发控制" class="headerlink" title="11-并发控制"></a>11-并发控制</h1><h2 id="1-并发控制概述"><a href="#1-并发控制概述" class="headerlink" title="1. 并发控制概述"></a>1. 并发控制概述</h2><ul>
<li><p>事务是并发控制的基本单位。</p>
</li>
<li><p>并发控制机制的任务：</p>
<ul>
<li>对并发操作进行正确调度</li>
<li>保证事务的隔离性</li>
<li>保证数据库的一致性</li>
</ul>
</li>
<li>并发控制技术<ul>
<li>封锁(Locking)</li>
<li>时间戳(Timestamp)</li>
<li>乐观控制法</li>
<li>多版本并发控制(MVCC)</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620195047507.png" alt="image-20220620195047507"></p>
<ul>
<li>事务串行执行</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211455910.png" alt="image-20220914211455910"></p>
<ul>
<li>交叉并发方式</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211505544.png" alt="image-20220914211505544"></p>
<ul>
<li>同时并发方式</li>
</ul>
<h2 id="2-并发操作带来的数据不一致性"><a href="#2-并发操作带来的数据不一致性" class="headerlink" title="2. 并发操作带来的数据不一致性"></a>2. 并发操作带来的数据不一致性</h2><h3 id="2-1-丢失修改"><a href="#2-1-丢失修改" class="headerlink" title="2.1 丢失修改"></a>2.1 丢失修改</h3><ul>
<li>两个事务 $T_1$ 和 $T_2$ 读入同一数据并修改，$T_2$ 的提交结果破坏了 $T_1$ 提交的结果，导致 $T_1$ 的修改被丢失。</li>
</ul>
<h3 id="2-2-不可重复读"><a href="#2-2-不可重复读" class="headerlink" title="2.2 不可重复读"></a>2.2 不可重复读</h3><ul>
<li>不可重复读是指事务 $T_1$ 读取数据后，事务 $T_2$ 执行更新操作，使 $T_1$ 无法再现前一次读取结果(例如为了校对需要重复读)。</li>
<li>不可重复读包括三种情况，后两种不可重复读有时也称为幻影现象：<ul>
<li>一读一改：事务 $T_1$ 读取某一数据后，事务 $T_2$ 对其做了修改，当事务 $T_1$ 再次读该数据时，得到与前一次不同的值 。</li>
<li>一读一删：事务 $T_1$ 按一定条件从数据库中读取了某些数据记录后，事务 $T_2$ 删除了其中部分记录，当 $T_1$ 再次按相同条件读取数据时，发现某些记录神秘地消失了。</li>
<li>一读一加：事务 $T_1$ 按一定条件从数据库中读取某些数据记录后，事务 $T_2$ 插入了一些记录，当 $T_1$ 再次按相同条件读取数据时，发现多了一些记录。</li>
</ul>
</li>
</ul>
<h3 id="2-3-读”脏”数据"><a href="#2-3-读”脏”数据" class="headerlink" title="2.3 读”脏”数据"></a>2.3 读”脏”数据</h3><ul>
<li>读”脏”数据是指：<ul>
<li>事务 $T_1$ 修改某一数据，并将其写回磁盘</li>
<li>事务 $T_2$ 读取同一数据后，$T_1$ 由于某种原因被撤销</li>
<li>这时 $T_1$ 已修改过的数据恢复原值，$T_2$ 读到的数据就与数据库中的数据不一致</li>
<li>$T_2$ 读到的数据就为”脏”数据，即不正确的数据</li>
</ul>
</li>
</ul>
<h2 id="3-封锁"><a href="#3-封锁" class="headerlink" title="3. 封锁"></a>3. 封锁</h2><ul>
<li>封锁就是事务 $T$ 在对某个数据对象(例如表、记录等)操作之前，先向系统发出请求，对其加锁。</li>
<li>加锁后事务 $T$ 就对该数据对象有了一定的控制，在事务 $T$ 释放它的锁之前，其它的事务不能更新此数据对象。</li>
<li><p>基本封锁类型：</p>
<ul>
<li>排它锁(eXclusive Locks，简记为 X 锁)</li>
<li>共享锁(Share Locks，简记为 S 锁)</li>
</ul>
</li>
<li><p>排它锁又称为写锁，表示<strong>正在写，其他事务不能读</strong>。</p>
<ul>
<li>若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其它任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。保证其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</li>
</ul>
</li>
<li><p>共享锁又称为读锁，表示<strong>正在读，其他事务不能写</strong>。</p>
<ul>
<li>若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其它事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。保证其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708122018750.png" alt="image-20230708122018750"></p>
<h3 id="3-1-封锁协议"><a href="#3-1-封锁协议" class="headerlink" title="3.1 封锁协议"></a>3.1 封锁协议</h3><h4 id="3-1-1-一级封锁协议"><a href="#3-1-1-一级封锁协议" class="headerlink" title="3.1.1 一级封锁协议"></a>3.1.1 一级封锁协议</h4><ul>
<li>事务 T 在<strong>修改数据 R 之前必须先对其加 X 锁</strong>，直到<strong>事务结束</strong>(COMMIT 或 ROLLBACK)才释放。</li>
<li>一级封锁协议可<strong>防止丢失修改</strong>，并<strong>保证事务 T 是可恢复的</strong>。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它<strong>不能保证可重复读</strong>和<strong>不读”脏”数据</strong>。</li>
</ul>
<h4 id="3-1-2-二级封锁协议"><a href="#3-1-2-二级封锁协议" class="headerlink" title="3.1.2 二级封锁协议"></a>3.1.2 二级封锁协议</h4><ul>
<li>一级封锁协议加上事务 T 在<strong>读取数据 R 之前必须先对其加 S 锁</strong>，<strong>读完后</strong>即可释放S锁。</li>
<li>二级封锁协议可以<strong>防止丢失修改</strong>和<strong>读”脏”数据</strong>。在二级封锁协议中，由于读完数据后即可释放 S 锁，所以它<strong>不能保证可重复读</strong>。</li>
</ul>
<h4 id="3-1-3-三级封锁协议"><a href="#3-1-3-三级封锁协议" class="headerlink" title="3.1.3 三级封锁协议"></a>3.1.3 三级封锁协议</h4><ul>
<li>一级封锁协议加上事务 T 在<strong>读取数据 R 之前必须先对其加 S 锁</strong>，直到<strong>事务结束</strong>才释放。</li>
<li>三级封锁协议可<strong>防止丢失修改、读脏数据和不可重复读</strong>。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230708122424625.png" alt="image-20230708122424625"></p>
<h3 id="3-2-活锁"><a href="#3-2-活锁" class="headerlink" title="3.2 活锁"></a>3.2 活锁</h3><ul>
<li>因为优先级低而永远等待</li>
<li>避免活锁：采用先来先服务的策略</li>
</ul>
<h3 id="3-3-死锁"><a href="#3-3-死锁" class="headerlink" title="3.3 死锁"></a>3.3 死锁</h3><ul>
<li>原因：两个或多个事务都已封锁了一些数据对象，然后又都请求对已被其他事务封锁的数据对象加锁，从而出现死等待。</li>
<li><p>预防：破坏产生死锁的条件</p>
<ul>
<li>一次封锁法<ul>
<li>要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。</li>
<li>问题：<ul>
<li>降低系统并发度</li>
<li>难以事先精确确定封锁对象</li>
</ul>
</li>
</ul>
</li>
<li>顺序封锁法<ul>
<li>预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁</li>
<li>问题：<ul>
<li>维护成本</li>
<li>难以实现</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>诊断并解除死锁(常用)</p>
<ul>
<li><strong>超时法</strong>：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。</li>
<li><strong>等待图法</strong>：并发控制子系统周期性地(比如每隔数秒)生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。</li>
</ul>
</li>
<li>解除死锁<ul>
<li>选择一个处理死锁代价最小的事务，将其撤消</li>
<li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li>
</ul>
</li>
</ul>
<h2 id="4-事务调度"><a href="#4-事务调度" class="headerlink" title="4. 事务调度"></a>4. 事务调度</h2><ul>
<li>串行调度是正确的。执行结果等价于串行调度的调度也是正确的，称为<strong>可串行化调度</strong>。</li>
<li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。</li>
<li><strong>可串行性(Serializability)</strong>是并发事务正确调度的准则：一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</li>
</ul>
<h3 id="4-1-冲突可串行化"><a href="#4-1-冲突可串行化" class="headerlink" title="4.1 冲突可串行化"></a>4.1 冲突可串行化</h3><ul>
<li>一个调度 Sc 在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 Sc’，如果 Sc’ 是串行的，称调度 Sc 是冲突可串行化的调度</li>
</ul>
<h3 id="4-2-两段锁协议"><a href="#4-2-两段锁协议" class="headerlink" title="4.2 两段锁协议"></a>4.2 两段锁协议</h3><ul>
<li><p>两段锁协议，指所有事务必须分两个阶段对数据项加锁和解锁 ：</p>
<ul>
<li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li>
</ul>
</li>
<li><p>在此协议下，事务分为两个阶段：</p>
<ul>
<li>第一阶段是获得封锁，也称为扩展阶段：事务可以申请获得任何数据项上的任何类型的锁，但是<strong>不能释放任何锁</strong></li>
<li>第二阶段是释放封锁，也称为收缩阶段：事务可以释放任何数据项上的任何类型的锁，但是<strong>不能再申请任何锁</strong></li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220620204053987.png" alt="image-20220620204053987"></p>
<ul>
<li>事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。</li>
<li>但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。</li>
</ul>
<h2 id="5-封锁粒度"><a href="#5-封锁粒度" class="headerlink" title="5. 封锁粒度"></a>5. 封锁粒度</h2><ul>
<li>封锁粒度与系统的并发度和并发控制的开销密切相关：<ul>
<li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li>
<li>封锁的粒度越小，并发度较高，但系统开销也就越大</li>
</ul>
</li>
</ul>
<h3 id="5-1-多粒度封锁"><a href="#5-1-多粒度封锁" class="headerlink" title="5.1 多粒度封锁"></a>5.1 多粒度封锁</h3><ul>
<li>多粒度封锁：在一个系统中同时支持多种封锁粒度供不同的事务选择。</li>
<li>选择封锁粒度，同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度：<ul>
<li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li>
<li>需要处理大量元组的用户事务：以关系为封锁单元</li>
<li>只处理少量元组的用户事务：以元组为封锁单位</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211518287.png" alt="image-20220914211518287"></p>
<ul>
<li>多粒度封锁协议允许多粒度树中的每个结点被独立地加锁。</li>
<li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。</li>
<li>在多粒度封锁中一个数据对象可能以两种方式封锁：<ul>
<li><strong>显式封锁</strong>：直接加到数据对象上的封锁</li>
<li><strong>隐式封锁</strong>：是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁</li>
</ul>
</li>
<li><p>显式封锁和隐式封锁的效果是一样的。</p>
</li>
<li><p>系统检查封锁冲突时既要检查显式封锁，还要检查隐式封锁。</p>
</li>
<li>对某个数据对象加锁，系统要检查：<ul>
<li>该数据对象：有无显式封锁与之冲突</li>
<li>所有上级结点：检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突(由上级结点已加的封锁造成的)冲突</li>
<li>所有下级结点：看上面的显式封锁是否与本事务的隐式封锁(将加到下级结点的封锁)冲突</li>
</ul>
</li>
</ul>
<h3 id="5-2-意向锁"><a href="#5-2-意向锁" class="headerlink" title="5.2 意向锁"></a>5.2 意向锁</h3><ul>
<li>引进意向锁目的：提高对某个数据对象加锁时系统的检查效率。</li>
<li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。</li>
<li>对任一结点加基本锁，必须先对它的上层结点加意向锁。<ul>
<li>意向共享锁(IS 锁)：表示它的后裔结点拟(意向)加 S 锁。</li>
<li>意向排它锁(IX 锁)：表示它的后裔结点拟(意向)加 X 锁。</li>
<li>共享意向排它锁(SIX 锁)：表示对它加 S 锁，再加 IX 锁，即 SIX = S + IX。<ul>
<li>例：对某个表加SIX锁，则表示该事务要读整个表(所以要对该表加S锁)，同时会更新个别元组(所以要对该表加IX锁)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220914211529089.png" alt="image-20220914211529168"></p>
<ul>
<li>申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。</li>
<li>具有意向锁的多粒度封锁方法：提高了系统的并发度，减少了加锁和解锁的开销，在实际的数据库管理系统产品中得到广泛应用。</li>
</ul>
<h1 id="12-NoSQL数据模型"><a href="#12-NoSQL数据模型" class="headerlink" title="12-NoSQL数据模型"></a>12-NoSQL数据模型</h1><h2 id="1-阻抗失谐"><a href="#1-阻抗失谐" class="headerlink" title="1. 阻抗失谐"></a>1. 阻抗失谐</h2><ul>
<li><p>SQL 操作所<strong>使用及返回的数据都是关系元组</strong>，不能包含嵌套记录或列表等任何结构。而<strong>内存中的数据结构则无此限制</strong>，它可以使用的数据组织形式比关系更丰富。</p>
</li>
<li><p>关系模型和内存中的数据结构之间存在差异。这种现象通常称为<strong>阻抗失谐</strong>。</p>
</li>
<li><p>如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成关系形式。于是就发生了阻抗失谐：<strong>需要在两种不同的表示形式之间转译</strong>。</p>
</li>
<li><p>解决方法</p>
<ul>
<li>面向对象数据库</li>
<li>对象-关系映射框架</li>
</ul>
</li>
<li>问题：<ul>
<li>查询性能问题</li>
<li>集成问题</li>
</ul>
</li>
</ul>
<h2 id="2-应用程序数据库与集成数据库"><a href="#2-应用程序数据库与集成数据库" class="headerlink" title="2. 应用程序数据库与集成数据库"></a>2. 应用程序数据库与集成数据库</h2><ul>
<li><p>SQL 充当了应用程序之间的一种集成机制。数据库在这种情况下成了<strong>集成数据库</strong></p>
<ul>
<li>通常由不同团队所开发的多个应用程序，将其数据存储在一个公用的数据库中。</li>
<li>所有应用程序都在操作内容一致的持久数据，提高了数据通信的效率</li>
<li>为了能将很多应用程序集成起来，数据库的结构比单个应用程序所要用到的结构复杂得多</li>
<li>如果某个应用程序想要修改存储的数据，那么它就得和所有使用此数据库的其他应用程序相调。</li>
<li>各种应用程序的结构和性能要求不尽相同，数据库通常不能任由应用程序更新其数据。为了保持数据库的完整性，我们需要将这一责任交由数据库自身负责。</li>
</ul>
</li>
<li><p>将数据库视为<strong>“应用程序数据库”</strong>，其内容只能由一个应用程序的代码库直接访问</p>
<ul>
<li><p>由于只有开发应用程序的团队才需要知道其结构，模式的维护与更新就更容易了。由于应用程序开发团队同时管理数据库和应用程序代码，因此可以把维护数据库完整性的工作放在应用程序代码中。</p>
</li>
<li><p>交互工作转交由应用程序接口来完成</p>
</li>
<li>在使用应用程序数据库后，由于内部数据库与外部通信服务之间已经解耦，所以外界并不关心数据如何存储，这样就可以选用非关系型数据库了</li>
</ul>
</li>
</ul>
<h2 id="3-集群"><a href="#3-集群" class="headerlink" title="3. 集群"></a>3. 集群</h2><ul>
<li>纵向扩展(scale up)：功能强大的计算机、更多的处理器、磁盘存储空间和内存。但成本高、扩展尺度有限。</li>
<li>横向扩展(scale out)：采用由多个小型计算机组成的集群。集群中的小型机使用性价比较高的硬件，降低扩展所需的成本。</li>
<li>关系型数据库并不是设计给集群用的。</li>
</ul>
<h2 id="4-NoSQL登场"><a href="#4-NoSQL登场" class="headerlink" title="4. NoSQL登场"></a>4. NoSQL登场</h2><ul>
<li>不使用关系模型</li>
<li>在集群中运行良好</li>
<li>开源</li>
<li>适用于 21 世纪的互联网公司</li>
<li><strong>无模式</strong></li>
</ul>
<h2 id="5-分布式模型"><a href="#5-分布式模型" class="headerlink" title="5. 分布式模型"></a>5. 分布式模型</h2><ul>
<li>数据分布有两条路径：<strong>分片与复制</strong><ul>
<li>“分片”是将不同数据存放在不同节点中</li>
<li>“复制”是将同一份数据拷贝至多个节点<ul>
<li>“主从式” 和 “对等式”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-1-分片"><a href="#5-1-分片" class="headerlink" title="5.1 分片"></a>5.1 分片</h3><ul>
<li>把数据的各个部分存放于不同的服务器中，以此实现横向扩展。该技术就叫”分片”。</li>
<li>为达成目标，必须保证需要同时访问的那些数据都存放在同一节点上，而且节点必须排布好这些数据块，使访问速度最优。</li>
<li>采用应用程序的逻辑实现分片</li>
<li>采用NoSQL数据库提供的”自动分片”功能</li>
<li>分片可以同时提升读取与写入效率</li>
<li>分片对改善数据库的”故障恢复能力”帮助并不大。尽管数据分布在不同的节点上，但是和”单一服务器”方案一样，<strong>只要某节点出错，那么该分片上的数据就无法访问了</strong><ul>
<li>在发生故障时，只有访问此数据的那些用户才会受影响，而其余用户则能正常访问</li>
<li>由于多节点问题，从实际效果出发，分片技术可能会降低数据库的错误恢复能力</li>
</ul>
</li>
</ul>
<h3 id="5-2-主从复制"><a href="#5-2-主从复制" class="headerlink" title="5.2 主从复制"></a>5.2 主从复制</h3><ul>
<li><p>在”主从式分布”中</p>
<ul>
<li><p>其中有一个节点叫做”主节点”，或”主要节点”。主节点存放权威数据，而且通常负责处理数据<strong>更新</strong>操作。</p>
</li>
<li><p>其余节点都叫”从节点”，或”次要节点”，和主节点保持同步，负责<strong>读取</strong>操作。</p>
</li>
</ul>
</li>
<li><p>在需要频繁读取数据集的情况下，”主从复制”(master-slave replication) 有助于提升数据访问性能</p>
</li>
<li><p>“主从复制”可以增强”读取操作的故障恢复能力”(read resilience)</p>
<ul>
<li>万一主节点出错了，那么从节点依然可以处理读取请求。</li>
<li>主节点出错之后，除非将其恢复，或另行指派新的主节点，否则数据库就无法处理写入操作。</li>
<li>在主节点出错之后，由于拥有内容与主节点相同的从节点，很快就能指派一个从节点作为新的主节点，从而具备故障恢复能力。</li>
<li>主节点可以手工指派，也可自动选择。 </li>
</ul>
</li>
</ul>
<h3 id="5-3-对等复制"><a href="#5-3-对等复制" class="headerlink" title="5.3 对等复制"></a>5.3 对等复制</h3><ul>
<li>“对等复制” 它没有”主节点”这一概念。所有”副本”(replica) 地位相同，都可以接受写入请求，而且丢失其中一个副本，并不影响整个数据库的访问。</li>
</ul>
<h3 id="5-4-结合复制与分片"><a href="#5-4-结合复制与分片" class="headerlink" title="5.4 结合复制与分片"></a>5.4 结合复制与分片</h3><ul>
<li><strong>结合”主从复制”与”分片”</strong><ul>
<li>如果同时使用”主从复制”与”分片”，那么就意味着整个系统有多个主节点，然而对每项数据来说，负责它的主节点只有一个</li>
<li>根据配置需要，同一个节点既可以做某些数据的主节点，也可以充当其他数据的从节点，此外，也可以指派全职的主节点或从节点</li>
</ul>
</li>
<li><strong>结合”对等复制”与”分片”</strong><ul>
<li>数据可能分布于集群中的数十个或数百个节点上。在采用”对等复制”方案时，一开始可以用 “3” 作为复制因子(replication factor), 也就是把每个分片数据放在 3 个节点中。一旦某个节点出错，那么它上面保存的那些分片数据会由其他节点重建</li>
</ul>
</li>
</ul>
<h2 id="6-放宽”一致性”和”持久性”约束"><a href="#6-放宽”一致性”和”持久性”约束" class="headerlink" title="6. 放宽”一致性”和”持久性”约束"></a>6. 放宽”一致性”和”持久性”约束</h2><h3 id="6-1-使用事务保障”一致性”"><a href="#6-1-使用事务保障”一致性”" class="headerlink" title="6.1 使用事务保障”一致性”"></a>6.1 使用事务保障”一致性”</h3><ul>
<li>使用”事务”达成强一致性</li>
<li>引入放松”隔离级别”(isolation level)的功能，以允许查询操作读取尚未提交的数据。<ul>
<li>读未提交，一个事务可以读取另一个未提交事务的数据。脏读</li>
<li>读已提交，一个事务要等另一个事务提交后才能读取数据。不可重复读</li>
<li>可重复读，在开始读取数据(事务开启)时，不再允许修改操作。幻读</li>
<li>可串行化，事务串行化顺序执行。严格一致性，效率是一个问题</li>
</ul>
</li>
</ul>
<h3 id="6-2-CAP定理"><a href="#6-2-CAP定理" class="headerlink" title="6.2 CAP定理"></a>6.2 CAP定理</h3><ul>
<li><p>CAP定理：给定<strong>“一致性”、”可用性”、”分区耐受性”</strong> 这三个属性，我们只能同时满足其中两个属性。</p>
<ul>
<li>“一致性”</li>
<li>“可用性”，如果客户可以同集群中的某个节点通信，那么该节点就必然能够处理读取及写入操作。</li>
<li>“分区耐受性”，如果发生通信故障，导致整个集群被分割成多个无法互相通信的分区时(这种情况也叫”脑裂”，split brain)，集群仍然可用。</li>
</ul>
</li>
<li><p>CA系统：具备”一致性”(Consistency)与”可用性”(Availability)，但却不具备”分区耐受性”的系统</p>
<ul>
<li>大多数关系型数据库</li>
</ul>
</li>
<li><p>CA集群</p>
<ul>
<li>无法保证”分区耐受性”，这使得一旦”分区”发生，所有节点必须停止运作</li>
<li>CAP中的，可用性定义为”系统中某个无故障节点所接收的每一条请求，无论成功或失败，都必将得到响应。”</li>
<li>介于此时所有节点均为故障节点，不违反CAP中的”可用性”</li>
</ul>
</li>
</ul>
<h3 id="6-3-BASE"><a href="#6-3-BASE" class="headerlink" title="6.3 BASE"></a>6.3 BASE</h3><ul>
<li>与关系型数据库所支持的ACID事务不同，NoSQL系统具备”BASE属性”<ul>
<li>基本可用，Basically Available</li>
<li>柔性状态，Soft state</li>
<li>最终一致性，Eventual consistency </li>
</ul>
</li>
</ul>
<h3 id="6-4-“一致性”与”延迟”-之间取舍"><a href="#6-4-“一致性”与”延迟”-之间取舍" class="headerlink" title="6.4 “一致性”与”延迟” 之间取舍"></a>6.4 “一致性”与”延迟” 之间取舍</h3><ul>
<li>在权衡分布式数据库的”一致性”时，与其考虑如何权衡”一致性”与”可用性”，不如思考怎样在”一致性”与”延迟”(latency)之间取舍。<ul>
<li>参与交互操作的节点越多，”一致性”就越好</li>
<li>然而，每新增一个节点，都会使交互操作的响应时间变长</li>
<li>“可用性”可以视为能够忍受的最大延迟时间，一旦延迟过高，我们就放弃操作，并认为数据不可用</li>
<li>这样一来，就和”CAP定理”对”可用性”所下的定义相当吻合了</li>
</ul>
</li>
</ul>
<h2 id="7-仲裁"><a href="#7-仲裁" class="headerlink" title="7. 仲裁"></a>7. 仲裁</h2><h3 id="7-1-写入仲裁"><a href="#7-1-写入仲裁" class="headerlink" title="7.1 写入仲裁"></a>7.1 写入仲裁</h3><ul>
<li>保强一致性(strong consistency)，需要使用多少个节点才行?</li>
<li>对等式分布模型：如果发生两个相互冲突的写入操作，那么只有其中一个操作能为超过半数的节点所认可，$W&gt;N/2$ 。即，参与写入操作的节点数(W)，必须超过副本节点数(N)的一半。副本个数又称为复制因子</li>
<li>主从式分布模型：只需要向主节点中写入数据</li>
</ul>
<h3 id="7-2-读取仲裁"><a href="#7-2-读取仲裁" class="headerlink" title="7.2 读取仲裁"></a>7.2 读取仲裁</h3><ul>
<li>想要保证能够读到最新数据，必须与多少个节点联系才行?</li>
<li>对等式分布模型：只有当 $R+W&gt;N$ 时，才能保证读取操作的强一致性。其中，执行读取操作时所需联系的节点数(R)，确认写入操作时所需征询的节点数(W)，以及复制因子(N)</li>
<li>主从式分布模型：只需从主节点中读取数据</li>
</ul>
<h2 id="8-如何存放，适合做什么，不适合做什么"><a href="#8-如何存放，适合做什么，不适合做什么" class="headerlink" title="8. 如何存放，适合做什么，不适合做什么"></a>8. 如何存放，适合做什么，不适合做什么</h2><h3 id="8-1-键值数据库"><a href="#8-1-键值数据库" class="headerlink" title="8.1 键值数据库"></a>8.1 键值数据库</h3><ul>
<li>定义：键值数据库是一张简单的哈希表，主要用在所有数据库访问均通过主键来操作的情况下。</li>
<li>适用案例<ul>
<li><strong>存放会话信息</strong><ul>
<li>因为全部会话内容都可以用一条 PUT 请求来存放，而且只需一条 GET 请求就能取得。</li>
<li>由于会话中的所有信息都放在一个对象中，所以这种单请求操作很迅速。</li>
</ul>
</li>
<li><strong>用户配置信息</strong><ul>
<li>内容可全部放在一个对象里，只用一次 GET 操作即获取某位用户的全部配置信息。</li>
</ul>
</li>
<li><strong>购物车数据</strong><ul>
<li>可把购物信息放在 value 属性中，并将其绑定到 userid 这个键名上。</li>
</ul>
</li>
</ul>
</li>
<li>不适用案例<ul>
<li><strong>数据间关系</strong></li>
<li><strong>含有多项操作的事务</strong></li>
<li><strong>查询数据</strong></li>
</ul>
</li>
</ul>
<h3 id="8-2-文档数据库"><a href="#8-2-文档数据库" class="headerlink" title="8.2 文档数据库"></a>8.2 文档数据库</h3><ul>
<li>定义：文档数据库所存放的文档，就相当于键值数据库所存放的”值”。文档数据库可视为其值可查的键值数据库。</li>
<li>适用案例<ul>
<li><strong>事件记录</strong></li>
<li><strong>内容管理系统及博客平台</strong></li>
<li><strong>电子商务应用程序</strong></li>
</ul>
</li>
<li>不适用案例<ul>
<li><strong>包含多项操作的事务</strong></li>
<li><strong>查询持续变化的聚合结构</strong></li>
</ul>
</li>
</ul>
<h3 id="8-3-列族数据库"><a href="#8-3-列族数据库" class="headerlink" title="8.3 列族数据库"></a>8.3 列族数据库</h3><ul>
<li>定义：可以存储关键字及其映射值,并且可以把值分成多个列族，让每个列族代表一张数据映射表</li>
<li>适用案例<ul>
<li><strong>事件记录</strong></li>
<li><strong>内容管理系统及博客平台</strong></li>
<li><strong>计数器</strong></li>
<li><strong>限期</strong></li>
</ul>
</li>
<li>不适用案例<ul>
<li><strong>需要以 ACID 事务执行写入及读取操作的系统。</strong></li>
</ul>
</li>
</ul>
<h3 id="8-4-图数据库"><a href="#8-4-图数据库" class="headerlink" title="8.4 图数据库"></a>8.4 图数据库</h3><ul>
<li><p>定义：图数据库可存放实体及实体间关系。实体也叫”节点”，它们具有属性。关系又叫”边”，它们也有属性。</p>
</li>
<li><p>适用案例：</p>
<ul>
<li><strong>互联数据</strong></li>
<li><strong>安排运输路线、分派货物和基于位置的服务</strong></li>
</ul>
</li>
<li><p>不适用案例</p>
<ul>
<li><strong>更新全部或某子集内的实体时</strong></li>
</ul>
</li>
</ul>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/07/06/%E5%A4%8F%E4%BB%A4%E8%90%A5-%E8%AE%A1%E7%BD%91%E5%BE%80%E5%B9%B4%E5%8D%B7/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-08-09 14:53:19
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/" title="NJU">
                        <b>#</b> NJU
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" title="数据管理基础">
                        <b>#</b> 数据管理基础
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/07/12/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%E2%85%A1/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#01-%E7%BB%AA%E8%AE%BA"><span class="toc-text">01-绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 数据管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2. 几个基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-text">3. 数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.1 概念模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.2 逻辑模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">3.2.1 关系模型的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3.2.2 关系模型的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-NoSQL"><span class="toc-text">3.2.3 NoSQL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">4. 数据库系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A8%A1%E5%BC%8F-%E9%80%BB%E8%BE%91%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.1 模式(逻辑模式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%A4%96%E6%A8%A1%E5%BC%8F-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E3%80%81%E5%AD%90%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.2 外模式(用户模式、子模式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%86%85%E6%A8%A1%E5%BC%8F-%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.3 内模式(存储模式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%A4%96%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E5%BC%8F%E6%98%A0%E5%83%8F"><span class="toc-text">4.4 外模式&#x2F;模式映像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%A8%A1%E5%BC%8F-%E5%86%85%E6%A8%A1%E5%BC%8F%E6%98%A0%E5%83%8F"><span class="toc-text">4.5 模式&#x2F;内模式映像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">5. 数据库系统的组成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">02-关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E7%B3%BB"><span class="toc-text">1. 关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%85%B3%E7%B3%BB%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-text">1.1 关系的类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9F%BA%E6%9C%AC%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">1.2 基本关系的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3 关系模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">2. 数据库完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-text">3. 关系代数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BC%A0%E7%BB%9F%E7%9A%84%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-text">3.1 传统的集合操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%B0%E5%8F%B7"><span class="toc-text">3.2 使用的记号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%93%E9%97%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97"><span class="toc-text">3.3 专门的关系运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL"><span class="toc-text">03-关系数据库标准语言SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SQL%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-text">1. SQL数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B1%82%E6%AC%A1%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E6%9C%BA%E5%88%B6"><span class="toc-text">1.1 层次化的数据库对象命名机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-text">1.2 数据定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%B4%A2%E5%BC%95"><span class="toc-text">1.3 索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8"><span class="toc-text">1.4 数据字典</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="toc-text">2. SQL数据查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.1 单表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.2 连接查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.3 嵌套查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.4 集合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%9F%BA%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.5 基于派生表的查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"><span class="toc-text">3. 数据更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SQL%E4%B8%AD%E7%9A%84%E7%A9%BA%E5%80%BC"><span class="toc-text">4. SQL中的空值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A7%86%E5%9B%BE"><span class="toc-text">5. 视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE"><span class="toc-text">5.1 定义视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-text">5.2 删除视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE"><span class="toc-text">5.3 查询视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="toc-text">5. 更新视图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">04-数据库安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6"><span class="toc-text">1. 自主存取控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-GRANT"><span class="toc-text">1.1 GRANT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-REVOKE"><span class="toc-text">1.2 REVOKE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-text">1.3 创建数据库模式的权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%92%E8%89%B2"><span class="toc-text">1.4 数据库角色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%BA%E5%88%B6%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6"><span class="toc-text">2. 强制存取控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%86%E5%9B%BE%E3%80%81%E5%AE%A1%E8%AE%A1%E3%80%81%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%8F%8A%E5%85%B6%E4%BB%96"><span class="toc-text">3. 视图、审计、数据加密及其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%A7%86%E5%9B%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">3.1 视图机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%A1%E8%AE%A1"><span class="toc-text">3.2 审计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86"><span class="toc-text">3.3 数据加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E6%80%A7%E4%BF%9D%E6%8A%A4"><span class="toc-text">3.4 其他安全性保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">05-数据库完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">1. 实体完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">2. 参照完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">3. 用户定义完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%AD%E8%A8%80"><span class="toc-text">4. 断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">5. 触发器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA-%E9%87%8D%E7%82%B9"><span class="toc-text">06-关系数据理论(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E5%8F%8A%E8%8C%83%E5%BC%8F"><span class="toc-text">1. 关系模式及范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-text">2. 函数依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1NF"><span class="toc-text">3. 1NF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2NF"><span class="toc-text">4. 2NF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3NF"><span class="toc-text">5. 3NF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-BCNF"><span class="toc-text">6. BCNF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"><span class="toc-text">7. 多值依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4NF"><span class="toc-text">8. 4NF</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-text">07-数据库设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 数据库设计概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-E-R-%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. E-R 模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">3. 逻辑结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BD%AC%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">3.1 转换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A7%A3"><span class="toc-text">3.2 水平分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%9E%82%E7%9B%B4%E5%88%86%E8%A7%A3"><span class="toc-text">3.3 垂直分解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">4. 物理结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-text">4.1 关系模式存取方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%81%9A%E7%B0%87"><span class="toc-text">4.2 聚簇</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B"><span class="toc-text">08-数据库编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jdbc"><span class="toc-text">1. jdbc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%87%E7%A8%8B%E5%8C%96SQL"><span class="toc-text">2. 过程化SQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-text">3. 存储过程和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">3.1 存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%87%BD%E6%95%B0"><span class="toc-text">3.2 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">09-关系查询处理和查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86"><span class="toc-text">1. 查询处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">2. 查询优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-text">3. 代数优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AD%89%E4%BB%B7%E5%8F%98%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-text">3.1 常见的等价变换规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B8%E5%9E%8B%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-text">3.2 典型的启发式规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%89%A9%E7%90%86%E4%BC%98%E5%8C%96"><span class="toc-text">4. 物理优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="toc-text">10-数据库恢复技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1"><span class="toc-text">1. 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">1.1 原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">1.2 一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-text">1.3 隔离性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%8C%81%E7%BB%AD%E6%80%A7%E4%B9%9F%E7%A7%B0%E6%B0%B8%E4%B9%85%E6%80%A7"><span class="toc-text">1.4 持续性也称永久性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%85%E9%9A%9C%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D"><span class="toc-text">2. 故障和数据库恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8"><span class="toc-text">3. 数据转储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-text">4. 日志文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.1 日志文件的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%99%BB%E8%AE%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-text">4.2 登记日志文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="toc-text">5. 恢复策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-text">5.1 事务故障的恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-text">5.2 系统故障的恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-text">5.3 介质故障的恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="toc-text">6. 具有检查点的恢复技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%8A%A8%E6%80%81%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6.1 动态维护日志文件的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%88%A9%E7%94%A8%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%AD%A5%E9%AA%A4"><span class="toc-text">6.2 利用检查点的恢复步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%95%9C%E5%83%8F"><span class="toc-text">7. 数据库镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">11-并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 并发控制概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">2. 并发操作带来的数据不一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9"><span class="toc-text">2.1 丢失修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-text">2.2 不可重复读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%AF%BB%E2%80%9D%E8%84%8F%E2%80%9D%E6%95%B0%E6%8D%AE"><span class="toc-text">2.3 读”脏”数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%81%E9%94%81"><span class="toc-text">3. 封锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1 封锁协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1.1 一级封锁协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1.2 二级封锁协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1.3 三级封锁协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B4%BB%E9%94%81"><span class="toc-text">3.2 活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%AD%BB%E9%94%81"><span class="toc-text">3.3 死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8B%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-text">4. 事务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%86%B2%E7%AA%81%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="toc-text">4.1 冲突可串行化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">4.2 两段锁协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B0%81%E9%94%81%E7%B2%92%E5%BA%A6"><span class="toc-text">5. 封锁粒度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%A4%9A%E7%B2%92%E5%BA%A6%E5%B0%81%E9%94%81"><span class="toc-text">5.1 多粒度封锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">5.2 意向锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-NoSQL%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-text">12-NoSQL数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%98%BB%E6%8A%97%E5%A4%B1%E8%B0%90"><span class="toc-text">1. 阻抗失谐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9B%86%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">2. 应用程序数据库与集成数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9B%86%E7%BE%A4"><span class="toc-text">3. 集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-NoSQL%E7%99%BB%E5%9C%BA"><span class="toc-text">4. NoSQL登场</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="toc-text">5. 分布式模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%88%86%E7%89%87"><span class="toc-text">5.1 分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">5.2 主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%AF%B9%E7%AD%89%E5%A4%8D%E5%88%B6"><span class="toc-text">5.3 对等复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E7%BB%93%E5%90%88%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%88%86%E7%89%87"><span class="toc-text">5.4 结合复制与分片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%94%BE%E5%AE%BD%E2%80%9D%E4%B8%80%E8%87%B4%E6%80%A7%E2%80%9D%E5%92%8C%E2%80%9D%E6%8C%81%E4%B9%85%E6%80%A7%E2%80%9D%E7%BA%A6%E6%9D%9F"><span class="toc-text">6. 放宽”一致性”和”持久性”约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E4%BF%9D%E9%9A%9C%E2%80%9D%E4%B8%80%E8%87%B4%E6%80%A7%E2%80%9D"><span class="toc-text">6.1 使用事务保障”一致性”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-CAP%E5%AE%9A%E7%90%86"><span class="toc-text">6.2 CAP定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-BASE"><span class="toc-text">6.3 BASE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E2%80%9C%E4%B8%80%E8%87%B4%E6%80%A7%E2%80%9D%E4%B8%8E%E2%80%9D%E5%BB%B6%E8%BF%9F%E2%80%9D-%E4%B9%8B%E9%97%B4%E5%8F%96%E8%88%8D"><span class="toc-text">6.4 “一致性”与”延迟” 之间取舍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BB%B2%E8%A3%81"><span class="toc-text">7. 仲裁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%86%99%E5%85%A5%E4%BB%B2%E8%A3%81"><span class="toc-text">7.1 写入仲裁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%AF%BB%E5%8F%96%E4%BB%B2%E8%A3%81"><span class="toc-text">7.2 读取仲裁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%AD%98%E6%94%BE%EF%BC%8C%E9%80%82%E5%90%88%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%8D%E9%80%82%E5%90%88%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">8. 如何存放，适合做什么，不适合做什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">8.1 键值数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">8.2 文档数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%88%97%E6%97%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">8.3 列族数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">8.4 图数据库</span></a></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80 + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2023%2F07%2F08%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25AE%25A1%25E7%2590%2586%25E5%259F%25BA%25E7%25A1%2580%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2023/07/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
