<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="南京大学软件学院大三在读" />
  
  
  <title>
    
      JavaScript 从入门到放弃 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">JavaScript 从入门到放弃</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-08-13 17:28:10
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Language/" title="Language">
                    <b>#</b> Language
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/Language/JavaScript/" title="JavaScript">
                    <b>#</b> JavaScript
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="JAVASCRIPT-编程语言"><a href="#JAVASCRIPT-编程语言" class="headerlink" title="JAVASCRIPT 编程语言"></a>JAVASCRIPT 编程语言</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-Hello-world"><a href="#1-1-Hello-world" class="headerlink" title="1.1 Hello,world!"></a>1.1 Hello,world!</h3><blockquote>
<p>一般来说，只有最简单的脚本才嵌入到 HTML 中。更复杂的脚本存放在单独的文件中。</p>
<p>使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的缓存中。</p>
<p>之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。</p>
<p>这可以节省流量，并使得页面(加载)更快。</p>
</blockquote>
<ul>
<li><p>如果设置了 <code>src</code> 特性，<code>script</code> 标签内容将会被忽略。</p>
<ul>
<li>一个单独的 <code>&lt;script&gt;</code> 标签不能同时有 <code>src</code> 特性和内部包裹的代码。</li>
</ul>
</li>
<li><p><code>type</code> 和 <code>language</code> 特性(attribute)不是必需的。</p>
</li>
<li><p>外部的脚本可以通过 <code>&lt;script src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt;</code> 的方式插入。</p>
</li>
</ul>
<h3 id="1-2-代码结构"><a href="#1-2-代码结构" class="headerlink" title="1.2 代码结构"></a>1.2 代码结构</h3><ul>
<li><p>分号</p>
<ul>
<li><p>当存在换行符(line break)时，在大多数情况下可以省略分号。JavaScript 将换行符理解成“隐式”的分号。这也被称为 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">自动分号插入</a>。</p>
</li>
<li><p>但存在 JavaScript 无法确定是否真的需要自动插入分号的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">forEach</span>(alert);<br><br><span class="hljs-comment">//被视为alert(&quot;Hello&quot;)[1, 2].forEach(alert); 只有第一个 Hello 会被显示出来，并且有一个报错</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>不支持注释嵌套！</strong></p>
</li>
</ul>
<h3 id="1-3-现代模式，”use-strict”"><a href="#1-3-现代模式，”use-strict”" class="headerlink" title="1.3 现代模式，”use strict”"></a>1.3 现代模式，”use strict”</h3><p>ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。需要一个特殊的指令 —— <code>&quot;use strict&quot;</code> 来明确地激活这些特性。</p>
<p>当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br>...<br></code></pre></td></tr></table></figure>

<p><code>&quot;use strict&quot;</code> 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。</p>
<ul>
<li><p><strong>确保 “use strict” 出现在最顶部</strong></p>
<ul>
<li>只有注释可以出现在 <code>&quot;use strict&quot;</code> 的上面。</li>
</ul>
</li>
<li><p><strong>没有办法取消</strong> <code>use strict</code></p>
</li>
<li><p>现代 JavaScript 支持 “class” 和 “module” —— 高级语言结构，它们会自动启用 <code>use strict</code>。因此，如果我们使用它们，则无需添加 <code>&quot;use strict&quot;</code> 指令。</p>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>我们可以使用 <code>var</code>、<code>let</code> 或 <code>const</code> 声明变量来存储数据。</p>
<ul>
<li><code>let</code> — 现代的变量声明方式。</li>
<li><code>var</code> — 老旧的变量声明方式。一般情况下，我们不会再使用它。</li>
<li><code>const</code> — 类似于 <code>let</code>，但是变量的值无法被修改。</li>
</ul>
<p>变量应当以一种容易理解变量内部是什么的方式进行命名。</p>
</li>
<li><p><strong>未采用</strong> <code>use strict</code> <strong>下的赋值</strong></p>
<ul>
<li><p>一般，我们需要在使用一个变量前定义它。但是在早期，我们可以不使用 <code>let</code> 进行变量声明，而可以简单地通过赋值来创建一个变量。现在如果我们不在脚本中使用 <code>use strict</code> 声明启用严格模式，这仍然可以正常工作，这是为了保持对旧脚本的兼容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注意：这个例子中没有 &quot;use strict&quot;</span><br><br>num = <span class="hljs-number">5</span>; <span class="hljs-comment">// 如果变量 &quot;num&quot; 不存在，就会被创建</span><br><br><span class="hljs-title function_">alert</span>(num); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>上面这是个糟糕的做法，严格模式下会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br>num = <span class="hljs-number">5</span>; <span class="hljs-comment">// 错误：num 未定义</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="1-5-数据类型"><a href="#1-5-数据类型" class="headerlink" title="1.5 数据类型"></a>1.5 数据类型</h3><p>JavaScript 中有八种基本的数据类型(译注：前七种为基本数据类型，也称为原始类型，而 <code>object</code> 为复杂数据类型)。</p>
<h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h4><ul>
<li><p>用于任何类型的数字：整数或浮点数，在 $\pm (2^{53}-1)$ 范围内的整数。</p>
</li>
<li><p>特殊数值(special numeric values)也属于这种类型：<code>Infinity</code>、<code>-Infinity</code> 和 <code>NaN</code>。</p>
<ul>
<li><p>可以通过除以 0 来得到它, 或者在代码中直接使用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-number">1</span> / <span class="hljs-number">0</span> ); <span class="hljs-comment">// Infinity</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Infinity</span> ); <span class="hljs-comment">// Infinity</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>NaN</code> 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;not a number&quot;</span> / <span class="hljs-number">2</span> ); <span class="hljs-comment">// NaN，这样的除法是错误的</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>NaN</code> 是粘性的。任何对 <code>NaN</code> 的进一步数学运算都会返回 <code>NaN</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">NaN</span> + <span class="hljs-number">1</span> ); <span class="hljs-comment">// NaN</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-number">3</span> * <span class="hljs-title class_">NaN</span> ); <span class="hljs-comment">// NaN</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;not a number&quot;</span> / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> ); <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 只有一个例外：NaN ** 0 (幂) 结果为 1</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Bigint-类型"><a href="#Bigint-类型" class="headerlink" title="Bigint 类型"></a>Bigint 类型</h4><ul>
<li><p>用于任意长度的整数。</p>
</li>
<li><p>“number” 类型无法表示大于 $(2^{53}-1)$ (即 <code>9007199254740991</code>)，或小于 $-(2^{53}-1)$ 的整数</p>
</li>
<li><p>更准确的说，“number” 类型可以存储更大的整数(最多 1.7976931348623157 * $10^{308}$)，但超出安全整数范围 $±(2^{53}-1)$ 会出现精度问题，因为并非所有数字都适合固定的 64 位存储。因此，可能存储的是“近似值”。</p>
</li>
<li><p>可以通过将 <code>n</code> 附加到整数字段的末尾来创建 <code>BigInt</code> 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 尾部的 &quot;n&quot; 表示这是一个 BigInt 类型</span><br><span class="hljs-keyword">const</span> bigInt = <span class="hljs-number">1234567890123456789012345678901234567890n</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><ul>
<li><p>用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</p>
</li>
<li><p>JavaScript 中的字符串必须被括在引号里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&#x27;Single quotes are ok too&#x27;</span>;<br><span class="hljs-keyword">let</span> phrase = <span class="hljs-string">`can embed another <span class="hljs-subst">$&#123;str&#125;</span>`</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别。</p>
</li>
<li><p>反引号是 <strong>功能扩展</strong> 引号。它们允许我们通过将变量和表达式包装在 <code>$&#123;...&#125;</code> 中，来将它们嵌入到字符串中。</p>
</li>
<li><p><strong>JavaScript 中没有</strong> <em>character</em> <strong>类型。</strong></p>
</li>
</ul>
<h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h4><ul>
<li>用于 <code>true</code> 和 <code>false</code>。</li>
</ul>
<h4 id="null-值"><a href="#null-值" class="headerlink" title="null 值"></a>null 值</h4><ul>
<li>用于未知的值: 只有一个 <code>null</code> 值的独立类型</li>
<li><strong>不是</strong>一个 “对不存在的 <code>object</code> 的引用” 或者 “null 指针”</li>
</ul>
<h4 id="undefined-值"><a href="#undefined-值" class="headerlink" title="undefined 值"></a>undefined 值</h4><ul>
<li><p>用于未定义的值: 只有一个 <code>undefined</code> 值的独立类型。</p>
</li>
<li><p>通常，使用 <code>null</code> 将一个“空”或者“未知”的值写入变量中，而 <code>undefined</code> 则保留作为未进行初始化的事物的默认初始值</p>
</li>
</ul>
<h4 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h4><ul>
<li>用于创建对象的唯一标识符</li>
</ul>
<h4 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h4><ul>
<li>用于储存数据集合和更复杂的实体</li>
</ul>
<h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><ul>
<li><p>通常用作 <code>typeof x</code>，但 <code>typeof(x)</code> 也可行。</p>
</li>
<li><p>以字符串的形式返回类型名称，例如 <code>&quot;string&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>) <span class="hljs-comment">// &quot;symbol&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span> <span class="hljs-comment">// &quot;object&quot;  </span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;object&quot; </span><br><span class="hljs-keyword">typeof</span> alert <span class="hljs-comment">// &quot;function&quot;  </span><br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><code>typeof null</code> 会返回 <code>&quot;object&quot;</code> —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 <code>object</code></p>
<p>在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 <code>object</code> 类型。但是 <code>typeof</code> 会对函数区分对待，并返回 function</p>
</blockquote>
<h3 id="1-6-交互：alert、prompt、confirm"><a href="#1-6-交互：alert、prompt、confirm" class="headerlink" title="1.6 交互：alert、prompt、confirm"></a>1.6 交互：alert、prompt、confirm</h3><p><code>alert</code></p>
<ul>
<li>显示信息。对 <code>alert</code> 的调用没有返回值。或者说返回的是 <code>undefined</code>。</li>
</ul>
<p><code>prompt</code></p>
<ul>
<li>显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 Esc 键返回 <code>null</code>。以字符串形式返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">result = <span class="hljs-title function_">prompt</span>(title, [<span class="hljs-keyword">default</span>]);<br></code></pre></td></tr></table></figure>

<p><code>confirm</code></p>
<ul>
<li>显示信息等待用户点击确定或取消。点击确定返回 <code>true</code>，点击取消或按下 Esc 键返回 <code>false</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> isBoss = <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;Are you the boss?&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。</p>
<p>上述所有方法共有两个限制：</p>
<ol>
<li>模态窗口的确切位置由浏览器决定。通常在页面中心。</li>
<li>窗口的确切外观也取决于浏览器。我们不能修改它。</li>
</ol>
<h3 id="1-7-类型转换"><a href="#1-7-类型转换" class="headerlink" title="1.7 类型转换"></a>1.7 类型转换</h3><p>有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。</p>
<p><strong>字符串转换</strong> —— 转换发生在输出内容<code>alert</code>的时候，也可以通过 <code>String(value)</code> 进行显式转换。原始类型值的 string 类型转换通常是很明显的。</p>
<p><strong>数字型转换</strong> —— 转换发生在进行算术操作时，也可以通过 <code>Number(value)</code> 进行显式转换。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">变成</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>NaN</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>0</code></td>
</tr>
<tr>
<td align="left"><code>true / false</code></td>
<td align="left"><code>1 / 0</code></td>
</tr>
<tr>
<td align="left"><code>string</code></td>
<td align="left">“按原样读取”字符串，两端的空白字符会被忽略。空字符串变成 <code>0</code>。转换出错则输出 <code>NaN</code>。</td>
</tr>
</tbody></table>
<p><strong>布尔型转换</strong> —— 转换发生在进行逻辑操作时，也可以通过 <code>Boolean(value)</code> 进行显式转换。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">变成</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>&quot;&quot;</code></td>
<td align="left"><code>false</code></td>
</tr>
<tr>
<td align="left">其他值</td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<p>上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：</p>
<ul>
<li>对 <code>undefined</code> 进行数字型转换时，输出结果为 <code>NaN</code>，而非 <code>0</code></li>
<li>对 <code>&quot;0&quot;</code> 和只有空格的字符串(比如：<code>&quot; &quot;</code>)进行布尔型转换时，输出结果为 <code>true</code></li>
</ul>
<h3 id="1-8-基础运算符，数学运算"><a href="#1-8-基础运算符，数学运算" class="headerlink" title="1.8 基础运算符，数学运算"></a>1.8 基础运算符，数学运算</h3><p><strong>+, -, *, &#x2F;, %, *</strong>*</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-number">2</span> ** <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2² = 4</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-number">8</span> ** (<span class="hljs-number">1</span>/<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 2(1/3 次方与立方根相同)</span><br></code></pre></td></tr></table></figure>

<p><strong>用二元运算符 + 连接字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;my&quot;</span> + <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-title function_">alert</span>(s); <span class="hljs-comment">// mystring</span><br></code></pre></td></tr></table></figure>

<ul>
<li>注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;1&#x27;</span> ); <span class="hljs-comment">// &quot;41&quot;</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-number">2</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">// &quot;122&quot;</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-number">6</span> - <span class="hljs-string">&#x27;2&#x27;</span> ); <span class="hljs-comment">// 4，将 &#x27;2&#x27; 转换为数字</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;6&#x27;</span> / <span class="hljs-string">&#x27;2&#x27;</span> ); <span class="hljs-comment">// 3，将两个运算元都转换为数字</span><br></code></pre></td></tr></table></figure>

<p><strong>数字转化，一元运算符 +</strong></p>
<p>一元运算符加号，或者说，加号 <code>+</code> 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 <code>+</code> 则会将其转化为数字。它的效果和 <code>Number(...)</code> 相同，但是更加简短。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对数字无效</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-title function_">alert</span>( +x ); <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 转化非数字</span><br><span class="hljs-title function_">alert</span>( +<span class="hljs-literal">true</span> ); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">alert</span>( +<span class="hljs-string">&quot;&quot;</span> );   <span class="hljs-comment">// 0</span><br><br><span class="hljs-keyword">let</span> apples = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">let</span> oranges = <span class="hljs-string">&quot;3&quot;</span>;<br><span class="hljs-comment">// 在二元运算符加号起作用之前，所有的值都被转化为了数字</span><br><span class="hljs-title function_">alert</span>( +apples + +oranges ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>

<p><strong>逗号运算符</strong></p>
<ul>
<li><p>逗号运算符能让我们处理多个语句，使用 <code>,</code> 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-number">3</span> + <span class="hljs-number">4</span>);<br><br><span class="hljs-title function_">alert</span>(a); <span class="hljs-comment">// 7(3 + 4 的结果)</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-9-值的比较"><a href="#1-9-值的比较" class="headerlink" title="1.9 值的比较"></a>1.9 值的比较</h3><ul>
<li><p>字符串的比较，会按照“词典”顺序逐字符地比较大小。</p>
<ul>
<li><code>&quot;a&quot;</code> 大于 <code>&quot;A&quot;</code></li>
</ul>
</li>
<li><p>当对不同类型的值进行比较时，它们会先被转化为数字(不包括严格相等检查)再进行比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-number">1</span> ); <span class="hljs-comment">// true，字符串 &#x27;2&#x27; 会被转化为数字 2</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&#x27;01&#x27;</span> == <span class="hljs-number">1</span> ); <span class="hljs-comment">// true，字符串 &#x27;01&#x27; 会被转化为数字 1</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">true</span> == <span class="hljs-number">1</span> ); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">false</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</strong></p>
</li>
<li><p>在非严格相等 <code>==</code> 下，<code>null</code> 和 <code>undefined</code> 相等且各自不等于任何其他的值。</p>
</li>
<li><p>在使用 <code>&gt; &gt;=</code> 或 <code>&lt; &lt;=</code> 进行比较时，需要注意变量可能为 <code>null/undefined</code> 的情况。比较好的方法是单独检查变量是否等于 <code>null/undefined</code>。</p>
<ul>
<li><code>null/undefined</code> 会被转化为数字：<code>null</code> 被转化为 <code>0</code>，<code>undefined</code> 被转化为 <code>NaN</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>奇怪的结果：null vs 0</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> &gt; <span class="hljs-number">0</span> );  <span class="hljs-comment">// (1) false</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// (2) false</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">null</span> &gt;= <span class="hljs-number">0</span> ); <span class="hljs-comment">// (3) true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>这是因为相等性检查 <code>==</code> 和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。</p>
</li>
<li><p>进行值的比较时，<code>null</code> 会被转化为数字，因此它被转化为了 <code>0</code>。</p>
<ul>
<li>(3)中 <code>null &gt;= 0</code> 返回值是 true</li>
<li>(1)中 <code>null &gt; 0</code> 返回值是 false</li>
</ul>
</li>
<li><p>另一方面，<code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值</p>
<ul>
<li>(2)中 <code>null == 0</code> 会返回 false。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>特立独行的 undefined</strong></p>
<p><code>undefined</code> 不应该被与其他值进行比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> &gt; <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (1)</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> &lt; <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (2)</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-literal">undefined</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (3)</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>(1)</code> 和 <code>(2)</code> 都返回 <code>false</code> 是因为 <code>undefined</code> 在比较中被转换为了 <code>NaN</code>，而 <code>NaN</code> 是一个特殊的数值型值，它与任何值进行比较都会返回 <code>false</code>。</li>
<li><code>(3)</code> 返回 <code>false</code> 是因为这是一个相等性检查，而 <code>undefined</code> 只与 <code>null</code> 相等，不会与其他值相等。</li>
</ul>
</blockquote>
<h3 id="1-10-逻辑运算符"><a href="#1-10-逻辑运算符" class="headerlink" title="1.10 逻辑运算符"></a>1.10 逻辑运算符</h3><p><strong>或运算寻找第一个真值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">result = value1 || value2 || value3;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>或运算将返回第一个真值，如果不存在真值，就返回该链的最后一个值</p>
</li>
<li><p>获取变量列表或者表达式中的第一个真值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">let</span> lastName = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">let</span> nickName = <span class="hljs-string">&quot;SuperCoder&quot;</span>;<br><br><span class="hljs-title function_">alert</span>( firstName || lastName || nickName || <span class="hljs-string">&quot;Anonymous&quot;</span>); <span class="hljs-comment">// SuperCoder</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>短路求值(Short-circuit evaluation)</p>
<ul>
<li>有时，人们利用这个特性，只在左侧的条件为假时才执行命令</li>
</ul>
</li>
</ul>
<p><strong>与运算寻找第一个假值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">result = value1 &amp;&amp; value2 &amp;&amp; value3;<br></code></pre></td></tr></table></figure>

<ul>
<li>与运算返回第一个假值，如果没有假值就返回最后一个值</li>
</ul>
<blockquote>
<p>与运算 <code>&amp;&amp;</code> 在或运算 <code>||</code> 之前进行</p>
<ul>
<li>与运算 <code>&amp;&amp;</code> 的优先级比或运算 <code>||</code> 要高</li>
</ul>
<p>不要用 <code>||</code> 或 <code>&amp;&amp;</code> 来取代 <code>if</code></p>
</blockquote>
<p><strong><code>!</code>(非)</strong></p>
<ul>
<li><p><strong>两个非运算 <code>!!</code> 有时候用来将某个值转化为布尔类型：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( !!<span class="hljs-string">&quot;non-empty string&quot;</span> ); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">alert</span>( !!<span class="hljs-literal">null</span> ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>有更多详细的方法可以完成同样的事 —— 一个内建的 <code>Boolean</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&quot;non-empty string&quot;</span>) ); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">null</span>) ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>非运算符 <code>!</code> 的优先级在所有逻辑运算符里面最高，所以它总是在 <code>&amp;&amp;</code> 和 <code>||</code> 之前执行。</p>
</li>
</ul>
<h3 id="1-11-空值合并运算符’-’"><a href="#1-11-空值合并运算符’-’" class="headerlink" title="1.11 空值合并运算符’??’"></a>1.11 空值合并运算符’??’</h3><ul>
<li><p>当一个值既不是 <code>null</code> 也不是 <code>undefined</code> 时，我们将其称为“已定义的(defined)”。</p>
<ul>
<li><p><code>a ?? b</code> 的结果是：</p>
<ul>
<li>如果 <code>a</code> 是已定义的，则结果为 <code>a</code>，</li>
<li>如果 <code>a</code> 不是已定义的，则结果为 <code>b</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>??</code> 的常见使用场景是提供默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> firstName = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> lastName = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> nickName = <span class="hljs-string">&quot;Supercoder&quot;</span>;<br><br><span class="hljs-comment">// 显示第一个已定义的值：</span><br><span class="hljs-title function_">alert</span>(firstName ?? lastName ?? nickName ?? <span class="hljs-string">&quot;匿名&quot;</span>); <span class="hljs-comment">// Supercoder</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>与<code>||</code>比较</strong></p>
<ul>
<li><p>它们之间重要的区别是：</p>
<ul>
<li><code>||</code> 返回第一个 <strong>真</strong> 值。</li>
<li><code>??</code> 返回第一个 <strong>已定义的</strong> 值。</li>
</ul>
</li>
<li><p>换句话说，<code>||</code> 无法区分 <code>false</code>、<code>0</code>、空字符串 <code>&quot;&quot;</code> 和 <code>null/undefined</code>。它们都一样 —— 假值(falsy values)。如果其中任何一个是 <code>||</code> 的第一个参数，那么我们将得到第二个参数作为结果。</p>
</li>
<li><p><code>??</code> 运算符的优先级与 <code>||</code> 相同</p>
<ul>
<li>这意味着，就像 <code>||</code> 一样，空值合并运算符在 <code>=</code> 和 <code>?</code> 运算前计算，但在大多数其他运算(例如 <code>+</code> 和 <code>*</code>)之后计算。</li>
</ul>
</li>
<li><p>出于安全原因，JavaScript 禁止将 <code>??</code> 运算符与 <code>&amp;&amp;</code> 和 <code>||</code> 运算符一起使用，除非使用括号明确指定了优先级。</p>
</li>
</ul>
<h3 id="1-12-循环：while和for"><a href="#1-12-循环：while和for" class="headerlink" title="1.12 循环：while和for"></a>1.12 循环：while和for</h3><ul>
<li><p><strong>禁止</strong> <code>break/continue</code> <strong>在 ‘?’ 的右边</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(i &gt; <span class="hljs-number">5</span>) ? <span class="hljs-title function_">alert</span>(i) : <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 代码会停止运行，并显示有语法错误。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>break&#x2F;continue 标签</strong></p>
<ul>
<li><p><strong>标签</strong> 是在循环之前带有冒号的标识符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">labelName</span>: <span class="hljs-keyword">for</span> (...) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>break &lt;labelName&gt;</code> 语句跳出循环至标签处：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">outer</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>    <span class="hljs-keyword">let</span> input = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">`Value at coords (<span class="hljs-subst">$&#123;i&#125;</span>,<span class="hljs-subst">$&#123;j&#125;</span>)`</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-comment">// 如果是空字符串或被取消，则中断并跳出这两个循环。</span><br>    <span class="hljs-keyword">if</span> (!input) <span class="hljs-keyword">break</span> outer; <span class="hljs-comment">// (*)</span><br>  &#125;<br>&#125;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Done!&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>我们还可以将标签移至单独一行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">outer</span>:<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123; ... &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>continue</code> 指令也可以与标签一起使用。在这种情况下，执行跳转到标记循环的下一次迭代。</p>
</li>
</ul>
</li>
<li><p><strong>标签并不允许“跳到”所有位置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">break</span> label;  <span class="hljs-comment">// 跳转至下面的 label 处(无效)</span><br><br><span class="hljs-attr">label</span>: <span class="hljs-keyword">for</span> (...)<br></code></pre></td></tr></table></figure>

<ul>
<li><code>break</code> 指令必须在代码块内。从技术上讲，任何被标记的代码块都有效，例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">label</span>: &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">break</span> label; <span class="hljs-comment">// 有效</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>continue</code> 只有在循环内部才可行。</li>
</ul>
</li>
</ul>
<h3 id="1-14-switch语句"><a href="#1-14-switch语句" class="headerlink" title="1.14 switch语句"></a>1.14 switch语句</h3><ul>
<li><p><code>switch/case</code> 有通过 case 进行“分组”的能力，其实是 switch 语句没有 <code>break</code> 时的副作用。</p>
</li>
<li><p>这里的相等是<strong>严格相等</strong>。被比较的值必须是相同的类型才能进行匹配。</p>
</li>
</ul>
<h3 id="1-15-函数"><a href="#1-15-函数" class="headerlink" title="1.15 函数"></a>1.15 函数</h3><ul>
<li>作为参数传递给函数的值，会被复制到函数的局部变量。</li>
<li>如果在函数内部声明了同名变量，那么函数会 <strong>遮蔽</strong> 外部变量。</li>
<li>函数可以返回值。如果没有返回值或为空值，则其返回的结果是 <code>undefined</code>。</li>
</ul>
<blockquote>
<p>参数(parameter)是函数声明中括号内列出的变量(它是函数声明时的术语)</p>
<p>参数(argument)是调用函数时传递给函数的值(它是函数调用时的术语)</p>
</blockquote>
<ul>
<li>如果一个函数被调用，但有参数(argument)未被提供，那么相应的值就会变成 <code>undefined</code>。</li>
<li>我们可以使用 <code>=</code> 为函数声明中的参数指定所谓的“默认”(如果对应参数的值未被传递则使用)值：</li>
</ul>
<p><strong>不要在</strong> <code>return</code> <strong>与返回值之间添加新行</strong></p>
<ul>
<li>JavaScript 默认会在 <code>return</code> 之后加上分号。</li>
</ul>
<h3 id="1-16-函数表达式"><a href="#1-16-函数表达式" class="headerlink" title="1.16 函数表达式"></a>1.16 函数表达式</h3><ul>
<li><p>另一种创建函数的语法称为 <strong>函数表达式</strong>。它允许我们在任何表达式的中间创建一个新函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span> );<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>function</code> 关键字后面没有函数名。函数表达式允许省略函数名。</li>
</ul>
</li>
<li><p><strong>函数是值</strong>。它们可以在代码的任何地方被分配，复制或声明。</p>
<ul>
<li><p>我们还可以用 <code>alert</code> 显示这个变量的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span> );<br>&#125;<br><span class="hljs-keyword">let</span> func = sayHi; <span class="hljs-comment">// 复制</span><br><br><span class="hljs-title function_">alert</span>( sayHi ); <span class="hljs-comment">// 显示函数源代码</span><br><span class="hljs-title function_">func</span>(); <span class="hljs-comment">// 执行</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>回调函数</strong></p>
<ul>
<li><p>函数需要提出 <code>question</code>(问题)，并根据用户的回答，调用 <code>yes()</code> 或 <code>no()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()<br>  <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showOk</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;You agreed.&quot;</span> );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showCancel</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;You canceled the execution.&quot;</span> );<br>&#125;<br><br><span class="hljs-comment">// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask</span><br><span class="hljs-title function_">ask</span>(<span class="hljs-string">&quot;Do you agree?&quot;</span>, showOk, showCancel);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>ask</code> 的两个参数值 <code>showOk</code> 和 <code>showCancel</code> 可以被称为 <strong>回调函数</strong> 或简称 <strong>回调</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>匿名函数</strong></p>
<ul>
<li><p>我们可以使用函数表达式来编写一个等价的、更简洁的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()<br>  <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();<br>&#125;<br><br><span class="hljs-title function_">ask</span>(<br>  <span class="hljs-string">&quot;Do you agree?&quot;</span>,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;You agreed.&quot;</span>); &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;You canceled the execution.&quot;</span>); &#125;<br>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>这里直接在 <code>ask(...)</code> 调用内进行函数声明。这两个函数没有名字，所以叫 <strong>匿名函数</strong>。这样的函数在 <code>ask</code> 外无法访问(因为没有对它们分配变量)</p>
</li>
</ul>
</li>
<li><p>在执行代码块之前，内部算法会<strong>先处理函数声明</strong>。所以函数声明在其被声明的代码块内的任何位置都是可见的。</p>
</li>
<li><p><strong>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。</strong></p>
</li>
<li><p><strong>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</strong></p>
<ul>
<li><p>可以使用函数表达式，并将函数赋值给在 <code>if</code> 外声明的变量，并具有正确的可见性。</p>
</li>
<li><p>或者可以使用问号运算符 <code>?</code> 来进一步对代码进行简化：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;What is your age?&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-keyword">let</span> welcome = (age &lt; <span class="hljs-number">18</span>) ?<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>); &#125; :<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Greetings!&quot;</span>); &#125;;<br><br><span class="hljs-title function_">welcome</span>(); <span class="hljs-comment">// 现在可以了</span><br></code></pre></td></tr></table></figure>

<p>在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。</p>
<h3 id="1-17-箭头函数，基础知识"><a href="#1-17-箭头函数，基础知识" class="headerlink" title="1.17 箭头函数，基础知识"></a>1.17 箭头函数，基础知识</h3><p>创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好。它被称为“箭头函数”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2, ..., argN</span>) =&gt; expression;<br></code></pre></td></tr></table></figure>

<p>这里创建了一个函数 <code>func</code>，它接受参数 <code>arg1..argN</code>，然后使用参数对右侧的 <code>expression</code> 求值并返回其结果。</p>
<ul>
<li><p>如果我们只有一个参数，可以省略掉参数外的圆括号，使代码更短</p>
</li>
<li><p>如果没有参数，括号则是空的(但括号必须保留)</p>
</li>
<li><p>多行的箭头函数</p>
</li>
</ul>
<p>有时我们需要更复杂一点的函数，比如带有多行的表达式或语句。在这种情况下，我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 <code>return</code> 才能返回值(就像常规函数一样)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;  <span class="hljs-comment">// 花括号表示开始一个多行函数</span><br>  <span class="hljs-keyword">let</span> result = a + b;<br>  <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<h2 id="2-Object-对象-：基础知识"><a href="#2-Object-对象-：基础知识" class="headerlink" title="2. Object(对象)：基础知识"></a>2. Object(对象)：基础知识</h2><h3 id="2-1-对象"><a href="#2-1-对象" class="headerlink" title="2.1 对象"></a>2.1 对象</h3><p>可以通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>&#123;…&#125;</code> 来创建对象。一个属性就是一个键值对（“key: value”），其中键（<code>key</code>）是一个字符串（也叫做属性名），值（<code>value</code>）可以是任何值。</p>
<ul>
<li><p>可以用下面两种语法中的任一种来创建一个空的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// “构造函数” 的语法</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;;  <span class="hljs-comment">// “字面量” 的语法</span><br><br><span class="hljs-keyword">let</span> user = &#123;     <span class="hljs-comment">// 一个对象</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,  <span class="hljs-comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>        <span class="hljs-comment">// 键 &quot;age&quot;，值 30</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以使用点符号访问属性值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 读取文件的属性：</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">age</span> ); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>属性的值可以是任意类型，如添加一个布尔类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">user.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以用 <code>delete</code> 操作符移除属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> user.<span class="hljs-property">age</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>也可以用多字词语来作为属性名，但必须给它们加上引号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-string">&quot;likes birds&quot;</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 多词属性名必须加引号</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>对于多词属性，点操作就不能用了，另一种方法，就是使用方括号，可用于任何字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-comment">// 设置</span><br>user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 读取</span><br><span class="hljs-title function_">alert</span>(user[<span class="hljs-string">&quot;likes birds&quot;</span>]); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">delete</span> user[<span class="hljs-string">&quot;likes birds&quot;</span>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>方括号同样提供了一种可以通过任意表达式来获取属性名的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;likes birds&quot;</span>;<br><br><span class="hljs-comment">// 跟 user[&quot;likes birds&quot;] = true; 一样</span><br>user[key] = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，变量 <code>key</code> 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。</p>
</li>
<li><p>当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 <strong>计算属性</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br><br><span class="hljs-keyword">let</span> bag = &#123;<br>  [fruit]: <span class="hljs-number">5</span>, <span class="hljs-comment">// 属性名是从 fruit 变量中得到的</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( bag.<span class="hljs-property">apple</span> ); <span class="hljs-comment">// 5 如果 fruit=&quot;apple&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>我们可以在方括号中使用更复杂的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;<br>  [fruit + <span class="hljs-string">&#x27;Computers&#x27;</span>]: <span class="hljs-number">5</span> <span class="hljs-comment">// bag.appleComputers = 5</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。</p>
</li>
<li><p>所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。</p>
</li>
</ul>
</li>
<li><p>属性值简写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: name,<br>    <span class="hljs-attr">age</span>: age,<br>    <span class="hljs-comment">// ……其他的属性</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">makeUser</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure>

<p>在上面的例子中，属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 <strong>属性值缩写</strong> 方法，使属性名变得更短。</p>
<p>可以用 <code>name</code> 来代替 <code>name:name</code> 像下面那样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    name, <span class="hljs-comment">// 与 name: name 相同</span><br>    age,  <span class="hljs-comment">// 与 age: age 相同</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以把属性名简写方式和正常方式混用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  name,  <span class="hljs-comment">// 与 name:name 相同</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>属性命名没有限制。属性名可以是任何字符串或者 symbol</p>
<ul>
<li><p>其他类型会被自动地转换为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span><br>&#125;;<br><br><span class="hljs-comment">// 都会输出相同的属性(数字 0 被转为字符串 &quot;0&quot;)</span><br><span class="hljs-title function_">alert</span>( obj[<span class="hljs-string">&quot;0&quot;</span>] ); <span class="hljs-comment">// test</span><br><span class="hljs-title function_">alert</span>( obj[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// test (相同的属性)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>这里有个小陷阱：一个名为 <code>__proto__</code> 的属性。我们不能将它设置为一个非对象的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">__proto__</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 分配一个数字</span><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// [object Object] —— 值为对象，与预期结果不同</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>属性存在性测试，”in”操作符</p>
<ul>
<li><p>相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！</p>
</li>
<li><p>读取不存在的属性只会得到 <code>undefined</code>。所以我们可以很容易地判断一个属性是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">noSuchProperty</span> === <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true: 没有这个属性</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>检查属性是否存在的操作符 <code>&quot;in&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，user.age 存在</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;blabla&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// false，user.blabla 不存在。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>请注意，<code>in</code> 的左边必须是 <strong>属性名</strong>。通常是一个带引号的字符串。</p>
<p>如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;age&quot;</span>;<br><span class="hljs-title function_">alert</span>( key <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，属性 &quot;age&quot; 存在</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>为何会有 <code>in</code> 运算符呢？</p>
<p>属性存在，但存储的值是 <code>undefined</code> 的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-literal">undefined</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-property">test</span> ); <span class="hljs-comment">// 显示 undefined，所以属性不存在？</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-keyword">in</span> obj ); <span class="hljs-comment">// true，属性存在！</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>“for..in” 循环</strong></p>
<ul>
<li><p>为了遍历一个对象的所有键(key)，可以使用一个特殊形式的循环：<code>for..in</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;<br>  <span class="hljs-comment">// keys</span><br>  <span class="hljs-title function_">alert</span>( key );  <span class="hljs-comment">// name, age, isAdmin</span><br>  <span class="hljs-comment">// 属性键的值</span><br>  <span class="hljs-title function_">alert</span>( user[key] ); <span class="hljs-comment">// John, 30, true</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>排序</p>
<ul>
<li><p>对象有顺序吗？如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？</p>
</li>
<li><p>整数属性会被进行排序，其他属性则按照创建的顺序显示。详情如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> codes = &#123;<br>  <span class="hljs-string">&quot;49&quot;</span>: <span class="hljs-string">&quot;Germany&quot;</span>,<br>  <span class="hljs-string">&quot;41&quot;</span>: <span class="hljs-string">&quot;Switzerland&quot;</span>,<br>  <span class="hljs-string">&quot;44&quot;</span>: <span class="hljs-string">&quot;Great Britain&quot;</span>,<br>  <span class="hljs-comment">// ..,</span><br>  <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> code <span class="hljs-keyword">in</span> codes) &#123;<br>  <span class="hljs-title function_">alert</span>(code); <span class="hljs-comment">// 1, 41, 44, 49</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-2-对象引用和复制"><a href="#2-2-对象引用和复制" class="headerlink" title="2.2 对象引用和复制"></a>2.2 对象引用和复制</h3><ul>
<li><p>对象通过引用被赋值和拷贝。<strong>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。</strong>因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p>
</li>
<li><p>所有通过被拷贝的引用的操作(如添加、删除属性)都作用在同一个对象上。</p>
</li>
<li><p>仅当两个对象为同一对象时，两者才相等。<code>==</code>，<code>===</code></p>
</li>
<li><p>我们可以创建一个新对象，通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = &#123;&#125;; <span class="hljs-comment">// 新的空对象</span><br><br><span class="hljs-comment">// 将 user 中所有的属性拷贝到其中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;<br>  clone[key] = user[key];<br>&#125;<br><br><span class="hljs-comment">// 现在 clone 是带有相同内容的完全独立的对象</span><br>clone.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 改变了其中的数据</span><br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 原来的对象中的 name 属性依然是 John</span><br></code></pre></td></tr></table></figure>

<ul>
<li>我们也可以使用 Object.assign 方法来达成同样的效果。</li>
</ul>
</li>
<li><p>为了创建“真正的拷贝”(一个克隆)，我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”(嵌套对象被通过引用进行拷贝)或者使用“深拷贝”函数，例如 <a target="_blank" rel="noopener" href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
<ul>
<li><p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, [src1, src2, src3...])<br></code></pre></td></tr></table></figure>

<ul>
<li>第一个参数 <code>dest</code> 是指目标对象。</li>
<li>更后面的参数 <code>src1, ..., srcN</code>(可按需传递多个参数)是源对象。</li>
<li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。</li>
<li>调用结果返回 <code>dest</code>。</li>
</ul>
</li>
<li><p>我们可以用它来合并多个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> permissions1 = &#123; <span class="hljs-attr">canView</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-keyword">let</span> permissions2 = &#123; <span class="hljs-attr">canEdit</span>: <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, permissions1, permissions2);<br><br><span class="hljs-comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span> &#125;);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>我们也可以用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>深层克隆</p>
<ul>
<li>属性可以是对其他对象的引用。</li>
<li>为了解决这个问题，我们应该使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。</li>
</ul>
</li>
<li><p><strong>使用 const 声明的对象也是可以被修改的</strong></p>
<p>通过引用对对象进行存储的一个重要的副作用是声明为 <code>const</code> 的对象 <strong>可以</strong> 被修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br>user.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// (*)</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Pete</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>user</code> 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改。</p>
</li>
<li><p>换句话说，只有当我们尝试将 <code>user=...</code> 作为一个整体进行赋值时，<code>const user</code> 才会报错。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-垃圾回收"><a href="#2-3-垃圾回收" class="headerlink" title="2.3 垃圾回收"></a>2.3 垃圾回收</h3><ul>
<li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li>
<li>当对象是可达状态时，它一定是存在于内存中的。</li>
<li>被引用与可访问(从一个根)不同：一组相互连接的对象可能整体都不可达</li>
</ul>
<p>垃圾回收的基本算法被称为 “mark-and-sweep”。定期执行以下“垃圾回收”步骤：</p>
<ol>
<li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li>
<li>然后它遍历并“标记”来自它们的所有引用。</li>
<li>然后它遍历标记的对象并标记 <strong>它们的</strong> 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li>
<li>没有被标记的对象都会被删除。</li>
</ol>
<p>一些优化建议：</p>
<ul>
<li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。</li>
<li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。</li>
<li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li>
</ul>
<p>现代引擎实现了垃圾回收的高级算法。</p>
<h3 id="2-4-对象方法，”this”"><a href="#2-4-对象方法，”this”" class="headerlink" title="2.4 对象方法，”this”"></a>2.4 对象方法，”this”</h3><ul>
<li><p>方法示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br>user.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure>

<ul>
<li>我们也可以使用预先声明的函数作为方法，就像这样：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 首先，声明函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 然后将其作为一个方法添加</span><br>user.<span class="hljs-property">sayHi</span> = sayHi;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>方法简写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这些对象作用一样</span><br>user = &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 方法简写看起来更好，对吧？</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span><br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>“this” 不受限制</strong></p>
<ul>
<li>JavaScript 中的 <code>this</code> 可以用于任何函数，即使它不是对象的方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p>
</li>
<li><p>例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br><br><span class="hljs-comment">// 在两个对象中使用相同的函数</span><br>user.<span class="hljs-property">f</span> = sayHi;<br>admin.<span class="hljs-property">f</span> = sayHi;<br><br><span class="hljs-comment">// 这两个调用有不同的 this 值</span><br><span class="hljs-comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span><br>user.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// John(this == user)</span><br>admin.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// Admin(this == admin)</span><br><br>admin[<span class="hljs-string">&#x27;f&#x27;</span>](); <span class="hljs-comment">// Admin(使用点符号或方括号语法来访问这个方法，都没有关系。)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>这个规则很简单：如果 <code>obj.f()</code> 被调用了，则 <code>this</code> 在 <code>f</code> 函数调用期间是 <code>obj</code>。所以在上面的例子中 this 先是 <code>user</code>，之后是 <code>admin</code>。</li>
</ul>
</li>
<li><p><strong>在没有对象的情况下调用：</strong><code>this == undefined</code></p>
<ul>
<li><p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会报错。</p>
</li>
<li><p>在非严格模式的情况下，<code>this</code> 将会是 <strong>全局对象</strong>（浏览器中的 <code>window</code>）。这是一个历史行为，<code>&quot;use strict&quot;</code> 已经将其修复了。</p>
</li>
</ul>
</li>
<li><p><strong>箭头函数没有自己的”this”</strong></p>
<ul>
<li><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部“正常的”函数。</p>
<p>举个例子，这里的 <code>arrow()</code> 使用的 <code>this</code> 来自于外部的 <code>user.sayHi()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ilya&quot;</span>,<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>);<br>    <span class="hljs-title function_">arrow</span>();<br>  &#125;<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Ilya</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-5-构造器和操作符-“new”"><a href="#2-5-构造器和操作符-“new”" class="headerlink" title="2.5 构造器和操作符 “new”"></a>2.5 构造器和操作符 “new”</h3><ul>
<li><p>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jack</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 <code>this</code>。</li>
<li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li>
<li>返回 <code>this</code> 的值。</li>
</ol>
</li>
<li><p>构造函数只能使用 <code>new</code> 来调用。这样的调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</p>
</li>
<li><p>从技术上讲，任何函数(除了箭头函数，它没有自己的 <code>this</code>)都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p>
</li>
<li><p><strong>new function() { … }</strong></p>
<p>如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个函数并立即使用 new 调用它</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// ……用于用户创建的其他代码</span><br>  <span class="hljs-comment">// 也许是复杂的逻辑和语句</span><br>  <span class="hljs-comment">// 局部变量等</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p>
</li>
<li><p>构造器的return</p>
<p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p>
<p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p>
<ul>
<li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li>
<li>如果 <code>return</code> 返回的是一个原始类型或空，则忽略。</li>
</ul>
</li>
<li><p><strong>省略括号</strong></p>
<p>如果没有参数，我们可以省略 <code>new</code> 后的括号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>; <span class="hljs-comment">// &lt;-- 没有参数</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>构造器中的方法</p>
<p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;My name is: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><br>john.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// My name is: John</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">john = &#123;</span><br><span class="hljs-comment">   name: &quot;John&quot;,</span><br><span class="hljs-comment">   sayHi: function() &#123; ... &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-可选链-“-”"><a href="#2-6-可选链-“-”" class="headerlink" title="2.6 可选链 “?.”"></a>2.6 可选链 “?.”</h3><ul>
<li><p>可选链 <code>?.</code> 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。</p>
</li>
<li><p>如果可选链 <code>?.</code> 前面的值为 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回 <code>undefined</code>。</p>
<p>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined(不报错)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>不要过度使用可选链</strong></p>
<ul>
<li>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</li>
<li>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</li>
<li>那么，如果 <code>user</code> 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</li>
</ul>
</li>
<li><p><code>?.</code> <strong>前的变量必须已声明</strong></p>
</li>
<li><p>如果 <code>?.</code> 左边部分不存在，就会立即停止运算(“短路效应”)。</p>
<p>因此，如果在 <code>?.</code> 的右侧有任何进一步的函数调用或操作，它们均不会执行。</p>
</li>
<li><p>其他变体：?.()，?.[]</p>
<ul>
<li><p>将 <code>?.()</code> 用于调用一个可能不存在的函数。</p>
<p>在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userAdmin = &#123;<br>  <span class="hljs-title function_">admin</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;I am admin&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> userGuest = &#123;&#125;;<br><br>userAdmin.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// I am admin</span><br><br>userGuest.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// 啥都没发生(没有这样的方法)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如果我们想使用方括号 <code>[]</code> 而不是点符号 <code>.</code> 来访问属性，语法 <code>?.[]</code> 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;firstName&quot;</span>;<br><br><span class="hljs-keyword">let</span> user1 = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> user2 = <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">alert</span>( user1?.[key] ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user2?.[key] ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>我们可以使用</strong> <code>?.</code> <strong>来安全地读取或删除，但不能写入</strong></p>
<ul>
<li><p>可选链 <code>?.</code> 不能用在赋值语句的左侧。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><br>user?.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// Error，不起作用</span><br><span class="hljs-comment">// 因为它在计算的是：undefined = &quot;John&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可选链 <code>?.</code> 语法有三种形式：</p>
<ol>
<li><code>obj?.prop</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.prop</code>，否则返回 <code>undefined</code>。</li>
<li><code>obj?.[prop]</code> —— 如果 <code>obj</code> 存在则返回 <code>obj[prop]</code>，否则返回 <code>undefined</code>。</li>
<li><code>obj.method?.()</code> —— 如果 <code>obj.method</code> 存在则调用 <code>obj.method()</code>，否则返回 <code>undefined</code>。</li>
</ol>
</li>
</ul>
<h3 id="2-7-symbol类型"><a href="#2-7-symbol类型" class="headerlink" title="2.7 symbol类型"></a>2.7 symbol类型</h3><ul>
<li><p>根据规范，只有两种原始类型可以用作对象属性键：</p>
<ul>
<li><p>字符串类型</p>
</li>
<li><p>symbol 类型</p>
</li>
</ul>
<p>否则，如果使用另一种类型，例如数字，它会被自动转换为字符串。所以 <code>obj[1]</code> 与 <code>obj[&quot;1&quot;]</code> 相同，而 <code>obj[true]</code> 与 <code>obj[&quot;true&quot;]</code> 相同。</p>
</li>
<li><p><code>symbol</code> 是唯一标识符的基本类型</p>
</li>
<li><p>symbol 是使用带有可选描述(name)的 <code>Symbol()</code> 调用创建的。</p>
<p>创建时，我们可以给 symbol 一个描述(也称为 symbol 名)，这在代码调试时非常有用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// id 是描述为 &quot;id&quot; 的 symbol</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：<code>Symbol.for(key)</code> 返回(如果需要的话则创建)一个以 <code>key</code> 作为名字的全局 symbol。使用 <code>Symbol.for</code> 多次调用 <code>key</code> 相同的 symbol 时，返回的就是同一个 symbol。</p>
</li>
<li><p><strong>symbol 不会被自动转换为字符串</strong></p>
<ul>
<li><p>例如，这个 <code>alert</code> 将会提示出错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id); <span class="hljs-comment">// 类型错误：无法将 symbol 值转换为字符串。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个。</li>
</ul>
</li>
<li><p>如果我们真的想显示一个 symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Symbol(id)，现在它有效了</span><br></code></pre></td></tr></table></figure>

<p>或者获取 <code>symbol.description</code> 属性，只显示描述(description)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-property">description</span>); <span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>symbol 有两个主要的使用场景：</p>
<ol>
<li><p>“隐藏” 对象属性。</p>
<ul>
<li><p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 <code>for..in</code> 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p>
</li>
<li><p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p>
</li>
<li><p>但如果我们处于同样的目的，使用字符串 <code>&quot;id&quot;</code> 而不是用 symbol，那么 <strong>就会</strong> 出现冲突：</p>
</li>
</ul>
</li>
<li><p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 <code>Symbol.*</code> 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 <code>Symbol.iterator</code> 来进行 <a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable">迭代</a> 操作，使用 <code>Symbol.toPrimitive</code> 来设置 <a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive">对象原始值的转换</a> 等等。</p>
</li>
</ol>
</li>
</ul>
<p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 symbol。还有一个名为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p>
<ul>
<li><p>对象字面量中的symbol</p>
<ul>
<li><p>如果我们要在对象字面量 <code>&#123;...&#125;</code> 中使用 symbol，则需要使用方括号把它括起来。</p>
<p>就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  [id]: <span class="hljs-number">123</span> <span class="hljs-comment">// 而不是 &quot;id&quot;：123</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这是因为我们需要变量 <code>id</code> 的值作为键，而不是字符串 “id”。</p>
</li>
</ul>
</li>
<li><p>全局symbol</p>
<ul>
<li><p>这里有一个 <strong>全局 symbol 注册表</strong>。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。</p>
</li>
<li><p>要从注册表中读取(不存在则创建)symbol，请使用 <code>Symbol.for(key)</code>。</p>
</li>
<li><p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 symbol，则返回该 symbol，否则将创建一个新 symbol(<code>Symbol(key)</code>)，并通过给定的 <code>key</code> 将其存储在注册表中。</p>
</li>
<li><p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 从全局注册表中读取</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 如果该 symbol 不存在，则创建它</span><br><br><span class="hljs-comment">// 再次读取(可能是在代码中的另一个位置)</span><br><span class="hljs-keyword">let</span> idAgain = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-comment">// 相同的 symbol</span><br><span class="hljs-title function_">alert</span>( id === idAgain ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对于全局 symbol，<code>Symbol.for(key)</code> 按名字返回一个 symbol。相反，通过全局 symbol 返回一个名字，我们可以使用 <code>Symbol.keyFor(sym)</code></p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">let</span> localSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSymbol) ); <span class="hljs-comment">// name，全局 symbol</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(localSymbol) ); <span class="hljs-comment">// undefined，非全局</span><br><br><span class="hljs-title function_">alert</span>( localSymbol.<span class="hljs-property">description</span> ); <span class="hljs-comment">// name</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-8-对象-–-原始值转换"><a href="#2-8-对象-–-原始值转换" class="headerlink" title="2.8 对象 – 原始值转换*"></a>2.8 对象 – 原始值转换*</h3><ul>
<li><p>JavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言(Ruby，C++)不同，我们无法实现特殊的对象处理方法来处理加法(或其他运算)。</p>
<p>在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果(也是一个原始值)。</p>
</li>
<li><p>转换规则</p>
<ul>
<li>没有转换为布尔值。所有的对象在布尔上下文(context)中均为 <code>true</code>，就这么简单。只有字符串和数字转换。</li>
<li>数字转换发生在对象相减或应用数学函数时。例如，<code>Date</code> 对象可以相减，<code>date1 - date2</code> 的结果是两个日期之间的差值。</li>
<li>至于字符串转换 —— 通常发生在我们像 <code>alert(obj)</code> 这样输出一个对象和类似的上下文中。</li>
</ul>
</li>
<li><p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p>
<p>这里有三种类型(hint)：</p>
<ul>
<li><code>&quot;string&quot;</code>(对于 <code>alert</code> 和其他需要字符串的操作)</li>
<li><code>&quot;number&quot;</code>(对于数学运算)</li>
<li><code>&quot;default&quot;</code>(少数运算符，通常对象以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换)</li>
</ul>
<p>规范明确描述了哪个运算符使用哪个 hint。</p>
<p>转换算法是：</p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</li>
<li>否则，如果 hint 是<code>&quot;string&quot;</code><ul>
<li>尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li>
</ul>
</li>
<li>否则，如果 hint 是<code>&quot;number&quot;</code>或者<code>&quot;default&quot;</code><ul>
<li>尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li>
</ul>
</li>
</ol>
<p>所有这些方法都必须返回一个原始值才能工作(如果已定义)。</p>
</li>
<li><p>在实际使用中，通常只实现 <code>obj.toString()</code> 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</p>
</li>
</ul>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><h3 id="3-1-原始类型的方法"><a href="#3-1-原始类型的方法" class="headerlink" title="3.1 原始类型的方法"></a>3.1 原始类型的方法</h3><ul>
<li><p>除 <code>null</code> 和 <code>undefined</code> 以外的原始类型都提供了许多有用的方法。我们后面的章节中学习这些内容。</p>
<ul>
<li><p>例如，字符串方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">str.toUpperCase()</a> 返回一个大写化处理的字符串。</p>
<p>用法演示如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-title function_">alert</span>( str.<span class="hljs-title function_">toUpperCase</span>() ); <span class="hljs-comment">// HELLO</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>很简单，对吧？以下是 <code>str.toUpperCase()</code> 中实际发生的情况：</p>
<ol>
<li>字符串 <code>str</code> 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有可用的方法，例如 <code>toUpperCase()</code>。</li>
<li>该方法运行并返回一个新的字符串(由 <code>alert</code> 显示)。</li>
<li>特殊对象被销毁，只留下原始值 <code>str</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p>从形式上讲，这些方法通过临时对象工作，但 JavaScript 引擎可以很好地调整，以在内部对其进行优化，因此调用它们并不需要太高的成本。</p>
</li>
<li><p><strong>构造器</strong> <code>String/Number/Boolean</code> <strong>仅供内部使用</strong></p>
<ul>
<li><p>像 Java 这样的一些语言允许我们使用 <code>new Number(1)</code> 或 <code>new Boolean(false)</code> 等语法，明确地为原始类型创建“对象包装器”。</p>
<p>在 JavaScript 中，由于历史原因，这也是可以的，但极其 <strong>不推荐</strong>。因为这样会出问题。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span> ); <span class="hljs-comment">// &quot;number&quot;</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// &quot;object&quot;!</span><br></code></pre></td></tr></table></figure>

<p>对象在 <code>if</code> 中始终为真，所以此处的 alert 将显示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> zero = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (zero) &#123; <span class="hljs-comment">// zero 为 true，因为它是一个对象</span><br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;zero is truthy?!?&quot;</span> );<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>另一方面，调用不带 <code>new</code>(关键字)的 <code>String/Number/Boolean</code> 函数是可以的且有效的。它们将一个值转换为相应的类型：转成字符串、数字或布尔值(原始类型)。</p>
<p>例如，下面完全是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 将字符串转成数字</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>null&#x2F;undefined 没有任何方法</strong></p>
</li>
</ul>
<h3 id="3-2-数字类型"><a href="#3-2-数字类型" class="headerlink" title="3.2 数字类型"></a>3.2 数字类型</h3><p>要写有很多零的数字：</p>
<ul>
<li>将 <code>&quot;e&quot;</code> 和 0 的数量附加到数字后。就像：<code>123e6</code> 与 <code>123</code> 后面接 6 个 0 相同。</li>
<li><code>&quot;e&quot;</code> 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 <code>123e-6</code> 表示 <code>0.000123</code>(<code>123</code> 的百万分之一)。</li>
</ul>
<p>对于不同的数字系统：</p>
<ul>
<li>可以直接在十六进制(<code>0x</code>)，八进制(<code>0o</code>)和二进制(<code>0b</code>)系统中写入数字。</li>
<li><code>parseInt(str，base)</code> 将字符串 <code>str</code> 解析为在给定的 <code>base</code> 数字系统中的整数，<code>2 ≤ base ≤ 36</code>。</li>
<li><code>num.toString(base)</code> 将数字转换为在给定的 <code>base</code> 数字系统中的字符串。</li>
<li><strong>使用两个点来调用一个方法</strong><ul>
<li>请注意 <code>123456..toString(36)</code> 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 <code>toString</code>，那么我们需要在它后面放置两个点 <code>..</code>。</li>
<li>如果我们放置一个点：<code>123456.toString(36)</code>，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。</li>
<li>也可以写成 <code>(123456).toString(36)</code>。</li>
</ul>
</li>
</ul>
<p>对于常规数字检测：</p>
<ul>
<li><code>isNaN(value)</code> 将其参数转换为数字，然后检测它是否为 <code>NaN</code></li>
<li><code>isFinite(value)</code> 将其参数转换为数字，如果它是常规数字，则返回 <code>true</code>，而不是 <code>NaN/Infinity/-Infinity</code></li>
</ul>
<p>要将 <code>12pt</code> 和 <code>100px</code> 之类的值转换为数字：</p>
<ul>
<li>使用 <code>parseInt/parseFloat</code> 进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。</li>
</ul>
<p>小数：</p>
<ul>
<li>使用 <code>Math.floor</code>，<code>Math.ceil</code>，<code>Math.trunc</code>，<code>Math.round</code> 或 <code>num.toFixed(precision)</code> 进行舍入。</li>
<li>请确保记住使用小数时会损失精度。</li>
</ul>
<p>更多数学函数：</p>
<ul>
<li>需要时请查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a> 对象。这个库很小，但是可以满足基本的需求。</li>
</ul>
<h3 id="3-3-字符串"><a href="#3-3-字符串" class="headerlink" title="3.3 字符串"></a>3.3 字符串</h3><h3 id="3-4-数组"><a href="#3-4-数组" class="headerlink" title="3.4 数组"></a>3.4 数组</h3><h3 id="3-5-数组方法"><a href="#3-5-数组方法" class="headerlink" title="3.5 数组方法"></a>3.5 数组方法</h3><h3 id="3-6-Iterable-object-可迭代对象"><a href="#3-6-Iterable-object-可迭代对象" class="headerlink" title="3.6 Iterable object(可迭代对象)"></a>3.6 Iterable object(可迭代对象)</h3><h3 id="3-7-Map-and-Set-映射和集合"><a href="#3-7-Map-and-Set-映射和集合" class="headerlink" title="3.7 Map and Set(映射和集合)"></a>3.7 Map and Set(映射和集合)</h3><h3 id="3-8-WeakMap-and-WeakSet-弱映射和弱集合"><a href="#3-8-WeakMap-and-WeakSet-弱映射和弱集合" class="headerlink" title="3.8 WeakMap and WeakSet(弱映射和弱集合)"></a>3.8 WeakMap and WeakSet(弱映射和弱集合)</h3><h3 id="3-9-Object-keys，values，entries"><a href="#3-9-Object-keys，values，entries" class="headerlink" title="3.9 Object.keys，values，entries"></a>3.9 Object.keys，values，entries</h3><h3 id="3-10-解构赋值"><a href="#3-10-解构赋值" class="headerlink" title="3.10 解构赋值"></a>3.10 解构赋值</h3><h3 id="3-11-日期和时间"><a href="#3-11-日期和时间" class="headerlink" title="3.11 日期和时间"></a>3.11 日期和时间</h3><h3 id="3-12-JSON方法，toJSON"><a href="#3-12-JSON方法，toJSON" class="headerlink" title="3.12 JSON方法，toJSON"></a>3.12 JSON方法，toJSON</h3><h2 id="4-函数进阶"><a href="#4-函数进阶" class="headerlink" title="4. 函数进阶"></a>4. 函数进阶</h2><h2 id="5-对象属性配置"><a href="#5-对象属性配置" class="headerlink" title="5. 对象属性配置"></a>5. 对象属性配置</h2><h2 id="6-原型，继承"><a href="#6-原型，继承" class="headerlink" title="6. 原型，继承"></a>6. 原型，继承</h2><h3 id="6-1-原型继承"><a href="#6-1-原型继承" class="headerlink" title="6.1 原型继承"></a>6.1 原型继承</h3><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h4><p>在 JavaScript 中，所有的对象都有一个隐藏的 <code>[[Prototype]]</code> 属性，它要么是另一个对象，要么就是 <code>null</code>, 通过 <code>[[Prototype]]</code> 引用的对象被称为“原型”。</p>
<ul>
<li>我们可以使用 <code>obj.__proto__</code> 访问它(历史遗留下来的 getter&#x2F;setter)。</li>
<li><strong>只能有一个</strong> <code>[[Prototype]]</code>。一个对象不能从其他两个对象获得继承</li>
</ul>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222152010231.png" alt="image-20230222152010231" style="zoom:80%;" />

<p>当我们从 <code>object</code> 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。在编程中，这被称为<strong>“原型继承”</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<br>	<span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-keyword">let</span> rabbit = &#123;<br>	<span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br>rabbit.<span class="hljs-property">__proto__</span> = animal; <span class="hljs-comment">// (*) 将 animal 设置为 rabbit 的原型。</span><br><br><span class="hljs-comment">// 现在这两个属性我们都能在 rabbit 中找到：</span><br><span class="hljs-title function_">alert</span>( rabbit.<span class="hljs-property">eats</span> ); <span class="hljs-comment">// true (**)</span><br><span class="hljs-title function_">alert</span>( rabbit.<span class="hljs-property">jumps</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p><strong>原型链</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<br>    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-title function_">walk</span>(<span class="hljs-params"></span>) &#123;<br>    	<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Animal walk&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> rabbit = &#123;<br>    <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">__proto__</span>: animal<br>&#125;;<br><br><span class="hljs-keyword">let</span> longEar = &#123;<br>    <span class="hljs-attr">earLength</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">__proto__</span>: rabbit<br>&#125;;<br><br><span class="hljs-comment">// walk 是通过原型链获得的</span><br>longEar.<span class="hljs-title function_">walk</span>(); <span class="hljs-comment">// Animal walk</span><br><span class="hljs-title function_">alert</span>(longEar.<span class="hljs-property">jumps</span>); <span class="hljs-comment">// true（从 rabbit）</span><br></code></pre></td></tr></table></figure>

<p>这里只有两个限制：</p>
<ol>
<li>引用不能形成闭环。如果我们试图给 <code>__proto__</code> 赋值但会导致引用形成闭环时，JavaScript 会抛出错误。</li>
<li><code>__proto__</code> 的值可以是对象，也可以是 <code>null</code>。而其他的类型都会被忽略。</li>
</ol>
<blockquote>
<p><strong><code>__proto__</code> 是 <code>[[Prototype]]</code> 的因历史原因而留下来的 getter&#x2F;setter</strong></p>
<ul>
<li><p><code>__proto__</code> 与内部的 <code>[[Prototype]]</code> <strong>不一样</strong>。<code>__proto__</code> 是 <code>[[Prototype]]</code> 的 getter&#x2F;setter。</p>
</li>
<li><p><code>__proto__</code> 属性有点过时了。它的存在是出于历史的原因，现代编程语言建议我们应该使用函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code> 来取代 <code>__proto__</code> 去 get&#x2F;set 原型。</p>
</li>
<li><p>根据规范，<code>__proto__</code> 必须仅受浏览器环境的支持。但实际上，包括服务端在内的所有环境都支持它，因此我们使用它是非常安全的。</p>
</li>
</ul>
</blockquote>
<h4 id="写入不使用原型"><a href="#写入不使用原型" class="headerlink" title="写入不使用原型"></a>写入不使用原型</h4><p>写&#x2F;删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222152746444.png" alt="image-20230222152746444" style="zoom:80%;" />

<p><strong>“this”的值</strong></p>
<p><code>this</code> 不受原型的影响。</p>
<ul>
<li><p>无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，**<code>this</code> 始终是点符号 <code>.</code> 前面的对象。**</p>
</li>
<li><p>如果我们调用 <code>obj.method()</code>，而且 <code>method</code> 是从原型中获取的，<code>this</code> 仍然会引用 <code>obj</code>。因此，方法始终与当前对象一起使用，即使方法是继承的。</p>
</li>
</ul>
<h4 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h4><ul>
<li><code>for..in</code> 循环在其自身和继承的属性上进行迭代。所有其他的键&#x2F;值获取方法仅对对象本身起作用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<br>  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> rabbit = &#123;<br>  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">__proto__</span>: animal<br>&#125;;<br><br><span class="hljs-comment">// Object.keys 只返回自己的 key</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(rabbit)); <span class="hljs-comment">// jumps</span><br><br><span class="hljs-comment">// for..in 会遍历自己以及继承的键</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> rabbit) <span class="hljs-title function_">alert</span>(prop); <span class="hljs-comment">// jumps，然后是 eats</span><br></code></pre></td></tr></table></figure>

<h3 id="6-2-F-prototype"><a href="#6-2-F-prototype" class="headerlink" title="6.2 F.prototype"></a>6.2 F.prototype</h3><p><code>F.prototype</code> 属性（不要把它与 <code>[[Prototype]]</code> 弄混了）在 <code>new F()</code> 被调用时为新对象的 <code>[[Prototype]]</code> 赋值。</p>
<ul>
<li>这里的 <code>F.prototype</code> 指的是 <code>F</code> 的一个名为 <code>&quot;prototype&quot;</code> 的常规属性</li>
<li><code>F.prototype</code> 的值要么是一个对象，要么就是 <code>null</code>：其他值都不起作用。</li>
<li><code>&quot;prototype&quot;</code> 属性仅当设置在一个构造函数上，并通过 <code>new</code> 调用时，才具有这种特殊的影响。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<br>  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = animal;<br><br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(<span class="hljs-string">&quot;White Rabbit&quot;</span>); <span class="hljs-comment">//  rabbit.__proto__ == animal</span><br><br><span class="hljs-title function_">alert</span>( rabbit.<span class="hljs-property">eats</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222153319547.png" style="zoom:80%;" />

<h4 id="默认的-F-prototype-构造器属性"><a href="#默认的-F-prototype-构造器属性" class="headerlink" title="默认的 F.prototype, 构造器属性"></a>默认的 F.prototype, 构造器属性</h4><p>每个函数都有 <code>&quot;prototype&quot;</code> 属性，即使我们没有提供它。</p>
<p>默认的 <code>&quot;prototype&quot;</code> 是一个只有属性 <code>constructor</code> 的对象，属性 <code>constructor</code> 指向函数自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">// 默认：</span><br><span class="hljs-comment">// Rabbit.prototype = &#123; constructor: Rabbit &#125;</span><br><br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(); <span class="hljs-comment">// 继承自 &#123;constructor: Rabbit&#125;</span><br><span class="hljs-title function_">alert</span>(rabbit.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Rabbit</span>); <span class="hljs-comment">// true (from prototype)</span><br></code></pre></td></tr></table></figure>

<p>所以我们可以通过访问它的 <code>&quot;constructor&quot;</code> 属性来获取一个对象的构造器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。</span><br><span class="hljs-keyword">let</span> rabbit2 = <span class="hljs-keyword">new</span> rabbit.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">&quot;Black Rabbit&quot;</span></span>);<br></code></pre></td></tr></table></figure>

<p>在常规对象上，<code>prototype</code> 没什么特别的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">prototype</span>: <span class="hljs-string">&quot;Bla-bla&quot;</span> <span class="hljs-comment">// 这里只是普通的属性</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="6-3-原生的原型"><a href="#6-3-原生的原型" class="headerlink" title="6.3 原生的原型"></a>6.3 原生的原型</h3><h4 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-title function_">alert</span>( obj ); <span class="hljs-comment">// &quot;[object Object]&quot; ?</span><br></code></pre></td></tr></table></figure>

<p><code>obj = &#123;&#125;</code> 和 <code>obj = new Object()</code> 是一个意思，其中 <code>Object</code> 就是一个内建的对象构造函数，其自身的 <code>prototype</code> 指向一个带有 <code>toString</code> 和其他方法的一个巨大的对象。</p>
<p>当 <code>new Object()</code> 被调用（或一个字面量对象 <code>&#123;...&#125;</code> 被创建），这个对象的 <code>[[Prototype]]</code> 属性被设置为 <code>Object.prototype</code>：</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222154740488.png" alt="image-20230222154740488" style="zoom:80%;" />

<p>可以验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">toString</span> === obj.<span class="hljs-property">__proto__</span>.<span class="hljs-property">toString</span>); <span class="hljs-comment">//true</span><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">toString</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>); <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">// 请注意在 Object.prototype 上方的链中没有更多的 [[Prototype]]</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure>

<h4 id="其他内建原型"><a href="#其他内建原型" class="headerlink" title="其他内建原型"></a>其他内建原型</h4><p>其他内建对象，像 <code>Array</code>、<code>Date</code>、<code>Function</code> 及其他，都在 prototype 上挂载了方法。</p>
<p>例如，当我们创建一个数组 <code>[1, 2, 3]</code>，在内部会默认使用 <code>new Array()</code> 构造器。因此 <code>Array.prototype</code> 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。</p>
<p>按照规范，所有的内建原型顶端都是 <code>Object.prototype</code>。</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222155008991.png" alt="image-20230222155008991" style="zoom:80%;" />

<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>字符串、数字和布尔值并不是对象。但是如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 <code>String</code>、<code>Number</code> 和 <code>Boolean</code> 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。</p>
<p>这些对象对我们来说是无形地创建出来的。大多数引擎都会对其进行优化，但是规范中描述的就是通过这种方式。这些对象的方法也驻留在它们的 prototype 中，可以通过 <code>String.prototype</code>、<code>Number.prototype</code> 和 <code>Boolean.prototype</code> 进行获取。</p>
<blockquote>
<p>特殊值 <code>null</code> 和 <code>undefined</code> 比较特殊。它们没有对象包装器，所以它们没有方法和属性。并且它们也没有相应的原型。</p>
</blockquote>
<blockquote>
<p>原生的原型是可以被修改的, 但这通常是一个很不好的想法。</p>
<p>原型是全局的，所以很容易造成冲突。如果有两个库都添加了 <code>String.prototype.show</code> 方法，那么其中的一个方法将被另一个覆盖。</p>
</blockquote>
<blockquote>
<p><strong>在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。</strong></p>
<p>Polyfilling 是一个术语，表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">repeat</span>) &#123; <span class="hljs-comment">// 如果这儿没有这个方法</span><br>  <span class="hljs-comment">// 那就在 prototype 中添加它</span><br><br>  <span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">repeat</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-comment">// 重复传入的字符串 n 次</span><br><br>    <span class="hljs-comment">// 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）</span><br>    <span class="hljs-comment">// 但即使是不够完美的 polyfill 也常常被认为是足够好的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">join</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;La&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// LaLaLa</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="从原型中继承"><a href="#从原型中继承" class="headerlink" title="从原型中继承"></a>从原型中继承</h4><p>一些原生原型的方法通常会被借用。</p>
<p>例如，如果我们要创建类数组对象，则可能需要向其中复制一些 <code>Array</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Hello&quot;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;world!&quot;</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><br>obj.<span class="hljs-property">join</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">join</span>;<br><br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>) ); <span class="hljs-comment">// Hello,world!</span><br></code></pre></td></tr></table></figure>

<p>上面这段代码有效，是因为内建的方法 <code>join</code> 的内部算法只关心正确的索引和 <code>length</code> 属性。它不会检查这个对象是否是真正的数组。许多内建方法就是这样。</p>
<p>另一种方式是通过将 <code>obj.__proto__</code> 设置为 <code>Array.prototype</code>，这样 <code>Array</code> 中的所有方法都自动地可以在 <code>obj</code> 中使用了。</p>
<p>但是如果 <code>obj</code> 已经从另一个对象进行了继承，那么这种方法就不可行了（译注：因为这样会覆盖掉已有的继承。此处 <code>obj</code> 其实已经从 <code>Object</code> 进行了继承，但是 <code>Array</code> 也继承自 <code>Object</code>，所以此处的方法借用不会影响 <code>obj</code> 对原有继承的继承，因为 <code>obj</code> 通过原型链依旧继承了 <code>Object</code>）。请记住，我们<strong>一次只能继承一个对象</strong>。</p>
<p>方法借用很灵活，它允许在需要时混合来自不同对象的方法。</p>
<h3 id="6-4-原型方法，没有-proto-的对象"><a href="#6-4-原型方法，没有-proto-的对象" class="headerlink" title="6.4 原型方法，没有 __proto__ 的对象"></a>6.4 原型方法，没有 <code>__proto__</code> 的对象</h3>
      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/12/30/Node-js/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-08-13 17:28:10
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Language/" title="Language">
                        <b>#</b> Language
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/Language/JavaScript/" title="JavaScript">
                        <b>#</b> JavaScript
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/01/28/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-8-%E9%89%B4%E6%9D%83/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVASCRIPT-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-text">JAVASCRIPT 编程语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">1. 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Hello-world"><span class="toc-text">1.1 Hello,world!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-text">1.2 代码结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%8E%B0%E4%BB%A3%E6%A8%A1%E5%BC%8F%EF%BC%8C%E2%80%9Duse-strict%E2%80%9D"><span class="toc-text">1.3 现代模式，”use strict”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.5 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-%E7%B1%BB%E5%9E%8B"><span class="toc-text">Number 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bigint-%E7%B1%BB%E5%9E%8B"><span class="toc-text">Bigint 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%B1%BB%E5%9E%8B"><span class="toc-text">String 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean-%E7%B1%BB%E5%9E%8B"><span class="toc-text">Boolean 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null-%E5%80%BC"><span class="toc-text">null 值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined-%E5%80%BC"><span class="toc-text">undefined 值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-%E7%B1%BB%E5%9E%8B"><span class="toc-text">Symbol 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-%E7%B1%BB%E5%9E%8B"><span class="toc-text">Object 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">typeof 运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E4%BA%A4%E4%BA%92%EF%BC%9Aalert%E3%80%81prompt%E3%80%81confirm"><span class="toc-text">1.6 交互：alert、prompt、confirm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.7 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-text">1.8 基础运算符，数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E5%80%BC%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">1.9 值的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.10 逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%99-%E2%80%99"><span class="toc-text">1.11 空值合并运算符’??’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-%E5%BE%AA%E7%8E%AF%EF%BC%9Awhile%E5%92%8Cfor"><span class="toc-text">1.12 循环：while和for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-switch%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.14 switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-%E5%87%BD%E6%95%B0"><span class="toc-text">1.15 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-16-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1.16 函数表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">1.17 箭头函数，基础知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Object-%E5%AF%B9%E8%B1%A1-%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">2. Object(对象)：基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.1 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><span class="toc-text">2.2 对象引用和复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">2.3 垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%8C%E2%80%9Dthis%E2%80%9D"><span class="toc-text">2.4 对象方法，”this”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6-%E2%80%9Cnew%E2%80%9D"><span class="toc-text">2.5 构造器和操作符 “new”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%8F%AF%E9%80%89%E9%93%BE-%E2%80%9C-%E2%80%9D"><span class="toc-text">2.6 可选链 “?.”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-symbol%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.7 symbol类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%AF%B9%E8%B1%A1-%E2%80%93-%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.8 对象 – 原始值转换*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3. 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.1 原始类型的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2 数字类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3.3 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%95%B0%E7%BB%84"><span class="toc-text">3.4 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.5 数组方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Iterable-object-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.6 Iterable object(可迭代对象)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-Map-and-Set-%E6%98%A0%E5%B0%84%E5%92%8C%E9%9B%86%E5%90%88"><span class="toc-text">3.7 Map and Set(映射和集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-WeakMap-and-WeakSet-%E5%BC%B1%E6%98%A0%E5%B0%84%E5%92%8C%E5%BC%B1%E9%9B%86%E5%90%88"><span class="toc-text">3.8 WeakMap and WeakSet(弱映射和弱集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-Object-keys%EF%BC%8Cvalues%EF%BC%8Centries"><span class="toc-text">3.9 Object.keys，values，entries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">3.10 解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-text">3.11 日期和时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-JSON%E6%96%B9%E6%B3%95%EF%BC%8CtoJSON"><span class="toc-text">3.12 JSON方法，toJSON</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="toc-text">4. 函数进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-text">5. 对象属性配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E7%BB%A7%E6%89%BF"><span class="toc-text">6. 原型，继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-text">6.1 原型继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prototype"><span class="toc-text">[[Prototype]]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B"><span class="toc-text">写入不使用原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E2%80%A6in-%E5%BE%AA%E7%8E%AF"><span class="toc-text">for…in 循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-F-prototype"><span class="toc-text">6.2 F.prototype</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84-F-prototype-%E6%9E%84%E9%80%A0%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">默认的 F.prototype, 构造器属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-text">6.3 原生的原型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype"><span class="toc-text">Object.prototype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%BB%BA%E5%8E%9F%E5%9E%8B"><span class="toc-text">其他内建原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8E%9F%E5%9E%8B%E4%B8%AD%E7%BB%A7%E6%89%BF"><span class="toc-text">从原型中继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E6%B2%A1%E6%9C%89-proto-%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">6.4 原型方法，没有 __proto__ 的对象</span></a></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + JavaScript%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83 + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2023%2F01%2F10%2FJS%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%2594%25BE%25E5%25BC%2583%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2023/01/10/JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
