<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="南京大学软件学院大三在读" />
  
  
  <title>
    
      软件系统设计-设计(4) 行为型模式 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">软件系统设计-设计(4) 行为型模式</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-08-19 00:15:38
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/NJU/" title="NJU">
                    <b>#</b> NJU
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="软件系统设计">
                    <b>#</b> 软件系统设计
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="1-模板方法模式-类"><a href="#1-模板方法模式-类" class="headerlink" title="1. 模板方法模式(类)"></a>1. 模板方法模式(类)</h2><h3 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1 模式动机"></a>1.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612093800218.png" alt="image-20230612093800218" style="zoom:80%;" /></p>
<ol>
<li>模板方法模式是<strong>基于继承</strong>的代码复用基本技术，模板方法模式的结构和用法也是面向对象设计的核心之一。在模板方法模式中，可以<strong>将相同的代码放在父类中，而将不同的方法实现放在不同的子类中</strong>。</li>
<li>在模板方法模式中，我们需要准备一个抽象类，<strong>将部分逻辑以具体方法以及具体构造函数的形式实现</strong>，<strong>然后声明一些抽象方法来让子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现</strong>，这就是模板方法模式的用意。模板方法模式体现了面向对象的诸多重要思想，是一种使用频率较高的模式。</li>
</ol>
<h3 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2 模式定义"></a>1.2 模式定义</h3><ol>
<li>模板方法模式(Template Method Pattern)：定义一个操作中<strong>算法的骨架</strong>，而将一些步骤<strong>延迟到子类</strong>中，模板方法使得子类<strong>可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。模板方法是一种<strong>类行为型</strong>模式。</li>
<li>Template Method Pattern: Define <strong>the skeleton of an algorithm</strong> in an operation, <strong>deferring some steps to subclasses</strong>. Template Method <strong>lets subclasses redefine certain steps</strong> of an algorithm <strong>without changing the algorithm’s structure</strong>.</li>
</ol>
<h3 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3 模式结构"></a>1.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612094432867.png" alt="image-20230612094432867" style="zoom:80%;" /></p>
<p>模板方法模式包含如下角色：</p>
<ol>
<li>AbstractClass: 抽象类</li>
<li>ConcreteClass: 具体子类</li>
</ol>
<h3 id="1-4-模式分析"><a href="#1-4-模式分析" class="headerlink" title="1.4 模式分析"></a>1.4 模式分析</h3><ol>
<li>模板方法模式是一种类的行为型模式，在它的结构图中<strong>只有类之间的继承关系，没有对象关联关系</strong>。</li>
<li>在模板方法模式的使用过程中，要求开发抽象类和开发具体子类的设计师之间进行协作。一个设计师负责给出<strong>一个算法的轮廓和骨架</strong>，另一些设计师则<strong>负责给出这个算法的各个逻辑步骤</strong>。实现这些具体逻辑步骤的方法称为<strong>基本方法(Primitive Method)</strong>，而将这些基本法方法汇总起来的方法称为<strong>模板方法(Template Method)</strong>，模板方法模式的名字从此而来。</li>
<li>模板方法：一个模板方法是<strong>定义在抽象类中的、把基本操作方法组合在一起</strong>形成一个总算法或一个总行为的方法。</li>
<li>基本方法：基本方法是<strong>实现算法各个步骤的方法</strong>，是模板方法的组成部分。<ol>
<li>抽象方法(Abstract Method)</li>
<li>具体方法(Concrete Method)</li>
<li>钩子方法(Hook Method)：“挂钩”方法和空方法</li>
</ol>
</li>
<li>钩子方法(Hook Method)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">template</span><span class="hljs-params">()</span>&#123;<br>   open();<br>   display();<br>   <span class="hljs-keyword">if</span>(isPrint())&#123;<br>      print();<br>   &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrint</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>典型的抽象类代码如下所示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span>&#123;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//模板方法</span><br>      	primitiveOperation1();<br>      	primitiveOperation2();<br>      	primitiveOperation3();<br>   	&#125;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation1</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//基本方法—具体方法</span><br>   		<span class="hljs-comment">//实现代码</span><br>   	&#125;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//基本方法—抽象方法</span><br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation3</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-comment">//基本方法—钩子方法</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>典型的具体子类代码如下所示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//实现代码</span><br>    &#125;<br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation3</span><span class="hljs-params">()</span> &#123;<br>   		<span class="hljs-comment">//实现代码, 覆盖空方法</span><br>   	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，<strong>具体子类的基本方法将覆盖父类中定义的基本方法，子类的钩子方法也将覆盖父类的钩子方法</strong>，从而可以<strong>通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制</strong>。</li>
</ol>
<h3 id="1-5-模板方法模式实例与解析"><a href="#1-5-模板方法模式实例与解析" class="headerlink" title="1.5 模板方法模式实例与解析"></a>1.5 模板方法模式实例与解析</h3><p>实例一：银行业务办理流程</p>
<p>在银行办理业务时，一般都包含几个基本步骤，首先需要取号排队，然后办理具体业务，最后需要对银行工作人员进行评分。无论具体业务是取款、存款还是转账，其基本流程都一样。现使用模板方法模式模拟银行业务办理流程。模板方法模式</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612094805890.png" alt="image-20230612094805890" style="zoom:80%;" /></p>
<p>实例二：数据库操作模板</p>
<p>对数据库的操作一般包括连接、打开、使用、关闭等步骤，在数据库操作模板类中我们定义了<code>connDB()</code>、<code>openDB()</code>、<code>useDB()</code>、<code>closeDB()</code> 四个方法分别对应这四个步骤。对于不同类型的数据库（如SQL Server和Oracle），其操作步骤都一致，只是连接数据库 <code>connDB()</code> 方法有所区别，现使用模板方法模式对其进行设计。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612094835824.png" alt="image-20230612094835824" style="zoom:80%;" /></p>
<h3 id="1-6-模式优缺点"><a href="#1-6-模式优缺点" class="headerlink" title="1.6 模式优缺点"></a>1.6 模式优缺点</h3><p>模板方法模式的<strong>优点</strong></p>
<ol>
<li>模板方法模式<strong>在一个类中抽象地定义算法</strong>，而<strong>由它的子类实现细节的处理</strong>。</li>
<li>模板方法模式是一种<strong>代码复用的基本技术</strong>。</li>
<li>模板方法模式导致一种<strong>反向的控制结构</strong>，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，<strong>符合“开闭原则”</strong>。</li>
</ol>
<p>模板方法模式的<strong>缺点</strong></p>
<ol>
<li>每个不同的实现都需要定义一个子类，这会<strong>导致类的个数增加</strong>，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。</li>
</ol>
<h3 id="1-7-模式适用环境"><a href="#1-7-模式适用环境" class="headerlink" title="1.7 模式适用环境"></a>1.7 模式适用环境</h3><p>在以下情况下可以使用模板方法模式：</p>
<ol>
<li>一次性实现一个算法的不变的部分，并<strong>将可变的行为留给子类来实现</strong>。</li>
<li><strong>各子类中公共的行为应被提取出来并集中到一个公共父类</strong>中以避免代码重复。</li>
<li><strong>对一些复杂的算法进行分割</strong>，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。</li>
<li>控制<strong>子类的扩展</strong>。</li>
</ol>
<h3 id="1-8-模式应用"><a href="#1-8-模式应用" class="headerlink" title="1.8 模式应用"></a>1.8 模式应用</h3><ol>
<li>模板方法模式广泛应用于框架设计（如Spring，Struts等）中，<strong>以确保父类控制处理流程的逻辑顺序</strong>（如框架的初始化）。</li>
<li>Java单元测试工具JUnit中的TestCase类的设计：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runBare</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>   setUp();<br>   <span class="hljs-keyword">try</span> &#123;<br>      runTest();<br>   &#125;<br>   <span class="hljs-keyword">finally</span> &#123;<br>      tearDown();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-9-模式扩展"><a href="#1-9-模式扩展" class="headerlink" title="1.9 模式扩展"></a>1.9 模式扩展</h3><h4 id="关于继承的讨论"><a href="#关于继承的讨论" class="headerlink" title="关于继承的讨论"></a>关于继承的讨论</h4><ol>
<li>模板方法模式鼓励我们<strong>恰当使用继承</strong>，此模式可以用来改写一些拥有相同功能的相关类，<strong>将可复用的一般性的行为代码移到父类里面</strong>，而将特殊化的行为代码移到子类里面。这也进一步说明，虽然继承复用存在一些问题，但是在某些情况下还是可以给开发人员带来方便，<strong>模板方法模式就是体现继承优势的模式之一</strong>。</li>
</ol>
<h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><ol>
<li>在模板方法模式中，子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，<strong>父类控制对子类的调用</strong>，这种机制被称为<strong>好莱坞原则</strong>(Hollywood Principle)，好莱坞原则的定义为：“<strong>不要给我们打电话，我们会给你打电话(Don‘t call us, we’ll call you)</strong>”。</li>
<li>在模板方法模式中，好莱坞原则体现在：<strong>子类不需要调用父类，而通过父类来调用子类，将某些步骤的实现写在子类中，由父类来控制整个过程</strong>。</li>
</ol>
<h4 id="钩子方法的使用"><a href="#钩子方法的使用" class="headerlink" title="钩子方法的使用"></a>钩子方法的使用</h4><ol>
<li>钩子方法的引入使得子类可以控制父类的行为。</li>
<li>最简单的钩子方法就是<strong>空方法</strong>，也<strong>可以在钩子方法中定义一个默认的实现</strong>，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</li>
<li>比较复杂一点的钩子方法<strong>可以对其他方法进行约束</strong>，这种钩子方法通常返回一个boolean类型，即返回true或false，用来判断是否执行某一个基本方法。</li>
</ol>
<h3 id="1-10-小结"><a href="#1-10-小结" class="headerlink" title="1.10 小结"></a>1.10 小结</h3><ol>
<li>在模板方法模式中，定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。</li>
<li>模板方法模式包含两个角色<ol>
<li>在抽象类中定义一系列基本操作，这些基本操作可以是具体的，也可以是抽象的，同时，在抽象类中实现了一个模板方法，用于定义一个算法的骨架</li>
<li>具体子类是抽象类的子类，用于实现在父类中定义的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中实现的具体基本操作。</li>
</ol>
</li>
<li>在模板方法模式中，方法可以分为模板方法和基本方法，其中基本方法又可以分为抽象方法、具体方法和钩子方法，钩子方法根据其特点又分为空方法和与实现算法步骤的基本方法“挂钩”的方法。</li>
<li>模板方法模式<ol>
<li>优点在于在子类定义详细的处理算法时不会改变算法的结构，实现了代码的复用，通过对子类的扩展可以增加新的行为，符合“开闭原则”</li>
<li>其缺点在于需要为每个不同的实现都定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</li>
</ol>
</li>
<li>模板方法模式适用情况包括<ol>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复</li>
<li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法，而一些可以改变的细节由其子类来实现</li>
<li>通过模板方法模式还可以控制子类的扩展。</li>
</ol>
</li>
</ol>
<h2 id="2-命令模式-对象"><a href="#2-命令模式-对象" class="headerlink" title="2. 命令模式(对象)"></a>2. 命令模式(对象)</h2><h3 id="2-1-模式动机"><a href="#2-1-模式动机" class="headerlink" title="2.1 模式动机"></a>2.1 模式动机</h3><p>命令模式可以<strong>对发送者和接收者完全解耦</strong>，发送者与接收者之间<strong>没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</strong>。这就是命令模式的模式动机。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314112052652.png" alt="image-20230314112052652" style="zoom:80%;" /></p>
<h3 id="2-2-模式定义"><a href="#2-2-模式定义" class="headerlink" title="2.2 模式定义"></a>2.2 模式定义</h3><p>命令模式(Command Pattern)：<strong>将一个请求封装为一个对象</strong>，从而使我们可用<strong>不同的请求对客户进行参数化</strong>；<strong>对请求排队或者记录请求日志，以及支持可撤销的操作</strong>。命令模式是一种<strong>对象行为型模式</strong>，其别名为动作(Action)模式或事务(Transaction)模式。</p>
<p>Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p>
<h3 id="2-3-模式结构"><a href="#2-3-模式结构" class="headerlink" title="2.3 模式结构"></a>2.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314112241809.png" alt="image-20230314112241809" style="zoom:80%;" /></p>
<p>命令模式包含如下角色：</p>
<ol>
<li>Command: 抽象命令类</li>
<li>ConcreteCommand: 具体命令类</li>
<li>Invoker: 调用者</li>
<li>Receiver: 接收者</li>
<li>Client:客户类</li>
</ol>
<h3 id="2-4-模式分析"><a href="#2-4-模式分析" class="headerlink" title="2.4 模式分析"></a>2.4 模式分析</h3><ol>
<li>命令模式的本质是<strong>对命令进行封装</strong>，<strong>将发出命令的责任和执行命令的责任分割开</strong>。</li>
<li>每一个命令都是一个操作：<strong>请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作</strong>。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，<strong>使得请求的一方不必知道接收请求的一方的接口</strong>，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
<li>命令模式<strong>使请求本身成为一个对象</strong>，这个对象和其他对象一样可以被存储和传递。</li>
<li>命令模式的关键在于<strong>引入了抽象命令接口</strong>，且<strong>发送者针对抽象命令接口编程</strong>，只有实现了抽象命令接口的<strong>具体命令才能与接收者相关联</strong>。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314114539376.png" alt="image-20230314114539376" style="zoom:80%;" /></p>
<p>典型的抽象命令类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的调用者代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span>&#123;<br>  <span class="hljs-keyword">private</span> Command command;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Invoker</span><span class="hljs-params">(Command command)</span>&#123;<br>    <span class="hljs-built_in">this</span>.command=command;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span>&#123;<br>    <span class="hljs-built_in">this</span>.command=command;<br>  &#125;<br>  <span class="hljs-comment">//业务方法，用于调用命令类的方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>    command.execute();<br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>典型的具体命令类代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>  <span class="hljs-keyword">private</span> Receiver receiver;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>    receiver.action();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的请求接收者代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//具体操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-5-命令模式实例与解析"><a href="#2-5-命令模式实例与解析" class="headerlink" title="2.5 命令模式实例与解析"></a>2.5 命令模式实例与解析</h3><p><strong>电视机遥控器</strong></p>
<p>电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。显然，电视机遥控器就是一个典型的命令模式应用实例。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314114828230.png" alt="image-20230314114828230" style="zoom:80%;" /></p>
<p><strong>功能键设置</strong></p>
<p>为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，如功能键 FunctionButton 可以用于退出系统(SystemExitClass)，也可以用于打开帮助界面 (DisplayHelpClass)。用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，相同的功能键可以对应不同的功能。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314115051773.png" alt="image-20230314115051773" style="zoom:80%;" /></p>
<h3 id="2-6-模式优缺点"><a href="#2-6-模式优缺点" class="headerlink" title="2.6 模式优缺点"></a>2.6 模式优缺点</h3><p>命令模式的优点</p>
<ol>
<li>降低系统的耦合度。</li>
<li>新的命令可以很容易地加入到系统中。</li>
<li>可以比较容易地设计一个命令队列和宏命令(组合命令)。</li>
<li><strong>可以方便地实现对请求的Undo和Redo</strong>。</li>
</ol>
<p>命令模式的缺点</p>
<ol>
<li>使用命令模式可能会<strong>导致某些系统有过多的具体命令类</strong>。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用</li>
</ol>
<h3 id="2-7-模式适用环境"><a href="#2-7-模式适用环境" class="headerlink" title="2.7 模式适用环境"></a>2.7 模式适用环境</h3><ol>
<li>系统<strong>需要将请求调用者和请求接收者解耦</strong>，使得调用者和接收者不直接交互。</li>
<li>系统<strong>需要在不同的时间指定请求、将请求排队和执行请求</strong>。</li>
<li>系统<strong>需要支持命令的撤销(Undo)操作和恢复(Redo)操作</strong>。</li>
<li>系统<strong>需要将一组操作组合在一起</strong>，即支持宏命令。</li>
</ol>
<h3 id="2-8-模式应用"><a href="#2-8-模式应用" class="headerlink" title="2.8 模式应用"></a>2.8 模式应用</h3><p>Java语言使用命令模式实现AWT/Swing GUI的<strong>委派事件模型 (Delegation Event Model, DEM)</strong>。</p>
<ul>
<li>在AWT/Swing中，Frame、Button等<strong>界面组件</strong>是<strong>请求发送者</strong>，而AWT提供的<strong>事件监听器接口和事件适配器类</strong>是<strong>抽象命令接口</strong>，<strong>用户可以自己</strong>写抽象命令接口的子类来实现事件处理，即实现<strong>具体命令类</strong>，而在具体命令类中可以调用业务处理方法来实现该事件的处理。对于界面组件而言，只需要了解命令接口即可，无须关心接口的实现，组件类并不关心实际操作，而操作由用户来实现。</li>
</ul>
<p>很多系统都提供了宏命令功能，如<strong>UNIX平台下的Shell编程</strong>，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列，这也是命令模式的应用实例之一。</p>
<h3 id="2-9-模式扩展"><a href="#2-9-模式扩展" class="headerlink" title="2.9 模式扩展"></a>2.9 模式扩展</h3><h4 id="撤销操作的实现"><a href="#撤销操作的实现" class="headerlink" title="撤销操作的实现"></a>撤销操作的实现</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314151619323.png" alt="image-20230314151619323" style="zoom:80%;" /></p>
<h4 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h4><ol>
<li>宏命令又称为<strong>组合命令</strong>，它是<strong>命令模式和组合模式</strong>联用的产物。</li>
<li>宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，<strong>在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法</strong>，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230314151824589.png" alt="image-20230314151824589" style="zoom:80%;" /></p>
<h2 id="3-迭代器模式-对象"><a href="#3-迭代器模式-对象" class="headerlink" title="3. 迭代器模式(对象)"></a>3. 迭代器模式(对象)</h2><h3 id="3-1-模式动机"><a href="#3-1-模式动机" class="headerlink" title="3.1 模式动机"></a>3.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627221420555.png" alt="image-20230627221420555"></p>
<ul>
<li>电视机 &lt;-&gt; 存储电视频道的集合 &lt;-&gt; 聚合类(Aggregate Classes)</li>
<li>电视机遥控器 &lt;-&gt; 操作电视频道 &lt;-&gt; 迭代器(Iterator)</li>
<li>访问一个聚合对象中的元素但又不需要暴露它的内部结构</li>
<li>聚合对象的两个职责：<ul>
<li><strong>存储数据</strong>，聚合对象的基本职责</li>
<li><strong>遍历数据</strong>，既是可变化的，又是可分离的</li>
</ul>
</li>
<li>将遍历数据的行为从聚合对象中分离出来，封装在迭代器对象中</li>
<li>由迭代器来提供遍历聚合对象内部数据的行为，简化聚合对象的设计，更符合单一职责原则</li>
</ul>
<h3 id="3-2-模式定义"><a href="#3-2-模式定义" class="headerlink" title="3.2 模式定义"></a>3.2 模式定义</h3><ul>
<li>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，且不用暴露该对象的内部表示。</li>
<li>Iterator Pattern: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</li>
<li>又名游标(Cursor)模式</li>
<li>通过引入迭代器，客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要很方便地增加新的遍历方式</li>
</ul>
<h3 id="3-3-模式结构"><a href="#3-3-模式结构" class="headerlink" title="3.3 模式结构"></a>3.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627221720676.png" alt="image-20230627221720676">迭代器模式包含以下4个角色：</p>
<ul>
<li>Iterator (抽象迭代器)</li>
<li>ConcreteIterator (具体迭代器)</li>
<li>Aggregate (抽象聚合类)</li>
<li>ConcreteAggregate (具体聚合类)</li>
</ul>
<p>典型的抽象迭代器代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span>; <span class="hljs-comment">//将游标指向第一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>; <span class="hljs-comment">//将游标指向下一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>; <span class="hljs-comment">//判断是否存在下一个元素</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>; <span class="hljs-comment">//获取游标指向的当前元素</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的具体迭代器代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">private</span> ConcreteAggregate objects; <span class="hljs-comment">//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor; <span class="hljs-comment">//定义一个游标，用于记录当前访问位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteIterator</span><span class="hljs-params">(ConcreteAggregate objects)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.objects=objects;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的抽象聚合类代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>	Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型的具体聚合类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    ......<br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-4-模式分析"><a href="#3-4-模式分析" class="headerlink" title="3.4 模式分析"></a>3.4 模式分析</h3><ul>
<li>如果需要<strong>增加一个新的具体聚合类</strong>，只需增加一个新的聚合子类和一个新的具体迭代器类即可，原有类库代码无须修改，<strong>符合开闭原则</strong></li>
<li>如果需要<strong>更换一个迭代器</strong>，只需要增加一个新的具体迭代器类作为抽象迭代器类的子类，重新实现遍历方法即可，原有迭代器代码无须修改，也<strong>符合开闭原则</strong></li>
<li>如果要在<strong>迭代器中增加新的方法</strong>，则需要修改抽象迭代器的源代码，这将<strong>违背开闭原则</strong></li>
</ul>
<h4 id="不同的实现-宽接口-vs-窄接口"><a href="#不同的实现-宽接口-vs-窄接口" class="headerlink" title="不同的实现(宽接口 vs. 窄接口)"></a>不同的实现(宽接口 vs. 窄接口)</h4><ul>
<li>宽接口：一个聚集的接口提供了可以用来修改聚集元素的方法</li>
<li>窄接口：一个聚集的接口没有提供修改聚集元素的方法</li>
</ul>
<h4 id="白箱聚集-vs-黑箱聚集"><a href="#白箱聚集-vs-黑箱聚集" class="headerlink" title="白箱聚集 vs. 黑箱聚集"></a>白箱聚集 vs. 黑箱聚集</h4><ul>
<li>白箱聚集：聚集对象为所有对象提供同一个接口(宽接口)<ul>
<li>迭代子可以从外部控制聚集元素的迭代，控制的仅仅是一个游标—游标(Cursor)/外禀(Extrinsic)迭代子</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627222858106.png" alt="image-20230627222858106"></p>
<ul>
<li>黑箱聚集：聚集对象为迭代子对象提供一个宽接口，而为其它对象提供一个窄接口。同时保证聚集对象的封装和迭代子功能的实现。<ul>
<li>迭代子是聚集的内部类，可以自由访问聚集的元素。迭代子可以自行实现迭代功能并控制聚集元素的迭代逻辑—内禀迭代子(Intrinsic Iterator)</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627222954258.png" alt="image-20230627222954258"></p>
<h3 id="3-5-模式优缺点"><a href="#3-5-模式优缺点" class="headerlink" title="3.5 模式优缺点"></a>3.5 模式优缺点</h3><p>迭代器模式优点</p>
<ul>
<li>支持<strong>以不同的方式遍历一个聚合对象</strong>，在同一个聚合对象上<strong>可以定义多种遍历方式</strong></li>
<li><strong>简化了聚合类</strong></li>
<li>由于引入了抽象层，<strong>增加新的聚合类和迭代器类都很方便</strong>，无须修改原有代码，符合开闭原则</li>
</ul>
<p>迭代器模式缺点</p>
<ul>
<li>在增加新的聚合类时需要对应地增加新的迭代器类，<strong>类的个数成对增加</strong>，这在一定程度上增加了系统的复杂性</li>
<li><strong>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。</strong>在自定义迭代器时，<strong>创建一个考虑全面的抽象迭代器并不是一件很容易的事情</strong></li>
</ul>
<h3 id="3-6-模式适用环境"><a href="#3-6-模式适用环境" class="headerlink" title="3.6 模式适用环境"></a>3.6 模式适用环境</h3><ul>
<li>访问一个聚合对象的内容而<strong>无须暴露它的内部表示</strong></li>
<li>需要<strong>为一个聚合对象提供多种遍历方式</strong></li>
<li><strong>为遍历不同的聚合结构提供一个统一的接口</strong>，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而<strong>客户端可以一致性地操作该接口</strong></li>
</ul>
<h3 id="3-7-模式应用"><a href="#3-7-模式应用" class="headerlink" title="3.7 模式应用"></a>3.7 模式应用</h3><p><strong>使用内部类实现迭代器</strong></p>
<ul>
<li>JDK中的AbstractList</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br>......<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>	......<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        ......<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用内部类实现的商品数据类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractObjectList</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProductList</span><span class="hljs-params">(List products)</span> &#123;<br>    	<span class="hljs-built_in">super</span>(products);<br>    &#125;<br>    <span class="hljs-keyword">public</span> AbstractIterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductIterator</span>();<br>    &#125;<br>    <span class="hljs-comment">//商品迭代器：具体迭代器，内部类实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractIterator</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor1;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor2;<br>        <span class="hljs-comment">//省略其他代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结构</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627223238811.png" alt="image-20230627223238811"></p>
<p>实现</p>
<ul>
<li><p>java.util.Collection</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br>    ......<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object c)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection c)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection c)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remainAll</span><span class="hljs-params">(Collection c)</span>;<br>    Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>java.util.Iterator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> Java java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Collection c)</span> &#123;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> c.iterator(); <span class="hljs-comment">//创建迭代器对象</span><br>        <span class="hljs-comment">//通过迭代器遍历聚合对象</span><br>        <span class="hljs-keyword">while</span>(i.hasNext()) &#123;<br>        	System.out.println(i.next().toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        Collection persons;<br>        persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">//创建一个ArrayList类型的聚合对象</span><br>        persons.add(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;小龙女&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;令狐冲&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;韦小宝&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;袁紫衣&quot;</span>);<br>        persons.add(<span class="hljs-string">&quot;小龙女&quot;</span>);<br>        process(persons);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-观察者模式-对象"><a href="#4-观察者模式-对象" class="headerlink" title="4. 观察者模式(对象)"></a>4. 观察者模式(对象)</h2><h3 id="4-1-模式动机"><a href="#4-1-模式动机" class="headerlink" title="4.1 模式动机"></a>4.1 模式动机</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612085531412.png" alt="image-20230612085531412" style="zoom:80%;" /></p>
<ul>
<li>建立一种<strong>对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应</strong>。<ul>
<li>发生改变的对象称为<strong>观察目标</strong></li>
<li>被通知的对象称为<strong>观察者</strong></li>
</ul>
</li>
<li><strong>一个观察目标可以对应多个观察者</strong>，而且这些观察者之间没有相互联系，<strong>可以根据需要增加和删除观察者，使得系统更易于扩展</strong>，这就是观察者模式的模式动机。</li>
</ul>
<h3 id="4-2-模式定义"><a href="#4-2-模式定义" class="headerlink" title="4.2 模式定义"></a>4.2 模式定义</h3><ol>
<li>观察者模式(Observer Pattern)：定义对象间的一种<strong>一对多依赖关系</strong>，使得<strong>每当一个对象状态发生改变</strong>时，其<strong>相关依赖对象皆得到通知并被自动更新</strong>。</li>
<li>观察者模式又叫做<strong>发布-订阅</strong>（Publish/Subscribe）模式、<strong>模型-视图</strong>（Model/View）模式、<strong>源-监听器</strong>（Source/Listener）模式或<strong>从属者</strong>（Dependents）模式。观察者模式是一种<strong>对象行为型</strong>模式。</li>
<li>Observer Pattern: Define a <strong>one-to-many dependency</strong> between objects so that when <strong>one  object changes state, all its dependents are notified  and updated automatically</strong>.</li>
</ol>
<h3 id="4-3-模式结构"><a href="#4-3-模式结构" class="headerlink" title="4.3 模式结构"></a>4.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612085646353.png" alt="image-20230612085646353" style="zoom:80%;" /></p>
<ul>
<li>观察者模式包含如下角色：<ul>
<li>Subject: 目标</li>
<li>ConcreteSubject: 具体目标</li>
<li>Observer: 观察者</li>
<li>ConcreteObserver: 具体观察者</li>
</ul>
</li>
</ul>
<h3 id="4-4-模式分析"><a href="#4-4-模式分析" class="headerlink" title="4.4 模式分析"></a>4.4 模式分析</h3><ul>
<li>观察者模式描述了<strong>如何建立对象与对象之间的依赖关系</strong>，如何构造满足这种需求的系统。</li>
<li>这一模式中的关键对象是观察目标和观察者，<strong>一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知</strong>。</li>
<li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅 (publish-subscribe)</strong>。</li>
</ul>
<p><strong>松耦合</strong></p>
<ul>
<li>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</li>
<li>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</li>
<li>改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，就可以自由地改变他们。</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ul>
<h3 id="4-5-观察者模式实例与解析"><a href="#4-5-观察者模式实例与解析" class="headerlink" title="4.5 观察者模式实例与解析"></a>4.5 观察者模式实例与解析</h3><p>WeatherData</p>
<ul>
<li>WeatherData类具有getter方法，可以取得三个测量值：温度、湿度与气压。</li>
<li>当新的测量数据备妥时，measurementsChanged() 方法就会被调用。</li>
<li>需要实现三个使用天气数据的布告板: “目前状况” 布告、“气象统计”布告、“天气预报”布告。一旦 WeatherData 有新测量，这些布告必须马上更新。</li>
<li>此系统必须可扩展，让其他开发人员建立定制的布告板，用户可以随心所欲地添加或删除任何布告板</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612090525324.png" alt="image-20230612090525324"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditions</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span>, DisplayElement &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CurrentConditions</span><span class="hljs-params">(Subject weatherSubject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.weatherData = weatherSubject;<br>        weatherData.registerObserver(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Current Conditions: &quot;</span> + temperature + <span class="hljs-string">&quot;F degrees and &quot;</span> + humidity + <span class="hljs-string">&quot;% humidity&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> t, <span class="hljs-type">float</span> h)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = t;<br>        <span class="hljs-built_in">this</span>.humidity = h;<br>        display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-6-模式优缺点"><a href="#4-6-模式优缺点" class="headerlink" title="4.6 模式优缺点"></a>4.6 模式优缺点</h3><p>观察者模式的优点</p>
<ol>
<li>观察者模式可以<strong>实现表示层和数据逻辑层的分离</strong>，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li>
<li>观察者模式在观察目标和观察者之间<strong>建立一个抽象的耦合</strong>。</li>
<li>观察者模式<strong>支持广播通信</strong>。</li>
<li>观察者模式<strong>符合开闭原则</strong>的要求。</li>
</ol>
<p>观察者模式的缺点</p>
<ol>
<li>如果一个观察目标对象有很多直接和间接的观察者的话，<strong>将所有的观察者都通知到会花费很多时间</strong>。</li>
<li>如果在观察者和观察目标之间有<strong>循环依赖的话</strong>，观察目标会触发它们之间进行循环调用，<strong>可能导致系统崩溃</strong>。</li>
<li>观察者模式<strong>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</strong>，而仅仅只是知道观察目标发生了变化。</li>
</ol>
<h3 id="4-7-模式适用环境"><a href="#4-7-模式适用环境" class="headerlink" title="4.7 模式适用环境"></a>4.7 模式适用环境</h3><p>在以下情况下可以使用观察者模式：</p>
<ol>
<li>一个抽象模型有两个方面，其中<strong>一个方面依赖于另一个方面</strong>。将这些方面<strong>封装在独立的对象中使它们可以各自独立地改变和复用</strong>。</li>
<li><strong>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变</strong>，可以降低对象之间的耦合度。</li>
<li><strong>一个对象必须通知其他对象，而并不知道这些对象是谁</strong>。</li>
<li><strong>需要在系统中创建一个触发链</strong>，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种<strong>链式触发机制</strong>。</li>
</ol>
<h3 id="4-8-模式应用"><a href="#4-8-模式应用" class="headerlink" title="4.8 模式应用"></a>4.8 模式应用</h3><ol>
<li>JDK1.1版本及以后的各个版本中，事件处理模型采用基于观察者模式的<strong>委派事件模型(Delegation Event Model, DEM)</strong>。<ol>
<li>在DEM中，事件的发布者称为<strong>事件源(Event Source)</strong>，而订阅者叫做<strong>事件监听器(Event Listener)</strong>，在这个过程中还可以通过<strong>事件对象(Event Object)</strong>来传递与事件相关的信息，可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。</li>
<li><strong>事件源对象、事件监听对象(事件处理对象)和事件对象</strong>构成了Java事件处理模型的三要素。</li>
</ol>
</li>
<li>除了AWT中的事件处理之外，Java语言解析XML的技术<strong>SAX2</strong>以及<strong>Servlet技术的事件处理机制</strong>都基于DEM，它们都是观察者模式的应用。</li>
<li>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到<strong>一对一或者一对多的对象交互场景都可以使用观察者模式</strong>。</li>
</ol>
<h3 id="4-9-模式扩展"><a href="#4-9-模式扩展" class="headerlink" title="4.9 模式扩展"></a>4.9 模式扩展</h3><h4 id="Java语言提供的对观察者模式的支持"><a href="#Java语言提供的对观察者模式的支持" class="headerlink" title="Java语言提供的对观察者模式的支持"></a>Java语言提供的对观察者模式的支持</h4><ul>
<li>在JDK的java.util包中，提供了<strong>Observable类</strong>以及<strong>Observer接口</strong>，它们构成了Java语言对观察者模式的支持。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612091826405.png" alt="image-20230612091826405" style="zoom:80%;" /></p>
<ul>
<li>Observer接口:<code>void update(Observable o, Object arg);</code></li>
<li><p>Observable类</p>
<ul>
<li><code>Observable()</code></li>
<li><code>addObserver(Observer o)</code></li>
<li><code>deleteObserver (Observer o)</code></li>
<li><code>notifyObservers()</code>、<code>notifyObservers(Object arg)</code></li>
<li><code>deleteObservers</code></li>
<li><code>setChanged()</code></li>
<li><code>clearChanged()</code></li>
<li><code>hasChanged()</code></li>
<li><code>countObservers()</code></li>
</ul>
</li>
<li><p>谁触发更新：目标和它的观察者依赖于通知机制来保持一致。但到底哪一个对象调用 Notify 来触发更新? 此时有两个选择:</p>
<ul>
<li>由目标对象的状态设定操作在改变目标对象的状态后自动调用 Notify。这种方法的优点是客户不需要记住要在目标对象上调用 Notify，缺点是多个连续的操作会产生多次连续的更新, 可能效率较低。</li>
<li>让客户负责在适当的时候调用 Notify。这样做的优点是客户可以在一系列的状态改变完成后再一次性地触发更新, 避免了不必要的中间更新。缺点是给客户增加了触发更新的责任。由于客户可能会忘记调用 Notify，这种方式较易出错。</li>
</ul>
</li>
</ul>
<h4 id="封装复杂的更新语义"><a href="#封装复杂的更新语义" class="headerlink" title="封装复杂的更新语义"></a>封装复杂的更新语义</h4><ul>
<li>当目标和观察者间的依赖关系特别复杂时, 可能需要一个维护这些关系的对象。我们称这样的对象为更改管理器（Change Manager）。</li>
<li>它的目的是尽量减少观察者反映其目标的状态变化所需的工作量。例如, 如果一个操作涉及到对几个相互依赖的目标进行改动, 就必须保证仅在所有目标都已更改完毕后，才一次性地通知它们的观察者, 而不是每个目标都通知观察者。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092416439.png" alt="image-20230612092416439" style="zoom:80%;" /></p>
<h4 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h4><ul>
<li>MVC模式是一种架构模式，它包含三个角色：<strong>模型(Model)，视图(View)和控制器(Controller)</strong>。观察者模式可以用来实现MVC模式，观察者模式中的<strong>观察目标</strong>就是MVC模式中的<strong>模型(Model)</strong>，而<strong>观察者</strong>就是MVC中的<strong>视图</strong>(View)，控制器(Controller)充当两者之间的中介者(Mediator)。<strong>当模型层的数据发生改变时，视图层将自动改变其显示内容</strong>。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092529510.png" alt="image-20230612092529510" style="zoom:80%;" /></p>
<h3 id="4-10-小结"><a href="#4-10-小结" class="headerlink" title="4.10 小结"></a>4.10 小结</h3><ol>
<li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li>
<li>观察者模式包含四个角色：<ol>
<li>目标又称为主题，它是指被观察的对象</li>
<li>具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知</li>
<li>观察者将对观察目标的改变做出反应</li>
<li>在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li>
</ol>
</li>
<li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li>
<li>观察者模式<ol>
<li>主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信</li>
<li>主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
</ol>
</li>
<li>观察者模式适用情况包括：<ol>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li>
</ol>
</li>
<li>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。</li>
</ol>
<h2 id="5-中介者模式-对象"><a href="#5-中介者模式-对象" class="headerlink" title="5. 中介者模式(对象)"></a>5. 中介者模式(对象)</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092658438.png" alt="image-20230612092658438" style="zoom:80%;" /></p>
<h3 id="5-1-模式动机"><a href="#5-1-模式动机" class="headerlink" title="5.1 模式动机"></a>5.1 模式动机</h3><ol>
<li>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：<ol>
<li><strong>系统结构复杂</strong>：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li>
<li><strong>对象可重用性差</strong>：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li>
<li><strong>系统扩展性低</strong>：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li>
</ol>
</li>
<li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们<strong>应该尽量将对象细化，使其只负责或呈现单一的职责</strong>。</li>
<li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，<strong>为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式</strong>，这就是中介者模式的模式动机。</li>
</ol>
<h3 id="5-2-模式定义"><a href="#5-2-模式定义" class="headerlink" title="5.2 模式定义"></a>5.2 模式定义</h3><ol>
<li>中介者模式(Mediator Pattern)定义：用一个中介对象来<strong>封装一系列的对象交互</strong>，中介者使各对象不需要显式地相互引用，从而<strong>使其耦合松散</strong>，而且<strong>可以独立地改变它们之间的交互</strong>。中介者模式又称为<strong>调停者模式</strong>，它是一种<strong>对象行为型模式</strong>。</li>
<li>Mediator Pattern: Define an object that encapsulates how a set of objects interact. Mediator promotes <strong>loose coupling</strong> by keeping objects from referring to each other explicitly, and <strong>it lets you vary their interaction independently</strong>.</li>
</ol>
<h3 id="5-3-模式结构"><a href="#5-3-模式结构" class="headerlink" title="5.3 模式结构"></a>5.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092759415.png" alt="image-20230612092759415"></p>
<p>中介者模式包含如下角色：</p>
<ol>
<li>Mediator: 抽象中介者</li>
<li>ConcreteMediator: 具体中介者</li>
<li>Colleague: 抽象同事类</li>
<li>ConcreteColleague: 具体同事类</li>
</ol>
<h3 id="5-4-模式分析"><a href="#5-4-模式分析" class="headerlink" title="5.4 模式分析"></a>5.4 模式分析</h3><ul>
<li>中介者模式可以使对象之间的关系数量急剧减少：</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612092851729.png" alt="image-20230612092851729"></p>
<ul>
<li><p>中介者承担两方面的职责：</p>
<ol>
<li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者<strong>在结构上的支持</strong>。</li>
<li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者<strong>在行为上的支持</strong>。</li>
</ol>
</li>
<li><p>典型的抽象中介者类代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>   <span class="hljs-keyword">protected</span> ArrayList colleagues;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Colleague colleague)</span> &#123;<br>      colleagues.add(colleague);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>典型的具体中介者类代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>      ......<br>      ((Colleague)(colleagues.get(<span class="hljs-number">0</span>))).method1();<br>      ......<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>典型的抽象同事类代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span>&#123;<br>   <span class="hljs-keyword">protected</span> Mediator mediator;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Colleague</span><span class="hljs-params">(Mediator mediator)</span>&#123;<br>      <span class="hljs-built_in">this</span>.mediator=mediator;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>典型的具体同事类代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague</span><span class="hljs-params">(Mediator mediator)</span>&#123;<br>      <span class="hljs-built_in">super</span>(mediator);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>      ......<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>      mediator.operation1();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-5-中介者模式实例与解析"><a href="#5-5-中介者模式实例与解析" class="headerlink" title="5.5 中介者模式实例与解析"></a>5.5 中介者模式实例与解析</h3><p><strong>实例：虚拟聊天室</strong></p>
<p>某论坛系统欲增加一个虚拟聊天室，允许论坛会员通过该聊天室进行信息交流，普通会员(CommonMember)可以给其他会员发送文本信息，钻石会员(DiamondMember)既可以给其他会员发送文本信息，还可以发送图片信息。该聊天室可以对不雅字符进行过滤，如“日”等字符；还可以对发送的图片大小进行控制。用中介者模式设计该虚拟聊天室。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230612093348250.png" alt="image-20230612093348250"></p>
<h3 id="5-6-模式优缺点"><a href="#5-6-模式优缺点" class="headerlink" title="5.6 模式优缺点"></a>5.6 模式优缺点</h3><p>中介者模式的优点</p>
<ol>
<li>简化了对象之间的交互。</li>
<li>将各同事解耦。</li>
<li>减少子类生成。</li>
<li>可以简化各同事类的设计和实现。</li>
</ol>
<p>中介者模式的缺点</p>
<ol>
<li>在具体中介者类中包含了同事之间的交互细节，可能会导致<strong>具体中介者类非常复杂</strong>，使得<strong>系统难以维护</strong>。</li>
</ol>
<h3 id="5-7-模式适用环境"><a href="#5-7-模式适用环境" class="headerlink" title="5.7 模式适用环境"></a>5.7 模式适用环境</h3><p>在以下情况下可以使用中介者模式：</p>
<ol>
<li>系统中<strong>对象之间存在复杂的引用关系</strong>，产生的相互依赖关系结构混乱且难以理解。</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致<strong>难以复用该对象</strong>。</li>
<li><strong>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类</strong>。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li>
</ol>
<h3 id="5-8-模式应用"><a href="#5-8-模式应用" class="headerlink" title="5.8 模式应用"></a>5.8 模式应用</h3><ol>
<li>中介者模式在<strong>事件驱动类软件</strong>中应用比较多，在设计GUI应用程序时，组件之间可能存在较为复杂的交互关系，一个组件的改变将影响与之相关的其他组件，此时可以使用中介者模式来对组件进行协调。</li>
<li>MVC 是Java EE 的一个基本模式，此时<strong>控制器Controller作为一种中介者</strong>，它负责控制视图对象View和模型对象Model之间的交互。如在Struts中，Action就可以作为JSP页面与业务对象之间的中介者。</li>
</ol>
<h3 id="5-9-模式扩展"><a href="#5-9-模式扩展" class="headerlink" title="5.9 模式扩展"></a>5.9 模式扩展</h3><ol>
<li>中介者模式与迪米特法则<ol>
<li>在中介者模式中，通过创造出一个中介者对象，<strong>将系统中有关的对象所引用的其他对象数目减少到最少</strong>，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，<strong>中介者模式就是迪米特法则的一个典型应用</strong>。</li>
</ol>
</li>
<li>中介者模式与GUI开发<ol>
<li>中介者模式可以方便地应用于<strong>图形界面(GUI)开发</strong>中，在比较复杂的界面中可能存在<strong>多个界面组件之间的交互关系</strong>。</li>
<li>对于这些复杂的交互关系，有时候我们可以引入一个中介者类，<strong>将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责</strong>，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。</li>
</ol>
</li>
</ol>
<h3 id="5-10-小结"><a href="#5-10-小结" class="headerlink" title="5.10 小结"></a>5.10 小结</h3><ol>
<li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li>
<li>中介者模式包含四个角色：<ol>
<li>抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信</li>
<li>具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用</li>
<li>抽象同事类定义各同事的公有方法</li>
<li>具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li>
</ol>
</li>
<li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li>
<li>中介者模式<ol>
<li>主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现</li>
<li>主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li>
</ol>
</li>
<li>中介者模式适用情况包括<ol>
<li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
</ol>
</li>
</ol>
<h2 id="6-状态模式-对象"><a href="#6-状态模式-对象" class="headerlink" title="6. 状态模式(对象)"></a>6. 状态模式(对象)</h2><h3 id="6-1-模式动机"><a href="#6-1-模式动机" class="headerlink" title="6.1 模式动机"></a>6.1 模式动机</h3><p>在很多情况下，<strong>一个对象的行为取决于一个或多个动态变化的属性</strong>，这样的属性叫做<strong>状态</strong>，这样的对象叫做<strong>有状态的(stateful)对象</strong>，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p>
<p>在UML中可以使用<strong>状态图</strong>来描述对象状态的变化。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307114008550.png" style="zoom: 67%;" /></p>
<h3 id="6-2-模式定义"><a href="#6-2-模式定义" class="headerlink" title="6.2 模式定义"></a>6.2 模式定义</h3><p>状态模式(State Pattern)：<strong>允许一个对象在其内部状态改变时改变它的行为</strong>，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</p>
<p>State Pattern: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</p>
<h3 id="6-3-模式结构"><a href="#6-3-模式结构" class="headerlink" title="6.3 模式结构"></a>6.3 模式结构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307115128774.png" alt="image-20230307115128774" style="zoom:80%;" /></p>
<p>状态模式包含如下角色：</p>
<ol>
<li>Context: 环境类</li>
<li>State: 抽象状态类</li>
<li>ConcreteState: 具体状态类</li>
</ol>
<p>在结构上策略模式和状态模式是一致的，但是在使用上是很不同的</p>
<ul>
<li>状态模式由状态自己进行转换</li>
<li>策略模式由客户端决定</li>
</ul>
<h3 id="6-4-模式分析"><a href="#6-4-模式分析" class="headerlink" title="6.4 模式分析"></a>6.4 模式分析</h3><ol>
<li>状态模式描述了<strong>对象状态的变化</strong>以及<strong>对象如何在每一种状态下表现出不同的行为</strong>。</li>
<li>状态模式的关键是<strong>引入了一个抽象类来专门表示对象的状态</strong>，这个类我们叫做<strong>抽象状态类</strong>，而对象的每一种具体状态类都继承了该类，并在<strong>不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换</strong>。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307115352857.png" alt="image-20230307115352857" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(state==<span class="hljs-string">&quot;空闲&quot;</span>)&#123;<br>    <span class="hljs-keyword">if</span>(预订房间)&#123;<br>        <span class="hljs-comment">// 预订操作;</span><br>        state=<span class="hljs-string">&quot;已预订&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(住进房间)&#123;<br>        <span class="hljs-comment">// 入住操作;</span><br>        state=<span class="hljs-string">&quot;已入住&quot;</span>;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state==<span class="hljs-string">&quot;已预订&quot;</span>)&#123;<br>    <span class="hljs-keyword">if</span>(住进房间)&#123;<br>        <span class="hljs-comment">// 入住操作;</span><br>        state=<span class="hljs-string">&quot;已入住&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(取消预订)&#123;<br>        <span class="hljs-comment">// 取消操作;</span><br>        state=<span class="hljs-string">&quot;空闲&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用状态模式重构</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307151033908.png" alt="image-20230307151033908" style="zoom:80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重构之后的“空闲状态类”示例代码</span><br><span class="hljs-keyword">if</span>(预订房间)&#123;<br>  <span class="hljs-comment">// 预订操作;</span><br>  context.setState(<span class="hljs-keyword">new</span> 已预订状态类());<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(住进房间)&#123;<br>  <span class="hljs-comment">// 入住操作;</span><br>  context.setState(<span class="hljs-keyword">new</span> 已入住状态类());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在状态模式结构中需要理解<strong>环境类与抽象状态类</strong>的作用：</p>
<ol>
<li>环境类实际上就是<strong>拥有状态的对象</strong>，环境类有时候可以充当<strong>状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作</strong>。</li>
<li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，<strong>状态类的产生是由于环境类存在多个状态</strong>，同时还满足两个条件：<strong>这些状态经常需要切换，在不同的状态下对象的行为不同</strong>。因此可以<strong>将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类</strong>，而实际上是<strong>由于切换到不同的具体状态类实现的</strong>。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li>
</ol>
<h3 id="6-5-状态模式实例与解析"><a href="#6-5-状态模式实例与解析" class="headerlink" title="6.5 状态模式实例与解析"></a>6.5 状态模式实例与解析</h3><p>实例：论坛用户等级</p>
<p>在某论坛系统中，用户可以发表留言，发表留言将增加积分；用户也可以回复留言，回复留言也将增加积分；用户还可以下载文件，下载文件将扣除积分。该系统用户分为三个等级，分别是新手、高手和专家，这三个等级对应三种不同的状态，这三种状态分别定义如下：</p>
<ol>
<li>如果积分小于100分，则为新手状态，用户可以发表留言、回复留言，但是不能下载文件。如果积分大于等于1000分，则转换为专家状态；如果积分大于等于100分，则转换为高手状态。</li>
<li>如果积分大于等于100分但小于1000分，则为高手状态，用户可以发表留言、回复留言，还可以下载文件，而且用户在发表留言时可以获取双倍积分。如果积分小于100分，则转换为新手状态；如果积分大于等于1000分，则转换为专家状态；如果下载文件后积分小于0，则不能下载该文件。</li>
<li>如果积分大于等于1000分，则为专家状态，用户可以发表留言、回复留言和下载文件，用户除了在发表留言时可以获取双倍积分外，下载文件只扣除所需积分的一半。如果积分小于100分，则转换为新手状态；如果积分小于1000分，但大于等于100，则转换为高手状态；如果下载文件后积分小于0，则不能下载该文件。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307151649799.png" alt="image-20230307151649799" style="zoom:80%;" /></p>
<h3 id="6-6-模式优缺点"><a href="#6-6-模式优缺点" class="headerlink" title="6.6 模式优缺点"></a>6.6 模式优缺点</h3><p>状态模式的优点</p>
<ol>
<li><strong>封装了转换规则</strong>。</li>
<li><strong>枚举可能的状态</strong>，在枚举状态之前需要确定状态种类。</li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以<strong>方便地增加新的状态</strong>，只需要改变对象状态即可改变对象的行为。</li>
<li>允许<strong>状态转换逻辑与状态对象合成一体</strong>，而不是某一个巨大的条件语句块。</li>
<li>可以<strong>让多个环境对象共享一个状态对象</strong>，从而减少系统中对象的个数。</li>
</ol>
<p>状态模式的缺点</p>
<ol>
<li>状态模式的使用必然会<strong>增加系统类和对象的个数</strong>。</li>
<li>状态模式的结构与实现都较为复杂，<strong>如果使用不当将导致程序结构和代码的混乱</strong>。</li>
<li>状态模式<strong>对“开闭原则”的支持并不太好</strong>，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ol>
<h3 id="6-7-模式适用环境"><a href="#6-7-模式适用环境" class="headerlink" title="6.7 模式适用环境"></a>6.7 模式适用环境</h3><ol>
<li>对象的<strong>行为依赖于它的状态(属性)</strong>并且<strong>可以根据它的状态改变而改变它的相关行为</strong>。</li>
<li>代码中包含大量与<strong>对象状态有关的条件语句</strong>，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>
</ol>
<h3 id="6-8-模式应用"><a href="#6-8-模式应用" class="headerlink" title="6.8 模式应用"></a>6.8 模式应用</h3><ol>
<li>状态模式在<strong>工作流或游戏</strong>等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。<strong>使用状态模式可以描述工作流对象(如批文)的状态转换以及不同状态下它所具有的行为。</strong></li>
<li>在目前主流的RPG(Role Play Game，角色扮演游戏)中，<strong>使用状态模式可以对游戏角色进行控制</strong>，游戏角色的升级伴随着其状态的变化和行为的变化。对于游戏程序本身也可以通过状态模式进行总控，一个游戏活动包括开始、运行、结束等状态，通过对状态的控制可以控制系统的行为，决定游戏的各个方面，因此<strong>可以使用状态模式对整个游戏的架构进行设计与实现</strong>。</li>
</ol>
<h3 id="6-9-模式扩展"><a href="#6-9-模式扩展" class="headerlink" title="6.9 模式扩展"></a>6.9 模式扩展</h3><h4 id="共享状态"><a href="#共享状态" class="headerlink" title="共享状态"></a>共享状态</h4><p>在有些情况下<strong>多个环境对象需要共享同一个状态</strong>，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么<strong>需要将这些状态对象定义为环境的静态成员对象</strong>。</p>
<h4 id="简单状态模式与可切换状态的状态模式"><a href="#简单状态模式与可切换状态的状态模式" class="headerlink" title="简单状态模式与可切换状态的状态模式"></a>简单状态模式与可切换状态的状态模式</h4><ol>
<li><strong>简单状态模式</strong>：简单状态模式是指<strong>状态都相互独立，状态之间无须进行转换的状态模式</strong>，这是最简单的一种状态模式。对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到环境类中。<strong>如果是这种简单的状态模式，它遵循“开闭原则”，在客户端可以针对抽象状态类进行编程</strong>，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。</li>
<li><strong>可切换状态的状态模式</strong>：大多数的状态模式都是<strong>可以切换状态的状态模式</strong>，在实现状态切换时，在具体状态类内部需要调用环境类<strong>Context的setState()</strong>方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换。在这种可以切换状态的状态模式中，<strong>增加新的状态类可能需要修改其他某些状态类甚至环境类的源代码</strong>，否则系统无法切换到新增状态。</li>
</ol>
<h2 id="7-策略模式-对象"><a href="#7-策略模式-对象" class="headerlink" title="7. 策略模式(对象)"></a>7. 策略模式(对象)</h2><h3 id="7-1-模式描述"><a href="#7-1-模式描述" class="headerlink" title="7.1 模式描述"></a>7.1 模式描述</h3><p>策略模式定义了一系列算法，将每个算法封装在一起，并使它们可替换。策略使算法可以独立于使用该算法的客户端而变化</p>
<ol>
<li>变化在客户使用时才会出现，也就是要实现这个模式就必须要将细节暴露给用户。</li>
<li>实际开发的时候，可能是由多个设计模式组合成的</li>
<li>我们可能需要一个算法族，希望彼此是可以替换的</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302010414510.png" alt="image-20230302010414510" style="zoom:80%;" /></p>
<h3 id="7-2-模式动机"><a href="#7-2-模式动机" class="headerlink" title="7.2 模式动机"></a>7.2 模式动机</h3><ul>
<li>例如：存在许多用于将文本流分成行的算法。将所有这样的算法硬连接到类中是不可取的。<ul>
<li>不满足开闭原则，每次修改都要反复检查每一个条件语句</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302010708842.png" alt="image-20230302010708842" style="zoom:80%;" /></p>
<h3 id="7-3-应用场景"><a href="#7-3-应用场景" class="headerlink" title="7.3 应用场景"></a>7.3 应用场景</h3><p>在以下情况下使用策略模式</p>
<ol>
<li>许多相关的类仅在<strong>行为</strong>上有所不同，策略提供了一种使用其中一种行为配置类的方法</li>
<li>您需要<strong>算法的不同变体</strong>。例如，您可能定义了反映不同空间/时间权衡的算法。将这些变体实现为算法的类层次结构时，可以使用策略。</li>
<li>一种算法使用客户端不应该知道的数据。使用策略模式<strong>可避免暴露复杂的、特定于算法的数据结构</strong></li>
<li>一个类定义了许多行为，这些行为在其操作中显示为多个条件语句。代替许多条件，将相关的条件分支移到他们自己的<strong>策略类</strong>中。</li>
</ol>
<h3 id="7-4-产生的结果"><a href="#7-4-产生的结果" class="headerlink" title="7.4 产生的结果"></a>7.4 产生的结果</h3><ul>
<li>相关算法族(<em>Families of related algorithms</em>)<ul>
<li>策略类的层次结构定义了一个算法族或行为，以供上下文重用。继承可以帮助分解出算法的通用功能</li>
</ul>
</li>
<li>子类化的替代方法(<em>An alternative to subclassing</em>)</li>
<li>策略消除了条件语句(<em>Strategies eliminate conditional statements</em>)</li>
<li>多种实现方式(<em>A choice of implementations</em>)<ul>
<li>策略可以提供相同行为的不同实现。客户可以选择具有不同时间和空间权衡的策略</li>
</ul>
</li>
<li>客户必须意识到不同的策略(<em>Clients must be aware of different Strategies</em>)<ul>
<li>这种模式有一个潜在的缺点，即<strong>客户在选择合适的策略之前必须先了解策略的不同</strong>，不然客户可能会遇到实现问题</li>
</ul>
</li>
<li>策略和上下文之间的通信开销(<em>Communication overhead between Strategy and Context</em>)</li>
<li>对象数量增加(<em>Increased number of objects</em>)</li>
</ul>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-3-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-08-19 00:15:38
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/" title="NJU">
                        <b>#</b> NJU
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="软件系统设计">
                        <b>#</b> 软件系统设计
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-5-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E3%80%81POP%E3%80%81MVC/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-%E7%B1%BB"><span class="toc-text">1. 模板方法模式(类)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">1.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">1.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">1.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">1.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">1.5 模板方法模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">1.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">1.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">1.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%A8%E8%AE%BA"><span class="toc-text">关于继承的讨论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E8%8E%B1%E5%9D%9E%E5%8E%9F%E5%88%99"><span class="toc-text">好莱坞原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">钩子方法的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">1.10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. 命令模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">2.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">2.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">2.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">2.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">2.5 命令模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">2.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">2.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">2.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">撤销操作的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">宏命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 迭代器模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">3.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">3.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">3.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">3.4 模式分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%AE%BD%E6%8E%A5%E5%8F%A3-vs-%E7%AA%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">不同的实现(宽接口 vs. 窄接口)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BD%E7%AE%B1%E8%81%9A%E9%9B%86-vs-%E9%BB%91%E7%AE%B1%E8%81%9A%E9%9B%86"><span class="toc-text">白箱聚集 vs. 黑箱聚集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3.5 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">3.6 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">3.7 模式应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">4. 观察者模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">4.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">4.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">4.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">4.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">4.5 观察者模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">4.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">4.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">4.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AF%B9%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">Java语言提供的对观察者模式的支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9B%B4%E6%96%B0%E8%AF%AD%E4%B9%89"><span class="toc-text">封装复杂的更新语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC%E6%A8%A1%E5%BC%8F"><span class="toc-text">MVC模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">4.10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">5. 中介者模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">5.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">5.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">5.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">5.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">5.5 中介者模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">5.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">5.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">5.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">5.9 模式扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E5%B0%8F%E7%BB%93"><span class="toc-text">5.10 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">6. 状态模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">6.1 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">6.2 模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">6.3 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">6.4 模式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-text">6.5 状态模式实例与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">6.6 模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-text">6.7 模式适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-text">6.8 模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-text">6.9 模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-text">共享状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%AF%E5%88%87%E6%8D%A2%E7%8A%B6%E6%80%81%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-text">简单状态模式与可切换状态的状态模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1"><span class="toc-text">7. 策略模式(对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A8%A1%E5%BC%8F%E6%8F%8F%E8%BF%B0"><span class="toc-text">7.1 模式描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-text">7.2 模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">7.3 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E4%BA%A7%E7%94%9F%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text">7.4 产生的结果</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1(4)%20%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2023%2F04%2F30%2F%25E8%25BD%25AF%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F%25E8%25AE%25BE%25E8%25AE%25A1-%25E8%25AE%25BE%25E8%25AE%25A1-4-%25E8%25A1%258C%25E4%25B8%25BA%25E5%259E%258B%25E6%25A8%25A1%25E5%25BC%258F%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-4-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
