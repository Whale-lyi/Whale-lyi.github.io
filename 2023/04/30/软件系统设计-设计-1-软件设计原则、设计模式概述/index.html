<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="南京大学软件学院大三在读" />
  
  
  <title>
    
      软件系统设计-设计(1) 软件设计原则 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">软件系统设计-设计(1) 软件设计原则</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-08-19 00:15:38
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/NJU/" title="NJU">
                    <b>#</b> NJU
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="软件系统设计">
                    <b>#</b> 软件系统设计
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="1-软件设计原则"><a href="#1-软件设计原则" class="headerlink" title="1. 软件设计原则"></a>1. 软件设计原则</h2><blockquote>
<p>不会直接考，理解即可</p>
</blockquote>
<h3 id="1-1-面向对象设计原则概述"><a href="#1-1-面向对象设计原则概述" class="headerlink" title="1.1 面向对象设计原则概述"></a>1.1 面向对象设计原则概述</h3><p>知名软件大师Robert C.Martin认为一个可维护性(Maintainability)较低的软件设计，通常由于如下 4 个原因造成：</p>
<ol>
<li>过于僵硬(Rigidity)：硬编码等</li>
<li>过于脆弱(Fragility)：软件一个部分的修改会影响另一个未预期的部分</li>
<li>复用率低(Immobility)：期望类和子系统可以作为黑盒使用</li>
<li>黏度过高(Viscosity)：在架构层面上，如果修改时需要修改整体的架构</li>
</ol>
<p>软件工程和建模大师Peter Coad认为，一个好的系统设计应该具备如下三个性质：</p>
<ol>
<li>可扩展性(Extensibility)</li>
<li>灵活性(Flexibility)</li>
<li>可插入性(Pluggability)</li>
</ol>
<h4 id="软件的可维护性和可复用性"><a href="#软件的可维护性和可复用性" class="headerlink" title="软件的可维护性和可复用性"></a>软件的可维护性和可复用性</h4><ol>
<li><strong>软件的复用(Reuse)或重用</strong>拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本，<strong>恰当的复用还可以改善系统的可维护性。</strong></li>
<li>面向对象设计复用的目标在于<strong>实现支持可维护性的复用</strong>。</li>
<li>在面向对象的设计里面，<strong>可维护性复用都是以面向对象设计原则为基础的</strong>，这些设计原则首先都是复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。</li>
<li>面向对象设计原则也是对系统进行合理重构的指南针，<strong>重构(Refactoring)是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。</strong></li>
</ol>
<h4 id="面向对象设计原则简介"><a href="#面向对象设计原则简介" class="headerlink" title="面向对象设计原则简介"></a>面向对象设计原则简介</h4><ol>
<li>常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。</li>
<li>原则之间也会有相互的作用</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230307105144843.png" alt="image-20230307105144843" style="zoom:80%;" /></p>
<h3 id="1-2-单一职责原则"><a href="#1-2-单一职责原则" class="headerlink" title="1.2 单一职责原则"></a>1.2 单一职责原则</h3><h4 id="单一职责原则定义"><a href="#单一职责原则定义" class="headerlink" title="单一职责原则定义"></a>单一职责原则定义</h4><p>单一职责原则(Single Responsibility Principle, SRP)定义如下：</p>
<ul>
<li>一个对象应该只包含<strong>单一的职责</strong>，并且该职责被完整地封装在一个类中。</li>
<li>Every object should have a <strong>single responsibility</strong>, and that responsibility should be entirely encapsulated by the class.</li>
</ul>
<p>另一种定义方式如下：</p>
<ul>
<li>就一个类而言，应该<strong>仅有一个引起它变化的原因</strong>。</li>
<li>There should <strong>never be more than one reason for a class to change</strong></li>
</ul>
<h4 id="单一职责原则分析"><a href="#单一职责原则分析" class="headerlink" title="单一职责原则分析"></a>单一职责原则分析</h4><ol>
<li><strong>一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小</strong>，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。</li>
<li><p>类的职责主要包括两个方面：</p>
<ul>
<li><p><strong>数据职责</strong>：通过其属性来体现。</p>
</li>
<li><p><strong>行为职责</strong>：通过其方法来体现。</p>
</li>
</ul>
</li>
<li>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</li>
</ol>
<h4 id="单一职责原则实例"><a href="#单一职责原则实例" class="headerlink" title="单一职责原则实例"></a>单一职责原则实例</h4><p>某基于Java的C/S系统的”登录功能”通过如下登录类(Login)实现：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/4.png" alt="img" style="zoom: 50%;" /></p>
<p>现使用单一职责原则对其进行重构</p>
<ul>
<li><p>我们将Login类拆分成了三个类</p>
</li>
<li><p>使用分层的方式修改</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/5.png" alt="img" style="zoom: 50%;" /></p>
<h3 id="1-3-开闭原则"><a href="#1-3-开闭原则" class="headerlink" title="1.3 开闭原则"></a>1.3 开闭原则</h3><h4 id="开闭原则定义"><a href="#开闭原则定义" class="headerlink" title="开闭原则定义"></a>开闭原则定义</h4><p>开闭原则(Open-Closed Principle, OCP)定义如下：</p>
<ul>
<li>一个软件实体应当<strong>对扩展开放，对修改关闭</strong>。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</li>
<li>Software entities should be <strong>open for extension</strong>, but <strong>closed for modification</strong></li>
</ul>
<h4 id="开闭原则分析"><a href="#开闭原则分析" class="headerlink" title="开闭原则分析"></a>开闭原则分析</h4><ol>
<li><p>在开闭原则的定义中，<strong>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong>。</p>
</li>
<li><p><strong>抽象化</strong>是开闭原则的关键。</p>
</li>
<li>开闭原则还可以通过一个更加具体的”<strong>对可变性封装原则</strong>“来描述，对可变性封装原则(<strong>Principle of Encapsulation of Variation, EVP</strong>)要求找到系统的可变因素并将其封装起来。</li>
<li>我们需要知道系统的哪些部分是变化的，开闭原则也是对单一职责原则的增强。而里氏代换原则和依赖倒置原则都是开闭原则的具体实现。</li>
</ol>
<h4 id="开闭原则实例"><a href="#开闭原则实例" class="headerlink" title="开闭原则实例"></a>开闭原则实例</h4><p>某图形界面系统提供了各种不同形状的按钮，客户端代码可针对这些按钮进行编程，用户可能会改变需求要求使用不同的按钮，原始设计方案如图所示</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/6.png" alt="img" style="zoom: 50%;" /></p>
<p>现对该系统进行重构，使之满足开闭原则的要求：尝试将代码变为数据(配置文件，Config.xml)，结合Java的反射机制来完成</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230610215106966.png" alt="image-20230610215106966"></p>
<h3 id="1-4-里氏代换原则"><a href="#1-4-里氏代换原则" class="headerlink" title="1.4 里氏代换原则"></a>1.4 里氏代换原则</h3><h4 id="里氏代换原则定义"><a href="#里氏代换原则定义" class="headerlink" title="里氏代换原则定义"></a>里氏代换原则定义</h4><p>里氏代换原则(Liskov Substitution Principle, LSP)有两种定义方式，第一种定义方式相对严格，其定义如下：</p>
<ul>
<li><p>如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o2 都代换成 o1 时，程序 P 的行为没有变化，那么类型 S 是类型 T 的子类型。</p>
</li>
<li><p>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</p>
</li>
</ul>
<p>第二种更容易理解的定义方式如下：</p>
<ul>
<li><p><strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong>。</p>
</li>
<li><p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
</li>
</ul>
<h4 id="里氏代换原则分析"><a href="#里氏代换原则分析" class="headerlink" title="里氏代换原则分析"></a>里氏代换原则分析</h4><ol>
<li>里氏代换原则可以通俗表述为：在<strong>软件中如果能够使用基类对象，那么一定能够使用其子类对象。</strong>把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。</li>
<li>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</li>
<li>Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T.</li>
<li><strong>子类不应该是父类的功能的扩展，我们可以使用组合的方式来扩展功能</strong></li>
</ol>
<h4 id="里氏代换原则实例"><a href="#里氏代换原则实例" class="headerlink" title="里氏代换原则实例"></a>里氏代换原则实例</h4><p>某系统需要实现对重要数据（如用户密码）的加密处理，在数据操作类(DataOperator)中需要调用加密类中定义的加密算法，系统提供了两个不同的加密类，CipherA 和 CipherB，它们实现不同的加密方法，在 DataOperator中 可以选择其中的一个实现加密操作。如图所示：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/8.png" alt="img" style="zoom: 50%;" /></p>
<p>也可以为CipherA和CipherB设计一个共同的父类，下面是指CipherB是在CipherA的基础上加密。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/9.png" alt="img" style="zoom:50%;" /></p>
<h3 id="1-5-依赖倒转原则"><a href="#1-5-依赖倒转原则" class="headerlink" title="1.5 依赖倒转原则"></a>1.5 依赖倒转原则</h3><h4 id="依赖倒转原则定义"><a href="#依赖倒转原则定义" class="headerlink" title="依赖倒转原则定义"></a>依赖倒转原则定义</h4><p>依赖倒转原则(Dependence Inversion Principle, DIP)的定义如下：</p>
<ul>
<li>高层模块<strong>不应该依赖低层模块</strong>，它们都应该<strong>依赖抽象</strong>。<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。</li>
<li>High level modules should not depend upon low level modules, both should depend upon abstractions. <strong>Abstractions should not depend upon details, details should depend upon abstractions</strong>.</li>
</ul>
<p>另一种表述为：</p>
<ul>
<li><p><strong>要针对接口编程，不要针对实现编程</strong>。</p>
</li>
<li><p>Program to an interface, not an implementation.</p>
</li>
</ul>
<h4 id="依赖倒转原则分析"><a href="#依赖倒转原则分析" class="headerlink" title="依赖倒转原则分析"></a>依赖倒转原则分析</h4><ol>
<li>简单来说，依赖倒转原则就是指：<strong>代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程</strong>。</li>
<li>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说<strong>开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段</strong>。</li>
<li>依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件<ul>
<li><strong>将抽象放进代码，将细节放进元数据</strong></li>
<li><strong>Put Abstractions in Code, Details in Metadata</strong></li>
</ul>
</li>
<li>类之间的耦合<ul>
<li><strong>零耦合</strong>关系：最好情况，但是不切实际</li>
<li><strong>具体耦合</strong>关系</li>
<li><strong>抽象耦合</strong>关系：依赖倒转要求至少一端是抽象的</li>
</ul>
</li>
<li>依赖倒转原则要求客户端依赖于抽象耦合，<strong>以抽象方式耦合是依赖倒转原则的关键</strong>。</li>
</ol>
<h4 id="依赖倒转原则实例"><a href="#依赖倒转原则实例" class="headerlink" title="依赖倒转原则实例"></a>依赖倒转原则实例</h4><p>某系统提供一个数据转换模块，可以将来自不同数据源的数据转换成多种格式，如可以转换来自数据库的数据(DatabaseSource)、也可以转换来自文本文件的数据(TextSource)，转换后的格式可以是XML文件(XMLTransformer)、也可以是XLS文件(XLSTransformer)等。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/11.png" alt="img" style="zoom:50%;" /></p>
<p>由于需求的变化，该系统可能需要增加新的数据源或者新的文件格式，每增加一个新的类型的数据源或者新的类型的文件格式，客户类MainClass都需要修改源代码，以便使用新的类，但违背了开闭原则。现使用依赖倒转原则对其进行重构。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/12.png" alt="img" style="zoom:50%;" /></p>
<h3 id="1-6-接口隔离原则"><a href="#1-6-接口隔离原则" class="headerlink" title="1.6 接口隔离原则"></a>1.6 接口隔离原则</h3><h4 id="接口隔离原则定义"><a href="#接口隔离原则定义" class="headerlink" title="接口隔离原则定义"></a>接口隔离原则定义</h4><p>接口隔离原则(Interface Segregation Principle, ISP)的定义如下：</p>
<ul>
<li><p>客户端<strong>不应该依赖</strong>那些<strong>它不需要的接口</strong>。</p>
</li>
<li><p>Clients should not be forced to depend upon interfaces that they do not use.</p>
</li>
<li><p>注意，在该定义中的接口指的是所定义的方法。</p>
</li>
</ul>
<p>另一种定义方法如下：</p>
<ul>
<li>一旦一个<strong>接口太大</strong>，则需要将它<strong>分割成一些更细小的接口</strong>，使用该接口的客户端仅需知道与之相关的方法即可。</li>
<li>Once an interface has gotten too ‘fat’ it needs to be <strong>split into smaller and more specific interfaces</strong> so that any clients of the interface will only know about the methods that pertain to them.</li>
</ul>
<h4 id="接口隔离原则分析"><a href="#接口隔离原则分析" class="headerlink" title="接口隔离原则分析"></a>接口隔离原则分析</h4><ol>
<li>接口隔离原则是指<strong>使用多个专门的接口，而不使用单一的总接口</strong>。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。<ol>
<li>一个接口就<strong>只代表一个角色</strong>，每个角色都有它特定的一个接口，此时这个原则可以叫做”角色隔离原则”。</li>
<li>接口<strong>仅仅提供客户端需要的行为</strong>，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li>
</ol>
</li>
<li>使用接口隔离原则拆分接口时，首先必须满足<strong>单一职责原则</strong>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</li>
<li>可以在进行系统设计时采用<strong>定制服务</strong>的方式，即<strong>为不同的客户端提供宽窄不同的接口</strong>，只提供用户需要的行为，而隐藏用户不需要的行为。</li>
</ol>
<h4 id="接口隔离原则实例"><a href="#接口隔离原则实例" class="headerlink" title="接口隔离原则实例"></a>接口隔离原则实例</h4><p>下图展示了一个拥有多个客户类的系统，在系统中定义了一个巨大的接口（胖接口）AbstractService来服务所有的客户类。可以使用接口隔离原则对其进行重构。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/13.png" alt="img" style="zoom:50%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230610221325326.png" alt="image-20230610221325326"></p>
<h3 id="1-7-合成复用原则"><a href="#1-7-合成复用原则" class="headerlink" title="1.7 合成复用原则"></a>1.7 合成复用原则</h3><h4 id="合成复用原则定义"><a href="#合成复用原则定义" class="headerlink" title="合成复用原则定义"></a>合成复用原则定义</h4><p>合成复用原则(Composite Reuse Principle, CRP)又称为组合/聚合复用原则(Composition/ Aggregate Reuse Principle,CARP)</p>
<p>其定义如下：</p>
<ul>
<li><p><strong>尽量使用对象组合</strong>，而<strong>不是继承</strong>来达到复用的目的。</p>
</li>
<li><p>Favor composition of objects over inheritance as a reuse mechanism.</p>
</li>
</ul>
<h4 id="合成复用原则分析"><a href="#合成复用原则分析" class="headerlink" title="合成复用原则分析"></a>合成复用原则分析</h4><ol>
<li>合成复用原则就是指在一个新的对象里通过<strong>关联关系（包括组合关系和聚合关系）</strong>来使用一些已有的对象，使之成为新对象的一部分；新对象<strong>通过委派调用已有对象的方法达到复用其已有功能的目的</strong>。简言之：<strong>要尽量使用组合/聚合关系，少用继承</strong>。</li>
<li>在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过<strong>组合/聚合关系</strong>或通过<strong>继承</strong>。<ul>
<li><em>继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（”<strong>白箱</strong>“复用）</em></li>
<li><em>组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（”<strong>黑箱</strong>“复用）</em></li>
</ul>
</li>
<li>组合/聚合可以<strong>使系统更加灵活</strong>，类与类之间的<strong>耦合度降低</strong>，一个类的变化对其他类造成的影响相对较少，因此一般<strong>首选使用组合/聚合来实现复用</strong>；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要<strong>慎重使用继承复用</strong>。</li>
</ol>
<h4 id="合成复用原则实例"><a href="#合成复用原则实例" class="headerlink" title="合成复用原则实例"></a>合成复用原则实例</h4><p>某教学管理系统部分数据库访问类设计如图所示</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230610221538019.png" alt="image-20230610221538019"></p>
<p>如果需要更换数据库连接方式，如原来采用 JDBC 连接数据库，现在采用数据库连接池连接，则需要修改DBUtil类源代码。如果 StudentDAO 采用 JDBC 连接，但是 TeacherDAO 采用连接池连接，则需要增加一个新的 DBUtil 类，并修改 StudentDAO 或 TeacherDAO 的源代码，使之继承新的数据库连接类，这将违背开闭原则，系统扩展性较差。</p>
<p>现使用合成复用原则对其进行重构。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/16.png" alt="img" style="zoom: 50%;" /></p>
<h3 id="1-8-最小知识原则-迪米特法则"><a href="#1-8-最小知识原则-迪米特法则" class="headerlink" title="1.8 最小知识原则(迪米特法则)"></a>1.8 最小知识原则(迪米特法则)</h3><h4 id="迪米特法则定义"><a href="#迪米特法则定义" class="headerlink" title="迪米特法则定义"></a>迪米特法则定义</h4><p>迪米特法则(Law of Demeter, LoD)又称为最少知识原则(Least Knowledge Principle, LKP)，它有多种定义方法，其中几种典型定义如下：</p>
<ol>
<li><strong>不要和”陌生人”说话</strong>。<ul>
<li>Don’t talk to strangers.</li>
</ul>
</li>
<li><strong>只与你的直接朋友通信</strong>。<ul>
<li>Talk only to your immediate friends.</li>
</ul>
</li>
<li><strong>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。<ul>
<li>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.</li>
</ul>
</li>
</ol>
<h4 id="迪米特法则分析"><a href="#迪米特法则分析" class="headerlink" title="迪米特法则分析"></a>迪米特法则分析</h4><ol>
<li><p>简单地说，迪米特法则就是指<strong>一个软件实体应当尽可能少的与其他实体发生相互作用</strong>。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。</p>
</li>
<li><p>在迪米特法则中，对于一个对象，其<strong>朋友</strong>包括以下几类：</p>
<ol>
<li>当前对象本身(this)</li>
<li>以参数形式传入到当前对象方法中的对象</li>
<li>当前对象的成员对象</li>
<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li>
<li>当前对象所创建的对象。</li>
</ol>
</li>
<li><p>任何一个对象，如果满足上面的条件之一，就是当前对象的”朋友”，否则就是”陌生人”。</p>
</li>
<li><p>迪米特法则可分为狭义法则和广义法则。在<strong>狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用</strong>，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过<strong>第三者转发这个调用</strong>。下图中，只允许 A 调用 B 对象的方法，但是不能调用 C 对象的方法(但是我们可以通过在 B 中添加一个 Wrapper 方法来间接调用 C)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/17.png" alt="img" style="zoom:50%;" /></p>
</li>
<li><p>狭义的迪米特法则：可以<strong>降低类之间的耦合</strong>，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会<strong>造成系统的不同模块之间的通信效率降低</strong>，使得系统的不同模块之间不容易协调。</p>
</li>
<li><p>广义的迪米特法则：指<strong>对对象之间的信息流量、流向以及信息的影响的控制</strong>，主要是<strong>对信息隐藏的控制</strong>。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。</p>
</li>
<li><p>迪米特法则的主要用途在于控制信息的过载：</p>
<ul>
<li>在类的划分上，应当尽量<strong>创建松耦合的类</strong>，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及</li>
<li>在类的结构设计上，每一个类都应当<strong>尽量降低其成员变量和成员函数的访问权限</strong></li>
<li>在类的设计上，只要有可能，<strong>一个类型应当设计成不变类</strong></li>
<li>在对其他类的引用上，<strong>一个对象对其他对象的引用应当降到最低</strong></li>
</ul>
</li>
</ol>
<h4 id="迪米特法则实例"><a href="#迪米特法则实例" class="headerlink" title="迪米特法则实例"></a>迪米特法则实例</h4><p>某系统界面类(如Form1、Form2等类)与数据访问类(如DAO1、DAO2等类)之间的调用关系较为复杂，如图所示：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/18.png" alt="img" style="zoom:50%;" /></p>
<p>使用迪米特法则修改</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/19.png" alt="img" style="zoom: 50%;" /></p>
<h3 id="1-9-小结"><a href="#1-9-小结" class="headerlink" title="1.9 小结"></a>1.9 小结</h3><ul>
<li>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</li>
<li>软件的复用可以提高软件的开发效率，提高软件质量，节约开发成本，恰当的复用还可以改善系统的可维护性。</li>
<li>单一职责原则要求在软件系统中，一个类只负责一个功能领域中的相应职责。</li>
<li>开闭原则要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</li>
<li><p>里氏代换原则可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p>
</li>
<li><p>依赖倒转原则要求抽象不应该依赖于细节，细节应该依赖于抽象；要针对接口编程，不要针对实现编程。</p>
</li>
<li>接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</li>
<li>合成复用原则要求复用时尽量使用对象组合，而不使用继承。</li>
<li><p>迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。</p>
</li>
<li><p>目标：开闭原则</p>
</li>
<li>指导：最小知识原则</li>
<li>基础：单一职责原则、可变性封装原则</li>
<li>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</li>
</ul>
<h2 id="2-设计模式概述"><a href="#2-设计模式概述" class="headerlink" title="2. 设计模式概述"></a>2. 设计模式概述</h2><p><a target="_blank" rel="noopener" href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Lec02-Strategy%20Pattern/">It is started with a simple SimUDuck application</a></p>
<h3 id="2-1-设计原则"><a href="#2-1-设计原则" class="headerlink" title="2.1 设计原则"></a>2.1 设计原则</h3><ul>
<li>封装各种变化<ul>
<li>对应实现的原则：<strong>开闭原则</strong></li>
</ul>
</li>
<li>面向接口编程，而不是面向实现<ul>
<li>对应实现的原则：<strong>依赖倒转原则</strong></li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230302005659071.png" alt="image-20230302005659071" style="zoom:80%;" /></p>
<h3 id="2-2-HAS-A可以比IS-A更好"><a href="#2-2-HAS-A可以比IS-A更好" class="headerlink" title="2.2 HAS-A可以比IS-A更好"></a>2.2 HAS-A可以比IS-A更好</h3><blockquote>
<p>优先考虑组合而不是继承</p>
</blockquote>
<ol>
<li>组合提供了更多的灵活性</li>
<li>它不仅可以将一个算法族封装到自己的类集中，而且还可以在运行时更改行为</li>
</ol>
<h3 id="2-3-引入设计模式的作用"><a href="#2-3-引入设计模式的作用" class="headerlink" title="2.3 引入设计模式的作用"></a>2.3 引入设计模式的作用</h3><h4 id="2-3-1-共享词汇"><a href="#2-3-1-共享词汇" class="headerlink" title="2.3.1 共享词汇"></a>2.3.1 共享词汇</h4><ul>
<li>设计模式为您提供了与其他开发人员共享的词汇表。</li>
<li>通过让您在<strong>模式级别</strong>(而不是实质性对象级别)进行思考，还可以提高您对体系结构的思考。</li>
</ul>
<h4 id="2-3-2-共享模式词汇的力量"><a href="#2-3-2-共享模式词汇的力量" class="headerlink" title="2.3.2 共享模式词汇的力量"></a>2.3.2 共享模式词汇的力量</h4><ul>
<li>共享模式词汇很强大<ul>
<li>当您使用模式与其他开发人员或团队进行沟通时，您不仅在沟通模式名称，还传达了模式所代表的整套质量属性，特征和约束</li>
</ul>
</li>
<li>模式可以让您用更少的话表达更多。<ul>
<li>当您在描述中使用模式时，其他开发人员会快速准确地了解您所考虑的设计。</li>
</ul>
</li>
<li>在模式级别进行交谈可以使您在”设计中”停留的时间更长。<ul>
<li>不要迷失在细节中。</li>
</ul>
</li>
<li>共享词汇可以为您的开发团队提供强大的动力。</li>
<li>共享的词汇表鼓励更多的初级开发人员快速上手。</li>
</ul>
<h3 id="2-4-如何使用设计模式"><a href="#2-4-如何使用设计模式" class="headerlink" title="2.4 如何使用设计模式"></a>2.4 如何使用设计模式</h3><ul>
<li>依赖库和框架：提供了全部和必要的功能，一般可以直接直接复用</li>
<li>设计模式帮助我们构建自己的应用程序，以使其更具可维护性和灵活性</li>
<li>设计模式首先进入你的大脑</li>
</ul>
<h4 id="2-4-1-工具"><a href="#2-4-1-工具" class="headerlink" title="2.4.1 工具"></a>2.4.1 工具</h4><ul>
<li>面向对象的基础 OO Basics<ul>
<li>抽象 Abstraction</li>
<li>封装 Encapsulation</li>
<li>多态性 Polymorphism</li>
<li>继承 Inheritance</li>
</ul>
</li>
<li>面向对象原则 OO Principles<ul>
<li>封装可变性 Encapsulate what varies</li>
<li>选择组合而不是继承 Favor composition over inheritance</li>
<li>面向接口编程，而不是面向实现编程 Program to interfaces, not implementation</li>
</ul>
</li>
<li>面向对象模式 OO Patterns：<ul>
<li>策略 Strategy</li>
</ul>
</li>
</ul>
<h3 id="2-5-软件模式"><a href="#2-5-软件模式" class="headerlink" title="2.5 软件模式"></a>2.5 软件模式</h3><p>软件模式是将模式的一般概念应用于软件开发领域，即<strong>软件开发的总体指导思路或参照样板</strong>。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，<strong>在软件生存期的每一个阶段都存在着一些被认同的模式</strong>。</p>
<p>软件模式可以认为是<strong>对软件开发这一特定“问题”的“解法”的某种统一表示</strong>，<strong>软件模式等于一定条件下的出现的问题以及解法</strong>。软件模式的基础结构由 4 个部分构成：<strong>问题描述</strong>、<strong>前提条件（环境或约束条件）</strong>、<strong>解法</strong>和<strong>效果</strong>。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230613143450535.png" alt="image-20230613143450535" style="zoom:80%;" /></p>
<p>软件模式与具体的应用领域无关，在模式发现过程中需要遵循<strong>大三律(Rule of Three)</strong>，即只有经过<strong>三个以上不同类型（或不同领域）的系统</strong>的校验，一个解决方案才能从候选模式升格为模式。</p>
<h3 id="2-6-设计模式"><a href="#2-6-设计模式" class="headerlink" title="2.6 设计模式"></a>2.6 设计模式</h3><h4 id="2-6-1-定义"><a href="#2-6-1-定义" class="headerlink" title="2.6.1 定义"></a>2.6.1 定义</h4><p><strong>设计模式(Design Pattern)</strong>是一套<strong>被反复使用、多数人知晓的、经过分类编目的代码设计经验的总结</strong>，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
<h4 id="2-6-2-基本要素"><a href="#2-6-2-基本要素" class="headerlink" title="2.6.2 基本要素"></a>2.6.2 基本要素</h4><p>设计模式一般有如下几个<strong>基本要素</strong>：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素包括以下四个方面：</p>
<ul>
<li><strong>模式名称</strong> (Pattern name)</li>
<li><strong>问题</strong> (Problem)</li>
<li><strong>解决方案</strong> (Solution)</li>
<li><strong>效果</strong> (Consequences) </li>
</ul>
<h4 id="2-6-3-分类"><a href="#2-6-3-分类" class="headerlink" title="2.6.3 分类"></a>2.6.3 分类</h4><p>根据其<strong>目的</strong>（模式是用来做什么的）可分为<strong>创建型 (Creational)</strong>，<strong>结构型 (Structural)</strong>和<strong>行为型 (Behavioral)</strong>三种：</p>
<ul>
<li>创建型模式主要用于<strong>创建对象</strong>。</li>
<li>结构型模式主要用于<strong>处理类或对象的组合</strong>。</li>
<li>行为型模式主要用于<strong>描述对类或对象怎样交互和怎样分配职责</strong>。</li>
</ul>
<p>根据<strong>范围</strong>，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为<strong>类模式</strong>和<strong>对象模式</strong>两种：</p>
<ul>
<li>类模式<strong>处理类和子类之间的关系</strong>，这些关系通过<strong>继承</strong>建立，在编译时刻就被确定下来，是属于<strong>静态</strong>的。</li>
<li>对象模式<strong>处理对象间的关系</strong>，这些关系在运行时刻变化，更具<strong>动态</strong>性。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230627114431082.png" alt="image-20230627114431082" style="zoom:80%;" /></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/04/13/Linux%E9%87%8D%E7%82%B9/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-08-19 00:15:38
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/" title="NJU">
                        <b>#</b> NJU
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="软件系统设计">
                        <b>#</b> 软件系统设计
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-2-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">1. 软件设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 面向对象设计原则概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%92%8C%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7"><span class="toc-text">软件的可维护性和可复用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%AE%80%E4%BB%8B"><span class="toc-text">面向对象设计原则简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-text">1.2 单一职责原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">单一职责原则定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E5%88%86%E6%9E%90"><span class="toc-text">单一职责原则分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E5%AE%9E%E4%BE%8B"><span class="toc-text">单一职责原则实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">1.3 开闭原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">开闭原则定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E5%88%86%E6%9E%90"><span class="toc-text">开闭原则分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E5%AE%9E%E4%BE%8B"><span class="toc-text">开闭原则实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">1.4 里氏代换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">里氏代换原则定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%E5%88%86%E6%9E%90"><span class="toc-text">里氏代换原则分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%E5%AE%9E%E4%BE%8B"><span class="toc-text">里氏代换原则实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="toc-text">1.5 依赖倒转原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">依赖倒转原则定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E5%88%86%E6%9E%90"><span class="toc-text">依赖倒转原则分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E5%AE%9E%E4%BE%8B"><span class="toc-text">依赖倒转原则实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-text">1.6 接口隔离原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">接口隔离原则定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E5%88%86%E6%9E%90"><span class="toc-text">接口隔离原则分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E5%AE%9E%E4%BE%8B"><span class="toc-text">接口隔离原则实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-text">1.7 合成复用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">合成复用原则定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%E5%88%86%E6%9E%90"><span class="toc-text">合成复用原则分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%E5%AE%9E%E4%BE%8B"><span class="toc-text">合成复用原则实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E6%9C%80%E5%B0%8F%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-text">1.8 最小知识原则(迪米特法则)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">迪米特法则定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E5%88%86%E6%9E%90"><span class="toc-text">迪米特法则分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E5%AE%9E%E4%BE%8B"><span class="toc-text">迪米特法则实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E5%B0%8F%E7%BB%93"><span class="toc-text">1.9 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-text">2. 设计模式概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">2.1 设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-HAS-A%E5%8F%AF%E4%BB%A5%E6%AF%94IS-A%E6%9B%B4%E5%A5%BD"><span class="toc-text">2.2 HAS-A可以比IS-A更好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BC%95%E5%85%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2.3 引入设计模式的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%85%B1%E4%BA%AB%E8%AF%8D%E6%B1%87"><span class="toc-text">2.3.1 共享词汇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E8%AF%8D%E6%B1%87%E7%9A%84%E5%8A%9B%E9%87%8F"><span class="toc-text">2.3.2 共享模式词汇的力量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.4 如何使用设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%B7%A5%E5%85%B7"><span class="toc-text">2.4.1 工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.5 软件模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.6 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.6.1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-text">2.6.2 基本要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E5%88%86%E7%B1%BB"><span class="toc-text">2.6.3 分类</span></a></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1(1)%20%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99 + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2023%2F04%2F30%2F%25E8%25BD%25AF%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F%25E8%25AE%25BE%25E8%25AE%25A1-%25E8%25AE%25BE%25E8%25AE%25A1-1-%25E8%25BD%25AF%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258E%259F%25E5%2588%2599%25E3%2580%2581%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%25E6%25A6%2582%25E8%25BF%25B0%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2023/04/30/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1-1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
</body>
</html>
