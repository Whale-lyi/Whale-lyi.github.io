<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Node.js初识 Node.js 与内置模块1. fs 文件系统模块1.1 什么是 fsfs 模块是 Node.js 官方提供的，用来操作文件的模块。提供了一系列的方法和属性，用来满足用户对文件的操作需求  fs.readFile(): 用来读取指定文件的内容 fs.writeFile(): 用来向指定的文件写入内容  如果要在 JS 代码中，使用 fs 模块来操作文件，需要使用如下方式导入 c">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js">
<meta property="og:url" content="https://whale-lyi.github.io/2022/12/30/Node-js/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="Node.js初识 Node.js 与内置模块1. fs 文件系统模块1.1 什么是 fsfs 模块是 Node.js 官方提供的，用来操作文件的模块。提供了一系列的方法和属性，用来满足用户对文件的操作需求  fs.readFile(): 用来读取指定文件的内容 fs.writeFile(): 用来向指定的文件写入内容  如果要在 JS 代码中，使用 fs 模块来操作文件，需要使用如下方式导入 c">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-12-29T16:49:41.000Z">
<meta property="article:modified_time" content="2023-08-09T06:53:19.981Z">
<meta property="article:author" content="Whale">
<meta property="article:tag" content="Node.js">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Node.js</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/01/10/JS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/12/26/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-7-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2022/12/30/Node-js/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://whale-lyi.github.io/2022/12/30/Node-js/&text=Node.js"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://whale-lyi.github.io/2022/12/30/Node-js/&is_video=false&description=Node.js"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Node.js&body=Check out this article: https://whale-lyi.github.io/2022/12/30/Node-js/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://whale-lyi.github.io/2022/12/30/Node-js/&name=Node.js&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://whale-lyi.github.io/2022/12/30/Node-js/&t=Node.js"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Node-js"><span class="toc-number">1.</span> <span class="toc-text">Node.js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-Node-js-%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.</span> <span class="toc-text">初识 Node.js 与内置模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-fs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. fs 文件系统模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-fs"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1 什么是 fs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.2 读取指定文件的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%90%91%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.3 向指定文件写入内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%A4%84%E7%90%86%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.4 处理路径问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-path-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. path 路径模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF-path-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1 什么是 path 路径模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.2 路径拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">2.3 获取路径中的文件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">2.4 获取路径中的文件扩展名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-http-%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. http 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF-http-%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">3.1 什么是 http 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">3.2 创建基本 Web 服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C-url-%E5%93%8D%E5%BA%94%E4%B8%8D%E5%90%8C%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3.3 根据不同 url 响应不同内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 模块化的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.1 什么是模块化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">1.2 模块化规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Node-js-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. Node.js 中的模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Node-js-%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.1 Node.js 中模块的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2 加载模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.3 模块作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%90%91%E5%A4%96%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.4 向外共享模块作用域中的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Node-js-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.5 Node.js 中的模块化规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-npm-%E4%B8%8E%E5%8C%85"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. npm 与包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%8C%85"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">3.1 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-npm"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">3.2 npm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%8C%85%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.3 包管理配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-npm-%E6%8D%A2%E6%BA%90"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">3.4 npm 换源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 模块的加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%BC%98%E5%85%88%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">4.1 优先从缓存中加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">4.2 内置模块的加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">4.3 自定义模块的加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4.4 第三方模块加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E7%9B%AE%E5%BD%95%E4%BD%9C%E4%B8%BA%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">4.5 目录作为模块加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Express"><span class="toc-number">1.3.</span> <span class="toc-text">Express</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E8%AF%86-Express"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 初识 Express</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">1.2 托管静态资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Express-%E8%B7%AF%E7%94%B1"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. Express 路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">2.1 路由的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.2 路由的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Express-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. Express 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.1 中间件的概念</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Node.js
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Whale</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-12-29T16:49:41.000Z" class="dt-published" itemprop="datePublished">2022-12-30</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Frontend/">Frontend</a> › <a class="category-link" href="/categories/Frontend/Node-js/">Node.js</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Node-js/" rel="tag">Node.js</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="初识-Node-js-与内置模块"><a href="#初识-Node-js-与内置模块" class="headerlink" title="初识 Node.js 与内置模块"></a>初识 Node.js 与内置模块</h2><h3 id="1-fs-文件系统模块"><a href="#1-fs-文件系统模块" class="headerlink" title="1. fs 文件系统模块"></a>1. fs 文件系统模块</h3><h4 id="1-1-什么是-fs"><a href="#1-1-什么是-fs" class="headerlink" title="1.1 什么是 fs"></a>1.1 什么是 fs</h4><p>fs 模块是 Node.js 官方提供的，用来操作文件的模块。提供了一系列的方法和属性，用来满足用户对文件的操作需求</p>
<ul>
<li><code>fs.readFile()</code>: 用来读取指定文件的内容</li>
<li><code>fs.writeFile()</code>: 用来向指定的文件写入内容</li>
</ul>
<p>如果要在 JS 代码中，使用 fs 模块来操作文件，需要使用如下方式导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="1-2-读取指定文件的内容"><a href="#1-2-读取指定文件的内容" class="headerlink" title="1.2 读取指定文件的内容"></a>1.2 读取指定文件的内容</h4><p><strong><code>fs.readFile()</code>的语法格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(path[, options], callback)<br></code></pre></td></tr></table></figure>
<ul>
<li>参数1: 必选参数，字符串，表示文件的路径</li>
<li>参数2: 可选参数，表示以什么编码格式来读取文件</li>
<li>参数3: 必选参数，文件读取完成后，通过回调函数拿到读取的结果</li>
</ul>
<p><strong><code>fs.readFile()</code>的示例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以 UTF-8 的编码格式, 读取指定文件内容，并打印 err 和 dataStr 的值</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr);<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>读取成功</p>
<ul>
<li>err: null</li>
<li>dataStr: 文件内容</li>
</ul>
</li>
<li><p>读取失败</p>
<ul>
<li>err: 错误对象</li>
<li>dataStr: undefined</li>
</ul>
</li>
</ul>
<p><strong>判断文件是否读取成功</strong></p>
<p>可以判断 err 对象是否为 null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>    <span class="hljs-keyword">if</span>(err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件读取失败: &#x27;</span> + err.<span class="hljs-property">message</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件读取成功, 内容是: &#x27;</span> + dataStr);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="1-3-向指定文件写入内容"><a href="#1-3-向指定文件写入内容" class="headerlink" title="1.3 向指定文件写入内容"></a>1.3 向指定文件写入内容</h4><p><strong><code>fs.writeFile()</code>的语法格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">writeFile</span>(file, data[, options], callback)<br></code></pre></td></tr></table></figure>
<ul>
<li>参数1: 必选参数，需要制定一个文件路径的字符串</li>
<li>参数2: 必选参数，表示要写入的内容</li>
<li>参数3: 可选参数，表示以什么编码格式来写入文件内容, 默认值是 utf8</li>
<li>参数4: 必选参数，文件写入完成后的回调函数</li>
</ul>
<p><strong><code>fs.writeFile()</code>的示例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./11.txt&#x27;</span>, <span class="hljs-string">&#x27;Hello Node.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li>写入成功<ul>
<li>err: null</li>
</ul>
</li>
<li>写入失败<ul>
<li>err: 错误对象</li>
</ul>
</li>
</ul>
<p><strong>判断文件是否写入成功</strong></p>
<p>可以判断 err 对象是否为 null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./11.txt&#x27;</span>, <span class="hljs-string">&#x27;Hello Node.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span>(err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入失败: &#x27;</span> + err.<span class="hljs-property">message</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入成功&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="1-4-处理路径问题"><a href="#1-4-处理路径问题" class="headerlink" title="1.4 处理路径问题"></a>1.4 处理路径问题</h4><p>在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题</p>
<ul>
<li>原因：代码在运行时，会以<strong>执行 node 命令时所处的目录</strong>，动态拼接出被操作文件的完整路径</li>
<li>解决：直接提供完整的路径<ul>
<li><code>__dirname</code> 表示当前文件所处目录</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(__dirname + <span class="hljs-string">&#x27;/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="2-path-路径模块"><a href="#2-path-路径模块" class="headerlink" title="2. path 路径模块"></a>2. path 路径模块</h3><h4 id="2-1-什么是-path-路径模块"><a href="#2-1-什么是-path-路径模块" class="headerlink" title="2.1 什么是 path 路径模块"></a>2.1 什么是 path 路径模块</h4><p>path 模块是 Node.js 官方提供的，用来处理路径的模块。提供了一系列的方法和属性，用来满足用户对路径的处理需求</p>
<ul>
<li><code>path.join()</code>: 用来将多个路径片段拼接成一个完整的路径字符串</li>
<li><code>path.basename()</code>: 用来从路径字符串中，将文件名解析出来</li>
</ul>
<p>使用如下方法导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="2-2-路径拼接"><a href="#2-2-路径拼接" class="headerlink" title="2.2 路径拼接"></a>2.2 路径拼接</h4><p><strong><code>path.join()</code>的语法格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">join</span>([...paths])<br></code></pre></td></tr></table></figure>
<ul>
<li>参数: …paths 字符串类型，路径片段的序列</li>
<li>返回值: 字符串</li>
</ul>
<p><strong><code>path.join()</code>的代码示例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> pathStr = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-string">&#x27;/b/c&#x27;</span>, <span class="hljs-string">&#x27;../&#x27;</span>, <span class="hljs-string">&#x27;./d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathStr); <span class="hljs-comment">// 输出 \a\b\d\e</span><br><br><span class="hljs-keyword">const</span> pathStr2 = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./11.txt&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathStr2);<br></code></pre></td></tr></table></figure>
<ul>
<li>今后涉及到路径的拼接操作，使用 <code>path.join()</code>，不要直接使用 + 进行字符串的拼接</li>
</ul>
<h4 id="2-3-获取路径中的文件名"><a href="#2-3-获取路径中的文件名" class="headerlink" title="2.3 获取路径中的文件名"></a>2.3 获取路径中的文件名</h4><p><strong><code>path.basename()</code>的语法格式</strong></p>
<p>使用 <code>path.basename()</code> 可以获取到路径中的最后一部分，常通过该方法获取路径中的文件名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">basename</span>(path[, ext])<br></code></pre></td></tr></table></figure>
<ul>
<li>path: 必选参数，表示一个路径的字符串</li>
<li>ext: 可选参数，表示文件扩展名的字符串</li>
<li>返回值: 路径中的最后一部分</li>
</ul>
<p><strong><code>path.basename()</code>的代码示例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><span class="hljs-keyword">var</span> fullName = path.<span class="hljs-title function_">basename</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName) <span class="hljs-comment">// index.html</span><br><br><span class="hljs-keyword">var</span> nameWithoutExt = path.<span class="hljs-title function_">basename</span>(fpath, <span class="hljs-string">&#x27;.html&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nameWithoutExt) <span class="hljs-comment">//index</span><br></code></pre></td></tr></table></figure>
<h4 id="2-4-获取路径中的文件扩展名"><a href="#2-4-获取路径中的文件扩展名" class="headerlink" title="2.4 获取路径中的文件扩展名"></a>2.4 获取路径中的文件扩展名</h4><p><strong><code>path.extname()</code>的语法格式</strong></p>
<p>使用 <code>path.extname()</code> 可以获取到路径中的扩展名部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">path.<span class="hljs-title function_">extname</span>(path)<br></code></pre></td></tr></table></figure>
<ul>
<li>path: 必选参数，表示一个路径的字符串</li>
<li>返回值: 扩展名字符串</li>
</ul>
<p><strong><code>path.extname()</code>的代码示例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span><br><span class="hljs-keyword">const</span> fext = path.<span class="hljs-title function_">extname</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fext) <span class="hljs-comment">// .html</span><br></code></pre></td></tr></table></figure>
<h3 id="3-http-模块"><a href="#3-http-模块" class="headerlink" title="3. http 模块"></a>3. http 模块</h3><h4 id="3-1-什么是-http-模块"><a href="#3-1-什么是-http-模块" class="headerlink" title="3.1 什么是 http 模块"></a>3.1 什么是 http 模块</h4><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 <code>http.createServer()</code> 方法，就能方便地把一台普通的电脑，变成一台 web 服务器，从而对外提供服务</p>
<p>使用如下方法导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="3-2-创建基本-Web-服务器"><a href="#3-2-创建基本-Web-服务器" class="headerlink" title="3.2 创建基本 Web 服务器"></a>3.2 创建基本 Web 服务器</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 创建 web 服务器实例</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br><span class="hljs-comment">// 为服务器实例绑定 request 事件，监听客户端的请求</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-comment">// 只要有请求，就会触发 request 事件，从而调用这个事件处理函数</span><br>    <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>    <span class="hljs-keyword">const</span> method = req.<span class="hljs-property">method</span><br>    <span class="hljs-keyword">const</span> str = <span class="hljs-string">`Your request url is <span class="hljs-subst">$&#123;url&#125;</span>, and request method is <span class="hljs-subst">$&#123;method&#125;</span>`</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br><br>    <span class="hljs-comment">// 设置 Content-Type 响应头，解决中文乱码的问题</span><br>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>    <span class="hljs-comment">// 向客户端响应内容</span><br>    res.<span class="hljs-title function_">end</span>(str)<br>&#125;)<br><br><span class="hljs-comment">// 调用 .listen() 方法就能启动服务器</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p><strong>req 请求对象</strong></p>
<p>只要服务器接收到了客户端的请求，就会调用通过 <code>server.on()</code> 为服务器绑定的 request 事件处理函数</p>
<p>如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用 req 对象</p>
<p><strong>res 响应对象</strong></p>
<p>在服务器的 request 事件处理函数中，访问与服务器相关的数据或属性，可以使用 req 对象</p>
<h4 id="3-3-根据不同-url-响应不同内容"><a href="#3-3-根据不同-url-响应不同内容" class="headerlink" title="3.3 根据不同 url 响应不同内容"></a>3.3 根据不同 url 响应不同内容</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-comment">// 设置默认的响应内容为 404 Not found</span><br>  <span class="hljs-keyword">let</span> content = <span class="hljs-string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br>  <span class="hljs-comment">// 判断用户请求的是否为 / 或 /index.html 首页</span><br>  <span class="hljs-comment">// 判断用户请求的是否为 /about.html 关于页面</span><br>  <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/&#x27;</span> || url === <span class="hljs-string">&#x27;/index.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/about.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br>  &#125;<br><br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>  res.<span class="hljs-title function_">end</span>(content)<br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="1-模块化的基本概念"><a href="#1-模块化的基本概念" class="headerlink" title="1. 模块化的基本概念"></a>1. 模块化的基本概念</h3><h4 id="1-1-什么是模块化"><a href="#1-1-什么是模块化" class="headerlink" title="1.1 什么是模块化"></a>1.1 什么是模块化</h4><ul>
<li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li>
<li>编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并相互依赖的多个小模块</li>
<li>模块化可提高代码的复用性和可维护性，实现按需加载。</li>
</ul>
<h4 id="1-2-模块化规范"><a href="#1-2-模块化规范" class="headerlink" title="1.2 模块化规范"></a>1.2 模块化规范</h4><ul>
<li>模块化规范是对代码进行模块化拆分和组合时，需要遵守的规则<ul>
<li>如使用何种语法格式引用模块和向外暴露成员</li>
</ul>
</li>
</ul>
<h3 id="2-Node-js-中的模块化"><a href="#2-Node-js-中的模块化" class="headerlink" title="2. Node.js 中的模块化"></a>2. Node.js 中的模块化</h3><h4 id="2-1-Node-js-中模块的分类"><a href="#2-1-Node-js-中模块的分类" class="headerlink" title="2.1 Node.js 中模块的分类"></a>2.1 Node.js 中模块的分类</h4><ul>
<li>内置模块：由 Node.js 官方提供的，例如 fs, path, http 等</li>
<li>自定义模块：用户创建的每个 .js 文件，都是自定义模块</li>
<li>第三方模块：由第三方开发出来的模块，使用前需下载</li>
</ul>
<h4 id="2-2-加载模块"><a href="#2-2-加载模块" class="headerlink" title="2.2 加载模块"></a>2.2 加载模块</h4><ul>
<li><code>require()</code> 方法，可以加载三类模块，只有加载自定义模块需要路径名(可以省略后缀名)<ul>
<li>使用 <code>require()</code> 加载模块时，会执行被加载模块中的代码</li>
</ul>
</li>
</ul>
<h4 id="2-3-模块作用域"><a href="#2-3-模块作用域" class="headerlink" title="2.3 模块作用域"></a>2.3 模块作用域</h4><ul>
<li><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</p>
</li>
<li><p>可以防止全局变量污染</p>
</li>
</ul>
<h4 id="2-4-向外共享模块作用域中的成员"><a href="#2-4-向外共享模块作用域中的成员" class="headerlink" title="2.4 向外共享模块作用域中的成员"></a>2.4 向外共享模块作用域中的成员</h4><p><strong><code>module</code> 对象</strong></p>
<ul>
<li>每个 .js 自定义模块中都有一个 <code>module</code> 对象，它里面存储了和当前模块有关的信息</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">Module <span class="hljs-punctuation">&#123;</span><br>  id<span class="hljs-punctuation">:</span> &#x27;.&#x27;<span class="hljs-punctuation">,</span><br>  path<span class="hljs-punctuation">:</span> &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\VSC\\nodejs&#x27;<span class="hljs-punctuation">,</span><br>  exports<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  filename<span class="hljs-punctuation">:</span> &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\VSC\\nodejs\\a.js&#x27;<span class="hljs-punctuation">,</span><br>  loaded<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  children<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  paths<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\VSC\\nodejs\\node_modules&#x27;<span class="hljs-punctuation">,</span><br>    &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\VSC\\node_modules&#x27;<span class="hljs-punctuation">,</span><br>    &#x27;E<span class="hljs-punctuation">:</span>\\WorkSpace\\node_modules&#x27;<span class="hljs-punctuation">,</span><br>    &#x27;E<span class="hljs-punctuation">:</span>\\node_modules&#x27;<br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p><strong><code>module.exports</code> 对象</strong></p>
<ul>
<li>在自定义模块中，可以使用 <code>module.exports</code> 对象，将模块内的成员共享出去，供外界使用。</li>
<li>外界使用 <code>require()</code> 导入自定义模块时，得到的就是 <code>module.exports</code> 指向的对象。</li>
<li>使用 <code>require()</code> 导入模块时，<strong>导入的结果永远以 <code>module.exports</code> 指向的对象为准</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 向 module.exports 对象上挂载属性和方法</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;zs&#x27;</span>;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong><code>exports</code> 对象</strong></p>
<ul>
<li>默认情况下，<code>exports</code> 和 <code>module.exports</code> 指向同一个对象。<strong>最终共享的结果，以 <code>module.exports</code> 指向的对象为准。</strong></li>
</ul>
<h4 id="2-5-Node-js-中的模块化规范"><a href="#2-5-Node-js-中的模块化规范" class="headerlink" title="2.5 Node.js 中的模块化规范"></a>2.5 Node.js 中的模块化规范</h4><p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何互相依赖</p>
<p><strong>CommonJS 模块化规范</strong></p>
<ul>
<li>每个模块内部，<code>module</code> 变量代表当前模块</li>
<li><code>module</code> 变量是一个对象，<code>module.exports</code> 是对外的接口</li>
<li>加载某个模块即加载该模块的 <code>module.exports</code> 属性，<code>require()</code> 用于加载模块</li>
</ul>
<h3 id="3-npm-与包"><a href="#3-npm-与包" class="headerlink" title="3. npm 与包"></a>3. npm 与包</h3><h4 id="3-1-包"><a href="#3-1-包" class="headerlink" title="3.1 包"></a>3.1 包</h4><ul>
<li>Node.js 中的第三方模块又叫做包，由第三方个人或团队开发出来，免费供所有人使用</li>
<li>包是基于内置模块封装出来的</li>
</ul>
<h4 id="3-2-npm"><a href="#3-2-npm" class="headerlink" title="3.2 npm"></a>3.2 npm</h4><p><strong>初次装包后多了哪些文件</strong></p>
<ul>
<li>node_modules 文件夹<ul>
<li>用来存放所有已安装到项目中的包</li>
</ul>
</li>
<li>package-lock.json 配置文件<ul>
<li>记录 node_modules 目录下的每一个包的下载信息，例如包名、版本号、下载地址</li>
</ul>
</li>
<li>不需要手动修改，npm 会自动维护</li>
</ul>
<p><strong>安装指定版本的包</strong></p>
<ul>
<li>默认安装最新版本的包，可以通过 <code>包名@版本号</code> 指定具体版本</li>
</ul>
<p><strong>包的语义化版本规范</strong></p>
<p>分为三位数字，以”点分十进制”形式进行定义, eg. <code>2.24.0</code></p>
<ul>
<li>第 1 位: 大版本</li>
<li>第 2 位: 功能版本</li>
<li>第 3 位: Bug修复版本</li>
</ul>
<h4 id="3-3-包管理配置文件"><a href="#3-3-包管理配置文件" class="headerlink" title="3.3 包管理配置文件"></a>3.3 包管理配置文件</h4><p>npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置信息，例如</p>
<ul>
<li>项目的名称、版本号、描述等</li>
<li>项目中都用到了哪些包</li>
<li>哪些包只在开发期间会用到</li>
<li>哪些包在开发和部署时都需要用到</li>
</ul>
<p><strong>快速创建 package.json</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm init -y<br></code></pre></td></tr></table></figure>
<p><strong>安装包</strong></p>
<p>使用 <code>npm i(nstall)</code> 可以一次性安装所有的依赖包</p>
<ul>
<li>会先读取 package.json 中的 dependencies 节点</li>
</ul>
<p><strong>卸载包</strong></p>
<p><code>npm uninstall</code></p>
<p><strong>devDependencies 节点</strong></p>
<p>如果某些包只在项目开发阶段用到，项目上线后不会用到，则建议把这些包记录到 devDependencies 节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 记录到 devDependencies 节点</span><br>npm i 包名 -D<br><span class="hljs-comment"># 上面是简写，等价于下方完整写法</span><br>npm install 包名 --save-dev<br></code></pre></td></tr></table></figure>
<p>与之相对，如果某些包在开发和上线都需要用到，则建议把这些包记录到 dependencies 节点</p>
<h4 id="3-4-npm-换源"><a href="#3-4-npm-换源" class="headerlink" title="3.4 npm 换源"></a>3.4 npm 换源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前下载源</span><br>npm config get registry<br><span class="hljs-comment"># 切换为淘宝源</span><br>npm config <span class="hljs-built_in">set</span> registry=http://registry.npmmirror.com<br></code></pre></td></tr></table></figure>
<h3 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="4. 模块的加载机制"></a>4. 模块的加载机制</h3><h4 id="4-1-优先从缓存中加载"><a href="#4-1-优先从缓存中加载" class="headerlink" title="4.1 优先从缓存中加载"></a>4.1 优先从缓存中加载</h4><p><strong>模块第一次加载后会被缓存</strong>，即多次调用 <code>require()</code> 不会导致模块的代码被执行多次，提高模块加载效率</p>
<h4 id="4-2-内置模块的加载机制"><a href="#4-2-内置模块的加载机制" class="headerlink" title="4.2 内置模块的加载机制"></a>4.2 内置模块的加载机制</h4><p>内置模块加载优先级最高。</p>
<h4 id="4-3-自定义模块的加载机制"><a href="#4-3-自定义模块的加载机制" class="headerlink" title="4.3 自定义模块的加载机制"></a>4.3 自定义模块的加载机制</h4><p>加载自定义模块时，路径要以 <code>./</code> 或 <code>../</code> 开头，否则会作为内置模块或第三方模块加载。</p>
<p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p>
<ul>
<li>按确切的文件名加载</li>
<li>补全 <code>.js</code> 扩展名加载</li>
<li>补全 <code>.json</code> 扩展名加载</li>
<li>补全 <code>.node</code> 扩展名加载</li>
<li>报错</li>
</ul>
<h4 id="4-4-第三方模块加载"><a href="#4-4-第三方模块加载" class="headerlink" title="4.4 第三方模块加载"></a>4.4 第三方模块加载</h4><ul>
<li>若导入第三方模块，Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 <code>/node_modules</code> 文件夹中加载第三方模块。</li>
<li>如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。</li>
</ul>
<blockquote>
<p>例如，假设在 <code>C:\Users\bruce\project\foo.js</code> 文件里调用了 <code>require(&#39;tools&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li><code>C:\Users\bruce\project\node_modules\tools</code></li>
<li><code>C:\Users\bruce\node_modules\tools</code></li>
<li><code>C:\Users\node_modules\tools</code></li>
<li><code>C:\node_modules\tools</code></li>
</ul>
</blockquote>
<h4 id="4-5-目录作为模块加载"><a href="#4-5-目录作为模块加载" class="headerlink" title="4.5 目录作为模块加载"></a>4.5 目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p>
<ul>
<li>在被加载的目录下查找 <code>package.json</code> 的文件，并寻找 <code>main</code> 属性，作为 <code>require()</code> 加载的入口</li>
<li>如果没有 <code>package.json</code> 文件，或者 <code>main</code> 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 <code>index.js</code> 文件。</li>
<li>若失败则报错</li>
</ul>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><h3 id="1-初识-Express"><a href="#1-初识-Express" class="headerlink" title="1. 初识 Express"></a>1. 初识 Express</h3><p><a target="_blank" rel="noopener" href="https://www.expressjs.com.cn/">官网传送门</a></p>
<blockquote>
<p>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</p>
</blockquote>
<p>Express 是用于快速创建服务器的第三方模块</p>
<h4 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h4><p>安装 Express：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install express<br></code></pre></td></tr></table></figure>
<p>创建服务器，监听客户端请求，并返回内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 web 服务器</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span> &#125;)<br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 通过 req.query 可以获取到客户端发送过来的查询参数</span><br>  <span class="hljs-comment">// ?name=zs&amp;age=20</span><br>  <span class="hljs-comment">// req.query.name   req.query.age</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">query</span>)<br>&#125;)<br><br><span class="hljs-comment">// 这里的 :id 是一个动态的参数</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id/:username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// req.params 是动态匹配到的 URL 参数，默认是一个空对象</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>)<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<h4 id="1-2-托管静态资源"><a href="#1-2-托管静态资源" class="headerlink" title="1.2 托管静态资源"></a>1.2 托管静态资源</h4><ul>
<li>通过 <code>express.static()</code> 方法可创建静态资源服务器，向外开放访问静态资源。</li>
<li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，<strong>存放静态文件的目录名不会出现在 URL 中</strong></li>
<li>访问静态资源时，会根据目录的添加顺序查找文件</li>
<li>可为静态资源访问路径添加前缀</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>))<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/bruce&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;bruce&#x27;</span>))<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">可直接访问 public, files 目录下的静态资源</span><br><span class="hljs-comment">http://localhost:3000/images/bg.jpg</span><br><span class="hljs-comment">http://localhost:3000/css/style.css</span><br><span class="hljs-comment">http://localhost:3000/js/login.js</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">通过带有 /bruce 前缀的地址访问 bruce 目录下的文件</span><br><span class="hljs-comment">http://localhost:8080/bruce/images/logo.png</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="2-Express-路由"><a href="#2-Express-路由" class="headerlink" title="2. Express 路由"></a>2. Express 路由</h3><h4 id="2-1-路由的概念"><a href="#2-1-路由的概念" class="headerlink" title="2.1 路由的概念"></a>2.1 路由的概念</h4><ul>
<li>Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系</li>
<li>Express 中的路由分 3 部分组成，分别是<strong>请求的类型、请求的 URL 地址、处理函数</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">METHOD</span>(<span class="hljs-variable constant_">PATH</span>, <span class="hljs-variable constant_">HANDLER</span>)<br></code></pre></td></tr></table></figure>
<h4 id="2-2-路由的使用"><a href="#2-2-路由的使用" class="headerlink" title="2.2 路由的使用"></a>2.2 路由的使用</h4><ul>
<li><p>简单使用: 把路由直接挂载到 app 上，如上述代码所示</p>
</li>
<li><p>模块化路由: 为了<strong>方便对路由进行模块化的管理</strong>，Express<strong>不建议</strong>将路由直接挂载到 app 上，而是<strong>推荐将路由抽离为单独的模块</strong>。将路由抽离为单独模块的步骤如下：</p>
<ol>
<li>创建路由模块对应的 .js 文件</li>
<li>调用 <code>express.Router()</code> 函数创建路由对象</li>
<li>向路由对象上挂载具体的路由</li>
<li>使用 <code>module.exports</code> 向外共享路由对象</li>
<li>使用 <code>app.use()</code> 函数注册路由模块</li>
</ol>
</li>
<li><p>创建路由模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建路由对象</span><br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<br><br><span class="hljs-comment">// 挂载具体路由</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list.&#x27;</span>)<br>&#125;)<br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user.&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 向外导出路由对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br></code></pre></td></tr></table></figure>
</li>
<li><p>注册路由模块，添加访问前缀</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 注册路由模块，添加访问前缀(可选)</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>app.use()</code> 函数的作用，就是来注册全局中间件</p>
</li>
</ul>
<h3 id="3-Express-中间件"><a href="#3-Express-中间件" class="headerlink" title="3. Express 中间件"></a>3. Express 中间件</h3><h4 id="3-1-中间件的概念"><a href="#3-1-中间件的概念" class="headerlink" title="3.1 中间件的概念"></a>3.1 中间件的概念</h4><ul>
<li>中间件(Middleware)，特指业务流程的<strong>中间处理环节</strong></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Node-js"><span class="toc-number">1.</span> <span class="toc-text">Node.js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-Node-js-%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.</span> <span class="toc-text">初识 Node.js 与内置模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-fs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. fs 文件系统模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-fs"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1 什么是 fs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.2 读取指定文件的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%90%91%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.3 向指定文件写入内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%A4%84%E7%90%86%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.4 处理路径问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-path-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. path 路径模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF-path-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1 什么是 path 路径模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.2 路径拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">2.3 获取路径中的文件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">2.4 获取路径中的文件扩展名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-http-%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. http 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF-http-%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">3.1 什么是 http 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">3.2 创建基本 Web 服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C-url-%E5%93%8D%E5%BA%94%E4%B8%8D%E5%90%8C%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3.3 根据不同 url 响应不同内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 模块化的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.1 什么是模块化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">1.2 模块化规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Node-js-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. Node.js 中的模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Node-js-%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.1 Node.js 中模块的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2 加载模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.3 模块作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%90%91%E5%A4%96%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.4 向外共享模块作用域中的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Node-js-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.5 Node.js 中的模块化规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-npm-%E4%B8%8E%E5%8C%85"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. npm 与包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%8C%85"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">3.1 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-npm"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">3.2 npm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%8C%85%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.3 包管理配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-npm-%E6%8D%A2%E6%BA%90"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">3.4 npm 换源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 模块的加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%BC%98%E5%85%88%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">4.1 优先从缓存中加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">4.2 内置模块的加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">4.3 自定义模块的加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4.4 第三方模块加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E7%9B%AE%E5%BD%95%E4%BD%9C%E4%B8%BA%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">4.5 目录作为模块加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Express"><span class="toc-number">1.3.</span> <span class="toc-text">Express</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E8%AF%86-Express"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 初识 Express</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">1.2 托管静态资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Express-%E8%B7%AF%E7%94%B1"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. Express 路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">2.1 路由的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.2 路由的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Express-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. Express 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.1 中间件的概念</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2022/12/30/Node-js/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://whale-lyi.github.io/2022/12/30/Node-js/&text=Node.js"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://whale-lyi.github.io/2022/12/30/Node-js/&is_video=false&description=Node.js"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Node.js&body=Check out this article: https://whale-lyi.github.io/2022/12/30/Node-js/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://whale-lyi.github.io/2022/12/30/Node-js/&title=Node.js"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://whale-lyi.github.io/2022/12/30/Node-js/&name=Node.js&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://whale-lyi.github.io/2022/12/30/Node-js/&t=Node.js"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    Whale
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
