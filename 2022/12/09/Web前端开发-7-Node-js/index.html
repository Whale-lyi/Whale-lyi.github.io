<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="9-Node.js1. 服务端编程静态网页与动态网页静态页面  客户&#x2F;消费者的观点: 一个url指向同一个html文件 服务器&#x2F;生产者的观点: 存储在Web服务器根文件夹内或子文件夹内的文件 HTML文件: 无论何时当一个特定资源被请求的时候都返回相同的被硬编码的内容 可以直接在浏览器上显示  动态页面  客户&#x2F;消费者的观点: url指的是动态html(可能每次请求都不同) 服务器&#x2F;生产者的观点:">
<meta property="og:type" content="article">
<meta property="og:title" content="Web前端开发(7) Node.js">
<meta property="og:url" content="https://whale-lyi.github.io/2022/12/09/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-7-Node-js/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="9-Node.js1. 服务端编程静态网页与动态网页静态页面  客户&#x2F;消费者的观点: 一个url指向同一个html文件 服务器&#x2F;生产者的观点: 存储在Web服务器根文件夹内或子文件夹内的文件 HTML文件: 无论何时当一个特定资源被请求的时候都返回相同的被硬编码的内容 可以直接在浏览器上显示  动态页面  客户&#x2F;消费者的观点: url指的是动态html(可能每次请求都不同) 服务器&#x2F;生产者的观点:">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126145036774.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126155638013.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160013635.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160035582.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160042277.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126162814121.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126210438297.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230127150018532.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113254724.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113438817.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113515334.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113646359.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128140941232.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128141012898.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002408387.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002447793.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002557988.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129145316636.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129172729202.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222224055948.png">
<meta property="article:published_time" content="2022-12-09T06:06:01.000Z">
<meta property="article:modified_time" content="2023-08-09T06:53:19.981Z">
<meta property="article:author" content="Whale">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126145036774.png">

<link rel="canonical" href="https://whale-lyi.github.io/2022/12/09/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-7-Node-js/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Web前端开发(7) Node.js | Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/12/09/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-7-Node-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Web前端开发(7) Node.js
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-09 14:06:01" itemprop="dateCreated datePublished" datetime="2022-12-09T14:06:01+08:00">2022-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Web前端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="9-Node-js"><a href="#9-Node-js" class="headerlink" title="9-Node.js"></a>9-Node.js</h1><h2 id="1-服务端编程"><a href="#1-服务端编程" class="headerlink" title="1. 服务端编程"></a>1. 服务端编程</h2><h4 id="静态网页与动态网页"><a href="#静态网页与动态网页" class="headerlink" title="静态网页与动态网页"></a>静态网页与动态网页</h4><p>静态页面</p>
<ul>
<li>客户/消费者的观点: 一个url指向同一个html文件</li>
<li>服务器/生产者的观点: 存储在Web服务器根文件夹内或子文件夹内的文件</li>
<li>HTML文件: 无论何时当一个特定资源被请求的时候都返回相同的被硬编码的内容</li>
<li>可以直接在浏览器上显示</li>
</ul>
<p>动态页面</p>
<ul>
<li>客户/消费者的观点: url指的是动态html(可能每次请求都不同)</li>
<li>服务器/生产者的观点: 程序/脚本生成html</li>
<li>它不是一个html, 而是一个程序产生的html(s), 页面通常是通过将数据库的数据植入到HTML模板中的占位符中而产生的。</li>
<li>不能直接在浏览器中显示</li>
</ul>
<h4 id="服务端编程"><a href="#服务端编程" class="headerlink" title="服务端编程"></a>服务端编程</h4><ul>
<li>服务器端页面是使用多种web编程语言/框架之一编写的程序<ul>
<li>例如: PHP, Java/JSP, Ruby on Rails, ASP.NET, Python, Perl</li>
</ul>
</li>
<li>每种语言/框架都有其优点和缺点</li>
</ul>
<h4 id="服务端编程的优势"><a href="#服务端编程的优势" class="headerlink" title="服务端编程的优势"></a>服务端编程的优势</h4><ul>
<li>信息的高效存储和传输、定制用户体验、控制对内容的访问、存储会话和状态信息、通知和通讯、数据分析</li>
</ul>
<h2 id="2-Node-js"><a href="#2-Node-js" class="headerlink" title="2. Node.js"></a>2. Node.js</h2><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><ul>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/">Node</a>(正式名称 Node.js)是一个开源的、跨平台的运行时环境</li>
<li>服务端Javascript: 开发人员可以使用 JavaScript 创建各种服务器端工具和应用程序</li>
<li>事件驱动, 异步I/O框架</li>
<li>性能: 在v8之上的c++内核</li>
<li>在单一进程中可以最小的开销(cpu/内存)处理成千上万的并发连接</li>
<li>模块系统</li>
<li>不是一个web框架, 也不是一种语言</li>
</ul>
<blockquote>
<p>Node.js is a platform built on <a target="_blank" rel="noopener" href="http://code.google.com/p/v8/">Chrome’s JavaScript runtime</a> for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices. — from nodejs.org</p>
</blockquote>
<h4 id="Node-js-的诞生"><a href="#Node-js-的诞生" class="headerlink" title="Node.js 的诞生"></a>Node.js 的诞生</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126145036774.png" alt="image-20230126145036774" style="zoom:80%;" /></p>
<h4 id="Node-js-现状"><a href="#Node-js-现状" class="headerlink" title="Node.js 现状"></a>Node.js 现状</h4><ul>
<li>2018 年 5 月 31 日, Node.js 基⾦会发布的用户调查报告, 显示学习 Node.js 看起来更容易了, 少于 2 年 node 经验的用户中, 有 43% 的觉得”容易”。绝大多数(85%)Node.js 用户用于网页开发, 43% 参与一些企业级开发, 13% 用于大数据分析, 8% 用于嵌入式系统。</li>
</ul>
<h4 id="Node-js-应用场景"><a href="#Node-js-应用场景" class="headerlink" title="Node.js 应用场景"></a>Node.js 应用场景</h4><ul>
<li>网站(如express/koa等)</li>
<li>im即时聊天(socket.io)</li>
<li>api(移动端, pc, h5)</li>
<li>HTTP Proxy(淘宝、Qunar、腾讯、百度都有)</li>
<li>前端构建工具(grunt/gulp/bower/webpack/fis3…)</li>
<li>写操作系统(NodeOS)</li>
<li>跨平台打包工具(PC端的electron、nw.js, 比如钉钉PC客户端、微信小程序IDE、微信客户端, 移动的cordova, 即老的 Phonegap, 还有更加有名的一站式开发框架ionicframework)</li>
<li>命令行工具(比如cordova、shell.js)</li>
<li>反向代理(比如anyproxy, node-http-proxy)</li>
</ul>
<h4 id="Node-优势"><a href="#Node-优势" class="headerlink" title="Node 优势"></a>Node 优势</h4><p>从 web 服务器开发的⻆度来看, Node 有很多好处: </p>
<ul>
<li>卓越的性能表现！Node 为优化 web 应用的吞吐量和扩展度而生, 对常见的 web 开发问题是一套绝佳方案(比如实时 web 应用)</li>
<li>代码还是熟悉的老伙伴 JavaScript, 这意味着在客户端和服务器端”上下文切换”的时间成本更低</li>
<li>与传统的 web 服务器语言(例如 Python、PHP 等)相比, JavaScript 理念更新, 语言设计的改进带来了诸多好处。许多其它新近流行的语言也可编译/转换成 JavaScript, 所以 TypeScript、CoffeeScript、ClojureScript、Scala、LiveScript 等等也可以使用</li>
<li>Node 包管理工具(node package manager, NPM)提供了数十万个可重用的工具包。它还提供了一流的依赖解决方案, 可实现自动化工具链构建</li>
<li>Node.js 是可移植的, 可运行于 Microsoft Windows、macOS、Linux、Solaris、FreeBSD、OpenBSD、WebOS 和 NonStop OS。此外, 许多 web 主机供应商对其提供了良好支持(包括专用的基础框架和构建 Node 站点的文档)</li>
<li>它有一个非常活跃的第三方生态系统和开发者社区, 很多人愿意提供帮助</li>
</ul>
<h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><ul>
<li>Node所针对的应用程序有一个专门的简称: DIRT, 表示数据密集型实时(data-intensive real-time)程序</li>
<li>性能和I/O负载: Nodejs非常好的解决了IO密集的问题, 通过异步IO来实现</li>
<li>大前端的基石</li>
<li>从脚⼿架、辅助前端开发(比如 SSR、PWA 等)的快速开发实践, 到 API 中间层、代理层, 到专业的后端开发都有非常成熟的经验</li>
<li>全栈</li>
</ul>
<h4 id="Node-js-不适合的领域"><a href="#Node-js-不适合的领域" class="headerlink" title="Node.js 不适合的领域"></a>Node.js 不适合的领域</h4><ul>
<li>计算密集型应用</li>
<li>内存控制</li>
<li>大内存的应用, 由于V8引擎有内存设计的限制, 32位环境中最大堆是 1G, 64位环境中最大堆也不到2G, 如果要一次读入 10G 数据, 对于 Nodejs来说也无法实现</li>
<li>静态服务器, 虽然Nodejs的优势在IO密集集应用, 但是和 Nginx 的处理静态资源还是有很大的差距</li>
<li>不需要异步的应用: 比如系统管理, 自行化脚本等, Nodejs的异步调用可能会给编程带来一些麻烦。</li>
</ul>
<h2 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3. 事件循环"></a>3. 事件循环</h2><h4 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903999506923528">事件循环</a></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126155638013.png" alt="image-20230126155638013" style="zoom:80%;" /></p>
<blockquote>
<p>There are a couple of implications of this apparently very simple and basic model Avoid synchronous code at all costs because it blocks the event loop Which means: callbacks, callbacks, and more callbacks</p>
</blockquote>
<h4 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h4><ul>
<li>由一个事件收集器、一个事件发送器和一个事件处理器组成</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160013635.png" alt="image-20230126160013635" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160035582.png" alt="image-20230126160035582"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126160042277.png" alt="image-20230126160042277" style="zoom:80%;" /></p>
<h4 id="Node-js-支持-JS"><a href="#Node-js-支持-JS" class="headerlink" title="Node.js 支持 JS"></a>Node.js 支持 JS</h4><p>这是 Node.js 能够发展壮大的一个非常重要的间接原因</p>
<ul>
<li>首先, Javascript 作为前端工程师的主⼒语言, 在技术社区中有相当的号召⼒。而且, 随着 Web 技术的不断发展, 特别是前端的重要性增加, 不少前端工程师开始试水”后台应用”, 在许多采用 Node.js 的企业中, 工程师都表示因为习惯了 Javascript, 所以选择 Node.js</li>
<li>其次, Javascript 的匿名函数和闭包特性非常适合事件驱动、异步编程</li>
<li>有 Google V8 引擎的加持, Node.js 的性能也是受益其中。</li>
</ul>
<h2 id="4-阻塞"><a href="#4-阻塞" class="headerlink" title="4. 阻塞"></a>4. 阻塞</h2><h4 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h4><div class="table-container">
<table>
<thead>
<tr>
<th>同步</th>
<th>异步</th>
</tr>
</thead>
<tbody>
<tr>
<td>等待每个操作完成, 然后执行下一个操作。</td>
<td>从不等待每个操作完成, 一次执行所有操作。</td>
</tr>
<tr>
<td>一步一步执行</td>
<td>回调, 用于处理结果</td>
</tr>
</tbody>
</table>
</div>
<h4 id="同步式-I-O-和异步式-I-O-的特点"><a href="#同步式-I-O-和异步式-I-O-的特点" class="headerlink" title="同步式 I/O 和异步式 I/O 的特点"></a>同步式 I/O 和异步式 I/O 的特点</h4><ul>
<li>阻塞方法同步执行, 非阻塞方法异步执行</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>同步式 I/O(阻塞式)</th>
<th>异步式 I/O(非阻塞式)</th>
</tr>
</thead>
<tbody>
<tr>
<td>利用多线程提供吞吐量</td>
<td>单线程即可实现高吞吐量</td>
</tr>
<tr>
<td>通过事件片分割和线程调度利用多核CPU</td>
<td>通过功能划分利用多核CPU</td>
</tr>
<tr>
<td>需要由操作系统调度多线程使用多核 CPU</td>
<td>可以将单进程绑定到单核 CPU</td>
</tr>
<tr>
<td>难以充分利用 CPU 资源</td>
<td>可以充分利用 CPU 资源</td>
</tr>
<tr>
<td>内存轨迹大, 数据局部性弱</td>
<td>内存轨迹小, 数据局部性强</td>
</tr>
<tr>
<td>符合线性的编程思维</td>
<td>不符合传统编程思维</td>
</tr>
</tbody>
</table>
</div>
<h4 id="阻塞-vs-非阻塞"><a href="#阻塞-vs-非阻塞" class="headerlink" title="阻塞 vs 非阻塞"></a>阻塞 vs 非阻塞</h4><ul>
<li>阻塞 是指在 Node.js 程序中, 其它 JavaScript 语句的执行, 必须等待一个非 JavaScript 操作完成。这是因为当阻塞发生时, 事件循环无法继续运行 JavaScript</li>
<li>在 Node.js 中, JavaScript 由于执行 CPU 密集型操作, 而不是等待一个非 JavaScript 操作(例如 I/O)而表现不佳, 通常不被称为阻塞。在 Node.js 标准库中使用 libuv 的同步方法是最常用的阻塞操作。原生模块中也有阻塞方法</li>
<li><p>在Node.js标准库中的所有I/O方法都提供异步版本, 非阻塞, 并且接受回调函数。某些方法也有对应的阻塞版本, 名字以 Sync 结尾</p>
</li>
<li><p>示例: 从文件中读取数据并显示数据</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126162814121.png" alt="image-20230126162814121"></p>
</li>
</ul>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>同步</li>
<li>文件读取<ul>
<li>从文件读取数据</li>
<li>显示数据</li>
<li>完成其他任务</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Do other tasks&quot;</span>);<br></code></pre></td></tr></table></figure>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>异步</li>
<li>从文件中读取数据<ul>
<li>当读取数据完成时, 显示数据</li>
</ul>
</li>
<li>完成其他任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// callback</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<h2 id="5-实践"><a href="#5-实践" class="headerlink" title="5. 实践"></a>5. 实践</h2><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>项目信息</p>
<ul>
<li>name 项目名称</li>
<li>version 项目的版本号</li>
<li>description 项目的描述信息</li>
<li>entry point 项目的入口文件</li>
<li>test command 项目启动时脚本命令</li>
<li>git repository 如果你有 Git 地址, 可以将这个项目放到你的 Git 仓库⾥</li>
<li>keywords 关键词</li>
<li>author 作者</li>
<li>license 项目要发行的时候需要的证书, 平时可以忽略它</li>
</ul>
<h4 id="Node-js-API"><a href="#Node-js-API" class="headerlink" title="Node.js API"></a>Node.js API</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230126210438297.png" alt="image-20230126210438297" style="zoom:80%;" /></p>
<h4 id="Node-js流行模块"><a href="#Node-js流行模块" class="headerlink" title="Node.js流行模块"></a>Node.js流行模块</h4><ul>
<li>Express.js 由核⼼ Node 项目团队的成员之一 TJ Holowaychuk 构建。大型社区支持此框架, 因此具有不断更新和改⾰所有核⼼功能的优势。这是一个极简主义的框架, 用于构建 mobile 应用程序和 API</li>
<li>Koa 由创建 Express.js 的同一团队开发, 通常被称为下一代 NodeJS 框架。 Koa 的独特之处在于它使用了一些非常酷的 ECMAScript (ES6)方法, 使你无需回调即可工作, 同时极大地扩展了错误处理</li>
<li>Hapi 是一个强大且健壮的框架, 用于开发API。完善的插件系统和各种关键功能(例如输入验证、基于配置的功能、实现缓存、错误处理、日志记录等)使 Hapi 成为最受欢迎的框架之一。它用于构建有用的应用, 并通为 PayPal, Disney 等多个大型网站提供技术解决方案。Hapi 以最小的开销构建安全、强大、可扩展的开箱即用的功能</li>
<li>Socket.io用于构建实时 Web 应用。这是一个 Javascript 库, 可在 Web 客户端和服务器之间进行双向数据通信。异步数据 I/O、⼆进制流和即时消息传递是此框架最重要的功能</li>
<li>Meteor.JS 是最常用的 NodeJS 框架之一。 NodeJS 的全栈框架, 允许用户构建实时应用程序。它用于创建基于移动和基于 Web 的 JavaScript 应用。</li>
</ul>
<h2 id="6-模块"><a href="#6-模块" class="headerlink" title="6. 模块"></a>6. 模块</h2><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>两种模块, 不兼容</p>
<ul>
<li>ES6 模块, 简称 ESM</li>
<li>Node.js 专用的 CommonJS 模块, 简称 CJS</li>
</ul>
<h4 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h4><p>语法</p>
<ul>
<li>CommonJS 模块使用 <code>require()</code> 加载和 <code>module.exports</code> 输出</li>
<li>ES6 模块使用 <code>import</code> 和 <code>export</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-comment">// profile.js</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><span class="hljs-keyword">export</span> &#123;firstName, lastName, year&#125;;<br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123;firstName, lastName, year&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstName, lastName) <span class="hljs-comment">// Michael Jackson</span><br></code></pre></td></tr></table></figure>
<p>CommonJS 模块输出的是一个值的拷贝, ES6 模块输出的是值的引用</p>
<p>CommonJS 模块是运行时加载, ES6 模块是编译时输出接口</p>
<ul>
<li>CommonJS 加载的是一个对象(即module.exports属性), 该对象只有在脚本运行完才会生成</li>
<li>ES6 模块不是对象, 它的对外接口只是一种静态定义, 在代码静态解析阶段就会生成</li>
</ul>
<h4 id="模块加载的实质"><a href="#模块加载的实质" class="headerlink" title="模块加载的实质"></a>模块加载的实质</h4><p>cjs</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// lib.js</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">incCounter</span>(<span class="hljs-params"></span>) &#123;<br>	counter++;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">counter</span>: counter,<br>    <span class="hljs-attr">incCounter</span>: incCounter,<br>&#125;;<br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">var</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod.<span class="hljs-property">counter</span>); <span class="hljs-comment">// 3</span><br>mod.<span class="hljs-title function_">incCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod.<span class="hljs-property">counter</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<p>es6</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// lib.mjs</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> counter = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">incCounter</span>(<span class="hljs-params"></span>) &#123;<br>	counter++;<br>&#125;<br><span class="hljs-comment">// main.mjs</span><br><span class="hljs-keyword">import</span> &#123; counter, incCounter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lib.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter); <span class="hljs-comment">// 3</span><br><span class="hljs-title function_">incCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>
<h4 id="Node-js-的区分"><a href="#Node-js-的区分" class="headerlink" title="Node.js 的区分"></a>Node.js 的区分</h4><ul>
<li>Node.js 要求 ES6 模块采用 .mjs 后缀文件名<ul>
<li>只要脚本文件⾥面使用 import 或者 export 命令, 那么就必须采用.mjs后缀名</li>
<li>Node.js 遇到.mjs文件, 就认为是 ES6 模块, <strong>默认启用严格模式</strong>, 不必在每个模块文件顶部指定”use strict”</li>
<li>如果不希望将后缀名改成.mjs, 可以在项目的package.json文件中, 指定 type 字段为 module</li>
</ul>
</li>
<li>.cjs 文件总是以 CommonJS 模块加载<ul>
<li>如果没有 type 字段, 或者 type 字段为 commonjs, 则 .js 脚本会被解释成 CommonJS 模块</li>
</ul>
</li>
<li>.js 文件的加载取决于 package.json ⾥面 type 字段的设置</li>
<li>注意, ES6 模块与 CommonJS 模块尽量不要混用！！！<ul>
<li>require 命令不能加载 .mjs 文件, 会报错, 只有 import 命令才可以加载 .mjs 文件</li>
<li>反之, .mjs 文件⾥面也不能使用 require 命令, 必须使用 import</li>
</ul>
</li>
</ul>
<h4 id="同时支持两种格式的模块-了解"><a href="#同时支持两种格式的模块-了解" class="headerlink" title="同时支持两种格式的模块(了解)"></a>同时支持两种格式的模块(了解)</h4><ul>
<li><p>如果原始模块是 ES6 格式, 那么需要给出一个整体输出接口, 比如 export default obj, 使得 CommonJS 可以用 import() 进行加载</p>
</li>
<li><p>如果原始模块是 CommonJS 格式, 那么可以加一个包装层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> cjsModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../index.js&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = cjsModule.<span class="hljs-property">foo</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以把这个文件的后缀名改为 .mjs, 或者放在一个子目录, 再在这个子目录⾥面放一个单独的 package.json 文件, 指明{ type: “module” }</p>
</li>
<li><p>另一种做法是在 package.json 文件的 exports 字段, 指明两种格式模块各自的加载入口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.js&quot;</span>, <br>    <span class="hljs-string">&quot;import&quot;</span>: <span class="hljs-string">&quot;./esm/wrapper.js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="require-方法查找策略"><a href="#require-方法查找策略" class="headerlink" title="require 方法查找策略"></a>require 方法查找策略</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230127150018532.png" alt="image-20230127150018532" style="zoom:80%;" /></p>
<h4 id="A-simple-file-server"><a href="#A-simple-file-server" class="headerlink" title="A simple file server"></a>A simple file server</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)&#123;<br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>)<br>&#125;);<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running at http://localhost:3000/&#x27;</span>);<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">node server.js<br>sudo npm install -g supervisor<br>supervisor server.js<br></code></pre></td></tr></table></figure>
<h4 id="as"><a href="#as" class="headerlink" title="as"></a>as</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> &#123; lastName <span class="hljs-keyword">as</span> surname &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(surname); <span class="hljs-comment">// Jackson</span><br><br><span class="hljs-comment">//profile.js</span><br><span class="hljs-keyword">export</span> &#123;firstName <span class="hljs-keyword">as</span> name&#125;<br></code></pre></td></tr></table></figure>
<h4 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//default.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>)&#123;<br>	<span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> add;<br><span class="hljs-comment">// 实际上</span><br><span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> add <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./default&#x27;</span><br><span class="hljs-comment">//实际上 add 名字可以随便起</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> add&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./default&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="7-循环加载"><a href="#7-循环加载" class="headerlink" title="7. 循环加载"></a>7. <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">循环加载</a></h2><h4 id="CommonJS-循环加载"><a href="#CommonJS-循环加载" class="headerlink" title="CommonJS 循环加载"></a>CommonJS 循环加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在 a.js 之中, b.done = %j&#x27;</span>, b.<span class="hljs-property">done</span>);<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a.js 执行完毕&#x27;</span>);<br><br><span class="hljs-comment">//b.js</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在 b.js 之中, a.done = %j&#x27;</span>, a.<span class="hljs-property">done</span>);<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">done</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b.js 执行完毕&#x27;</span>);<br><br><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.<span class="hljs-property">done</span>, b.<span class="hljs-property">done</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在 b.js 之中, a.done = false</span><br><span class="hljs-comment">b.js 执行完毕</span><br><span class="hljs-comment">在 a.js 之中, b.done = true</span><br><span class="hljs-comment">a.js 执行完毕</span><br><span class="hljs-comment">在 main.js 之中, a.done=true, b.done=true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>CommonJS模块的重要特性是加载时执行, 即脚本代码在<code>require</code>的时候, 就会全部执行。<strong>CommonJS的做法是, 一旦出现某个模块被”循环加载”, 就只输出已经执行的部分, 还未执行的部分不会输出。</strong></p>
</blockquote>
<h4 id="ES6-循环加载"><a href="#ES6-循环加载" class="headerlink" title="ES6 循环加载"></a>ES6 循环加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.mjs如下</span><br><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a.mjs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><br><span class="hljs-comment">// b.mjs</span><br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b.mjs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> bar = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$ node --experimental-modules a.mjs</span><br><span class="hljs-comment">b.mjs</span><br><span class="hljs-comment">ReferenceError: Cannot access &#x27;foo&#x27; before initialization</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>借助函数提升解决, 改为函数表达式也会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.mjs</span><br><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a.mjs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bar</span>());<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span> &#125;<br><span class="hljs-keyword">export</span> &#123;foo&#125;;<br><span class="hljs-comment">// b.mjs</span><br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.mjs&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b.mjs&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>());<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;bar&#x27;</span> &#125;<br><span class="hljs-keyword">export</span> &#123;bar&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$ node --experimental-modules a.mjs</span><br><span class="hljs-comment">b.mjs</span><br><span class="hljs-comment">foo</span><br><span class="hljs-comment">a.mjs</span><br><span class="hljs-comment">bar</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><h4 id="Node-js-版本"><a href="#Node-js-版本" class="headerlink" title="Node.js 版本"></a>Node.js 版本</h4><ul>
<li>LTS 和 Current 其实并不是版本, 而是同一个主版本号的不同阶段<ul>
<li>LTS: Long Term Support。该版本进入了漫长的维护期。它又分为两个阶段: Active LTS 和 Maintenance LTS。从以往的发布历史看, LTS 至少会被跟进 2 年时间, 按照最新的官方网站的说法, Active LTS 持续 12 个月, Maintenance LTS 将会被持续维护 18 个月的时间。Node.js 12 之前, active 阶段持续18个月, maintenance 阶段持续 12 个月。</li>
<li>Current: 一个新主版本号 release 后, 先进入 Current 阶段, 该阶段持续 6 个月, 目的是给各个库(library)的作者时间来支持新版。偶数版本在 Current 阶段后进入 LTS 阶段, 而奇数版本则终结不再维护</li>
</ul>
</li>
<li>奇偶版本号<ul>
<li>Nodejs主版本号(semver-major)奇数版本和偶数版本有不同的生命周期</li>
<li>每隔6个月, 社区会从 Nodejs master 分支拉出一个分支作为主版本的release。偶数版本在4月发版, 奇数版本则在10月</li>
<li>奇数版本发版时, 上一个偶数版本会进入LTS阶段, 而奇数版本则只持续6个月的时间, 终结不再维护</li>
</ul>
</li>
</ul>
<h4 id="已无性能优势"><a href="#已无性能优势" class="headerlink" title="已无性能优势?"></a>已无性能优势?</h4><ul>
<li>实现成本、调优成本、学习成本</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113254724.png" alt="image-20230128113254724" style="zoom:80%;" /></p>
<h4 id="MEAN"><a href="#MEAN" class="headerlink" title="MEAN"></a>MEAN</h4><p>MEAN 是一个 Javascript 平台的现代 Web 开发框架总称</p>
<ul>
<li>MongoDB 是一个使用 JSON 风格存储的数据库, 非常适合 JavaScript (JSON是JS数据格式)</li>
<li>ExpressJS 是一个 Web 应用框架, 提供有帮助的组件和模块帮助建立一个网站应用。</li>
<li>AngularJS 是一个前端 MVC 框架。</li>
<li>Node.js 是一个并发、异步、事件驱动的Javascript服务器后端开发平台。</li>
</ul>
<h4 id="MEAN-架构原理"><a href="#MEAN-架构原理" class="headerlink" title="MEAN 架构原理"></a>MEAN 架构原理</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113438817.png" alt="image-20230128113438817" style="zoom:80%;" /></p>
<h4 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113515334.png" alt="image-20230128113515334" style="zoom:80%;" /></p>
<h4 id="Node-js-框架的优势"><a href="#Node-js-框架的优势" class="headerlink" title="Node.js 框架的优势"></a>Node.js 框架的优势</h4><p>现在 NodeJS 框架正在成为最常用的构建 Web 应用前后端的开发框架。这是自定义 Web 开发的首选环境。让我们检查一些主要的 NodeJS 框架的优点</p>
<ul>
<li>实时工作环境、简单的编码经验、无缝数据流、在整个开发过程中使用相同的代码模式、方便易用</li>
</ul>
<h4 id="框架选型"><a href="#框架选型" class="headerlink" title="框架选型"></a>框架选型</h4><ul>
<li>业务场景、特点</li>
<li>自身团队能⼒、喜好, 有时候技术选型决定团队氛围的, 需要平衡激进与稳定</li>
<li>熟悉程度</li>
<li>个人学习求新, 企业架构求稳, 无非喜好与场景而已</li>
</ul>
<h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128113646359.png" alt="image-20230128113646359" style="zoom:80%;" /></p>
<h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128140941232.png" alt="image-20230128140941232" style="zoom:80%;" /></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230128141012898.png" alt="image-20230128141012898" style="zoom:80%;" /></p>
<h1 id="10-Express"><a href="#10-Express" class="headerlink" title="10-Express"></a>10-Express</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h4 id="什么是-Express"><a href="#什么是-Express" class="headerlink" title="什么是 Express ?"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs/Introduction#Is_Express_opinionated">什么是 Express ?</a></h4><ul>
<li>Express是最流行的node web框架, 它是许多其他流行的节点 web 框架的底层库。它提供了机制:<ul>
<li>在不同的URL路径(路由)中使用不同HTTP动词的请求编写处理程序</li>
<li>与”视图”呈现引擎集成, 以便通过将数据插入模板来生成响应</li>
<li>设置常见的web应用程序设置, 比如用于连接的端口, 以及用于呈现响应的模板的位置</li>
<li>在请求处理管道的任何位置添加额外的请求处理”中间件”</li>
</ul>
</li>
<li>虽然Express本身是非常简单的, 但是开发人员已经创建了兼容的中间件包来解决几乎所有的 web 开发问题<ul>
<li>cookie、会话、用户登录、URL参数、POST数据、安全标头等等。</li>
</ul>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>精简、灵活、web 程序框架、单页 web 程序、多页和混合的 web 程序</li>
</ul>
<h4 id="Is-Express-opinionated"><a href="#Is-Express-opinionated" class="headerlink" title="Is Express opinionated?"></a>Is Express opinionated?</h4><ul>
<li>Web框架通常将自己称为”固执己见”或”不固执己见”</li>
<li>固执的框架认为应该有一套”标准答案”来解决各类具体任务。通常支持特定领域的快速开发(解决特定类型的问题)。因为标准答案通常易于理解且文档丰富。然而在解决主领域之外的问题时, 就会显得不那么灵活, 可用的组件和方法也更少</li>
<li>Express是不固执己见的,是高度包容的<ul>
<li>几乎可以将任何您喜欢的任何兼容的中间件插入到请求处理链中</li>
<li>可以在一个文件或多个文件中构造该应用程序, 并使用任何目录结构</li>
<li>有太多的选择！</li>
</ul>
</li>
</ul>
<h4 id="Express-开发环境概述"><a href="#Express-开发环境概述" class="headerlink" title="Express 开发环境概述"></a>Express 开发环境概述</h4><p>完整的 Express 本地开发环境包括</p>
<ul>
<li>Nodejs</li>
<li>NPM 包管理器</li>
<li>Express 应用生成器(可选)</li>
</ul>
<h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// npm init</span><br><span class="hljs-comment">// npm install express —save</span><br><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Example app listening on port 3000!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="应用生成器工具"><a href="#应用生成器工具" class="headerlink" title="应用生成器工具"></a>应用生成器工具</h4><p>通过应用生成器工具 express-generator 可以快速创建一个应用的⻣架</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002408387.png" alt="image-20230129002408387" style="zoom:80%;" /></p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002447793.png" alt="image-20230129002447793" style="zoom:80%;" /></p>
<h2 id="2-路由"><a href="#2-路由" class="headerlink" title="2. 路由"></a>2. 路由</h2><h4 id="处理数据流"><a href="#处理数据流" class="headerlink" title="处理数据流"></a>处理数据流</h4><ul>
<li>下图展示了 HTTP 请求/响应处理的主数据流和需要实现的行为</li>
<li>路由: 把需要支持的请求(以及请求 URL 中包含的任何信息)转发到适当的控制器函数</li>
<li>控制器: 从模型中获取请求的数据, 创建一个 HTML 页面显示出数据, 并将页面返回给用户, 以便在浏览器中查看</li>
<li>视图(模板): 供控制器用来渲染数据。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129002557988.png" alt="image-20230129002557988" style="zoom:80%;" /></p>
<h4 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h4><ul>
<li>路由用于确定应用程序如何响应对特定端点的客户机请求, 包含一个 URI(或路径)和一个特定的 HTTP 请求方法(GET、POST 等)</li>
<li>每个路由可以具有一个或多个处理程序函数, 这些函数在路由匹配时执行</li>
<li>路由定义采用以下结构: <ul>
<li><code>app.METHOD(PATH, HANDLER)</code></li>
<li>其中: <ul>
<li>app 是 express 的实例</li>
<li>METHOD 是 HTTP 请求方法</li>
<li>PATH 是服务器上的路径</li>
<li>HANDLER 是在路由匹配时执行的函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="路由示例"><a href="#路由示例" class="headerlink" title="路由示例"></a>路由示例</h4><p>以主页上的 Hello World! 进行响应: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>在根路由 (/) 上(应用程序的主页)对 POST 请求进行响应: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Got a POST request&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>对 /user 路由的 PUT 请求进行响应: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Got a PUT request at /user&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由方法"><a href="#路由方法" class="headerlink" title="路由方法"></a>路由方法</h4><p>路由方法派生自 HTTP 方法之一, 附加到 express 类的实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// GET method route</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;GET request to the homepage&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// POST method route</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;POST request to the homepage&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="特殊路由方法-app-all"><a href="#特殊路由方法-app-all" class="headerlink" title="特殊路由方法: app.all()"></a>特殊路由方法: app.all()</h4><ul>
<li>有一种特殊路由方法: <code>app.all()</code>, 它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数</li>
<li>在以下示例中, 无论使用 GET、POST、PUT、DELETE 还是在 http 模块中支持的其他任何 HTTP 请求方法, 都将为针对”/ secret”的请求执行处理程序</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;/secret&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Accessing the secret section ...&#x27;</span>);<br>	<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// pass control to the next handler</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由路径"><a href="#路由路径" class="headerlink" title="路由路径"></a>路由路径</h4><ul>
<li><p>路由路径与请求方法相结合, 用于定义可以在其中提出请求的端点。路由路径可以是字符串、字符串模式或正则表达式</p>
</li>
<li><p>路由路径用于定义可请求的端点。之前示例中路径都是字符串, 并且必须精确写为: ‘/‘、’/about’、’/book’等等</p>
</li>
<li><p>路由路径也可以是字符串模式(String Pattern)。可用部分正则表达式语法来定义端点的模式。以下是所涉及的正则表达式(注意, 连字符(-)和点(.)在字符串路径中解释为字面量, 不能作为正则表达式): </p>
<ul>
<li>?: 问号之前的一个字符只能出现零次或一次。<ul>
<li>例如, 路由路径 ‘/ab?cd’ 路径匹配端点 acd 或 abcd</li>
</ul>
</li>
<li>+: 加号之前的一个字符至少出现一次<ul>
<li>例如, 路径路径 ‘/ab+cd’ 匹配端点 abcd、abbcd、abbbcd 等</li>
</ul>
</li>
<li>*: 星号可以替换为任意字符串<ul>
<li>例如, 路由路径 ‘/ab*cd’ 匹配端点 abcd、abXcd、abSOMErandomTEXTcd 等</li>
</ul>
</li>
<li>(): 将一个字符串视为一体以执行 ?、+、 * 操作<ul>
<li>例如。 ‘/ab(cd)?e’ 将对 (cd) 进行匹配, 将匹配到 abe 和 abcde</li>
</ul>
</li>
</ul>
</li>
<li><p>路由路径也可以是 JavaScript 正则表达式。</p>
<ul>
<li><p>例如, 下面的路由路径将匹配 catfish 和 dogfish, 但不会匹配 catflap、catfishhead 等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-regexp">/.*fish$/</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br> ...<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意, 正则表达式路径不再用引号 “…” 括起来, 而是正则表达式语法 /…/</p>
</li>
</ul>
</li>
<li><p>Express 使用 path-to-regexp 来匹配路由路径</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 此路由路径将请求与根路由 / 匹配。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;root&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 此路由路径将请求与 /about 匹配。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;about&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 此路由路径将请求与 /random.text 匹配。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/random.text&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;random.text&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 基于字符串模式的路由路径的示例。此路由路径将匹配 acd 和 abcd。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/ab?cd&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ab?cd&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><ul>
<li>路径参数是命名的 URL 段, 用于捕获在 URL 中的位置指定的值。命名段以冒号为前缀, 然后是名称<ul>
<li>例如 /:your_parameter_name/。捕获的值保存在 req.params 对象中, 键即参数名<ul>
<li>例如 req.params.your_parameter_name</li>
</ul>
</li>
</ul>
</li>
<li>路由参数名必须由”单词字符”(<code>/[A-Za-z0-9_]/</code>)组成</li>
<li>举例说, 一个包含用户和藏书信息的 URL: <a target="_blank" rel="noopener" href="http://localhost:3000/users/34/books/8989">http://localhost:3000/users/34/books/8989</a>, 可以这样提取信息(使用 userId 和 bookId 路径参数): </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users/:userId/books/:bookId&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br> <span class="hljs-comment">// 通过 req.params.userId 访问 userId</span><br> <span class="hljs-comment">// 通过 req.params.bookId 访问 bookId</span><br> res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由处理程序"><a href="#路由处理程序" class="headerlink" title="路由处理程序"></a>路由处理程序</h4><ul>
<li>可以提供多个回调函数, 以类似于中间件的行为方式来处理请求。唯一例外是这些回调函数可能调用 next(‘route’)来绕过剩余的路由回调。可以使用此机制对路由施加先决条件, 在没有理由继续执行当前路由的情况下, 可将控制权传递给后续路由</li>
<li>路由处理程序的形式可以是一个函数、一组函数或者两者的结合, 如以下示例中所示</li>
<li>单个回调函数可以处理一个路由。例如: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单个回调函数可以处理一个路由。例如: </span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/example/a&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from A!&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 多个回调函数可以处理一个路由(确保您指定 next 对象)。例如: </span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/example/b&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the response will be sent by the next function ...&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br> 	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from B!&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 一组回调函数可以处理一个路由。例如: </span><br><span class="hljs-keyword">var</span> cb0 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CB0&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;<br><span class="hljs-keyword">var</span> cb1 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CB1&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;<br><span class="hljs-keyword">var</span> cb2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from C!&#x27;</span>);<br>&#125;<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/example/c&#x27;</span>, [cb0, cb1, cb2]);<br><br><span class="hljs-comment">// 独立函数与一组函数的组合可以处理一个路由。例如: </span><br><span class="hljs-keyword">var</span> cb0 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CB0&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;<br><span class="hljs-keyword">var</span> cb1 = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CB1&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/example/d&#x27;</span>, [cb0, cb1], <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the response will be sent by the next function ...&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from D!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="响应方法"><a href="#响应方法" class="headerlink" title="响应方法"></a>响应方法</h4><p>下表中响应对象 (res) 的方法可以向客户机发送响应, 并终止请求/响应循环。如果没有从路由处理程序调用其中任何方法, 客户机请求将保持挂起状态。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="http://expressjs.com/zh-cn/4x/api.html#res.download">方法</a></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>res.download()</td>
<td>提示将要下载文件</td>
</tr>
<tr>
<td>res.end()</td>
<td>结束响应进程</td>
</tr>
<tr>
<td>res.json()</td>
<td>发送 JSON 响应</td>
</tr>
<tr>
<td>res.jsonp()</td>
<td>在 JSONP 的支持下发送 JSON 响应</td>
</tr>
<tr>
<td>res.redirect()</td>
<td>重定向请求</td>
</tr>
<tr>
<td>res.render()</td>
<td>呈现视图模板</td>
</tr>
<tr>
<td>res.send()</td>
<td>发送各种类型的响应</td>
</tr>
<tr>
<td>res.sendFile()</td>
<td>以⼋位元流形式发送文件</td>
</tr>
<tr>
<td>res.sendStatus()</td>
<td>设置响应状态码并以响应主体形式发送其字符串表示</td>
</tr>
</tbody>
</table>
</div>
<h4 id="app-route"><a href="#app-route" class="headerlink" title="app.route()"></a>app.route()</h4><ul>
<li>可以使用 <code>app.route()</code> 为路由路径创建链式路由处理程序。因为在单一位置指定路径, 所以可以减少冗余和输入错误。有关路由的更多信息, 请参阅 <a target="_blank" rel="noopener" href="http://expressjs.com/zh-cn/4x/api.html#router">Router()文档</a>。 以下是使用 <code>app.route()</code> 定义的链式路由处理程序的示例。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/book&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get a random book&#x27;</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add a book&#x27;</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">put</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Update the book&#x27;</span>);<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h4 id="express-Router"><a href="#express-Router" class="headerlink" title="express.Router"></a>express.Router</h4><ul>
<li>使用 express.Router 类来创建可安装的模块化路由处理程序</li>
<li>Router 实例是完整的中间件和路由系统；因此, 常常将其称为”微型应用程序”</li>
<li>以下示例将路由器创建为模块, 在其中装入中间件, 定义一些路由, 然后安装在主应用程序的路径中</li>
<li>在应用程序目录中创建名为 birds.js 的路由器文件, 其中包含以下内容: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><span class="hljs-comment">// middleware that is specific to this router</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeLog</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time: &#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>    <span class="hljs-title function_">next</span>();<br>&#125;);<br><span class="hljs-comment">// define the home page route</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Birds home page&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// define the about route</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;About birds&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure>
<ul>
<li>接着, 在应用程序中装入路由器模块: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> birds = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./birds&#x27;</span>);<br>...<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/birds&#x27;</span>, birds);<br></code></pre></td></tr></table></figure>
<h2 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3. 中间件"></a>3. 中间件</h2><h4 id="编写中间件"><a href="#编写中间件" class="headerlink" title="编写中间件"></a>编写中间件</h4><ul>
<li>Connect 创造了”中间件”(middleware)这个术语来描述插入式的 Node 模块</li>
<li>从概念上讲, 中间件是一种功能的封装方式, 具体来说就是封装在程序中处理 HTTP 请求的功能</li>
<li>中间件是在管道中执行的。<ul>
<li>在 Express 程序中, 通过调用 app.use() 向管道中插入中间件。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129145316636.png" alt="image-20230129145316636" style="zoom:80%;" /></p>
<h4 id="Express工作重点"><a href="#Express工作重点" class="headerlink" title="Express工作重点"></a>Express工作重点</h4><ul>
<li>路由处理器(app.get、app.post 等, 经常被统称为app.VERB)可以被看作只处理特定 HTTP动词 (GET、POST等)的中间件。同样, 也可以将中间件看作可以处理全部 HTTP动词 的路由处理器(基本上等同于app.all, 可以处理任何HTTP动词; 对于 PURGE 之类特别的动词会有细微的差别, 但对于普通的动词而言, 效果是一样的)</li>
<li>路由处理器的第一个参数必须是路径。如果你想让某个路由匹配所有路径, 只需用<code>/*</code> 。中间件也可以将路径作为第一个参数, 但它是可选的(如果忽略这个参数, 它会匹配所有路径, 就像指定了 <code>/*</code> 一样)</li>
<li>路由处理器和中间件的参数中都有回调函数, 这个函数有2个、3个或4个参数(从技术上讲也可以有 0 或 1 个参数, 但这些形式没有意义)<ul>
<li>如果有 2 个或 3 个参数, 头两个参数是请求和响应对象, 第三个参数是 next 函数</li>
<li>如果有 4 个参数, 它就变成了<strong>错误处理中间件, 第一个参数变成了错误对象, 然后依次是请求、响应和 next 对象</strong></li>
</ul>
</li>
<li>如果不调用 next(), 管道就会被终止, 也不会再有处理器或中间件做后续处理。如果不调用 next(), 则应该发送一个响应到客户端(res.send、res.json、res.render 等); 如果你不这样做, 客户端会被挂起并最终导致超时</li>
<li>如果调用了 next(), 一般不宜再发送响应到客户端。如果你发送了, 管道中后续的中间件或路由处理器还会执行, 但它们发送的<strong>任何响应都会被忽略</strong></li>
</ul>
<h4 id="中间件函数的简单示例"><a href="#中间件函数的简单示例" class="headerlink" title="中间件函数的简单示例"></a>中间件函数的简单示例</h4><ul>
<li>此函数仅在应用程序的请求通过它时显示”LOGGED”。中间件函数会分配给名为 myLogger 的变量</li>
<li>请注意以上对 next() 的调用<ul>
<li>调用此函数时, 将调用应用程序中的下一个中间件函数</li>
<li>next() 函数不是 Node.js 或 Express API 的一部分, 而是传递给中间件函数的第三自变量</li>
<li>next() 函数可以命名为任何名称, 但是按约定, 始终命名为”next”</li>
<li>为了避免混淆, 请始终使用此约定。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myLogger = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LOGGED&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>要装入中间件函数, 请调用 <code>app.use()</code> 并指定中间件函数。例如, 以下代码在根路径 (/) 的路由之前装入 myLogger 中间件函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">var</span> myLogger = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LOGGED&#x27;</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;;<br>app.<span class="hljs-title function_">use</span>(myLogger);<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>中间件装入顺序很重要<ul>
<li><strong>首先装入的中间件函数也首先被执行</strong></li>
</ul>
</li>
<li>如果在根路径的路由之后装入 myLogger, 那么请求永远都不会到达该函数, 应用程序也不会显示”LOGGED”, 因为根路径的路由处理程序终止了请求/响应循环</li>
<li>中间件函数 myLogger 只是显示消息, 然后通过调用 next() 函数将请求传递到堆栈中的下一个中间件函数</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>名为 requestTime 的属性添加到请求对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> requestTime = <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	req.<span class="hljs-property">requestTime</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>	<span class="hljs-title function_">next</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>现在, 该应用程序使用 requestTime 中间件函数。此外, 根路径路由的回调函数使用由中间件函数添加到 req(请求对象)的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(requestTime);<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	<span class="hljs-keyword">var</span> responseText = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br>	responseText += <span class="hljs-string">&#x27;Requested at: &#x27;</span> + req.<span class="hljs-property">requestTime</span> + <span class="hljs-string">&#x27;&#x27;</span>;<br>	res.<span class="hljs-title function_">send</span>(responseText);<br>&#125;);<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>
<h4 id="使用中间件"><a href="#使用中间件" class="headerlink" title="使用中间件"></a>使用中间件</h4><ul>
<li>Express 是一个路由和中间件 Web 框架, 其自身只具有最低程度的功能: <ul>
<li>Express 应用程序基本上是一系列中间件函数调用</li>
</ul>
</li>
<li>中间件函数能够访问请求对象 (req)、响应对象 (res) 以及应用程序的请求/响应循环中的下一个中间件函数。下一个中间件函数通常由名为 next 的变量来表示</li>
<li>中间件函数可以执行以下任务: <ul>
<li>执行任何代码</li>
<li>对请求和响应对象进行更改</li>
<li>结束请求/响应循环</li>
<li>调用堆栈中的下一个中间件函数</li>
</ul>
</li>
<li><p>如果当前中间件函数没有结束请求/响应循环, 那么它必须调用 next(), 以将控制权传递给下一个中间件函数。否则, 请求将保持挂起状态。</p>
</li>
<li><p>Express 应用程序可以使用以下类型的中间件: </p>
<ul>
<li>应用层中间件</li>
<li>路由器层中间件</li>
<li>错误处理中间件</li>
<li>内置中间件</li>
<li>第三方中间件</li>
</ul>
</li>
<li>可以使用可选安装路径来装入应用层和路由器层中间件。还可以将一系列中间件函数一起装入, 这样会在安装点创建中间件系统的子堆栈。</li>
</ul>
<h4 id="应用层中间件"><a href="#应用层中间件" class="headerlink" title="应用层中间件"></a>应用层中间件</h4><ul>
<li>使用 <code>app.use()</code> 和 <code>app.METHOD()</code> 函数将应用层中间件绑定到<a target="_blank" rel="noopener" href="http://expressjs.com/zh-cn/4x/api.html#app">应用程序对象</a>的实例, 其中 METHOD 是中间件函数处理的请求的小写 HTTP 方法(例如 GET、PUT 或 POST)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 此示例显示没有安装路径的中间件函数。应用程序每次收到请求时执行该函数。</span><br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time:&#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>	<span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// 此示例显示安装在 /user/:id 路径中的中间件函数。在 /user/:id 路径中为任何类型的 HTTP 请求执行此函数。</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request Type:&#x27;</span>, req.<span class="hljs-property">method</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// 此示例显示一个路由及其处理程序函数(中间件系统)。此函数处理针对 /user/:id 路径的 GET 请求。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;USER&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 在安装点使用安装路径装入一系列中间件函数的示例。演示一个中间件子堆栈, 用于显示针对 /user/:id 路径的任何类型 HTTP 请求的信息。</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request URL:&#x27;</span>, req.<span class="hljs-property">originalUrl</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request Type:&#x27;</span>, req.<span class="hljs-property">method</span>);<br>	<span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>路由处理程序可以为一个路径定义多个路由。以下示例为针对 /user/:id 路径的 GET 请求定义两个路由。第⼆个路由不会导致任何问题, 但是永远都不会被调用, 因为第一个路由结束了请求/响应循环。</p>
</li>
<li><p>此示例显示一个中间件子堆栈, 用于处理针对 /user/:id 路径的 GET 请求。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ID:&#x27;</span>, req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br> 	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User Info&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// handler for the /user/:id path, which prints the user ID</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	res.<span class="hljs-title function_">end</span>(req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>要跳过路由器中间件堆栈中剩余的中间件函数, 请调用 <code>next(&#39;route&#39;)</code> 将控制权传递给下一个路由</p>
</li>
<li><p>next(‘route’) 仅在使用 <code>app.METHOD()</code> 或 <code>router.METHOD()</code> 函数装入的中间件函数中有效</p>
</li>
<li><p>此示例显示一个中间件子堆栈, 用于处理针对 /user/:id 路径的 GET 请求</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-comment">// if the user ID is 0, skip to the next route</span><br> 	<span class="hljs-keyword">if</span> (req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> == <span class="hljs-number">0</span>) <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;route&#x27;</span>);<br> 	<span class="hljs-comment">// otherwise pass the control to the next middleware function in this stack</span><br> 	<span class="hljs-keyword">else</span> <span class="hljs-title function_">next</span>(); <span class="hljs-comment">//</span><br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-comment">// render a regular page</span><br> 	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;regular&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// handler for the /user/:id path, which renders a special page</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;special&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="路由器层中间件"><a href="#路由器层中间件" class="headerlink" title="路由器层中间件"></a>路由器层中间件</h4><ul>
<li>路由器层中间件的工作方式与应用层中间件基本相同, 差异之处在于它绑定到 <code>express.Router()</code> 的实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>使用 <code>router.use()</code> 和 <code>router.METHOD()</code> 函数装入路由器层中间件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">// a middleware function with no mount path. This code is executed for every request to the router</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time:&#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br> 	<span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request URL:&#x27;</span>, req.<span class="hljs-property">originalUrl</span>);<br> 	<span class="hljs-title function_">next</span>();<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Request Type:&#x27;</span>, req.<span class="hljs-property">method</span>);<br> 	<span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// a middleware sub-stack that handles GET requests to the /user/:id path</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-comment">// if the user ID is 0, skip to the next router</span><br> 	<span class="hljs-keyword">if</span> (req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> == <span class="hljs-number">0</span>) <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;route&#x27;</span>);<br> 	<span class="hljs-comment">// otherwise pass control to the next middleware function in this stack</span><br> 	<span class="hljs-keyword">else</span> <span class="hljs-title function_">next</span>(); <span class="hljs-comment">//</span><br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-comment">// render a regular page</span><br> 	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;regular&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// handler for the /user/:id path, which renders a special page</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br> 	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;special&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// mount the router on the app</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, router);<br></code></pre></td></tr></table></figure>
<h4 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h4><ul>
<li>错误处理中间件始终采用四个自变量。必须提供四个自变量, 以将函数标识为错误处理中间件函数。即使无需使用 next 对象, 也必须指定该对象以保持特征符的有效性。否则, next 对象将被解释为常规中间件, 从而无法处理错误</li>
<li>错误处理中间件函数的定义方式与其他中间件函数基本相同, 差别在于错误处理函数有四个自变量而不是三个, 专门具有特征符 <code>(err, req, res, next)</code>: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) &#123;<br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">stack</span>);<br> 	res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h4><ul>
<li>自 V4.x 起, Express 不再依赖于 Connect。除 <code>express.static</code> 外, 先前 Express 随附的所有中间件函数现在以单独模块的形式提供。请查看中间件函数的列表。</li>
<li><code>express.static(root, [options])</code><ul>
<li>Express 中唯一内置的中间件函数是 <code>express.static</code>。此函数基于 serve-static, 负责提供 Express 应用程序的静态资源</li>
<li>root 自变量指定从其中提供静态资源的根目录</li>
<li>可选的 options 对象可以具有以下属性: </li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230129172729202.png" alt="image-20230129172729202" style="zoom:80%;" /></p>
<ul>
<li>以下示例将使用了 <code>express.static</code> 中间件, 并且提供了一个详细的 ‘options’ 对象(作为示例): </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> options = &#123;<br>    <span class="hljs-attr">dotfiles</span>: <span class="hljs-string">&#x27;ignore&#x27;</span>,<br>    <span class="hljs-attr">etag</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;htm&#x27;</span>, <span class="hljs-string">&#x27;html&#x27;</span>],<br>    <span class="hljs-attr">index</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">maxAge</span>: <span class="hljs-string">&#x27;1d&#x27;</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">setHeaders</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res, path, stat</span>) &#123;<br>    	res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;x-timestamp&#x27;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>    &#125;<br>&#125;<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>, options));<br></code></pre></td></tr></table></figure>
<ul>
<li>对于每个应用程序, 可以有多个静态目录</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;uploads&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>));<br></code></pre></td></tr></table></figure>
<h4 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h4><ul>
<li>使用第三方中间件向 Express 应用程序添加功能</li>
<li>安装具有所需功能的 Node.js 模块, 然后在应用层或路由器层的应用程序中将其加装入</li>
<li>以下示例演示如何安装和装入 cookie 解析中间件函数 cookie-parser</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$ npm install cookie-parser<br><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">var</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cookie-parser&#x27;</span>);<br><span class="hljs-comment">// load the cookie-parsing middleware</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cookieParser</span>());<br></code></pre></td></tr></table></figure>
<h2 id="4-模板引擎"><a href="#4-模板引擎" class="headerlink" title="4. 模板引擎"></a>4. 模板引擎</h2><h4 id="将模板引擎用于-Express"><a href="#将模板引擎用于-Express" class="headerlink" title="将模板引擎用于 Express"></a>将模板引擎用于 Express</h4><ul>
<li>Express 应用生成器支持多款流行的视图/模板引擎, 包括 EJS、Hbs、Pug (Jade)、Twig 和 Vash, 缺省选项是 Jade。Express 本身也支持大量其他模板语言, 开箱即用</li>
<li>在 Express 可以呈现模板文件之前, 必须设置以下应用程序设置: <ul>
<li>views: 模板文件所在目录。例如: <code>app.set(&#39;views&#39;, &#39;./views&#39;)</code></li>
<li>view engine: 要使用的模板引擎。例如: <code>app.set(&#39;view engine&#39;, &#39;pug&#39;)</code></li>
</ul>
</li>
<li>然后安装对应的模板引擎 npm 包: <ul>
<li>$ npm install pug —save</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在设置视图引擎之后, 不必指定该引擎或者在应用程序中装入模板引擎模块；Express 在内部装入此模块, 如下所示(针对以上示例)</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;pug&#x27;</span>);<br><br><span class="hljs-comment">// 在 views 目录中创建名为 index.pug 的 Pug 模板文件, 其中包含以下内容: </span><br>html<br>  head<br>    title= title<br>  body<br>	h1= message<br><br><span class="hljs-comment">// 随后创建路由以呈现 index.pug 文件。如果未设置 view engine 属性, 必须指定 view 文件的扩展名。否则, 可以将其忽略。</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hey&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello there!&#x27;</span>&#125;);<br>&#125;);<br><br><span class="hljs-comment">// 向主页发出请求时, index.pug 文件将呈现为 HTML。</span><br></code></pre></td></tr></table></figure>
<h4 id="选用模板引擎需要考虑的因素"><a href="#选用模板引擎需要考虑的因素" class="headerlink" title="选用模板引擎需要考虑的因素"></a>选用模板引擎需要考虑的因素</h4><p>一般来说, 你应该选择一个大而全的模板引擎, 可以尽快进入生产状态。就像你选择其他组件一样！选用模板引擎需要考虑以下因素: </p>
<ul>
<li>进入生产状态的时间 —— 如果你的团队已经有某个模板语言的经验, 那么用它可能更快进入生产状态。否则你应该考虑所选模板引擎的学习曲线</li>
<li>流行度和活跃度 —— 要评估所选引擎的流行程度, 以及它是否拥有活跃的社区。在网站的生命周期中遇到问题时, 是否能够获得相关支持非常重要</li>
<li>风格 —— 某些模板引擎使用特定标记, 来标识插入”普通”HTML 中的内容, 而另一些模板引擎使用不同的语法(例如使用缩进和块名称)构造 HTML</li>
<li>性能/渲染时间</li>
<li>功能——你应该考虑所选引擎是否具有以下功能: <ul>
<li>布局继承: 可以定义基本模板, 然后”继承”它的一部分, 使不同页面可以有不同的呈现。这通常比包含大量所需组件, 或每次从头开始构建模板更好</li>
<li>“包含”支持: 可以通过包含其他模板来构建新模板</li>
<li>简明的变量和循环控制语法</li>
<li>能够在模板级别过滤变量值(例如, 将变量设置为大写, 或格式化日期值)</li>
<li>能够生成 HTML 以外的输出格式(例如 JSON 或 XML)</li>
<li>支持异步操作和流</li>
<li>可以同时在客户端和服务器上使用。如果一款模板引擎可以在客户端使用, 那么就使在客户端托管数据并完成所有(或大多数)渲染成为可能。</li>
</ul>
</li>
</ul>
<h4 id="为-Express-开发模板引擎"><a href="#为-Express-开发模板引擎" class="headerlink" title="为 Express 开发模板引擎"></a>为 Express 开发模板引擎</h4><ul>
<li>可以使用 <code>app.engine(ext, callback)</code> 方法创建自己的模板引擎<ul>
<li><code>ext</code> 表示文件扩展名</li>
<li><code>callback</code> 表示模板引擎函数, 它接受以下项作为参数: 文件位置、选项对象和回调函数</li>
</ul>
</li>
<li>以下代码示例实现非常简单的模板引擎以呈现 <code>.ntl</code> 文件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// this engine requires the fs module</span><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>); <br><span class="hljs-comment">// define the template engine</span><br>app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;ntl&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">filePath, options, callback</span>) &#123; <br>	fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, content</span>) &#123;<br>		<span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(err));<br> 		<span class="hljs-comment">// this is an extremely simple template engine</span><br> 		<span class="hljs-keyword">var</span> rendered = content.<span class="hljs-title function_">toString</span>()<br>        	.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#title#&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>+ options.<span class="hljs-property">title</span> +<span class="hljs-string">&#x27;&#x27;</span>)<br> 			.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#message#&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>+ options.<span class="hljs-property">message</span> +<span class="hljs-string">&#x27;&#x27;</span>);<br> 		<span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, rendered);<br> 	&#125;);<br>&#125;);<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, <span class="hljs-string">&#x27;./views&#x27;</span>); <span class="hljs-comment">// specify the views directory</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ntl&#x27;</span>); <span class="hljs-comment">// register the template engine</span><br><br><span class="hljs-comment">// 应用程序现在能够呈现 .ntl 文件。在 views 目录中创建名为 index.ntl 且包含以下内容的文件: </span><br>#title#<br>#message#<br><span class="hljs-comment">// 然后, 在应用程序中创建以下路径: </span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>	res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hey&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello there!&#x27;</span>&#125;);<br>&#125;);<br><span class="hljs-comment">// 您向主页发出请求时, index.ntl 将呈现为 HTML。</span><br></code></pre></td></tr></table></figure>
<h4 id="调试-Express"><a href="#调试-Express" class="headerlink" title="调试 Express"></a>调试 Express</h4><ul>
<li>Express 在内部使用调试模块来记录关于路由匹配、使用的中间件函数、应用程序模式以及请求/响应循环流程的信息</li>
<li>debug 就像是扩充版的 console.log, 但是与 console.log 不同, 不必注释掉生产代码中的 debug 日志。缺省情况下, 日志记录功能已关闭, 可以使用 DEBUG 环境变量有条件地开启日志记录</li>
<li>要查看 Express 中使用的所有内部日志, 在启动应用程序时, 请将 DEBUG 环境变量设置为 express:*<ul>
<li>$ DEBUG=express:* node index.js</li>
</ul>
</li>
<li>在 Windows 上, 使用对应的命令<ul>
<li>> set DEBUG=express:* &amp; node index.js</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230222224055948.png" alt="image-20230222224055948" style="zoom:80%;" /></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-5-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/" rel="prev" title="编译原理(5) 语义分析">
      <i class="fa fa-chevron-left"></i> 编译原理(5) 语义分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/12/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-6-LLVM-IR/" rel="next" title="编译原理(6) LLVM IR">
      编译原理(6) LLVM IR <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Node-js"><span class="nav-number">1.</span> <span class="nav-text">9-Node.js</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1. 服务端编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">静态网页与动态网页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">服务端编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">服务端编程的优势</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Node-js"><span class="nav-number">1.2.</span> <span class="nav-text">2. Node.js</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">Node.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">Node.js 的诞生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E7%8E%B0%E7%8A%B6"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">Node.js 现状</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">Node.js 应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-%E4%BC%98%E5%8A%BF"><span class="nav-number">1.2.0.5.</span> <span class="nav-text">Node 优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.0.6.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E4%B8%8D%E9%80%82%E5%90%88%E7%9A%84%E9%A2%86%E5%9F%9F"><span class="nav-number">1.2.0.7.</span> <span class="nav-text">Node.js 不适合的领域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.3.</span> <span class="nav-text">3. 事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">Node.js 事件循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">事件驱动模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E6%94%AF%E6%8C%81-JS"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">Node.js 支持 JS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%98%BB%E5%A1%9E"><span class="nav-number">1.4.</span> <span class="nav-text">4. 阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5-vs-%E5%BC%82%E6%AD%A5"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">同步 vs 异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%8F-I-O-%E5%92%8C%E5%BC%82%E6%AD%A5%E5%BC%8F-I-O-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">同步式 I&#x2F;O 和异步式 I&#x2F;O 的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E-vs-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">阻塞 vs 非阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">1.4.0.5.</span> <span class="nav-text">非阻塞</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.5.</span> <span class="nav-text">5. 实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#package-json"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">package.json</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-API"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">Node.js API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js%E6%B5%81%E8%A1%8C%E6%A8%A1%E5%9D%97"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">Node.js流行模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%A8%A1%E5%9D%97"><span class="nav-number">1.6.</span> <span class="nav-text">6. 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">ES6 模块与 CommonJS 模块的差异</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="nav-number">1.6.0.3.</span> <span class="nav-text">模块加载的实质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E7%9A%84%E5%8C%BA%E5%88%86"><span class="nav-number">1.6.0.4.</span> <span class="nav-text">Node.js 的区分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81%E4%B8%A4%E7%A7%8D%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%9D%97-%E4%BA%86%E8%A7%A3"><span class="nav-number">1.6.0.5.</span> <span class="nav-text">同时支持两种格式的模块(了解)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#require-%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E7%AD%96%E7%95%A5"><span class="nav-number">1.6.0.6.</span> <span class="nav-text">require 方法查找策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A-simple-file-server"><span class="nav-number">1.6.0.7.</span> <span class="nav-text">A simple file server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#as"><span class="nav-number">1.6.0.8.</span> <span class="nav-text">as</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#export-default"><span class="nav-number">1.6.0.9.</span> <span class="nav-text">export default</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.7.</span> <span class="nav-text">7. 循环加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CommonJS-%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">CommonJS 循环加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6-%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">ES6 循环加载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%85%B6%E4%BB%96"><span class="nav-number">1.8.</span> <span class="nav-text">8. 其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E7%89%88%E6%9C%AC"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">Node.js 版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%B2%E6%97%A0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">已无性能优势?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MEAN"><span class="nav-number">1.8.0.3.</span> <span class="nav-text">MEAN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MEAN-%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.0.4.</span> <span class="nav-text">MEAN 架构原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web-%E6%A1%86%E6%9E%B6"><span class="nav-number">1.8.0.5.</span> <span class="nav-text">Web 框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-js-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.8.0.6.</span> <span class="nav-text">Node.js 框架的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B"><span class="nav-number">1.8.0.7.</span> <span class="nav-text">框架选型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.8.0.8.</span> <span class="nav-text">预处理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="nav-number">1.8.0.9.</span> <span class="nav-text">跨平台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">1.8.0.10.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Express"><span class="nav-number">2.</span> <span class="nav-text">10-Express</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.</span> <span class="nav-text">1. 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Express"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">什么是 Express ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Is-Express-opinionated"><span class="nav-number">2.1.0.3.</span> <span class="nav-text">Is Express opinionated?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Express-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.0.4.</span> <span class="nav-text">Express 开发环境概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hello-world"><span class="nav-number">2.1.0.5.</span> <span class="nav-text">Hello world</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%B7%A5%E5%85%B7"><span class="nav-number">2.1.0.6.</span> <span class="nav-text">应用生成器工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.0.7.</span> <span class="nav-text">文件结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B7%AF%E7%94%B1"><span class="nav-number">2.2.</span> <span class="nav-text">2. 路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">处理数据流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E7%94%B1"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">基本路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.2.0.3.</span> <span class="nav-text">路由示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.0.4.</span> <span class="nav-text">路由方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E8%B7%AF%E7%94%B1%E6%96%B9%E6%B3%95-app-all"><span class="nav-number">2.2.0.5.</span> <span class="nav-text">特殊路由方法: app.all()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%AF%E5%BE%84"><span class="nav-number">2.2.0.6.</span> <span class="nav-text">路由路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.0.7.</span> <span class="nav-text">路由参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.0.8.</span> <span class="nav-text">路由处理程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.0.9.</span> <span class="nav-text">响应方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#app-route"><span class="nav-number">2.2.0.10.</span> <span class="nav-text">app.route()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#express-Router"><span class="nav-number">2.2.0.11.</span> <span class="nav-text">express.Router</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">3. 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.3.0.1.</span> <span class="nav-text">编写中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Express%E5%B7%A5%E4%BD%9C%E9%87%8D%E7%82%B9"><span class="nav-number">2.3.0.2.</span> <span class="nav-text">Express工作重点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.3.0.3.</span> <span class="nav-text">中间件函数的简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.3.0.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.3.0.5.</span> <span class="nav-text">使用中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.3.0.6.</span> <span class="nav-text">应用层中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B1%82%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.3.0.7.</span> <span class="nav-text">路由器层中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.3.0.8.</span> <span class="nav-text">错误处理中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.3.0.9.</span> <span class="nav-text">内置中间件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.3.0.10.</span> <span class="nav-text">第三方中间件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="nav-number">2.4.</span> <span class="nav-text">4. 模板引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%94%A8%E4%BA%8E-Express"><span class="nav-number">2.4.0.1.</span> <span class="nav-text">将模板引擎用于 Express</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-number">2.4.0.2.</span> <span class="nav-text">选用模板引擎需要考虑的因素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA-Express-%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="nav-number">2.4.0.3.</span> <span class="nav-text">为 Express 开发模板引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-Express"><span class="nav-number">2.4.0.4.</span> <span class="nav-text">调试 Express</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Whale-lyi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Whale-lyi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
