<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="南京大学软件学院大三在读" />
  
  
  <title>
    
      C++高级程序设计 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">C++高级程序设计</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-08-09 14:53:19
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/NJU/" title="NJU">
                    <b>#</b> NJU
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/NJU/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计">
                    <b>#</b> C++高级程序设计
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="结构化程序设计部分"><a href="#结构化程序设计部分" class="headerlink" title="结构化程序设计部分"></a>结构化程序设计部分</h2><h3 id="1-C-历史"><a href="#1-C-历史" class="headerlink" title="1. C++历史"></a>1. C++历史</h3><h4 id="1-1-演化历程"><a href="#1-1-演化历程" class="headerlink" title="1.1 演化历程"></a>1.1 演化历程</h4><ul>
<li>Father of Simula67、Father of OO programming<ul>
<li>Ole-Johan Dahl、Kristen Nygaard</li>
</ul>
</li>
<li>C语言之父、共同发明UNIX<ul>
<li>Dennis Ritchie、Ken Thompson</li>
</ul>
</li>
<li>1980年形成C with class<ul>
<li>Bjarne Stroustrup</li>
</ul>
</li>
<li>1983年正式命名为C++<ul>
<li>Rick Mascitti</li>
</ul>
</li>
<li>1994年制定ANSI C++标准草案</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621131005571.png" alt="image-20220621131005571"></p>
<h4 id="1-2-设计理念"><a href="#1-2-设计理念" class="headerlink" title="1.2 设计理念"></a>1.2 设计理念</h4><ul>
<li>效率</li>
<li>实用性优于艺术性严谨性</li>
<li>相信程序员（允许一个有用的特征比防止各种错误使用更重要）</li>
</ul>
<h4 id="1-3-C-与-C-的关系"><a href="#1-3-C-与-C-的关系" class="headerlink" title="1.3 C 与 C++ 的关系"></a>1.3 C 与 C++ 的关系</h4><ul>
<li>C++ 完全包含了 C 语言成分，支持 C 支持的全部编程技巧，C 是建立 C++ 的基础，同时 C++ 还添加了OOP的完全支持。</li>
<li>任何 C 程序都能被 C++ 用基本相同的方法编写，并具有相同的运行效率和空间。</li>
<li>C++ 还引入了重载、内联函数、异常处理等功能，对 C 中过程化控制及其功能进行了扩充</li>
</ul>
<h4 id="1-4-C和C-混合编程应该注意的问题"><a href="#1-4-C和C-混合编程应该注意的问题" class="headerlink" title="1.4 C和C++混合编程应该注意的问题"></a>1.4 C和C++混合编程应该注意的问题</h4><ul>
<li><p>名变换：如果调用C语言库中的函数，则需要附加 <code>&quot;extern C&quot;</code>，限制 C++ 编译器进行名变换，便于可以连接</p>
</li>
<li><p>静态初始化：C++ 静态的类对象和定义在全局的、命名空间中的或文件体中的类对象的构造函数通常在 <code>main</code> 被执行前就被调用，尽可能把主函数写在 cpp 文件当中</p>
</li>
<li><p>内存动态分配：C++ 使用 <code>new/delete</code>，C 使用 <code>malloc/free</code>，需要注意匹配</p>
</li>
<li><p>数据结构兼容：将在两种语言间传递的东西限制在用 C 编译的数据结构的范围内，这些结构的 C++版本可以包含⾮虚成员函数，不能有虚函数。</p>
</li>
<li><p>因为C++是C的超集，且C是结构化编程语言，⽽C++支持面向对象编程语言，所以在混合编程时，不应当出现class等⾯向对象的关键字</p>
</li>
<li><p>C语言不支持函数重载。</p>
<blockquote>
<p>在C++中f (int, int) 与 f(int, double) 是不同的函数，都重载了函数 f()；但是在C语言中却被认为是相同的函数。因为在编译时，<em>C语言给这几个函数的命名为 f；而C++命名分别为 f_int_int，f_int_double，f</em>，以表示区别；所以混合编程时应注意重载函数的问题</p>
</blockquote>
</li>
<li><p>在 C++ 中也允许在 <code>struct</code> 和 <code>union</code> 中定义函数，他们也具有类的基本功能，与 <code>class</code> 所不同的是，<code>struct</code> 和 <code>union</code> 的成员的默认访问控制为 <code>public</code></p>
</li>
</ul>
<h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h3><h4 id="2-1-Data"><a href="#2-1-Data" class="headerlink" title="2.1 Data"></a>2.1 Data</h4><ul>
<li>强类型，动&#x2F;静结合</li>
</ul>
<h4 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h4><ul>
<li>Modifiers ：long、short、signed、unsigned<ul>
<li>char 只能用signed、unsigned修饰</li>
<li>float 不能被修饰</li>
<li>double 只能用long修饰</li>
<li>int 可以用4种修饰符组合修饰</li>
</ul>
</li>
<li>操作符 sizeof</li>
<li>typedef 定义同义词</li>
</ul>
<h4 id="2-3-表达式"><a href="#2-3-表达式" class="headerlink" title="2.3 表达式"></a>2.3 表达式</h4><ul>
<li><p>赋值表达式</p>
<ul>
<li>左值＝右值表达式<ul>
<li>左值：可以出现在赋值表达式左部的表达式，具有存放数据的确定地址</li>
<li>类型不同时，先计算右值表达式的值，再转换为左值类型，然后赋值</li>
</ul>
</li>
</ul>
</li>
<li><p>条件运算符表达式</p>
<ul>
<li>&lt;exp1&gt; ? &lt;exp2&gt; : &lt;exp3&gt;</li>
<li>如果&lt;exp2&gt; 和&lt;exp3&gt;的值类型相同，且均为左值，则该条件运算符表达式为左值表达式</li>
<li>可嵌套<ul>
<li>sign(x)      x &gt; 0? 1: x &#x3D;&#x3D; 0? 0 : -1</li>
<li>就近原则</li>
</ul>
</li>
</ul>
</li>
<li><p>逗号表达式</p>
<ul>
<li><p>$<exp_1>,<exp_2>,…,<exp_n>$</p>
</li>
<li><p>$<exp_n>$的值作为该逗号表达式的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a, b, c;<br><span class="hljs-type">int</span> d = (a = <span class="hljs-number">1</span>, b = a+<span class="hljs-number">2</span>, c = b+<span class="hljs-number">3</span>);<br>cout &lt;&lt; d &lt;&lt; endl; <span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如$<exp_n>$为左值，则该逗号表达式为左值</p>
</li>
</ul>
</li>
<li><p>影响表达式值的因素</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h4 id="2-4-语句"><a href="#2-4-语句" class="headerlink" title="2.4 语句"></a>2.4 语句</h4><ul>
<li>表达式语句、IO语句和控制流语句</li>
<li>switch<ul>
<li>整形常量表达式：<code>5、const、enum、define</code>(对于compiler是固定的)</li>
<li>值不重复</li>
<li>次序任意(特指case)</li>
<li>switch可以和enum结合使用，将具体数值解耦</li>
<li>switch的进一步优化可以使用表驱动</li>
</ul>
</li>
</ul>
<h5 id="2-4-1-switch的实现与优化-表驱动"><a href="#2-4-1-switch的实现与优化-表驱动" class="headerlink" title="2.4.1 switch的实现与优化(表驱动)"></a>2.4.1 switch的实现与优化(表驱动)</h5><ul>
<li>对于switch的汇编格式，其只需要被翻译为cmp一次即可。</li>
<li>switch：使用表驱动来提高效率</li>
<li>详见PPT 36页的动画：不要将提示语进行硬编码，可以使用枚举类型(集中管理)</li>
<li>计算机中的所有的鼠标操作都会对应一个事件</li>
<li>字面常量调整为枚举类型，还可以使用事件表来完成<ul>
<li>使用一个handler</li>
<li>表是从内存中装载进来</li>
</ul>
</li>
<li>目前操作系统中的对应存储对应的文件为RC</li>
</ul>
<h5 id="2-4-2-switch的实现与优化（编译过程）"><a href="#2-4-2-switch的实现与优化（编译过程）" class="headerlink" title="2.4.2 switch的实现与优化（编译过程）"></a>2.4.2 switch的实现与优化（编译过程）</h5><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621172638151.png" alt="image-20220621172638151" style="zoom:80%;" />

<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621172655516.png" alt="image-20220621172655516" style="zoom:80%;" />

<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621173115017.png" alt="image-20220621173115017" style="zoom:80%;" />

<h5 id="2-4-3-如果range很大"><a href="#2-4-3-如果range很大" class="headerlink" title="2.4.3 如果range很大"></a>2.4.3 如果range很大</h5><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621173711476.png" alt="image-20220621173711476" style="zoom:80%;" />

<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621173748658.png" alt="image-20220621173748658" style="zoom:80%;" />

<h4 id="2-5-表驱动"><a href="#2-5-表驱动" class="headerlink" title="2.5 表驱动"></a>2.5 表驱动</h4><ul>
<li>Application Scene应用<ul>
<li>Error&#x2F;exception handle 异常处理</li>
<li>Message-driven 信息驱动</li>
<li>Function pointer 函数指针：就是例子中case里面只是简答的打印，而实际情况中可能只是相似的接口而已，这是我们就要使用到函数指针了。</li>
</ul>
</li>
<li>Implementation 实现<ul>
<li>Array 数组</li>
<li>Map</li>
</ul>
</li>
</ul>
<h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul>
<li>原则<ul>
<li>定义不允许嵌套</li>
<li>先定义后使用</li>
</ul>
</li>
<li>函数的执行机制<ul>
<li>建立被调用函数的栈空间</li>
<li>参数传递<ul>
<li>值传递 (call by value)</li>
<li>引用传递 (call by reference)</li>
</ul>
</li>
<li>保存调用函数的运行状态</li>
<li>将控制转交被调函数</li>
</ul>
</li>
</ul>
<h4 id="3-1-函数与内存"><a href="#3-1-函数与内存" class="headerlink" title="3.1 函数与内存"></a>3.1 函数与内存</h4><h5 id="3-1-1-存储空间与内存"><a href="#3-1-1-存储空间与内存" class="headerlink" title="3.1.1 存储空间与内存"></a>3.1.1 存储空间与内存</h5><ul>
<li>从上到下分别是<ul>
<li>Code：存放函数体的二进制代码</li>
<li>Data：存放数据(静态变量和全局变量和字符串常量)</li>
<li>Stack：由系统管理，存放函数参数值，局部变量</li>
<li>Heap：可以用程序员进行分配，可以在运行时动态确定，<code>int *p = (int *)malloc(4)</code>，归还内存<code>free</code>(在C++中不推荐使用这种方法进行处理，而是使用new和delete)</li>
</ul>
</li>
</ul>
<h5 id="3-1-2-Runtime-Environment"><a href="#3-1-2-Runtime-Environment" class="headerlink" title="3.1.2 Runtime Environment"></a>3.1.2 Runtime Environment</h5><ul>
<li><p>__cdecl</p>
</li>
<li><p>__stdcall</p>
</li>
<li><p>__fastcall</p>
</li>
<li><p>__thiscall</p>
</li>
</ul>
<h4 id="3-2-函数执行机制"><a href="#3-2-函数执行机制" class="headerlink" title="3.2 函数执行机制"></a>3.2 函数执行机制</h4><h5 id="3-2-1-建立被调用函数栈空间"><a href="#3-2-1-建立被调用函数栈空间" class="headerlink" title="3.2.1 建立被调用函数栈空间"></a>3.2.1 建立被调用函数栈空间</h5><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621190618458.png" alt="image-20220621190618458" style="zoom:80%;" />

<h5 id="3-2-2-参数传递"><a href="#3-2-2-参数传递" class="headerlink" title="3.2.2 参数传递"></a>3.2.2 参数传递</h5><ul>
<li>值传递</li>
</ul>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621192112390.png" alt="image-20220621192112390" style="zoom:80%;" />

<ul>
<li>引用传递<ul>
<li>传递的是地址，会同时修改对应地址单元中的值。（函数副作用）</li>
</ul>
</li>
</ul>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621192134712.png" alt="image-20220621192134712" style="zoom:80%;" />

<ul>
<li>call by name：是指在用到该参数的时候才会计算参数表达式的值</li>
<li>call by value-result</li>
</ul>
<h5 id="3-2-3-保存调用函数的运行状态-额外的Cost"><a href="#3-2-3-保存调用函数的运行状态-额外的Cost" class="headerlink" title="3.2.3 保存调用函数的运行状态(额外的Cost)"></a>3.2.3 保存调用函数的运行状态(额外的Cost)</h5><ul>
<li>存储新的基指针：如上面，将ret_addr和main_esp进行存储。</li>
<li>分配函数存储的空间</li>
<li>执行某些功能</li>
<li>释放不必要的存储空间</li>
</ul>
<h5 id="3-2-4-将控制转交给被调函数"><a href="#3-2-4-将控制转交给被调函数" class="headerlink" title="3.2.4 将控制转交给被调函数"></a>3.2.4 将控制转交给被调函数</h5><ul>
<li>加载调用者的基指针</li>
<li>记载返回地址</li>
</ul>
<h5 id="3-2-5-Summary"><a href="#3-2-5-Summary" class="headerlink" title="3.2.5 Summary"></a>3.2.5 Summary</h5><ul>
<li>加载参数(进栈)</li>
<li>保存上下文环境<ul>
<li>保存返回地址</li>
<li>保存调用者基指针</li>
</ul>
</li>
<li>执行函数<ul>
<li>设置新的基指针</li>
<li>分配空间(可选)</li>
<li>执行一些任务</li>
<li>释放空间(如果分配了的话)</li>
</ul>
</li>
<li>恢复上下文环境<ul>
<li>加载调用者基指针</li>
<li>加载返回指针</li>
</ul>
</li>
<li>继续执行调用者的功能</li>
</ul>
<h4 id="3-3-函数原型"><a href="#3-3-函数原型" class="headerlink" title="3.3 函数原型"></a>3.3 函数原型</h4><ul>
<li><p>遵守先定义后使用原则</p>
</li>
<li><p>自由安排函数定义位置</p>
</li>
<li><p>语句:只需参数类型，无需参数名称</p>
</li>
<li><p>编译器检查</p>
</li>
<li><p>函数原型:只需要看到函数名和参数读取到即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">int func(int,int)<br></code></pre></td></tr></table></figure>

<ul>
<li>在调用点一定要能看到接口</li>
<li>仅仅需要函数名和参数类型即可</li>
</ul>
</li>
<li><p>函数原型应当放置在头文件中</p>
</li>
</ul>
<h4 id="3-4-函数重载"><a href="#3-4-函数重载" class="headerlink" title="3.4 函数重载"></a>3.4 函数重载</h4><ul>
<li><p>原则：</p>
<ul>
<li>名称相同，参数不同(重载函数的参数个数、参数类型、参数顺序至少一个不同)</li>
<li>返回值类型不作为区别重载函数的依据</li>
</ul>
</li>
<li><p>匹配原则</p>
<ul>
<li>严格匹配</li>
<li>内部转换</li>
<li>用户定义的转换</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//下面这种是不被允许的，ambiguous</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;            <br><span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-5-函数的默认参数"><a href="#3-5-函数的默认参数" class="headerlink" title="3.5 函数的默认参数"></a>3.5 函数的默认参数</h4><ul>
<li><p>默认参数的声明</p>
<ul>
<li><strong>函数原型中给出</strong></li>
<li>先定义的函数中给出</li>
</ul>
</li>
<li><p>默认参数的顺序</p>
<ul>
<li><strong>右→左</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">2</span>)</span> <span class="hljs-comment">//正确</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> c)</span> <span class="hljs-comment">//错误</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>不间断</li>
</ul>
</li>
<li><p>默认参数与函数重载要注意</p>
<ul>
<li><code>void f(int); void f(int, int=2);</code>，ambiguous</li>
</ul>
</li>
</ul>
<h4 id="3-6-外部函数-extern"><a href="#3-6-外部函数-extern" class="headerlink" title="3.6 外部函数 extern"></a>3.6 外部函数 extern</h4><ul>
<li>符号表：Name mangling: extern “C”<ul>
<li>在C++的g中调用C中的f，会在link的时候出问题(因为不在C++ 的符号表中)</li>
<li>解决方案:在函数名前面加上extern的关键词(这样子编译器就会在编译过程中从外部进行寻找)</li>
</ul>
</li>
<li>C编译器编译的文件被放置在lib库中，C++不能直接调用，而是需要extern才可以</li>
<li>原因：符号表机制<ul>
<li>符号表：与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表<code>&lt;name,address&gt;</code>，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行</li>
<li>对于C语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载)</li>
<li>对于C++来说，因为有重载，所以f(int)和f(float)在符号表里的name是不同的</li>
<li>C++对于C语言的函数 f 会按c++的方式生成函数表中的nameA，但 C 编译好的函数表内 f 对应的nameB和nameA不一致，导致C++无法找到该函数</li>
</ul>
</li>
</ul>
<h4 id="3-7-inline"><a href="#3-7-inline" class="headerlink" title="3.7 inline"></a>3.7 inline</h4><ul>
<li>内联函数inline<ul>
<li>目的<ul>
<li>提高可读性</li>
<li>提高效率</li>
</ul>
</li>
<li>实现方法<ul>
<li>编译系统将为inline函数创建一段代码，在调用点，以相应的代码替换</li>
</ul>
</li>
<li>限制<ul>
<li>递归</li>
<li>函数指针</li>
</ul>
</li>
<li><strong>inline</strong> 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</li>
<li>适用<ul>
<li>使用频率高、简单、小段代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">ascii</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    r = <span class="hljs-built_in">ascii</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;r = %d\n&quot;</span>, r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;	<br></code></pre></td></tr></table></figure>

<ul>
<li><p>缺点：</p>
<ul>
<li><p>增大目标代码</p>
</li>
<li><p>病态的换页</p>
<blockquote>
<p><strong>如果有过长的代码，被替换进入代码的段中，代码页在内存和磁盘中反复换页抖动</strong>(每调用一次内联函数就会将那段代码复制到主文件中，内存增加，内存调用时原本一页的内容可能出现在第一页+第二页的一部分，<strong>造成操作系统的”抖动”</strong>)</p>
</blockquote>
</li>
<li><p>降低指令快取装置的命中率(instruction cache hit rate)</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-程序组织"><a href="#4-程序组织" class="headerlink" title="4 程序组织"></a>4 程序组织</h3><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220621200100752.png" alt="image-20220621200100752" style="zoom:80%;" />

<ul>
<li>编译只编译当前模块</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">g</span>()&#123;  <span class="hljs-comment">//a.cpp</span><br>	<span class="hljs-built_in">f</span>()  <span class="hljs-comment">//b.cpp</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>编译每个编译单元(<code>.cpp</code>)时是相互独立的，即每个cpp文件之间是不知道对方的存在的,<code>.cpp</code>编译成<code>.obj</code>后，link期时<code>a.obj</code>才会从<code>b.obj</code>中获得<code>f()</code>函数的信息</li>
<li>link时将编译的结果连接成可执行代码，主要是确定各部分的地址,将编译结果中的<strong>地址符号全换成实地址</strong>(call指令在a.cpp被编译时只是call f的符号，而不知道f确切的地址)</li>
</ul>
<h4 id="4-1-static"><a href="#4-1-static" class="headerlink" title="4.1 static"></a>4.1 static</h4><ul>
<li>修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。<ul>
<li>其他文件中可以定义相同名字的变量</li>
</ul>
</li>
<li>修饰局部变量时，表明该变量的值不会因为函数终止而丢失。<ul>
<li>该变量在全局数据区分配内存(局部变量在栈分配内存)</li>
<li>始终驻留在全局数据区直到程序运行结束，但作用域为局部作用域，不能再函数外访问</li>
</ul>
</li>
<li>修饰函数时，表明该函数只在同一文件中调用。<ul>
<li>其他文件中可以定义相同名字的函数</li>
</ul>
</li>
<li>修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有</li>
</ul>
<h4 id="4-2-namespace"><a href="#4-2-namespace" class="headerlink" title="4.2 namespace"></a>4.2 namespace</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> A<br>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">namespace</span> D<br>	&#123;<br>		<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> B<br>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">namespace</span> C<br>	&#123;<br>		<span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> B;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> C;<br>	cout &lt;&lt; b；<span class="hljs-comment">//必须using B,C否则b会报错</span><br>	<span class="hljs-built_in">getchar</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>using-declaration<ul>
<li>指定使用L中的哪些变量&#x2F;函数 <code>using L::k</code></li>
</ul>
</li>
<li>using-directive<ul>
<li>使用L中的全部内容 <code>using namespace L</code></li>
</ul>
</li>
</ul>
<h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h3><ul>
<li>特征：<ul>
<li>相同类型</li>
<li>连续存储</li>
</ul>
</li>
</ul>
<h4 id="5-1-一维数组"><a href="#5-1-一维数组" class="headerlink" title="5.1 一维数组"></a>5.1 一维数组</h4><ul>
<li><p>函数接口：void f(int a[]，int n)</p>
<ul>
<li><p>元素个数须通过参数<strong>显式</strong>给出，不能通过<em>sizeof</em>取得</p>
<ul>
<li><p>字符串特例：void f(char a[])</p>
</li>
<li><pre><code class="c++">char s1[] = &quot;abc&quot;;  //等价于2
char s2[] = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\0&#39;&#125;;
char s2[] = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;  //不正确
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>#### 5.2 二维数组<br><br>- 定义<br><br>  ```c++<br>  int B[2][6];<br>  typedef int T[6];<br>  T B[2];//等价于int B[2][6]<br>  int C[2][3][2];<br>  typedef int T2[2];<br>  typedef T2 T1[3];<br>  T1 C[2];//等价于int C[2][3][2]<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>参数传递</p>
<ul>
<li>缺省第一维</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">2</span>], <span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>], <span class="hljs-type">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-Struct"><a href="#6-Struct" class="headerlink" title="6. Struct"></a>6. Struct</h3><ul>
<li><p>可以做赋值操作：同类型，大块数据的传输</p>
<ul>
<li><p>struct按不同顺序排列sizeof()会不一样</p>
</li>
<li><pre><code class="c++">struct A &#123;
    char a;
    int b;
    short c;
&#125;
cout &lt;&lt; sizeof(A) &lt;&lt; endl; //此时sizeof(A) = 12
struct B &#123;
    short c;
    char a;
    int b;
&#125;
cout &lt;&lt; sizeof(B) &lt;&lt; endl;//此时sizeof(B) = 8，因为short占2个字节，四个字节并未占满，所以还可以填入一个char，但是再遇到int（4个字节）就不能再填充了，只能从写一个四字节地址开始，所以共占8个字节
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>### 7. Union<br><br>- 共享存储空间（公共的容器），能够节省空间，union变量占用的内存长度等于最长的成员的内存长度，所有成员的起始地址是一样的，故下面的&amp;test.b &amp;test.a &amp;test.c是一样的<br><br>  - ```c++<br>    union B &#123;<br>        char b;<br>        int a;<br>        short c;<br>    &#125; test;<br>    cout &lt;&lt; sizeof(B) &lt;&lt; endl;//输出存储空间最大的一位，即输出max(sizeof(b), sizeof(a), sizeof(c))<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li><p>矩阵</p>
<ul>
<li><pre><code class="c++">union Matrix &#123;
    struct &#123;
        double _a11, _a12, _a13;
        double _a21, _a22, _a23;
        double _a31, _a32, _a33;
    &#125;
&#125;
Matrix m;
int i,j;
for (i = 0; i &lt; 3; i++)
    for (j = 0; j &lt; 3; j++)
        m._element[i][j] = (i + 1) * (j + 1)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>### 8. 指针<br><br>- **最基本的作用：管理地址信息**<br><br>  - 管理数据<br>  - 调用代码<br><br>- 定义<br><br>  - 格式：&lt;基类型&gt; *&lt;指针变量&gt; 例：int *p;<br><br>  - 使用typedef定义一个指针类型<br><br>    ```c++<br>    typedef int* pointer;<br>    pointer p, q;//p,q均是指针变量<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作符</p>
<ul>
<li><p>&amp;取地址，*间接取内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">9</span>;<br><span class="hljs-type">int</span> *p;<br>p = &amp;x;<br>*p = <span class="hljs-number">1000</span>;<span class="hljs-comment">//p存储的是x的内容，*p间接获得x的内容</span><br><span class="hljs-comment">//x的地址是0X5212，x的内容是9，p的地址是0X7B77，p的内容是x的地址0X5212，*p就是x的内容</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>NULL和nullptr区别，在C++中，NULL代表0，nullptr代表空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;This is a NULL example&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *num)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;This is a nullptr example&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>);<br>	<span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br><span class="hljs-comment">// 输出结果为</span><br><span class="hljs-comment">// This is a NULL example</span><br><span class="hljs-comment">// This is a nullptr example</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>指针运算</p>
<ul>
<li><p>赋值</p>
<ul>
<li>同类型赋值</li>
</ul>
</li>
<li><p>+&#x2F;- 整形</p>
<ul>
<li><p>结果类型不变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x; <span class="hljs-type">int</span> *p;<br>p = p + <span class="hljs-number">1</span>;<br>p = &amp;x + <span class="hljs-number">2</span>;<br>p++; p--;<br></code></pre></td></tr></table></figure>
</li>
<li><p>数值：sizeof(基类型) * 整型数值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * p; <span class="hljs-type">double</span> * q;<br>p++;  <span class="hljs-comment">//p的值加4</span><br>q++;  <span class="hljs-comment">//q的值加8</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>同类型指针相减</p>
<ul>
<li><p>结果类型：整形</p>
</li>
<li><p>数值：偏移量    </p>
<ul>
<li>值差&#x2F;sizeof(基类型)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p, *q, offset;<br><span class="hljs-type">int</span> A[<span class="hljs-number">12</span>];<br>p = &amp;A[<span class="hljs-number">0</span>];<br>q = &amp;A[<span class="hljs-number">3</span>];<br>offset = q - p;<span class="hljs-comment">//offfset = 3</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>同类型指针比较</p>
<ul>
<li>&#x3D;&#x3D;、!&#x3D;</li>
</ul>
</li>
<li><p>输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> *p = &amp;x;<br>cout &lt;&lt; p;  <span class="hljs-comment">//x的地址</span><br>cout &lt;&lt; *p; <span class="hljs-comment">//x的值</span><br><br><span class="hljs-comment">//特例</span><br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;ABCD&quot;</span>;<br>cout &lt;&lt; p; 	 <span class="hljs-comment">//p指向的字符串，ABCD</span><br>cout &lt;&lt; *p;  <span class="hljs-comment">//p指向的字符，A</span><br>cout &lt;&lt; (<span class="hljs-type">int</span> *)p <span class="hljs-comment">//p的值，非char*</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>void *</p>
<ul>
<li><p>只管理地址信息</p>
</li>
<li><p>任何一种指针类型都能赋值给void *，void *是所有指针类型的公共接口</p>
</li>
<li><p>任何操作都要做<strong>强制类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将某块内存清零</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *pointer, <span class="hljs-type">unsigned</span> size)</span> </span>&#123;<br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)pointer;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; size; k++) &#123;<br>        *p++ = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;     <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常量指针</p>
<ul>
<li><p>一般形式 const &lt;类型&gt; * &lt;指针变量&gt;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cp;<br><span class="hljs-type">int</span> y = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> *q;<br>cp =&amp;c;		<span class="hljs-comment">//√</span><br>q = &amp;y;		<span class="hljs-comment">//√</span><br>*cp = <span class="hljs-number">1</span>;	<span class="hljs-comment">//×</span><br>*q = <span class="hljs-number">2</span>;		<span class="hljs-comment">//√</span><br>cp = &amp;y;	<span class="hljs-comment">//√，用于消除函数副作用</span><br>q = &amp;c;		<span class="hljs-comment">//×</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>不能把一个有读写权力的指针赋值给只有读权力的地址</p>
<ul>
<li>不能用普通指针指向常量</li>
</ul>
</li>
<li><p>const_cast可以取消常量属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> c=<span class="hljs-number">128</span>;<br><span class="hljs-type">int</span> * q = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(&amp;c);<br>*q = <span class="hljs-number">111</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot; c &quot;</span> &lt;&lt; &amp;c &lt;&lt; c &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot; q &quot;</span> &lt;&lt; &amp;q &lt;&lt; q &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;*q &quot;</span> &lt;&lt; q &lt;&lt; *q &lt;&lt; endl;<br><span class="hljs-comment">//c      0012FF74    128  为什么？</span><br><span class="hljs-comment">//q      0012FF70    0012FF74</span><br><span class="hljs-comment">//*q     0012FF74    111</span><br></code></pre></td></tr></table></figure>

<ul>
<li>编译器编译时已经把c换成字面常量128</li>
</ul>
</li>
</ul>
</li>
<li><p>指针常量</p>
<ul>
<li>一般形式 &lt;类型&gt; * const &lt;指针变量&gt; 必须在定义时初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x,y;<br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;x;<br>p = &amp;y;<span class="hljs-comment">//错误</span><br>*p = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>指针与数组</p>
<ul>
<li>数据升降维</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">void</span>(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n);<span class="hljs-comment">//此时的A是一个指针常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">12</span>];<br>    <span class="hljs-built_in">f</span>(a,<span class="hljs-number">12</span>);<br>    <span class="hljs-comment">//此时的a已经转化为一个int *const表达式，失去了原来数组的含义</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">12</span>];<br><span class="hljs-type">int</span> *p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">12</span>;i++)&#123;<br>    *(p++) = <span class="hljs-number">0</span>;<br>    *(a + i) = <span class="hljs-number">0</span>;<br>    *(a++) = <span class="hljs-number">0</span>;<span class="hljs-comment">//该写法错误</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622003704361.png" alt="image-20220622003704361" style="zoom:80%;" />

<h3 id="9-动态变量"><a href="#9-动态变量" class="headerlink" title="9. 动态变量"></a>9. 动态变量</h3><ul>
<li><p>申请</p>
<ul>
<li>new</li>
</ul>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622011214723.png" alt="image-20220622011214723" style="zoom:80%;" />

<ul>
<li>new vs malloc<ul>
<li>强制类型转换、构造函数</li>
</ul>
</li>
</ul>
</li>
<li><p>归还</p>
<ul>
<li>delete</li>
<li>delete[]</li>
</ul>
</li>
</ul>
<h3 id="10-函数指针、泛型"><a href="#10-函数指针、泛型" class="headerlink" title="10. 函数指针、泛型"></a>10. 函数指针、泛型</h3><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622183805313.png" alt="image-20220622183805313" style="zoom:80%;" />

<h3 id="11-引用"><a href="#11-引用" class="headerlink" title="11. 引用"></a>11. 引用</h3><ul>
<li>定义：<strong>为一块已有的内存空间取一个别名</strong><ul>
<li>引用变量和被引用变量，必须是同类型</li>
<li>引用变量定义中的&amp;不是取地址操作符</li>
<li>定义引用变量时，<strong>必须初始化</strong></li>
</ul>
</li>
<li>应用<ul>
<li>函数参数传递</li>
<li>动态变量命名</li>
</ul>
</li>
<li>函数返回值类型为引用<ul>
<li>注：<strong>不能返回局部变量的引用</strong></li>
</ul>
</li>
</ul>
<h2 id="面向对象部分"><a href="#面向对象部分" class="headerlink" title="面向对象部分"></a>面向对象部分</h2><h3 id="1-OOP"><a href="#1-OOP" class="headerlink" title="1. OOP"></a>1. OOP</h3><ul>
<li>Cfront编译之后（C++ –&gt; C）还是变成和c一样的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>  --&gt;  <span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack * <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> i)</span></span><br></code></pre></td></tr></table></figure>

<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h3><ul>
<li><strong>类的定义和声明是分开的，类声明的头文件仅仅给出接口部分</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类的声明 a.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TDate</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d)</span></span>;<br>    	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsLeapYear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-type">int</span> year,month,day;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类的定义 a.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TDate::SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    year = y;<br>    month = m;<br>    day = d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TDate::IsLeapYear</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (year%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year%<span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>定义在类内部的函数是隐式的<strong>inline</strong>函数</li>
</ul>
<h4 id="2-1-声明方法"><a href="#2-1-声明方法" class="headerlink" title="2.1 声明方法"></a>2.1 声明方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">TDate g; <span class="hljs-comment">//保存在全局静态区，已经初始化好，g不是引用就是一个对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    g.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <br>    TDate t;<span class="hljs-comment">//保存在栈</span><br>    t.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">11</span>, <span class="hljs-number">17</span>);<br>    <br>    TDate *p = <span class="hljs-keyword">new</span> TDate;<span class="hljs-comment">//保存在堆</span><br>    p-&gt;<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">11</span>, <span class="hljs-number">17</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-构造函数"><a href="#2-2-构造函数" class="headerlink" title="2.2 构造函数"></a>2.2 构造函数</h4><ul>
<li><p>功能</p>
<ul>
<li>给创建的对象建立标识符</li>
<li>为数据成员开辟内存空间</li>
<li>根据规定进行初始化</li>
</ul>
</li>
<li><p>默认构造函数不会对成员变量初始化</p>
<ul>
<li>c++11规定，对于未指定默认初始化的堆、栈中的变量，是一个不确定的值，不会进行初始化。而全局变量，静态变量会被初始化为0</li>
</ul>
</li>
<li><p>对象的<strong>初始化</strong>，构造函数可以被定义，也可以只声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br>      <span class="hljs-built_in">Line</span>();  <span class="hljs-comment">// 这是构造函数</span><br> <br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;<br>&#125;;<br> <br><span class="hljs-comment">// 成员函数定义，包括构造函数</span><br>Line::<span class="hljs-built_in">Line</span>(<span class="hljs-type">void</span>)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Line::setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span><br><span class="hljs-function"></span>&#123;<br>    length = len;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Line::getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br><span class="hljs-comment">// 程序的主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>   Line line;<br>   <span class="hljs-comment">// 设置长度</span><br>   line.<span class="hljs-built_in">setLength</span>(<span class="hljs-number">6.0</span>); <br>   cout &lt;&lt; <span class="hljs-string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="hljs-built_in">getLength</span>() &lt;&lt;endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br><span class="hljs-comment">//Object is being create</span><br><span class="hljs-comment">//6.0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>描述</p>
<ul>
<li><p>与类同名，<strong>无返回类型</strong>，构造函数可以<strong>有参数</strong>，初始化要带参数，比如上面的Line类的构造函数可以改为Line(double  len)，构造函数的定义改为将length初始化为len</p>
</li>
<li><p>自动调用，不可以直接调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">A</span>();<br>    	<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i);<br>    	<span class="hljs-built_in">A</span>(<span class="hljs-type">char</span> *p);<br>&#125;;<br>A a1 = <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//等价于A a1(a) //等价于A a1=1;	自动调用A(int i);</span><br>A a2 = <span class="hljs-built_in">A</span>();<span class="hljs-comment">//等价于A a2;	调用A(),不能写成A a2();</span><br>A a3 = <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<span class="hljs-comment">//等价于A a3(&quot;abcd&quot;) //等价于 A a3 = &quot;abcd&quot;	调用A (char *p)</span><br>A a[<span class="hljs-number">4</span>];<span class="hljs-comment">//调用a[0],a[1],a[2],a[3]的A()</span><br>A b[<span class="hljs-number">5</span>] = &#123;<span class="hljs-built_in">A</span>(), <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>), <span class="hljs-number">2</span>, <span class="hljs-string">&quot;xyz&quot;</span> &#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可重载</p>
</li>
<li><p>当类中没有提供构造函数时，编译系统自动提供</p>
</li>
<li><p>一般声明为public，但也可以定义为private</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-成员初始化表"><a href="#2-3-成员初始化表" class="headerlink" title="2.3 成员初始化表"></a>2.3 成员初始化表</h4><ul>
<li><p>构造函数的补充</p>
</li>
<li><p>先于构造体函数执行，<strong>按类数据成员声明次序</strong>，减轻compiler的负担</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span>    x;<br>    <span class="hljs-type">const</span>  <span class="hljs-type">int</span>   y;<br>    <span class="hljs-type">int</span>&amp; z;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">A</span>(): <span class="hljs-built_in">y</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">z</span>(x), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>)  &#123;  x = <span class="hljs-number">100</span>; &#125; <span class="hljs-comment">//按照xyz顺序初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li>构造函数中尽量使用成员初始化表代替赋值动作</li>
<li>数据成员太多时，不要使用，降低了可维护性</li>
</ul>
</li>
<li><p>c++98只有static const成员可以在类内部直接初始化<br>c++11允许非静态成员在声明处初始化</p>
</li>
</ul>
<h4 id="2-4-析构函数"><a href="#2-4-析构函数" class="headerlink" title="2.4 析构函数"></a>2.4 析构函数</h4><ul>
<li><p>结构：~类名()</p>
</li>
<li><p>对象消亡时，系统自动调用，释放对象持有的非内存资源</p>
</li>
<li><p>一般声明在public中，也可以声明在private中</p>
</li>
<li><p>没有返回值，不接受参数（不能重载）</p>
</li>
<li><p>声明为private：不能在栈上创建对象，只能通过new在堆上创建对象，通过实现一个public的方法来调用析构函数进行释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">A</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>更好的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(A *p)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br>A::<span class="hljs-built_in">free</span>(P);<br></code></pre></td></tr></table></figure>

<p>优点：可以强制自主控制对象存储分配</p>
</li>
<li><p>静态绑定，避免内存泄漏，基类析构函数需要声明为virtual</p>
</li>
</ul>
<h4 id="2-5-拷贝构造函数"><a href="#2-5-拷贝构造函数" class="headerlink" title="2.5 拷贝构造函数"></a>2.5 拷贝构造函数</h4><ul>
<li><p>创建对象时，用一同类的对象对其初始化</p>
</li>
<li><p>自动调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明</span><br>A a;<br>A b = a; <span class="hljs-comment">//等价于A b(a);</span><br><span class="hljs-comment">//传参</span><br><span class="hljs-built_in">f</span>(A a) &#123;...&#125;<br>A b;<br><span class="hljs-built_in">f</span>(b);<br><span class="hljs-comment">//返回值</span><br><span class="hljs-function">A <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    ...<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>声明</p>
<p>  public:<br>  A(const A&amp; a); &#x2F;&#x2F;为什么要写引用: 如果不写，传参本身就要调用拷贝构造</p>
</li>
<li><p>默认拷贝构造函数执行的是浅拷贝，一旦对象存在了动态成员，浅拷贝会出问题。此时要使用深拷贝</p>
</li>
<li><p>参考网址： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8459250.html">https://www.cnblogs.com/alantu2018/p/8459250.html</a> </p>
</li>
<li><p>例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-type">char</span> *p;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">string</span>(<span class="hljs-type">char</span> *str)&#123;<br>            p=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,str);<br>        &#125;<br>    	~<span class="hljs-built_in">string</span>()&#123;<br>            <span class="hljs-keyword">delete</span>[] p;<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>    string s2=s1;<br>    <span class="hljs-comment">//浅拷贝：s2和s1这两个指针指向堆里的同一空间，再销毁对象时，两个对象的析构函数将同一个内存空间释放两次，这就是错误所在</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-type">char</span> *p;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">string</span>(<span class="hljs-type">char</span> *str)&#123;<br>            p=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,str);<br>        &#125;<br>    	<span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string &amp; c)&#123;<br>            p=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(c.p)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,c.p);<br>        &#125;<br>    	~<span class="hljs-built_in">string</span>()&#123;<br>            <span class="hljs-keyword">delete</span>[] p;<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>    string s2=s1;<br>    <span class="hljs-comment">//深拷贝：s1和s2各自指向一段内存空间，他们指向的空间具有相同的内容</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>包含成员对象的类</strong></p>
<ul>
<li>调用默认拷贝构造函数<ul>
<li>调用成员对象的<strong>拷贝构造函数</strong></li>
</ul>
</li>
<li>自定义拷贝构造函数<ul>
<li>调用成员对象的<strong>默认构造函数</strong></li>
<li>避免上面情况可以使用类似<strong>成员初始化表</strong>方式显式调用构造函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-6-拷贝赋值函数"><a href="#2-6-拷贝赋值函数" class="headerlink" title="2.6 拷贝赋值函数"></a>2.6 拷贝赋值函数</h4><ul>
<li><p>类似拷贝构造</p>
</li>
<li><p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp; other_a) &#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-移动构造函数"><a href="#2-7-移动构造函数" class="headerlink" title="2.7 移动构造函数"></a>2.7 移动构造函数</h4><ul>
<li><p>引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp; y = x;<br><span class="hljs-comment">//int &amp; y = 5; 不允许，只能使用const引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; z = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; z = x;<br></code></pre></td></tr></table></figure>
</li>
<li><p>右值引用（A&amp;&amp;）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int &amp;&amp; a = num;不允许，右值引用不能初始化为左值</span><br><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<span class="hljs-comment">//可以进行修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">10</span>;<span class="hljs-comment">//编译器不会报错，支持定义常量右值引用</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string::<span class="hljs-built_in">string</span> (string &amp;&amp; s) : <span class="hljs-built_in">p</span>(s.p) &#123;<br>    s.p = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">generate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>&#125;<br><span class="hljs-comment">//string s = generate();</span><br>string &amp;&amp; s = <span class="hljs-built_in">generate</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>编译器会合成默认的移动构造函数，<strong>前提</strong>：</p>
<ul>
<li>没有自定义<strong>拷贝构造函数</strong>，<strong>拷贝赋值函数</strong><ul>
<li>移动构造目的是为了降低拷贝代价</li>
<li>定义了拷贝构造说明有一种特定的拷贝行为，移动也会有一种特定行为</li>
</ul>
</li>
<li>没有自定义<strong>析构函数</strong><ul>
<li>对申请的资源进行释放，自定义说明申请了额外的资源</li>
<li>对于这部分资源编译器不知道如何拷贝，移动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-8-移动赋值函数"><a href="#2-8-移动赋值函数" class="headerlink" title="2.8 移动赋值函数"></a>2.8 移动赋值函数</h4><ul>
<li><p>类似移动构造</p>
</li>
<li><p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A &amp;<span class="hljs-keyword">operator</span>=(A &amp;&amp; a);<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-9-拷贝构造和移动构造举例"><a href="#2-9-拷贝构造和移动构造举例" class="headerlink" title="2.9 拷贝构造和移动构造举例"></a>2.9 拷贝构造和移动构造举例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">http:<span class="hljs-comment">//c.biancheng.net/view/7847.html</span><br></code></pre></td></tr></table></figure>

<h3 id="3-动态内存"><a href="#3-动态内存" class="headerlink" title="3. 动态内存"></a>3. 动态内存</h3><h4 id="3-1-动态对象"><a href="#3-1-动态对象" class="headerlink" title="3.1 动态对象"></a>3.1 动态对象</h4><ul>
<li><p>在heap（堆）中创建</p>
</li>
<li><p>new&#x2F;delete</p>
<ul>
<li><strong>使用new和delete可以自动调用constructor和destructor</strong></li>
</ul>
</li>
<li><p>new可重载</p>
</li>
<li><p>malloc和free不调用构造函数和析构函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A *p,*q;<br>p = <span class="hljs-keyword">new</span> A;     <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 在程序的heap中申请一块大小为sizeof(A)的内存</span><br><span class="hljs-comment">2. 调用A的默认构造函数对该空间上的对象初始化</span><br><span class="hljs-comment">3. 返回创建的对象的地址并赋值给p</span><br><span class="hljs-comment">*/</span><br><br>q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);   <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. ……	</span><br><span class="hljs-comment">2. 调用A的另一个构造函数 A::A(int)</span><br><span class="hljs-comment">3. ……</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">delete</span>  p; 	<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 调用p所指向的对象的析构函数</span><br><span class="hljs-comment">2. 释放对象空间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">delete</span> q;	<br></code></pre></td></tr></table></figure>

<ul>
<li>对象删除</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> intPtr;<br>intPtr = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>

<h4 id="3-2-动态对象数组"><a href="#3-2-动态对象数组" class="headerlink" title="3.2 动态对象数组"></a>3.2 动态对象数组</h4><ul>
<li><p>创建与撤销</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A *p;<br>p = <span class="hljs-keyword">new</span> A[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">delete</span> []p;<br><br><span class="hljs-type">int</span> *q;<br>q = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">delete</span> q;<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li><p><strong>不能显式初始化，相应的类必须有默认构造函数</strong></p>
<ul>
<li><p>c++11引入统一初始化表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123;&#125;<br>&#125;;<br>A * p = <span class="hljs-keyword">new</span> A[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>delete中的**[]**不能省</p>
<ul>
<li>自定义对象数组前4个字节用来存储数组长度，因为要调用析构函数</li>
<li>普通类型因为不调用析构函数，不用存储，可以直接delete，也可以delete[]</li>
</ul>
</li>
</ul>
</li>
<li><p>动态2D数组</p>
<ul>
<li><p>普通申请方式会有指针的额外内存开销</p>
</li>
<li><p>可以使用一维数组申请，然后进行换算（<strong>通过下标操作符的重载</strong>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">12</span>];<br>a[i][j]  --&gt;  a[i * <span class="hljs-number">4</span> + j]<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="4-特殊成员"><a href="#4-特殊成员" class="headerlink" title="4. 特殊成员"></a>4. 特殊成员</h3><h4 id="4-1-Const成员"><a href="#4-1-Const成员" class="headerlink" title="4.1 Const成员"></a>4.1 Const成员</h4><ul>
<li><p>const成员变量</p>
<ul>
<li>初始化必须放在构造函数的<strong>成员初始化表</strong>中进行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    	<span class="hljs-type">const</span> <span class="hljs-type">int</span> x;<br>    	<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> y = <span class="hljs-number">100</span>;<span class="hljs-comment">//static const必须在声明的地方初始化</span><br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> c): <span class="hljs-built_in">x</span>(c) &#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>const成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//a.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123; <br>        <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//a.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  x = <span class="hljs-number">1</span>; y = <span class="hljs-number">1</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;  cout &lt;&lt;x &lt;&lt; y;&#125;<br><br><span class="hljs-comment">//b.cpp</span><br><span class="hljs-function"><span class="hljs-type">const</span> A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">//a.f(); 不允许</span><br>a.<span class="hljs-built_in">show</span>();<br></code></pre></td></tr></table></figure>

<ul>
<li><p>如果把f()也标记为const，如何分辨呢</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">( A * <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">const</span> A* <span class="hljs-type">const</span> <span class="hljs-keyword">this</span>)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>引用指向的值可以更改，因为引用本身没有改变</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> &amp; indirect_int;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>():<span class="hljs-built_in">indirect_int</span>(*<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)&#123; ... &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; <span class="hljs-keyword">delete</span> &amp;indirect_int; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; indirect_int++; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>mutable</strong>关键字</p>
<ul>
<li>可以在const成员函数中修改被mutable修饰的变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-静态成员"><a href="#4-2-静态成员" class="headerlink" title="4.2 静态成员"></a>4.2 静态成员</h4><ul>
<li><p>静态成员变量</p>
<ul>
<li>类对象所共享</li>
<li>唯一拷贝</li>
<li>遵循类访问控制</li>
<li>不随对象创建而分配内存，也不随对象销毁而销毁，保存在全局静态区，程序结束才释放内存</li>
</ul>
</li>
<li><p>静态成员变量必须在类声明的<strong>外部初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>  	<span class="hljs-type">int</span> x, y;<br>  	<span class="hljs-type">static</span> <span class="hljs-type">int</span> shared;<br>&#125;;<br><span class="hljs-type">int</span> A::shared = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>静态成员函数</p>
<ul>
<li>静态成员函数只能访问<strong>静态成员</strong>（变量，函数）</li>
<li>遵循类访问控制</li>
<li>静态成员函数与普通成员函数的根本区别在于<ul>
<li>普通成员函数有 <strong>this 指针</strong>，可以<strong>访问类中的任意成员</strong></li>
<li>而静态成员函数<strong>没有 this 指针</strong>，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>
</ul>
</li>
</ul>
</li>
<li><p>静态成员的使用</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A a;<br>a.<span class="hljs-built_in">f</span>();<span class="hljs-comment">//通过对象使用</span><br>    <br>A::<span class="hljs-built_in">f</span>();<span class="hljs-comment">//通过类使用</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>静态成员函数常用于：控制对象创建</p>
<ul>
<li>eg：单例模式</li>
</ul>
</li>
</ul>
<h4 id="4-3-友元"><a href="#4-3-友元" class="headerlink" title="4.3 友元"></a>4.3 友元</h4><ul>
<li><p>类外部不能访问该类的private成员</p>
<ul>
<li>通过public方法<ul>
<li>会降低对private成员的访问效率，缺乏灵活性</li>
</ul>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元类成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//友元函数,可以不提前声明</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;         <span class="hljs-comment">//友元类</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">C::f</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//友元类成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>特性</p>
<ul>
<li><p>友元不具有传递性</p>
<ul>
<li><pre><code class="c++">class Matrix&#123;
    friend void multiply(Matrix &amp;m, Vector &amp;v, Vector &amp;r);
&#125;;
class Vector&#123;
    friend void multiply(Matrix &amp;m, Vector &amp;v, Vector &amp;r);
&#125;;
//定义在两个类中的友元是单独针对Matrix或者Vector类的，两个不互通
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- 上述代码不能编译通过，需要进行**前置声明**<br><br>  ```c++<br>  class Vector;<br>  void multiply(Matrix &amp;m, Vector &amp;v, Vector &amp;r);<br>  ...<br>  //函数必须使用引用，因为通过第一行不知道Vector有多大，如果不使用引用需要使用拷贝，所以会出错，而引用的大小是一致的<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>C++11之后可以访问private成员</p>
</li>
<li><p>重点：<strong>先声明后使用</strong></p>
</li>
</ul>
</li>
<li><p>原则</p>
<ul>
<li><p>避免将数据成员放在公开接口中</p>
</li>
<li><p>努力将接口完满且最小化</p>
</li>
<li><pre><code class="c++">class AccessLevels &#123;
public:
   int getReadOnly const &#123; return readOnly; &#125;
   void setReadWrite(int value) &#123; readWrite = value; &#125;
   int getReadWrite() &#123; return readWrite; &#125;
   void setWriteOnly(int value) &#123; writeOnly = value; &#125;
private:
   int noAccess;
   int readOnly;
   int readWrite;
   int writeOnly;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- 作用<br><br>  - 提高程序设计的灵活性<br>  - 数据保护和对数据的存取效率之间的一个折中方案<br><br>### 5. 继承<br><br>- 继承机制<br>  - 基于目标代码的复用<br>  - 对事物进行分类<br>  - 增量开发<br><br>#### 5.1 单继承<br><br>- 单继承<br><br>  - protected<br><br>    - 派生类的**成员函数**可以访问基类的保护成员<br>    - 派生类/基类的**对象**都不能访问保护成员，在对象中相当于private<br><br>  - 子类无法继承父类的构造函数，友元函数，析构函数<br><br>  - ```c++<br>    class Student&#123;       <br>      int id; <br>      public:<br>        char nickname[16];<br>        void set_ID(int x)  &#123; id = x; &#125;<br>        void SetNickName(char* s) &#123; strcpy(nickname,s);&#125; <br>        virtual void showInfo() <br>        &#123; cout &lt;&lt; nickname &lt;&lt; &quot;:&quot; &lt;&lt; id &lt;&lt;endl; &#125;<br>      	//virtual使得函数可以被动态重载<br>    &#125;;<br>    //父类的变量子类同样拥有，可以通过sizeof验证<br>    //子类中父类已经定义元素的访问权限与父类相同<br>    class Undergraduated_Student : public Student&#123;      <br>      int dept_no; <br>      public:<br>      	void setDeptNo(int x) &#123; dept_np = x; &#125;<br>      	void set_ID(int x)&#123;<br>          //函数重定义（静态的，并非动态）,但不是同一个名空间<br>        &#125;<br>      	void showInfo()&#123;<br>          cout &lt;&lt; dept_no &lt;&lt; &quot;:&quot; &lt;&lt; nickname &lt;&lt; &quot;:&quot; &lt;&lt; id &lt;&lt;endl; <br>        &#125;<br>      private:<br>        using Student::nickname; //Undergraduated_Student的派生类不能再访问nickname，由于权限变成private<br>      	void SetNickName(); <br>      	//编译器：1.找名字（可以调用则调用，否则不调用）；2.在子类中找到了SetNickName的名空间，就不会去父类找（名空间覆盖）；3.子类SetNickName名空间没有匹配char* s的函数，因此调用失败<br>    &#125;;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>友元和protected</p>
<ul>
<li>友元不具有传递性</li>
<li>派生类可以访问<strong>基类</strong>的保护成员，但不能访问<strong>基类对象</strong>的保护成员</li>
</ul>
</li>
<li><p>基类构造函数的调用</p>
<ul>
<li><p>缺省执行基类默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;    <br>  <span class="hljs-type">int</span> x;<br>  <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>() &#123; x = <span class="hljs-number">0</span>; &#125;<br>     <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;   <br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">B</span>() &#123; y = <span class="hljs-number">0</span>; &#125;<br>   <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i) &#123; y = i; &#125;<br>   <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j):<span class="hljs-built_in">A</span>(i) <br>   &#123;   y = j;  &#125;<br>&#125;;<br><br>B b1; 	    <span class="hljs-comment">//执行A::A()和B::B()</span><br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; 	   <span class="hljs-comment">//执行A::A()和B::B(int)</span><br><span class="hljs-function">B <span class="hljs-title">b3</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//执行A::A(int)和B::B(int,int)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>没有指明基类如何拷贝且自定义派生类的拷贝构造函数，则会执行基类的默认构造函数<br>如何指明调用基类拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> B &amp; b) : <span class="hljs-built_in">A</span>(b) &#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>构造函数不能继承</p>
<ul>
<li><p>但如果派生类成员很少，基类很多会很麻烦<br>解决方法（语法糖）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-keyword">using</span> A::A <span class="hljs-comment">//继承A的构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>构造函数执行次序</p>
<ul>
<li>基类的构造函数</li>
<li>派生类对象成员类的构造函数</li>
<li>派生类的构造函数</li>
</ul>
</li>
</ul>
<h4 id="5-2-虚函数"><a href="#5-2-虚函数" class="headerlink" title="5.2 虚函数"></a>5.2 虚函数</h4><ul>
<li><p>类型相容</p>
<ul>
<li><p>对象切片</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>a = b;<br></code></pre></td></tr></table></figure>

<p>b的占用空间会比a大，执行a&#x3D;b时会有信息丢失</p>
<p>实现上：调用拷贝赋值函数（A的），不包含B的信息</p>
</li>
</ul>
</li>
<li><p>前期绑定</p>
<ul>
<li>编译时刻</li>
<li>依据对象的静态类型</li>
<li>效率高、灵活性差</li>
</ul>
</li>
<li><p>动态绑定</p>
<ul>
<li>运行时刻</li>
<li>依据对象的实际类型</li>
<li>灵活性高、效率差</li>
</ul>
</li>
<li><p>限制</p>
<ul>
<li>类的成员函数才可以是虚函数</li>
<li>静态成员函数不能是虚函数</li>
<li>内联成员函数不能是虚函数</li>
<li>构造函数不能是虚函数</li>
<li>析构函数可以（往往）是虚函数</li>
</ul>
</li>
<li><p>后期绑定的实现</p>
<ul>
<li><p>虚函数表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">A a; B b;<br>A *p;<br>(**((<span class="hljs-type">char</span> *)p - <span class="hljs-number">4</span>))(p)<br><span class="hljs-comment">//函数调用 (p) -- 参数, this</span><br>(<span class="hljs-type">char</span> *)p - <span class="hljs-number">4</span> : 指向虚函数表的指针<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//基类中声明即可</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>构造函数完成后才有虚函数表</strong>，因此完成前virtual不生效，调用构造函数所属类的函数</p>
</li>
<li><p><strong>final，override</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span> <span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span> <span class="hljs-params">()</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f5</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">final</span></span>;<br><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span>: B &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>;<span class="hljs-comment">//正确： f1与基类中的f1 匹配 </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span> </span>;<span class="hljs-comment">//错误： B没有形如f2(int) 的函数。int f2()？</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span> <span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>;<span class="hljs-comment">//错误： f3不是虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f4</span> <span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>;<span class="hljs-comment">//错误： B没有名为f4的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f5</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>;<span class="hljs-comment">//错误： B已经将f5声明成final</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>纯虚函数和抽象类</p>
<ul>
<li>纯虚函数<ul>
<li>声明时在函数原型后面加上**&#x3D;0**</li>
<li>往往只给出函数声明，不给出实现</li>
<li>虚函数表中留位置但没有地址，直到派生类重写</li>
</ul>
</li>
<li>抽象类<ul>
<li>至少包含一个纯虚函数</li>
<li>不能用于创建对象</li>
<li>为派生类提供框架</li>
</ul>
</li>
<li>应用：抽象工厂模式</li>
</ul>
</li>
<li><p>虚析构函数</p>
</li>
<li><p><strong>绝对不要重新定义继承而来的缺省参数值</strong></p>
<ul>
<li><strong>静态绑定</strong></li>
</ul>
</li>
<li><p>访问控制是静态绑定：</p>
<ul>
<li>即使派生类将父类的public方法改为private，通过父类指针或引用依然可以调用</li>
</ul>
</li>
</ul>
<h4 id="5-3-多继承"><a href="#5-3-多继承" class="headerlink" title="5.3 多继承"></a>5.3 多继承</h4><ul>
<li><p>基类的声明次序决定</p>
<ul>
<li>对基类构造函数&#x2F;析构函数的调用次序</li>
<li>对基类数据成员的存储安排</li>
</ul>
</li>
<li><p>名冲突</p>
<ul>
<li>&lt;基类名&gt;::&lt;基类成员名&gt;</li>
</ul>
</li>
<li><p><strong>虚继承、虚基类</strong></p>
<ul>
<li><p>问题：如果直接基类有公共的基类，则该公共基类中的成员变量再多继承的派生类中有多个副本</p>
</li>
<li><p>解决：虚继承</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> A;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: B, C;<br></code></pre></td></tr></table></figure>

<ul>
<li>实现：创建虚基类，虚继承的派生类持有虚基类的指针</li>
</ul>
</li>
<li><p>虚基类的构造函数由最新派生出的类的构造函数调用（D构造A）</p>
</li>
<li><p>虚基类的构造函数优先于非虚基类的构造函数执行</p>
</li>
</ul>
</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>一名多用：函数重载</li>
<li>类属：template</li>
<li>OO程序设计：虚函数</li>
</ul>
<h3 id="1-操作符重载"><a href="#1-操作符重载" class="headerlink" title="1. 操作符重载"></a>1. 操作符重载</h3><h4 id="1-1-一般操作符重载"><a href="#1-1-一般操作符重载" class="headerlink" title="1.1 一般操作符重载"></a>1.1 一般操作符重载</h4><ul>
<li><p>歧义控制：</p>
<ul>
<li>顺序</li>
<li>更好匹配（整型提升 eg. bool -&gt; int）</li>
</ul>
</li>
<li><p>不允许重载：</p>
<ul>
<li>.     .*    ::    ?:</li>
</ul>
</li>
<li><p>成员函数默认第一个参数为this</p>
</li>
<li><p>全局函数作为补充</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//成员函数支持obj + 10,不支持10 + obj</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CL</span>&#123;<br>    <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">friend</span> CL operater+(<span class="hljs-type">int</span> i, CL&amp; a);    <br>    <span class="hljs-keyword">friend</span> CL operater+(CL&amp; a, <span class="hljs-type">int</span> i);    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>永远不要重载&amp;&amp;和||</p>
<ul>
<li><p>利用了短路机制，如果重载则两个表达式都会被计算，可能会出错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>((p != <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">strlen</span>(p) &gt; <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>有效率但不是过度有效率<br>一些例子：<br>+-*&#x2F;一般使用拷贝即可，不需要引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational &amp; <span class="hljs-keyword">operator</span> *(<span class="hljs-type">const</span> Rational &amp; r) <span class="hljs-type">const</span>;<br><br>- <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(n*r.n, d*r.d); <span class="hljs-comment">//有&amp;临时变量无法赋给引用，无&amp;时在返回处创建对象不会发生拷贝</span><br><br>- Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(n*r.n, d*r.d); <span class="hljs-comment">//连乘会有内存泄漏</span><br>  <span class="hljs-keyword">return</span> *result;<br><br>- <span class="hljs-type">static</span> Rational result; <span class="hljs-comment">//不能同时利用 eg. if((a*b) == (c*d))</span><br>  result.n = n*r.n;<br>  result.d = d*r.d;<br>  <span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure>
</li>
<li><p>++a与a++</p>
<ul>
<li><p>++a返回的是左值，可以继续调用函数</p>
</li>
<li><p>a++仅仅返回一个值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>&#123;<br>  <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Counter</span>() &#123;value = <span class="hljs-number">0</span>;&#125;<br>  Counter&amp; <span class="hljs-keyword">operator</span>++() &#123; <span class="hljs-comment">// ++a</span><br>      value++;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  Counter <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// a++  //dummy argument哑元参数</span><br>      Counter temp = *<span class="hljs-keyword">this</span>;<br>      value++;<br>      <span class="hljs-keyword">return</span> temp;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="1-2-特殊操作符重载"><a href="#1-2-特殊操作符重载" class="headerlink" title="1.2 特殊操作符重载"></a>1.2 特殊操作符重载</h4><h5 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2.1 &#x3D;"></a>1.2.1 &#x3D;</h5><ul>
<li><p>为了支持链式赋值，要返回同类型引用，即*this</p>
</li>
<li><p>返回类型是否要加const，不要加，否则：</p>
<ul>
<li>支持a&#x3D;b&#x3D;c</li>
<li>不支持(a&#x3D;b).f()</li>
</ul>
</li>
<li><p>A a &#x3D; b; 调用拷贝构造函数</p>
</li>
<li><p>A a，b；a&#x3D;b；调用&#x3D;操作符重载</p>
</li>
<li><p>赋值到一半失败了（例如分配内存时内存不够），且已经发生了更改</p>
<ul>
<li><p>先赋值后释放（还可以解决自我赋值问题）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> *pOrig = p;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[...];<br><span class="hljs-built_in">strcpy</span>(...);<br><span class="hljs-keyword">delete</span>[] pOrig;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1.2.2 []"></a>1.2.2 []</h5><ul>
<li><p>问题：对于 非常量 希望返回char &amp;（更改），对于 常量 希望返回const char（不更改，只显示）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> i); <span class="hljs-comment">//string * const this</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;  <span class="hljs-comment">//可以重载,const string * const this</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>多维数组</p>
<ul>
<li>使用wrapper</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array2D</span>&#123; <br>  <span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">Array1D</span>&#123;  <br>      <span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Array1D</span>(<span class="hljs-type">int</span> *p) &#123; <span class="hljs-keyword">this</span>-&gt;p = p; &#125;<br>		<span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123; <span class="hljs-keyword">return</span> p[index]; &#125;<br>		<span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> p[index]; &#125;<br>	  <span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> *p;<br>	&#125;;<br>    <br>	<span class="hljs-built_in">Array2D</span>(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2) &#123; p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n1*n2]; num1 = n1; num2 = n2; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Array2D</span>() &#123; <span class="hljs-keyword">delete</span> [] p; &#125;<br>    <br>	Array1D <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index) &#123; <span class="hljs-keyword">return</span> p+index*num2; &#125;<br>	<span class="hljs-type">const</span> Array1D <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> p+index*num2; &#125;<br>    <br>  <span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> *p;<br>	<span class="hljs-type">int</span> num1, num2;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="1-2-3"><a href="#1-2-3" class="headerlink" title="1.2.3 ()"></a>1.2.3 ()</h5><ul>
<li><p>函数调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br>Func f;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">2.4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) n / d;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>若A -&gt; B<ul>
<li>B中构造函数有B(A)，同时A中定义了operator B()，会出错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="1-2-4"><a href="#1-2-4" class="headerlink" title="1.2.4 -&gt;"></a>1.2.4 -&gt;</h5><ul>
<li><p>无法确定参数类型</p>
<ul>
<li>重载时按一元操作符重载描述，返回指针类型、其他定义了-&gt;重载的对象</li>
</ul>
</li>
<li><p>智能指针</p>
<ul>
<li>程序运行时可能有多个出口，内存管理比较困难，可以使用一个封装类封装要使用的指针，在栈上创建</li>
<li>局限性：堆上创建的资源也要符合compiler控制的生命周期</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPointer</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmartPointer</span>(T *p=<span class="hljs-number">0</span>) :<span class="hljs-built_in">ptr</span>(p) &#123;&#125;<br>    ~<span class="hljs-built_in">SmartPointer</span>() &#123;<span class="hljs-keyword">delete</span> ptr;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br>    T&amp; <span class="hljs-keyword">operator</span> *() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125; <br><span class="hljs-keyword">private</span>:<br>    T* ptr;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="1-2-5-new、delete"><a href="#1-2-5-new、delete" class="headerlink" title="1.2.5 new、delete"></a>1.2.5 new、delete</h5><ul>
<li><p>new的过程</p>
<ul>
<li>分配内存（只能重载这一步）</li>
<li>调用构造函数</li>
<li>返回对象指针</li>
</ul>
</li>
<li><p>delete的过程</p>
<ul>
<li>调用析构函数</li>
<li>确定指向分配空间的指针</li>
<li>释放内存（可重载）</li>
</ul>
</li>
<li><p>new、delete为静态成员，在对象创建之前，析构函数之后</p>
<ul>
<li>隐式静态，不需要显式声明（声明也没事）</li>
</ul>
</li>
<li><p>全局函数（所有内存分配）、成员函数（只对重载过的类有效，<strong>推荐</strong>）</p>
</li>
<li><p>可继承</p>
</li>
<li><p>new和new[]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> size, ...)</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[] (<span class="hljs-type">size_t</span> size, ...);<br><span class="hljs-comment">//这两个是不同的、如果没有重载new[]，创建数组时依然使用全局默认的</span><br><span class="hljs-comment">//系统自动计算对象大小,并传值给size</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>delete</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-comment">//p:被撤销对象的地址</span><br><span class="hljs-comment">//第二个参数是被撤销对象的大小,可有可无</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>用途：内存池</p>
</li>
</ul>
<h3 id="2-模板template"><a href="#2-模板template" class="headerlink" title="2. 模板template"></a>2. 模板template</h3><h4 id="2-1-模板"><a href="#2-1-模板" class="headerlink" title="2.1 模板"></a>2.1 模板</h4><ul>
<li><p>源代码复用机制</p>
<ul>
<li>编译时代码实例化（eg. 将T换为int），根据类型不同<strong>复制</strong>为很多个版本</li>
<li>已经有的版本直接调用即可</li>
</ul>
</li>
<li><p>实例化</p>
<ul>
<li><p>函数模板</p>
<ul>
<li>隐式实现</li>
<li>根据具体模板函数调用</li>
</ul>
</li>
<li><p>类模板</p>
<ul>
<li>创建对象时显式指定</li>
</ul>
</li>
</ul>
</li>
<li><p>模板的完整定义通常出现在头文件中</p>
</li>
</ul>
<h4 id="2-2-函数模板（类属函数）"><a href="#2-2-函数模板（类属函数）" class="headerlink" title="2.2 函数模板（类属函数）"></a>2.2 函数模板（类属函数）</h4><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622145754868.png" alt="image-20220622145754868" style="zoom:80%;" />

<ul>
<li><p>隐式实例化：编译器会自动推导类型</p>
</li>
<li><p>使用自定义类型时，函数重载和函数模板同时使用</p>
</li>
<li><p>函数模板的参数</p>
<ul>
<li><p>可带多个类型参数，用逗号分隔</p>
</li>
<li><p>可带普通参数</p>
<ul>
<li><p>必须列在类型参数之后</p>
</li>
<li><p>调用时需显式实例化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T, <span class="hljs-type">int</span> size&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    T temp[size];<br>&#125;<br><br><span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-number">10</span>&gt;(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>默认参数：</p>
<ul>
<li>顺序可以任意，最好从右向左（与类模板一致）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U </span>= <span class="hljs-type">double</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t = <span class="hljs-number">0</span>, U u = <span class="hljs-number">0</span>)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;t=&quot;</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;u=&quot;</span> &lt;&lt; u &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;a&#x27;</span>);			<span class="hljs-comment">//调用test&lt;int, char&gt;(4, &#x27;a&#x27;)</span><br>    <span class="hljs-built_in">test</span>(<span class="hljs-number">4</span>);				<span class="hljs-comment">//调用test&lt;int double&gt;(4, 0)</span><br>    <span class="hljs-built_in">test</span>(); 				<span class="hljs-comment">//编译失败，没有指明T的类型</span><br>    <span class="hljs-built_in">test</span>&lt;<span class="hljs-type">int</span>&gt;();			<span class="hljs-comment">//调用test&lt;int, double&gt;(0, 0)</span><br>    <span class="hljs-built_in">test</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;();		<span class="hljs-comment">//调用test&lt;int, char&gt;(0, 0)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数模板与函数重载配合使用</p>
<ul>
<li>函数重载优先于函数模板</li>
</ul>
</li>
</ul>
<h4 id="2-3-类属类"><a href="#2-3-类属类" class="headerlink" title="2.3 类属类"></a>2.3 类属类</h4><ul>
<li>类定义带有类型参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>需要显式实例化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Stack&lt;<span class="hljs-type">int</span>&gt; st1;<br>Stack&lt;<span class="hljs-type">double</span>&gt; st2;<br></code></pre></td></tr></table></figure>

<ul>
<li>类模板的静态成员属于实例化后的类</li>
</ul>
<h3 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h3><ul>
<li><p>异常特征</p>
<ul>
<li>可以预见</li>
<li>无法避免</li>
</ul>
</li>
<li><p>throw</p>
<ul>
<li>调用拷贝构造函数</li>
<li>可以抛出指针，但不能指向局部变量</li>
</ul>
</li>
<li><p>catch</p>
<ul>
<li>精确匹配</li>
<li>允许派生类到基类的转换</li>
<li>自定义类使用引用，避免拷贝</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Base &amp; e)</span> </span>&#123;<br>    <span class="hljs-comment">//调用拷贝构造函数，发生对象切片</span><br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived e;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-built_in">f</span>(e);<br>    &#125;<span class="hljs-built_in">catch</span>(Derived &amp; e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span>;<br>    &#125;<span class="hljs-built_in">catch</span>(Base &amp; e) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//输出Base</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>构造函数出现异常</p>
<ul>
<li><p>不能自己处理，要在try中new</p>
</li>
<li><p>初始化列表异常，不属于构造函数</p>
<ul>
<li><p>最好的方法，不在初始化列表new对象</p>
</li>
<li><pre><code class="c++">A()try&#123;:...&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- 析构函数出现异常<br><br>  - 内部处理即可<br>  <br>- 特例<br><br>  - 无参数throw<br>  <br>    - 将捕获到的异常对象重新抛出<br>  <br>      ```c++<br>      catch(int) &#123; throw; &#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>catch(…)</p>
<ul>
<li>默认异常处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="1-c-为我们默认添加了哪些函数"><a href="#1-c-为我们默认添加了哪些函数" class="headerlink" title="1. c++为我们默认添加了哪些函数"></a>1. c++为我们默认添加了哪些函数</h3>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123; <br>    <span class="hljs-built_in">Empty</span>();<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp;);<br>    ~<span class="hljs-built_in">Empty</span>();<br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp;);<br>    Empty *<span class="hljs-keyword">operator</span> &amp;();<span class="hljs-comment">//取地址操作符重载</span><br>    <span class="hljs-type">const</span> Empty *<span class="hljs-keyword">operator</span> &amp;() <span class="hljs-type">const</span>;<span class="hljs-comment">//常成员情况 const Empty e; 防止常成员通过指针被修改</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="2-c-没有finally"><a href="#2-c-没有finally" class="headerlink" title="2. c++没有finally"></a>2. c++没有finally</h3><ul>
<li>理念：RAII，资源应该能做到自清理</li>
<li>RAII：资源的获取过程就是对象的初始化过程</li>
<li>可以使用智能指针</li>
<li>将指针内容转移到另一个智能指针实现所有权转移</li>
</ul>
<h3 id="3-遇到不能虚化的函数，但需要虚化"><a href="#3-遇到不能虚化的函数，但需要虚化" class="headerlink" title="3. 遇到不能虚化的函数，但需要虚化"></a>3. 遇到不能虚化的函数，但需要虚化</h3><ul>
<li><p>非虚接口</p>
</li>
<li><p>先构造一个可以虚化的函数，然后将不能虚化的包装起来</p>
<ul>
<li><p>全局函数</p>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622153214208.png" alt="image-20220622153214208" style="zoom:80%;" />
</li>
<li><p>构造函数</p>
</li>
</ul>
</li>
</ul>
<img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220622153114909.png" alt="image-20220622153114909" style="zoom:80%;" />



<h3 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPointer</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmartPointer</span>(T *p=<span class="hljs-number">0</span>) :<span class="hljs-built_in">ptr</span>(p) &#123;&#125;<br>    ~<span class="hljs-built_in">SmartPointer</span>() &#123;<span class="hljs-keyword">delete</span> ptr;&#125;<br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr; &#125;<br>    T&amp; <span class="hljs-keyword">operator</span> *() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *ptr; &#125; <br><span class="hljs-keyword">private</span>:<br>    T* ptr;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-永远不要多态地对待数组"><a href="#5-永远不要多态地对待数组" class="headerlink" title="5. 永远不要多态地对待数组"></a>5. 永远不要多态地对待数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span> &#123; … &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BalancedBST</span>: <span class="hljs-keyword">public</span> BST &#123; … &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBSTArray</span><span class="hljs-params">(ostream&amp; s, <span class="hljs-type">const</span> BST array[], <span class="hljs-type">int</span> numElements)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; numElements; i++)  s &lt;&lt; array[i]; &#125;  <span class="hljs-comment">//有问题,遍历的时候子类和父类偏移的大小是不一致的</span><br><br>BalancedBST bBSTArray[<span class="hljs-number">10</span>];<br>…<br><span class="hljs-built_in">printBSTArray</span>(cout, bBSTArray, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>


      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-08-09 14:53:19
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/" title="NJU">
                        <b>#</b> NJU
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/NJU/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="C++高级程序设计">
                        <b>#</b> C++高级程序设计
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/08/01/SpringMVC/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%83%A8%E5%88%86"><span class="toc-text">结构化程序设计部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-C-%E5%8E%86%E5%8F%B2"><span class="toc-text">1. C++历史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%BC%94%E5%8C%96%E5%8E%86%E7%A8%8B"><span class="toc-text">1.1 演化历程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-text">1.2 设计理念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-C-%E4%B8%8E-C-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">1.3 C 与 C++ 的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-C%E5%92%8CC-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1.4 C和C++混合编程应该注意的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2. 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Data"><span class="toc-text">2.1 Data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.2 基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.3 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%AF%AD%E5%8F%A5"><span class="toc-text">2.4 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-switch%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96-%E8%A1%A8%E9%A9%B1%E5%8A%A8"><span class="toc-text">2.4.1 switch的实现与优化(表驱动)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-2-switch%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%88%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-text">2.4.2 switch的实现与优化（编译过程）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-%E5%A6%82%E6%9E%9Crange%E5%BE%88%E5%A4%A7"><span class="toc-text">2.4.3 如果range很大</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E8%A1%A8%E9%A9%B1%E5%8A%A8"><span class="toc-text">2.5 表驱动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0"><span class="toc-text">3. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-text">3.1 函数与内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-text">3.1.1 存储空间与内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-Runtime-Environment"><span class="toc-text">3.1.2 Runtime Environment</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">3.2 函数执行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-%E5%BB%BA%E7%AB%8B%E8%A2%AB%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="toc-text">3.2.1 建立被调用函数栈空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">3.2.2 参数传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-%E4%BF%9D%E5%AD%98%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81-%E9%A2%9D%E5%A4%96%E7%9A%84Cost"><span class="toc-text">3.2.3 保存调用函数的运行状态(额外的Cost)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-%E5%B0%86%E6%8E%A7%E5%88%B6%E8%BD%AC%E4%BA%A4%E7%BB%99%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">3.2.4 将控制转交给被调函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-5-Summary"><span class="toc-text">3.2.5 Summary</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-text">3.3 函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">3.4 函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">3.5 函数的默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0-extern"><span class="toc-text">3.6 外部函数 extern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-inline"><span class="toc-text">3.7 inline</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A8%8B%E5%BA%8F%E7%BB%84%E7%BB%87"><span class="toc-text">4 程序组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-static"><span class="toc-text">4.1 static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-namespace"><span class="toc-text">4.2 namespace</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84"><span class="toc-text">5. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">5.1 一维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Struct"><span class="toc-text">6. Struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">9. 动态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">10. 函数指针、泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%BC%95%E7%94%A8"><span class="toc-text">11. 引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%83%A8%E5%88%86"><span class="toc-text">面向对象部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-OOP"><span class="toc-text">1. OOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85"><span class="toc-text">2. 封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95"><span class="toc-text">2.1 声明方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.2 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8"><span class="toc-text">2.3 成员初始化表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">2.4 析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.5 拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-text">2.6 拷贝赋值函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.7 移动构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-text">2.8 移动赋值函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E4%B8%BE%E4%BE%8B"><span class="toc-text">2.9 拷贝构造和移动构造举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-text">3. 动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.1 动态对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-text">3.2 动态对象数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98"><span class="toc-text">4. 特殊成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Const%E6%88%90%E5%91%98"><span class="toc-text">4.1 Const成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">4.2 静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%8F%8B%E5%85%83"><span class="toc-text">4.3 友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">5.2 虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">5.3 多继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">1. 操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">1.1 一般操作符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">1.2 特殊操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1"><span class="toc-text">1.2.1 &#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2"><span class="toc-text">1.2.2 []</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3"><span class="toc-text">1.2.3 ()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4"><span class="toc-text">1.2.4 -&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-5-new%E3%80%81delete"><span class="toc-text">1.2.5 new、delete</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A8%A1%E6%9D%BFtemplate"><span class="toc-text">2. 模板template</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A8%A1%E6%9D%BF"><span class="toc-text">2.1 模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%88%E7%B1%BB%E5%B1%9E%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">2.2 函数模板（类属函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%B1%BB%E5%B1%9E%E7%B1%BB"><span class="toc-text">2.3 类属类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">3. 异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0"><span class="toc-text">复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-c-%E4%B8%BA%E6%88%91%E4%BB%AC%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-text">1. c++为我们默认添加了哪些函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-c-%E6%B2%A1%E6%9C%89finally"><span class="toc-text">2. c++没有finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%81%87%E5%88%B0%E4%B8%8D%E8%83%BD%E8%99%9A%E5%8C%96%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BD%86%E9%9C%80%E8%A6%81%E8%99%9A%E5%8C%96"><span class="toc-text">3. 遇到不能虚化的函数，但需要虚化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">4. 智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%A4%9A%E6%80%81%E5%9C%B0%E5%AF%B9%E5%BE%85%E6%95%B0%E7%BB%84"><span class="toc-text">5. 永远不要多态地对待数组</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + C%2B%2B%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1 + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2022%2F06%2F04%2Fcpp%25E9%25AB%2598%25E7%25BA%25A7%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2022/06/04/cpp%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
