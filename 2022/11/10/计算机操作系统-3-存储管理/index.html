<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="NJUSE OS课程笔记 第三章 存储管理">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机操作系统(3) 存储管理">
<meta property="og:url" content="https://whale-lyi.github.io/2022/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="NJUSE OS课程笔记 第三章 存储管理">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221024112034401.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221024120103491.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027141452301.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027143738934.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027143949652.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027144502096.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027144710152.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150255136.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150427931.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150540542.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027151008590.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027151836071.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027152126219.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153045763.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153115917.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153332243.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153402167.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154114015.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154312547.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154358621.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154436828.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154908427.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031104352984.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031104727130.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031105524974.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031111641724.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031111843806.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031112900090.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031112932254.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031113150739.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115319441.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115356690.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115610482.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115733235.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107145644332.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107115819595.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107115940791.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120307367.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120330137.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120528299.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150325303.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150517462.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150916487.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151309031.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151347710.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151402680.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151727699.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151742038.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152412373.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152637357.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152213784.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152747958.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152336480.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152935682.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152945691.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105149441.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105221507.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105351296.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105402628.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105453288.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107110729262.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107110812406.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107111844378.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112035238.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112234403.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112533727.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112722467.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107154512018.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107154528175.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160528527.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160611184.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160636982.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108015614001.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108015707685.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020047797.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020225281.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020242078.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020302415.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020317071.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020434064.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134658588.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134717530.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134738142.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134854425.png">
<meta property="article:published_time" content="2022-11-10T06:05:57.000Z">
<meta property="article:modified_time" content="2023-08-09T06:53:19.996Z">
<meta property="article:author" content="Whale">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221024112034401.png">

<link rel="canonical" href="https://whale-lyi.github.io/2022/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>计算机操作系统(3) 存储管理 | Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2022/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机操作系统(3) 存储管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-10 14:05:57" itemprop="dateCreated datePublished" datetime="2022-11-10T14:05:57+08:00">2022-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-09 14:53:19" itemprop="dateModified" datetime="2023-08-09T14:53:19+08:00">2023-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机操作系统</span></a>
                </span>
            </span>

          
            <div class="post-description">NJUSE OS课程笔记 第三章 存储管理</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第三章-存储管理"><a href="#第三章-存储管理" class="headerlink" title="第三章 存储管理"></a>第三章 存储管理</h1><h2 id="3-1-存储管理基础"><a href="#3-1-存储管理基础" class="headerlink" title="3.1 存储管理基础"></a>3.1 存储管理基础</h2><h3 id="3-1-1-存储管理的主要模式"><a href="#3-1-1-存储管理的主要模式" class="headerlink" title="3.1.1 存储管理的主要模式"></a>3.1.1 存储管理的主要模式</h3><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a><strong>逻辑地址</strong></h4><ul>
<li><strong>逻辑地址</strong>：又称相对地址，即用户编程所使用的地址空间</li>
<li>逻辑地址从0开始编号，有两种形式<ul>
<li>一维逻辑地址(地址)</li>
<li>二维逻辑地址(段号:段内地址)</li>
</ul>
</li>
</ul>
<h4 id="段式程序设计"><a href="#段式程序设计" class="headerlink" title="段式程序设计"></a><strong>段式程序设计</strong></h4><ul>
<li>把一个程序设计成多个段<ul>
<li>代码段、数据段、堆栈段、等等</li>
</ul>
</li>
<li>用户可以自己应用<strong>段覆盖技术</strong>扩充内存空间使用量<ul>
<li>段覆盖技术：用户在程序设计时包括主程序段、堆栈段、多个子程序段和数据段，而执行程序时只调入主程序段、堆栈段与需要的子程序段和数据段，并<strong>根据执行的需要</strong>，由程序设计者预先设计的代码<strong>动态决定哪些段调入内存</strong></li>
<li>这一技术是程序设计技术，不是OS存储管理的功能</li>
</ul>
</li>
</ul>
<h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a><strong>物理地址</strong></h4><ul>
<li><strong>物理地址</strong>：又称绝对地址，即程序执行所使用的地址空间</li>
<li>处理器执行指令时按照物理地址进行</li>
</ul>
<h4 id="主存储器的复用"><a href="#主存储器的复用" class="headerlink" title="主存储器的复用"></a><strong>主存储器的复用</strong></h4><ul>
<li>多道程序设计需要复用主存</li>
<li>按照分区复用：<ul>
<li>主存划分为多个固定/可变尺寸的分区</li>
<li>一个程序/程序段占用一个分区</li>
</ul>
</li>
<li>按照页架(页框)复用：<ul>
<li>主存划分成多个固定大小的页架</li>
<li>一个程序/程序段占用多个页架</li>
</ul>
</li>
</ul>
<h4 id="存储管理的基本模式"><a href="#存储管理的基本模式" class="headerlink" title="存储管理的基本模式"></a><strong>存储管理的基本模式</strong></h4><ul>
<li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定分区或可变分区</li>
<li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li>
<li>页式存储管理：一维逻辑地址空间的程序占用多个主存页架区</li>
<li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区</li>
</ul>
<h4 id="存储管理模式示意图"><a href="#存储管理模式示意图" class="headerlink" title="存储管理模式示意图"></a><strong>存储管理模式示意图</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221024112034401.png" alt="image-20221024112034401" style="zoom:80%;" /></p>
<h3 id="3-1-2-存储管理的功能"><a href="#3-1-2-存储管理的功能" class="headerlink" title="3.1.2 存储管理的功能"></a>3.1.2 存储管理的功能</h3><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a><strong>地址转换</strong></h4><ul>
<li><strong>地址转换</strong>：又称重定位，即把逻辑地址转换成绝对地址</li>
<li><p><strong>静态重定位</strong>：在程序装入内存时进行地址转换</p>
<ul>
<li>由装入程序执行，早期小型OS使用</li>
</ul>
</li>
<li><p><strong>动态重定位</strong>：在CPU执行程序时进行地址转换</p>
<ul>
<li>从效率出发，依赖硬件地址转换机构</li>
</ul>
</li>
</ul>
<h4 id="主存储器空间的分配与去配"><a href="#主存储器空间的分配与去配" class="headerlink" title="主存储器空间的分配与去配"></a><strong>主存储器空间的分配与去配</strong></h4><ul>
<li><strong>分配</strong>：进程装入主存时，存储管理软件进行具体的主存分配操作，并设置一个表格记录主存空间的分配情况</li>
<li><strong>去配</strong>：当某个进程撤离或主动归还主存资源时，存储管理软件要收回它所占用的全部或者部分存储空间，调整主存分配表信息</li>
</ul>
<h4 id="主存储器空间的共享"><a href="#主存储器空间的共享" class="headerlink" title="主存储器空间的共享"></a><strong>主存储器空间的共享</strong></h4><ul>
<li><strong>多个进程共享主存储器资源</strong>：多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器</li>
<li><strong>多个进程共享主存储器的某些区域</strong>：若干个协作进程有共同的主存程序块或者主存数据块</li>
</ul>
<h4 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a><strong>存储保护</strong></h4><ul>
<li>为<strong>避免</strong>主存中的多个进程<strong>相互干扰</strong>，必须<strong>对主存中的程序和数据进行保护</strong><ul>
<li>私有主存区中的信息：可读可写</li>
<li>公共区中的共享信息：根据授权</li>
<li>非本进程信息：不可读写</li>
</ul>
</li>
<li>这一功能需要软硬件协同完成<ul>
<li>CPU检查是否允许访问，不允许则<strong>产生地址保护异常</strong>，由OS进行相应处理</li>
</ul>
</li>
</ul>
<h4 id="主存储器空间的扩充"><a href="#主存储器空间的扩充" class="headerlink" title="主存储器空间的扩充"></a><strong>主存储器空间的扩充</strong></h4><ul>
<li><strong>主存扩充</strong>：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存<ol>
<li>对换技术：把部分不运行的进程调出</li>
<li>虚拟技术：只调入进程的部分内容</li>
</ol>
</li>
<li>这一工作需要软硬件协作完成<ol>
<li>对换进程决定对换，硬件机构调入</li>
<li>CPU处理到不在主存的地址，发出<strong>虚拟地址异常</strong>，OS将其调入，重执指令</li>
</ol>
</li>
</ul>
<h3 id="3-1-3-虚拟存储器的概念"><a href="#3-1-3-虚拟存储器的概念" class="headerlink" title="3.1.3 虚拟存储器的概念"></a>3.1.3 虚拟存储器的概念</h3><h4 id="虚拟存储器思想的提出"><a href="#虚拟存储器思想的提出" class="headerlink" title="虚拟存储器思想的提出"></a><strong>虚拟存储器思想的提出</strong></h4><ul>
<li>主存容量限制带来诸多不便<ul>
<li>用户编写程序必须考虑主存容量限制</li>
<li>多道程序设计的道数受到限制</li>
</ul>
</li>
<li>用户编程行为分析<ul>
<li>全面考虑各种情况，执行时有互斥性</li>
<li>顺序性和循环性等空间局部性行为</li>
<li>某一阶段执行的时间局部性行为</li>
</ul>
</li>
<li>因此可以考虑部分调入进程内容</li>
</ul>
<h4 id="虚拟存储器的基本思想"><a href="#虚拟存储器的基本思想" class="headerlink" title="虚拟存储器的基本思想"></a><strong>虚拟存储器的基本思想</strong></h4><ul>
<li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为<strong>随用随调入</strong></li>
<li>如主存中没有足够的空闲空间，存储管理需要根据执行行为把主存中暂时不用的信息<strong>调出</strong>到辅存上去</li>
</ul>
<h4 id="虚拟存储器的实现思路"><a href="#虚拟存储器的实现思路" class="headerlink" title="虚拟存储器的实现思路"></a><strong>虚拟存储器的实现思路</strong></h4><ul>
<li>需要建立与自动管理两个地址空间<ul>
<li>(辅存)虚拟地址空间：容纳进程装入</li>
<li>(主存)实际地址空间：承载进程执行</li>
</ul>
</li>
<li>对于用户，计算机系统具有一个容量大得多的主存空间，即<strong>虚拟存储器</strong></li>
<li>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能的程序设计</li>
</ul>
<h4 id="虚拟存储器示意"><a href="#虚拟存储器示意" class="headerlink" title="虚拟存储器示意"></a><strong>虚拟存储器示意</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221024120103491.png" alt="image-20221024120103491" style="zoom:80%;" /></p>
<h3 id="3-1-4-存储管理的硬件支撑"><a href="#3-1-4-存储管理的硬件支撑" class="headerlink" title="3.1.4 存储管理的硬件支撑"></a>3.1.4 存储管理的硬件支撑</h3><h4 id="存储器的组织层次"><a href="#存储器的组织层次" class="headerlink" title="存储器的组织层次"></a><strong>存储器的组织层次</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027141452301.png" alt="image-20221027141452301" style="zoom:80%;" /></p>
<h4 id="存储管理涉及的存储对象"><a href="#存储管理涉及的存储对象" class="headerlink" title="存储管理涉及的存储对象"></a><strong>存储管理涉及的存储对象</strong></h4><ul>
<li>存储管理是OS管理主存储器的软件部分</li>
<li>为获得更好的处理性能，部分主存程序与数据（特别是关键性能数据）被调入Cache，存储管理需要对其进行管理，甚至包括对联想存储器的管理</li>
<li>为获得更大的虚拟地址空间，存储管理需要对存放在硬盘、固态硬盘、甚至网络硬盘上的虚拟存储器文件进行管理</li>
</ul>
<h4 id="高速缓存存储器-Cache"><a href="#高速缓存存储器-Cache" class="headerlink" title="高速缓存存储器(Cache)"></a><strong>高速缓存存储器(Cache)</strong></h4><ul>
<li>Cache是介于CPU和主存储器间的高速小容量存储器，由静态存储芯片SRAM组成，容量较小但比主存DRAM技术更加昂贵而快速，接近于CPU的速度</li>
<li>CPU往往需要重复读取同样的数据块，Cache的引入与缓存容量的增大，可以大幅提升CPU内部读取数据的命中率，从而提高系统性能</li>
</ul>
<h4 id="高速缓存存储器的构成"><a href="#高速缓存存储器的构成" class="headerlink" title="高速缓存存储器的构成"></a><strong>高速缓存存储器的构成</strong></h4><ul>
<li>高速缓存存储器通常由高速存储器、联想存储器、地址转换部件、替换逻辑等组成</li>
<li>联想存储器：根据内容进行寻址的存储器</li>
<li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换。命中时直接访问Cache；未命中时从内存中读取放入Cache</li>
<li>替换部件：在缓存已满时按一定策略进行数据块替换，并修改地址转换部件</li>
</ul>
<h4 id="高速缓存存储器的组织"><a href="#高速缓存存储器的组织" class="headerlink" title="高速缓存存储器的组织"></a><strong>高速缓存存储器的组织</strong></h4><ul>
<li>由于CPU芯片面积和成本，Cache很小</li>
<li>根据成本控制，划分为L1、L2、L3三级</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027143738934.png" alt="image-20221027143738934" style="zoom:80%;" /></p>
<h4 id="高速缓存存储器的分级"><a href="#高速缓存存储器的分级" class="headerlink" title="高速缓存存储器的分级"></a><strong>高速缓存存储器的分级</strong></h4><ul>
<li>L1 Cache：分为数据缓存和指令缓存；内置；其成本最高，对CPU的性能影响最大；通常在32KB-256KB之间</li>
<li>L2 Cache：分内置和外置两种，后者性能低一些；通常在512KB-8MB之间</li>
<li>L3 Cache：多为外置，在游戏和服务器领域有效；但对很多应用来说，<strong>总线改善</strong>比<strong>设置L3</strong>更加有利于提升系统性能</li>
</ul>
<h4 id="各类处理器架构"><a href="#各类处理器架构" class="headerlink" title="各类处理器架构"></a><strong>各类处理器架构</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027143949652.png" alt="image-20221027143949652" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027144502096.png" alt="image-20221027144502096" style="zoom:80%;" /></p>
<h4 id="地址转换-存储保护的硬件支撑"><a href="#地址转换-存储保护的硬件支撑" class="headerlink" title="地址转换/存储保护的硬件支撑"></a><strong>地址转换/存储保护的硬件支撑</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027144710152.png" alt="image-20221027144710152" style="zoom:80%;" /></p>
<h4 id="存储管理与硬件支撑"><a href="#存储管理与硬件支撑" class="headerlink" title="存储管理与硬件支撑"></a><strong>存储管理与硬件支撑</strong></h4><ul>
<li>鉴于程序执行与数据访问的局部性原理，存储管理软件使用Cache可以大幅度提升程序执行效率</li>
<li><p>动态重定位、存储保护等，若无硬件支撑在效率上是无意义的，即无实现价值</p>
</li>
<li><p>无虚拟地址中断，虚拟存储器无法实现</p>
</li>
<li>无页面替换等硬件支撑机制，虚拟存储器在效率上是无意义的</li>
</ul>
<h2 id="3-2-单连续分区存储管理"><a href="#3-2-单连续分区存储管理" class="headerlink" title="3.2 单连续分区存储管理"></a>3.2 单连续分区存储管理</h2><h3 id="3-2-1-单连续分区存储管理"><a href="#3-2-1-单连续分区存储管理" class="headerlink" title="3.2.1 单连续分区存储管理"></a>3.2.1 单连续分区存储管理</h3><h4 id="单连续分区存储管理"><a href="#单连续分区存储管理" class="headerlink" title="单连续分区存储管理"></a><strong>单连续分区存储管理</strong></h4><ul>
<li>每个进程占用一个物理上完全连续的存储空间(区域)</li>
<li>单用户连续存储管理</li>
<li>固定分区存储管理</li>
<li>可变分区存储管理</li>
</ul>
<h4 id="单用户连续分区存储管理"><a href="#单用户连续分区存储管理" class="headerlink" title="单用户连续分区存储管理"></a><strong>单用户连续分区存储管理</strong></h4><ul>
<li>主存区域划分为<strong>系统区</strong>与<strong>用户区</strong></li>
<li>设置一个<strong>栅栏寄存器</strong>界分两个区域，硬件用它在执行时进行存储保护</li>
<li>一般采用<strong>静态重定位</strong>进行地址转换</li>
<li>硬件实现代价低</li>
<li>适用于单用户单任务操作系统，如DOS</li>
</ul>
<h4 id="单用户连续分区存储管理示意"><a href="#单用户连续分区存储管理示意" class="headerlink" title="单用户连续分区存储管理示意"></a><strong>单用户连续分区存储管理示意</strong></h4><ul>
<li>静态重定位：在装入一个作业时，把该作业中程序的指令地址和数据地址<strong>全部转换成绝对地址</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150255136.png" alt="image-20221027150255136" style="zoom:80%;" /></p>
<h4 id="固定分区存储管理的基本思想"><a href="#固定分区存储管理的基本思想" class="headerlink" title="固定分区存储管理的基本思想"></a><strong>固定分区存储管理的基本思想</strong></h4><ul>
<li>支持多个分区</li>
<li>分区数量固定</li>
<li>分区大小固定</li>
<li>可用静态重定位</li>
<li>硬件实现代价低</li>
<li>早期OS采用</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150427931.png" alt="image-20221027150427931" style="zoom:50%;" /></p>
<h4 id="固定分区方式的主存分配"><a href="#固定分区方式的主存分配" class="headerlink" title="固定分区方式的主存分配"></a><strong>固定分区方式的主存分配</strong></h4><ul>
<li><p>主存分配表</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027150540542.png" alt="image-20221027150540542" style="zoom:80%;" /></p>
</li>
<li><p>主存分配与去配</p>
</li>
</ul>
<h4 id="固定分区方式的地址转换"><a href="#固定分区方式的地址转换" class="headerlink" title="固定分区方式的地址转换"></a><strong>固定分区方式的地址转换</strong></h4><ul>
<li><p>硬件实现机制与动态重定位</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027151008590.png" alt="image-20221027151008590" style="zoom:80%;" /></p>
</li>
</ul>
<h4 id="可变分区存储管理概述"><a href="#可变分区存储管理概述" class="headerlink" title="可变分区存储管理概述"></a><strong>可变分区存储管理概述</strong></h4><ul>
<li><p>固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存<strong>内零头</strong>，有浪费</p>
</li>
<li><p>能否按照进程实际内存需求<strong>动态划分分区</strong>，并允许<strong>分区个数可变</strong></p>
</li>
<li><p>这就是可变分区存储管理</p>
</li>
</ul>
<h3 id="3-2-2-可变分区存储管理"><a href="#3-2-2-可变分区存储管理" class="headerlink" title="3.2.2 可变分区存储管理"></a>3.2.2 可变分区存储管理</h3><h4 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a><strong>可变分区存储管理</strong></h4><ul>
<li>按进程的内存需求来动态划分分区</li>
<li>创建一个进程时，根据进程所需主存量查看主存中是否有足够的空闲空间<ul>
<li>若有，则按需要量分割一个分区</li>
<li>若无，则令该进程等待主存资源</li>
</ul>
</li>
<li>由于分区大小按照进程实际需要量来确定，因此分区个数是随机变化的</li>
</ul>
<h4 id="可变分区方式的内存分配示例"><a href="#可变分区方式的内存分配示例" class="headerlink" title="可变分区方式的内存分配示例"></a><strong>可变分区方式的内存分配示例</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027151836071.png" alt="image-20221027151836071" style="zoom:80%;" /></p>
<h4 id="可变分区方式的主存分配表"><a href="#可变分区方式的主存分配表" class="headerlink" title="可变分区方式的主存分配表"></a><strong>可变分区方式的主存分配表</strong></h4><ul>
<li>已分配区表与未分配区表，采用链表</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027152126219.png" alt="image-20221027152126219" style="zoom:80%;" /></p>
<h4 id="可变分区方式的内存分配"><a href="#可变分区方式的内存分配" class="headerlink" title="可变分区方式的内存分配"></a><strong>可变分区方式的内存分配</strong></h4><ul>
<li>最先适应分配算法<ul>
<li>从低地址向高地址扫描，所查找到的第一个可以容纳该进程的空闲区就分配给进程</li>
</ul>
</li>
<li>邻近适应分配算法<ul>
<li>从上一次分配的地址开始向高地址查找符合要求的空闲区，所查找到的第一个满足要求的空闲区就分配给进程。</li>
</ul>
</li>
<li>最优适应分配算法<ul>
<li>选择内存空闲区中最适合进程大小的分配。</li>
</ul>
</li>
<li>最坏适应分配算法<ul>
<li>挑选最大的空闲区</li>
</ul>
</li>
</ul>
<h4 id="可变分区方式的内存回收"><a href="#可变分区方式的内存回收" class="headerlink" title="可变分区方式的内存回收"></a><strong>可变分区方式的内存回收</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153045763.png" alt="image-20221027153045763" style="zoom:80%;" /></p>
<h4 id="地址转换与存储保护"><a href="#地址转换与存储保护" class="headerlink" title="地址转换与存储保护"></a><strong>地址转换与存储保护</strong></h4><ul>
<li>硬件实现机制与动态重定位</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153115917.png" alt="image-20221027153115917" style="zoom:80%;" /></p>
<h4 id="可变分区方式的内存零头"><a href="#可变分区方式的内存零头" class="headerlink" title="可变分区方式的内存零头"></a><strong>可变分区方式的内存零头</strong></h4><ul>
<li>固定分区方式会产生内存<strong>内零头</strong></li>
<li>可变分区方式也会随着进程的内存分配产生一些小的不可用的内存分区，称为<strong>内存外零头</strong></li>
<li>最优适配算法最容易产生外零头</li>
<li>任何适配算法都<strong>不能避免</strong>产生外零头</li>
</ul>
<h4 id="移动技术-程序浮动技术"><a href="#移动技术-程序浮动技术" class="headerlink" title="移动技术(程序浮动技术)"></a><strong>移动技术(程序浮动技术)</strong></h4><ul>
<li>移动分区以解决内存外零头</li>
<li>需要动态重定位支撑</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153332243.png" alt="image-20221027153332243" style="zoom:80%;" /></p>
<h4 id="移动技术的工作流程"><a href="#移动技术的工作流程" class="headerlink" title="移动技术的工作流程"></a><strong>移动技术的工作流程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027153402167.png" alt="image-20221027153402167" style="zoom:80%;" /></p>
<h2 id="3-3-页式存储管理"><a href="#3-3-页式存储管理" class="headerlink" title="3.3 页式存储管理"></a>3.3 页式存储管理</h2><h3 id="3-3-1-页式存储管理的基本原理"><a href="#3-3-1-页式存储管理的基本原理" class="headerlink" title="3.3.1 页式存储管理的基本原理"></a>3.3.1 页式存储管理的基本原理</h3><h4 id="页式存储管理的基本原理"><a href="#页式存储管理的基本原理" class="headerlink" title="页式存储管理的基本原理"></a><strong>页式存储管理的基本原理</strong></h4><ul>
<li><p>分页存储器将主存划分成多个大小相等的<strong>页架</strong></p>
</li>
<li><p>受页架尺寸限制，程序的逻辑地址也自然分成<strong>页</strong></p>
</li>
<li><p>不同的页可以放在不同页架中，不需要连续</p>
</li>
<li><p><strong>页表</strong>用于维系进程的主存<strong>完整性</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154114015.png" alt="image-20221027154114015" style="zoom:67%;" /></p>
</li>
</ul>
<h4 id="页式存储管理中的地址"><a href="#页式存储管理中的地址" class="headerlink" title="页式存储管理中的地址"></a><strong>页式存储管理中的地址</strong></h4><ul>
<li><p>页式存储管理的<strong>逻辑地址</strong>由两部分组成，<strong>页号和单元号(页内偏移量 offset)</strong>，逻辑地址形式：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154312547.png" alt="image-20221027154312547" style="zoom:50%;" /></p>
</li>
<li><p>页式存储管理的<strong>物理地址</strong>也有两部分组成：<strong>页架号和单元号</strong>，物理地址形式：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154358621.png" alt="image-20221027154358621" style="zoom:50%;" /></p>
</li>
<li><p>地址转换可以通过查页表完成</p>
</li>
<li>页内地址逐一连续对应<ul>
<li>所以地址转换时只需要从页号映射到页框号</li>
</ul>
</li>
</ul>
<h4 id="页式存储管理的地址转换思路"><a href="#页式存储管理的地址转换思路" class="headerlink" title="页式存储管理的地址转换思路"></a><strong>页式存储管理的地址转换思路</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154436828.png" alt="image-20221027154436828" style="zoom:80%;" /></p>
<h4 id="页式存储管理的内存分配-去配"><a href="#页式存储管理的内存分配-去配" class="headerlink" title="页式存储管理的内存分配/去配"></a><strong>页式存储管理的内存分配/去配</strong></h4><ul>
<li>可用一张<strong>位示图</strong>来记录主存分配情况</li>
<li>建立进程页表维护主存逻辑完整性</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221027154908427.png" alt="image-20221027154908427" style="zoom:80%;" /></p>
<h4 id="页的共享"><a href="#页的共享" class="headerlink" title="页的共享"></a><strong>页的共享</strong></h4><ul>
<li><p>页式存储管理能够实现多个进程共享程序和数据</p>
</li>
<li><p><strong>数据共享</strong>：不同进程可以使用<strong>不同</strong>页号共享数据页</p>
<ul>
<li>允许不同进程对共享的数据页用不同的页号，只要让各自页表中的有关表项<strong>指向共享的数据页框</strong></li>
</ul>
</li>
<li><p><strong>程序共享</strong>：不同进程必须使用<strong>相同</strong>页号共享代码页</p>
<ul>
<li>共享代码页中的(<strong>JMP &lt;页内地址&gt;</strong>)指令，使用不同页号是做不到</li>
<li>由于指令包含指向其他指令或数据的地址，进程依赖于这些地址才能执行，不同进程中正确执行共享代码页面，必须为它们在所有逻辑地址空间中指定同样页号</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-页式存储管理的地址转换"><a href="#3-3-2-页式存储管理的地址转换" class="headerlink" title="3.3.2 页式存储管理的地址转换"></a>3.3.2 页式存储管理的地址转换</h3><h4 id="页式存储管理的地址转换代价"><a href="#页式存储管理的地址转换代价" class="headerlink" title="页式存储管理的地址转换代价"></a><strong>页式存储管理的地址转换代价</strong></h4><ul>
<li><p><strong>页表放在主存</strong>: 每次地址转换必须访问两次主存</p>
<ol>
<li><p>按页号读出页表中的相应页架号</p>
</li>
<li><p>按计算出来的绝对地址进行读写</p>
</li>
</ol>
</li>
<li><p><strong>存在问题</strong>：降低了存取速度</p>
</li>
<li><p><strong>解决办法</strong>：利用Cache存放部分页表</p>
</li>
</ul>
<h4 id="页式存储管理的快表"><a href="#页式存储管理的快表" class="headerlink" title="页式存储管理的快表"></a><strong>页式存储管理的快表</strong></h4><ul>
<li>为提高地址转换速度，设置一个专用的高速存储器，用来存放页表的一部分</li>
<li><strong>快表</strong>：存放在高速存储器中的页表部分</li>
<li>快表表项：<strong>页号，页架号</strong></li>
<li>这种高速存储器是<strong>联想存储器</strong>，即<strong>按照内容寻址</strong>，而非按照地址访问</li>
</ul>
<h4 id="引入快表后的地址转换代价"><a href="#引入快表后的地址转换代价" class="headerlink" title="引入快表后的地址转换代价"></a><strong>引入快表后的地址转换代价</strong></h4><ul>
<li>采用<strong>快表</strong>后，可以加快地址转换速度</li>
<li>假定主存访问时间为200毫微秒，快表访问时间为40毫微秒，查快表的命中率是90%，平均地址转换代价为 (200+40)*90%+(200+200+40)*10%=260毫微秒</li>
<li>比两次访问主存的时间（400毫微秒）<strong>下降了35%</strong></li>
</ul>
<h4 id="基于快表的地址转换流程"><a href="#基于快表的地址转换流程" class="headerlink" title="基于快表的地址转换流程"></a><strong>基于快表的地址转换流程</strong></h4><ul>
<li>按逻辑地址中的页号查快表</li>
<li>若该页<strong>已在快表</strong>中，则由页架号和单元号形成绝对地址</li>
<li>若该页<strong>不在快表</strong>中，则再查主存页表形成绝对地址，同时将该页登记到快表中</li>
<li>当<strong>快表填满</strong>后，又要登记新页时，则需在快表中按一定策略<strong>淘汰</strong>一个旧登记项</li>
</ul>
<h4 id="多道程序环境下的进程表"><a href="#多道程序环境下的进程表" class="headerlink" title="多道程序环境下的进程表"></a><strong>多道程序环境下的进程表</strong></h4><ul>
<li>进程表中登记了每个进程的页表</li>
<li>进程占有处理器运行时，其<strong>页表起始地址和长度</strong>送入<strong>页表控制寄存器</strong></li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031104352984.png" alt="image-20221031104352984" style="zoom:80%;" /></p>
<h4 id="多道程序环境下的地址转换"><a href="#多道程序环境下的地址转换" class="headerlink" title="多道程序环境下的地址转换"></a><strong>多道程序环境下的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031104727130.png" alt="image-20221031104727130" style="zoom:80%;" /></p>
<h3 id="3-3-3-页式虚拟存储管理"><a href="#3-3-3-页式虚拟存储管理" class="headerlink" title="3.3.3 页式虚拟存储管理"></a>3.3.3 页式虚拟存储管理</h3><h4 id="页式虚拟存储管理的基本思想"><a href="#页式虚拟存储管理的基本思想" class="headerlink" title="页式虚拟存储管理的基本思想"></a><strong>页式虚拟存储管理的基本思想</strong></h4><ul>
<li>把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后，根据执行行为，动态调入不在主存的页，同时进行必要的页面调出</li>
<li>现代OS的<strong>主流存储管理技术</strong></li>
<li>首次只把进程第一页信息装入主存，称为<strong>请求页式存储管理</strong></li>
</ul>
<h4 id="页式虚拟存储管理的页表"><a href="#页式虚拟存储管理的页表" class="headerlink" title="页式虚拟存储管理的页表"></a><strong>页式虚拟存储管理的页表</strong></h4><ul>
<li>需要扩充页表项，指出：<ul>
<li>每页的虚拟地址、实际地址</li>
<li>主存驻留标志、写回标志、保护标志、引用标志、可移动标志</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031105524974.png" alt="image-20221031105524974" style="zoom: 67%;" /></p>
<h4 id="页式虚拟存储管理的实现"><a href="#页式虚拟存储管理的实现" class="headerlink" title="页式虚拟存储管理的实现"></a><strong>页式虚拟存储管理的实现</strong></h4><ul>
<li>CPU处理地址<ul>
<li>若页驻留，则获得块号形成绝对地址</li>
<li>若页不在内存，则CPU发出缺页中断</li>
</ul>
</li>
<li>OS处理缺页中断<ul>
<li>若有空闲页架，则根据辅存地址调入页，更新页表与快表等</li>
<li>若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表</li>
</ul>
</li>
</ul>
<h4 id="页式虚拟存储管理的地址转换"><a href="#页式虚拟存储管理的地址转换" class="headerlink" title="页式虚拟存储管理的地址转换"></a><strong>页式虚拟存储管理的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031111641724.png" alt="image-20221031111641724" style="zoom:80%;" /></p>
<h4 id="缺页中断的处理流程"><a href="#缺页中断的处理流程" class="headerlink" title="缺页中断的处理流程"></a><strong>缺页中断的处理流程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031111843806.png" alt="image-20221031111843806" style="zoom: 67%;" /></p>
<h4 id="补充：TLB-快表"><a href="#补充：TLB-快表" class="headerlink" title="补充：TLB(快表)"></a><strong>补充：TLB(快表)</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031112900090.png" alt="image-20221031112900090" style="zoom: 67%;" /></p>
<h4 id="补充：Paging-Hardware-With-TLB"><a href="#补充：Paging-Hardware-With-TLB" class="headerlink" title="补充：Paging Hardware With TLB"></a><strong>补充：Paging Hardware With TLB</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031112932254.png" alt="image-20221031112931920" style="zoom:80%;" /></p>
<h3 id="3-3-4-页面调度"><a href="#3-3-4-页面调度" class="headerlink" title="3.3.4 页面调度"></a>3.3.4 页面调度</h3><h4 id="页面调度"><a href="#页面调度" class="headerlink" title="页面调度"></a><strong>页面调度</strong></h4><ul>
<li>当主存空间已满而又需要装入新页时，页式虚拟存储管理必须按照一定的算法把已在主存的一些页调出去</li>
<li>选择淘汰页的工作称为<strong>页面调度</strong></li>
<li>选择淘汰页的算法称为<strong>页面调度算法</strong></li>
<li>页面调度算法设计不当，会出现（刚被淘汰的页面立即又要调入，并如此反复）</li>
<li>这种现象称为<strong>抖动</strong>或<strong>颠簸</strong></li>
</ul>
<h4 id="缺页中断率"><a href="#缺页中断率" class="headerlink" title="缺页中断率"></a><strong>缺页中断率</strong></h4><ul>
<li>假定进程P共 n 页，系统分配页架数 m 个</li>
<li>P运行中成功访问次数为S，不成功访问次数为F，总访问次数 A=S+F</li>
<li><strong>缺页中断率</strong>定义为：f=F/A</li>
<li>缺页中断率是衡量存储管理性能和用户编程水平的重要依据</li>
</ul>
<h4 id="影响缺页中断率的因素"><a href="#影响缺页中断率的因素" class="headerlink" title="影响缺页中断率的因素"></a><strong>影响缺页中断率的因素</strong></h4><ul>
<li>分配给进程的页架数：可用页架数越多，则缺页中断率就越低</li>
<li>页面的大小：页面尺寸越大，则缺页中断率就越低</li>
<li>用户的程序编制方法：在大数据量情况下，对缺页中断率也有很大影响</li>
</ul>
<h4 id="用户编程的例子"><a href="#用户编程的例子" class="headerlink" title="用户编程的例子"></a><strong>用户编程的例子</strong></h4><ul>
<li>程序将数组置为“0”，假定仅分得一个主存页架，页面尺寸为128个字，数组元素按行存放，开始时第一页在主存</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031113150739.png" alt="image-20221031113150739" style="zoom:67%;" /></p>
<h4 id="OPT页面调度算法"><a href="#OPT页面调度算法" class="headerlink" title="OPT页面调度算法"></a><strong>OPT页面调度算法</strong></h4><ul>
<li>理想的调度算法是：当要调入新页面时，首先淘汰以后不再访问的页，然后选择距现在最长时间后再访问的页</li>
<li>该算法由Belady出，称Belady算法，又称最佳算法(OPT)</li>
<li>OPT只可模拟，不可实现</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115319441.png" alt="image-20221031115319441" style="zoom:80%;" /></p>
<h4 id="先进先出FIFO页面调度算法"><a href="#先进先出FIFO页面调度算法" class="headerlink" title="先进先出FIFO页面调度算法"></a><strong>先进先出FIFO页面调度算法</strong></h4><ul>
<li>总是淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页(常驻的除外)</li>
<li>模拟的是程序执行的顺序性，有一定合理性</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115356690.png" alt="image-20221031115356690" style="zoom:80%;" /></p>
<h4 id="最近最少用LRU页面调度算法"><a href="#最近最少用LRU页面调度算法" class="headerlink" title="最近最少用LRU页面调度算法"></a><strong>最近最少用LRU页面调度算法</strong></h4><ul>
<li>淘汰最近一段时间较久未被访问的那一页，即那些刚被使用过的页面，可能马上还要被使用到</li>
<li>模拟了程序执行的局部属性，既考虑了循环性又兼顾了顺序性</li>
<li>严格实现的代价大(需要维持特殊队列)</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115610482.png" alt="image-20221031115610482" style="zoom:80%;" /></p>
<h4 id="LRU算法的模拟实现"><a href="#LRU算法的模拟实现" class="headerlink" title="LRU算法的模拟实现"></a><strong>LRU算法的模拟实现</strong></h4><ul>
<li>每页建一个引用标志，供硬件使用</li>
<li>设置一个时间间隔中断：中断时页引用标志置0</li>
<li>地址转换时，页引用标志置1</li>
<li>淘汰页面时，从页引用标志为0的页中间随机选择</li>
<li>时间间隔多长是个难点</li>
</ul>
<h4 id="最不常用LFU页面调度算法"><a href="#最不常用LFU页面调度算法" class="headerlink" title="最不常用LFU页面调度算法"></a><strong>最不常用LFU页面调度算法</strong></h4><ul>
<li>淘汰最近一段时间内访问次数较少的页面，对OPT的模拟性比LRU更好</li>
<li>基于时间间隔中断，并给每一页设置一个计数器</li>
<li>时间间隔中断发生后，所有计数器清0</li>
<li>每访问页1次就给计数器加1</li>
<li>选择计数值最小的页面淘汰</li>
</ul>
<h4 id="时钟CLOCK页面调度算法"><a href="#时钟CLOCK页面调度算法" class="headerlink" title="时钟CLOCK页面调度算法"></a><strong>时钟CLOCK页面调度算法</strong></h4><ul>
<li>采用循环队列机制构造页面队列，形成了一个类似于钟表面的环形表</li>
<li>队列指针则相当于钟表面上的表针，指向可能要淘汰的页面</li>
<li>使用页引用标志位</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221031115733235.png" alt="image-20221031115733235" style="zoom:80%;" /></p>
<h4 id="CLOCK算法的工作流程"><a href="#CLOCK算法的工作流程" class="headerlink" title="CLOCK算法的工作流程"></a><strong>CLOCK算法的工作流程</strong></h4><ul>
<li>页面调入主存时，其引用标志位置1</li>
<li>访问主存页面时，其引用标志位置1</li>
<li>淘汰页面时，从指针当前指向的页面开始扫描循环队列<ul>
<li>把所遇到的引用标志位是1的页面的引用标志位清0，并跳过</li>
<li>把所遇到的引用标志位是0的页面淘汰，指针推进一步</li>
</ul>
</li>
</ul>
<h3 id="3-3-5-反置页表-详见补充4"><a href="#3-3-5-反置页表-详见补充4" class="headerlink" title="3.3.5 反置页表(详见补充4)"></a>3.3.5 反置页表(详见补充4)</h3><h4 id="反置页表的提出"><a href="#反置页表的提出" class="headerlink" title="反置页表的提出"></a><strong>反置页表的提出</strong></h4><ul>
<li>页表及相关硬件机制在地址转换、存储保护、虚拟地址访问中发挥了<strong>关键作用</strong></li>
<li>为页式存储管理设置专门硬件机构</li>
<li>内存管理单元MMU：CPU管理虚拟/物理存储器的控制线路，把虚拟地址映射为物理地址，并提供存储保护，必要时确定淘汰页面</li>
<li>反置页表IPT：MMU用的数据结构</li>
</ul>
<h4 id="反置页表的基本思想"><a href="#反置页表的基本思想" class="headerlink" title="反置页表的基本思想"></a><strong>反置页表的基本思想</strong></h4><ul>
<li>针对内存中的每个页架建立一个页表，按照块号排序</li>
<li>表项包含：正在访问该页框的进程标识、页号及特征位，和哈希链指针等</li>
<li>用来完成内存页架到访问进程页号的对应，即物理地址到逻辑地址的转换</li>
</ul>
<h4 id="反置页表的页表项"><a href="#反置页表的页表项" class="headerlink" title="反置页表的页表项"></a><strong>反置页表的页表项</strong></h4><ul>
<li>页号：虚拟地址页号</li>
<li>进程标志符：使用该页的进程号（页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页）</li>
<li>标志位：有效、引用、修改、保护和锁定等标志信息</li>
<li>链指针：哈希链</li>
</ul>
<h4 id="基于反置页表的地址转换过程"><a href="#基于反置页表的地址转换过程" class="headerlink" title="基于反置页表的地址转换过程"></a><strong>基于反置页表的地址转换过程</strong></h4><ul>
<li>MMU通过哈希表把进程标识和虚页号转换成一个哈希值，指向IPT的一个表目</li>
<li>MMU遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，通过拼接位移便可生成物理地址</li>
<li>若遍历整个反置页表中未能找到匹配页表项，说明该页不在内存，产生缺页中断，请求操作系统调入</li>
</ul>
<h4 id="反置页表下的地址转换示意"><a href="#反置页表下的地址转换示意" class="headerlink" title="反置页表下的地址转换示意"></a><strong>反置页表下的地址转换示意</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107145644332.png" alt="image-20221107145644332" style="zoom:80%;" /></p>
<h2 id="3-4-段式存储管理"><a href="#3-4-段式存储管理" class="headerlink" title="3.4 段式存储管理"></a>3.4 段式存储管理</h2><h3 id="3-4-1-段式存储管理"><a href="#3-4-1-段式存储管理" class="headerlink" title="3.4.1 段式存储管理"></a>3.4.1 段式存储管理</h3><h4 id="段式程序设计-1"><a href="#段式程序设计-1" class="headerlink" title="段式程序设计"></a><strong>段式程序设计</strong></h4><ul>
<li>每个程序可由若干段组成，每一段都可以从“0”开始编址，段内的地址是连续的</li>
<li>分段存储器的逻辑地址由两部分组成<ul>
<li>段号：单元号</li>
</ul>
</li>
</ul>
<h4 id="程序的分段结构"><a href="#程序的分段结构" class="headerlink" title="程序的分段结构"></a><strong>程序的分段结构</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107115819595.png" alt="image-20221107115819595" style="zoom:80%;" /></p>
<h4 id="段式存储管理的基本思想"><a href="#段式存储管理的基本思想" class="headerlink" title="段式存储管理的基本思想"></a><strong>段式存储管理的基本思想</strong></h4><ul>
<li>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区</li>
<li>硬件需要增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段，附加段），供地址转换使用 </li>
<li>存储管理需要增加设置一个段表，每个段占用一个段表项，包括：段始址、段限长，以及存储保护、可移动、可扩充等标志位</li>
</ul>
<h4 id="段式存储管理的地址转换流程"><a href="#段式存储管理的地址转换流程" class="headerlink" title="段式存储管理的地址转换流程"></a><strong>段式存储管理的地址转换流程</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107115940791.png" alt="image-20221107115940791" style="zoom:80%;" /></p>
<h4 id="段的共享"><a href="#段的共享" class="headerlink" title="段的共享"></a><strong>段的共享</strong></h4><ul>
<li>通过不同进程段表中的项指向同一个段基址来实现</li>
<li>对共享段的信息必须进行保护，如规定只能读出不能写入，不满足保护条件则产生保护中断</li>
</ul>
<h3 id="3-4-2-段式虚拟存储管理"><a href="#3-4-2-段式虚拟存储管理" class="headerlink" title="3.4.2 段式虚拟存储管理"></a>3.4.2 段式虚拟存储管理</h3><h4 id="段式虚拟存储管理的基本思想"><a href="#段式虚拟存储管理的基本思想" class="headerlink" title="段式虚拟存储管理的基本思想"></a><strong>段式虚拟存储管理的基本思想</strong></h4><ul>
<li>把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入</li>
<li>段式虚拟存储管理中段的调进调出是由OS自动实现的，对用户透明</li>
<li>与段覆盖技术不同，它是用户控制的主存扩充技术，OS不感知</li>
</ul>
<h4 id="段式虚拟存储管理的段表扩充"><a href="#段式虚拟存储管理的段表扩充" class="headerlink" title="段式虚拟存储管理的段表扩充"></a><strong>段式虚拟存储管理的段表扩充</strong></h4><ul>
<li>段表的扩充<ul>
<li>特征位: 00(不在内存)01(在内存)11(共享段)</li>
<li>存取权限: 00(可执行)01(可读)11(可写)</li>
<li>扩充位: 0(固定长)1(可扩充)</li>
<li>标志位: 00(未修改)01(已修改)11(不可移动)</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120307367.png" alt="image-20221107120307367" style="zoom:80%;" /></p>
<h4 id="段式虚拟存储管理的地址转换"><a href="#段式虚拟存储管理的地址转换" class="headerlink" title="段式虚拟存储管理的地址转换"></a><strong>段式虚拟存储管理的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120330137.png" alt="image-20221107120330137" style="zoom:80%;" /></p>
<h3 id="3-4-3-段页式存储管理"><a href="#3-4-3-段页式存储管理" class="headerlink" title="3.4.3 段页式存储管理"></a>3.4.3 段页式存储管理</h3><h4 id="段页式存储管理的基本思想"><a href="#段页式存储管理的基本思想" class="headerlink" title="段页式存储管理的基本思想"></a><strong>段页式存储管理的基本思想</strong></h4><ul>
<li>段式存储管理可以基于页式存储管理实现</li>
<li>每一段不必占据连续的存储空间，可存放在不连续的主存页架中</li>
<li>能够扩充为段页式虚拟存储管理 </li>
<li>装入部分段，或者装入段中部分页面</li>
</ul>
<h4 id="段页式存储管理的段表和页表"><a href="#段页式存储管理的段表和页表" class="headerlink" title="段页式存储管理的段表和页表"></a><strong>段页式存储管理的段表和页表</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107120528299.png" alt="image-20221107120528299" style="zoom:80%;" /></p>
<h4 id="段页式存储管理的地址转换"><a href="#段页式存储管理的地址转换" class="headerlink" title="段页式存储管理的地址转换"></a><strong>段页式存储管理的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150325303.png" alt="image-20221107150325303" style="zoom:80%;" /></p>
<h4 id="段页式虚拟存储管理的地址转换"><a href="#段页式虚拟存储管理的地址转换" class="headerlink" title="段页式虚拟存储管理的地址转换"></a><strong>段页式虚拟存储管理的地址转换</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150517462.png" alt="image-20221107150517462" style="zoom:80%;" /></p>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="补充1：虚拟存储器的概念-补充局部性特征"><a href="#补充1：虚拟存储器的概念-补充局部性特征" class="headerlink" title="补充1：虚拟存储器的概念(补充局部性特征)"></a>补充1：虚拟存储器的概念(补充局部性特征)</h3><h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a><strong>抖动</strong></h4><ul>
<li>如果一块正好将要被用到之前扔出，操作系统有不得不很快把它取回来，太多的这类操作会导致一种称为系统抖动的情况</li>
<li>在处理缺页中断期间，处理器的大部分时间都用于交换块，而不是用户进程的执行指令</li>
</ul>
<h4 id="程序局部性原理-1"><a href="#程序局部性原理-1" class="headerlink" title="程序局部性原理(1)"></a><strong>程序局部性原理(1)</strong></h4><ul>
<li>指程序在执行过程中的一个较短时间内，所执行的<strong>指令地址或操作数地址分别局限于一定的存储区域中</strong>。又可细分时间局部性和空间局部性</li>
<li>早在1968年P. Denning研究程序执行时的局部性原理，对此进行研究的还有Knuth(分析一组学生的Fortran程序)、Tanenbaum (分析操作系统的过程)、Huck(分析通用科学计算程序)，<strong>发现程序和数据的访问都有聚集成群的倾向</strong></li>
<li>某存储单元被使用，其<strong>相邻存储单元很快也被使用(称空间局部性spatial locality)</strong></li>
<li>或者<strong>最近访问过的程序代码和数据，很快又被访问(称时间局部性temporal locality)</strong></li>
</ul>
<h4 id="分页下的运行情况"><a href="#分页下的运行情况" class="headerlink" title="分页下的运行情况"></a><strong>分页下的运行情况</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107150916487.png" alt="image-20221107150916487" style="zoom:80%;" /></p>
<h4 id="程序局部性原理-2"><a href="#程序局部性原理-2" class="headerlink" title="程序局部性原理(2)"></a><strong>程序局部性原理(2)</strong></h4><ul>
<li>程序中只有少量分支和过程调用，存在很多顺序执行的指令</li>
<li>程序含有若干循环结构，由少量代码组成，而被多次执行</li>
<li>过程调用的深度限制在小范围内，因而，指令引用通常被局限在少量过程中</li>
<li>涉及数组、记录之类的数据结构，对它们的连续引用是对位置相邻的数据项的操作</li>
<li>程序中有些部分彼此互斥，不是每次运行时都用到</li>
</ul>
<h4 id="程序局部性原理-3"><a href="#程序局部性原理-3" class="headerlink" title="程序局部性原理(3)"></a><strong>程序局部性原理(3)</strong></h4><p>经验与分析表明，程序具有局部性，进程执行时<strong>没有必要把全部信息调入主存，只需装入一部分的假设是合理的，部分装入的情况下，只要调度得当</strong>，不仅可正确运行，而且能在主存中放置更多进程，充分利用处理器和存储空间</p>
<h4 id="虚拟内存的技术需要"><a href="#虚拟内存的技术需要" class="headerlink" title="虚拟内存的技术需要"></a><strong>虚拟内存的技术需要</strong></h4><ul>
<li>必须有对所采用的分页或分段方案的硬件支持</li>
<li>操作系统必须有管理页或者段在主存和辅助存储器之间移动的软件。</li>
</ul>
<h3 id="补充2：伙伴系统"><a href="#补充2：伙伴系统" class="headerlink" title="补充2：伙伴系统"></a>补充2：伙伴系统</h3><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a><strong>伙伴系统</strong></h4><ul>
<li><p>伙伴系统(Knuth，1973)，又称buddy算法，是一种固定分区和可变分区折中的主存管理算法，基本原理是：任何尺寸为$2^{i}$的空闲块都可被分为两个尺寸为$2^{i-1}$的空闲块，这两个空闲块称作伙伴，它们可以被合并成尺寸为$2^{i}$的原先空闲块。</p>
</li>
<li><p>伙伴通过对大块的物理主存划分而获得</p>
<ul>
<li><p>假如从第0个页面开始到第3个页面结束的主存</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151309031.png" alt="image-20221107151309031"></p>
</li>
<li><p>每次都对半划分，那么第一次划分获得大小为2页的伙伴，如0、1和2、3</p>
</li>
<li><p>进一步划分，可以获得大小为1页的伙伴，例如0和1，2和3</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151347710.png" alt="image-20221107151347710" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151402680.png" alt="image-20221107151402680" style="zoom:80%;" /></p>
<h4 id="Linux伙伴系统"><a href="#Linux伙伴系统" class="headerlink" title="Linux伙伴系统"></a><strong>Linux伙伴系统</strong></h4><ol>
<li>以page结构为数组元素的mem_map[]数组</li>
<li>以free_area_struct结构为数组元素的free_area数组</li>
<li>位图数组(bitmap)</li>
</ol>
<h4 id="Linux基于伙伴的slab分配器"><a href="#Linux基于伙伴的slab分配器" class="headerlink" title="Linux基于伙伴的slab分配器"></a><strong>Linux基于伙伴的slab分配器</strong></h4><ul>
<li><p>为什么要使用slab分配器?</p>
<ul>
<li>伙伴系统以页框为基本分配单位，内核在很多情况下，<strong>需要的主存量远远小于页框大小</strong>，如inode、vma、task_struct等，为了更经济地使用内核主存资源，引入<strong>SunOS操作系统中首创的基于伙伴系统的slab分配器</strong>，其基本思想是：为经常使用的小对象建立缓存，小对象的申请与释放都通过slab分配器来管理，仅当缓存不够用时才向伙伴系统申请更多空间。//页内可以按2的幂次拆分。</li>
<li>优点：<strong>充分利用主存，减少内部碎片</strong>，对象管理局部化，尽可能少地与伙伴系统打交道，从而提高效率。</li>
</ul>
</li>
<li><p>slab的结构</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151727699.png" alt="image-20221107151727548" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107151742038.png" alt="image-20221107151742038" style="zoom:80%;" /></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/">https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/</a></li>
<li>Linux还提供十三种通用缓存，其存储对象的大小分别为32B、64B、128B、256B、512B、1KB、2KB、4KB、8KB、16KB、32KB、64KB和128KB，这些缓存用来满足特定对象之外的普通主存需求，单位的大小呈2的幂数增长，保证内部碎片率不超过50％。</li>
</ul>
</li>
<li><p>slab举例</p>
<p>例子task_struct slab</p>
<ul>
<li>内核用全局变量存放指向task_struct slab的指针：kmem_struct_t *task_struct_cachep；初始化时，在fork_init()中调用kmem_cache_create()函数创建高速缓存，存放类型为task_struct的对象。</li>
<li>每当进程调用fork()时，调用内核函数do_fork()，它再使用kmem_cache_alloc()函数在对应slab中建立一个task_struct对象。</li>
<li>进程执行结束后，task_struct对象被释放，返还给task_struct_cachep slab</li>
</ul>
</li>
<li><p>slab分配器主要操作</p>
<ul>
<li>kmem_cache_create()函数：创建专用cache，规定对象的大小和slab的构成，并加入cache管理队列；</li>
<li>kmem_cache_alloc()与kmem_cache_free()函数：分别用于分配和释放一个拥有专用slab队列的对象；</li>
<li>kmem_cache_grow()与kmem_cache_reap()函数：kmem_cache_grow()它向伙伴系统申请向cache增加一个slab；kmem_cache_reap()用于定时回收空闲slab；</li>
<li>kmem_cache_destroy()与kmem_cache_shrink()：用于cache的销毁和收缩；</li>
<li>kmalloc()与kfree()函数：用来从通用的缓冲区队列中申请和释放空间；</li>
<li>kmem_getpages()与kmem_freepages()函数：slab与页框级分配器的接口，当slab分配器要创建新的slab或cache时，通过kmem_getpages()向内核提供的伙伴算法来获得一组连续页框。如果释放分配给slab分配器的页框，则调用kmem_freepages()函数。</li>
</ul>
</li>
</ul>
<h3 id="补充3：分段和分页的寻址计算"><a href="#补充3：分段和分页的寻址计算" class="headerlink" title="补充3：分段和分页的寻址计算"></a>补充3：分段和分页的寻址计算</h3><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a><strong>分段</strong></h4><ul>
<li>采用分段法</li>
<li>某个分段的逻辑地址的段号为2, 段内偏移量为100, 计算它的物理地址</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152412373.png" alt="image-20221107152412373" style="zoom:80%;" /></p>
<h4 id="分页和分段的比较"><a href="#分页和分段的比较" class="headerlink" title="分页和分段的比较"></a><strong>分页和分段的比较</strong></h4><ul>
<li>分段<ul>
<li>分段是信息的逻辑单位，由源程序的逻辑结构所决定，用户可见</li>
<li>长可根据用户需要来规定，段起始地址可从任何主存地址开始。</li>
<li>分段方式中，源程序(段号，段内位移)经连结装配后地址仍保持二维结构。</li>
</ul>
</li>
<li>分页<ul>
<li>分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见</li>
<li>页长由系统确定，页面只能以页大小的整倍数地址开始</li>
<li>分页方式中，源程序(页号，页内位移)经连结装配后地址变成了一维结构</li>
</ul>
</li>
</ul>
<h4 id="分页：逻辑地址-gt-物理地址"><a href="#分页：逻辑地址-gt-物理地址" class="headerlink" title="分页：逻辑地址-&gt;物理地址"></a><strong>分页：逻辑地址-&gt;物理地址</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152637357.png" alt="image-20221107152637357" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152213784.png" alt="image-20221107152213784"></p>
<p>分页：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152747958.png" alt="image-20221107152747958" style="zoom:80%;" /></p>
<p>分段：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152336480.png" alt="image-20221107152336480" style="zoom:80%;" /></p>
<h4 id="分页地址转换"><a href="#分页地址转换" class="headerlink" title="分页地址转换"></a><strong>分页地址转换</strong></h4><ul>
<li>页面与页框的大小为1024字节, 指令 MOV 2100, 3100</li>
<li>求MOV指令中两个操作数的物理地址</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152935682.png" alt="image-20221107152935682" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107152945691.png" alt="image-20221107152945691" style="zoom:80%;" /></p>
<h3 id="补充4：多级页表与反置页表"><a href="#补充4：多级页表与反置页表" class="headerlink" title="补充4：多级页表与反置页表"></a>补充4：多级页表与反置页表</h3><h4 id="4-1-多级页表"><a href="#4-1-多级页表" class="headerlink" title="4.1 多级页表"></a>4.1 多级页表</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h5><p>现代计算机普遍支持$2^{32}～2^{64}$容量的逻辑地址空间，采用分页存储管理时，页表相当大，以Windows为例，其运行的Intel x86平台具有32位地址，规定页面4KB($2^{12}$)时，那么，4GB($2^{32}$)的逻辑地址空间由1兆($2^{20}$)个页组成，若每个页表项占用4个字节，则需要占用4MB($2^{22}$)连续主存空间存放页表。系统中有许多进程，因此页表存储开销很大。</p>
<h5 id="多级页表的概念"><a href="#多级页表的概念" class="headerlink" title="多级页表的概念"></a><strong>多级页表的概念</strong></h5><ul>
<li>系统为每个进程建一张页目录表,它的每个表项对应一个页表页,<strong>而页表页的每个表项给出了页面和页框的对应关系</strong>,页目录表是一级页表,页表页是二级页表。</li>
<li>逻辑地址结构有三部分组成：页目录、页表页和位移</li>
</ul>
<h5 id="两级页表-32位地址"><a href="#两级页表-32位地址" class="headerlink" title="两级页表(32位地址)"></a><strong>两级页表(32位地址)</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105149441.png" alt="image-20221107105149441" style="zoom:80%;" /></p>
<h5 id="多级页表的地址转换过程"><a href="#多级页表的地址转换过程" class="headerlink" title="多级页表的地址转换过程"></a><strong>多级页表的地址转换过程</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105221507.png" alt="image-20221107105221507" style="zoom:80%;" /></p>
<h5 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a><strong>二级页表</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105351296.png" alt="image-20221107105351296" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105402628.png" alt="image-20221107105402628" style="zoom:80%;" /></p>
<h5 id="SUN-SPARC计算机三级分页结构"><a href="#SUN-SPARC计算机三级分页结构" class="headerlink" title="SUN SPARC计算机三级分页结构"></a><strong>SUN SPARC计算机三级分页结构</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107105453288.png" alt="image-20221107105453288" style="zoom:80%;" /></p>
<ul>
<li>问题：增加了寻址时间，在计算机系统中时间与空间总是存在一些矛盾，因此经常会采取折中的方案，以时间换空间，或者以空间换取时间。</li>
</ul>
<h5 id="多级页表的本质"><a href="#多级页表的本质" class="headerlink" title="多级页表的本质"></a><strong>多级页表的本质</strong></h5><ul>
<li>多级不连续导致多级索引。</li>
<li>以二级页表为例，用户程序的页面不连续存放，要有页面地址索引，该索引是进程页表；进程页表又是不连续存放的多个页表页，故页表页也要页表页地址索引，该索引就是页目录。</li>
<li>页目录项是页表页的索引，而页表页项是进程程序的页面索引。</li>
</ul>
<h4 id="4-2-反置页表-Inverted-Page-Table"><a href="#4-2-反置页表-Inverted-Page-Table" class="headerlink" title="4.2 反置页表(Inverted Page Table)"></a>4.2 反置页表(Inverted Page Table)</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h5><ul>
<li>页表设计的一个重要缺陷是页表的大小与虚拟地址空间的大小成正比</li>
<li>在反向页表方法中，虚拟地址的页号部分使用一个简单散列函数映射到哈希表中。哈希表包含一个指向反向表的指针，而反向表中含有页表项。</li>
<li>通过这个结构，哈希表和反向表中只有一项对应于一个<strong>实存页(面向实存)</strong>，而不是<strong>虚拟页(面向虚存)</strong>。</li>
<li>因此，不论有多少进程、支持多少虚拟页，页表都只需要实存中的一个固定部分。</li>
<li>用于PowerPC, UltraSPARC, IA-64架构</li>
</ul>
<h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a><strong>组成</strong></h5><ul>
<li><strong>页号</strong>：虚拟地址页号部分。</li>
<li><strong>进程标志符</strong>：使用该页的进程。页号和进程标志符结合起来标志一个特定的进程的虚拟地址空间的一页。</li>
<li><strong>控制位</strong>：该域包含一些标记，比如有效、访问和修改，以及保护和锁定的信息。</li>
<li><strong>链指针</strong>：如果某个项没有链项，则该域为空(允许用一个单独的位来表示)。</li>
</ul>
<h5 id="线性反置页表的结构"><a href="#线性反置页表的结构" class="headerlink" title="线性反置页表的结构"></a><strong>线性反置页表的结构</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107110729262.png" alt="image-20221107110729262" style="zoom:80%;" /></p>
<ul>
<li>问题：线性查找，效率低，有可能遍历完才发现缺页中断</li>
</ul>
<h5 id="改进-引入hash"><a href="#改进-引入hash" class="headerlink" title="改进(引入hash)"></a><strong>改进(引入hash)</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107110812406.png" alt="image-20221107110812406" style="zoom:80%;" /></p>
<h5 id="反置页表地址转换过程"><a href="#反置页表地址转换过程" class="headerlink" title="反置页表地址转换过程"></a><strong>反置页表地址转换过程</strong></h5><p>逻辑地址<strong>给出进程标识和页号,用它们去比较IPT</strong>,若整个反置页表中<strong>未能找到匹配的页表项,说明该页不在主存,产生缺页中断</strong>,请求操作系统调入;否则，该表项的序号便是页框号,块号加上位移,便形成物理地址。</p>
<h5 id="线性反置页表"><a href="#线性反置页表" class="headerlink" title="线性反置页表"></a><strong>线性反置页表</strong></h5><p>pid是隐含的</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107111844378.png" alt="image-20221107111844378" style="zoom:80%;" /></p>
<h5 id="哈希线性反置页表"><a href="#哈希线性反置页表" class="headerlink" title="哈希线性反置页表"></a><strong>哈希线性反置页表</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112035238.png" alt="image-20221107112035238" style="zoom:80%;" /></p>
<p><strong>页表的结构称为“反向”是因为它使用帧号而不是虚拟页号来索引页表项</strong></p>
<h5 id="主存分配的位示图和链表方法"><a href="#主存分配的位示图和链表方法" class="headerlink" title="主存分配的位示图和链表方法"></a><strong>主存分配的位示图和链表方法</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112234403.png" alt="image-20221107112234403" style="zoom:80%;" /></p>
<h5 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a><strong>段页式存储管理</strong></h5><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112533727.png" alt="image-20221107112533727" style="zoom:80%;" /></p>
<h3 id="补充5：页的大小设计"><a href="#补充5：页的大小设计" class="headerlink" title="补充5：页的大小设计"></a>补充5：页的大小设计</h3><ul>
<li>页越小, 内存碎片越少</li>
<li>页越小, 每个进程需要页数越多</li>
<li>每个进程的页越多就意味着页表更大，而页表大意味着在虚拟内存中占据更多的空间</li>
<li>辅存设计用于有效传输大数据块，因此页面大小越大越好</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107112722467.png" alt="image-20221107112722467" style="zoom:80%;" /></p>
<ul>
<li>多种页面大小提供了有效使用TLB所需的灵活性</li>
<li>大多数操作系统只支持一种页面大小</li>
</ul>
<h3 id="补充6：页面替换算法"><a href="#补充6：页面替换算法" class="headerlink" title="补充6：页面替换算法"></a>补充6：页面替换算法</h3><p>OPT、FIFO、LRU、CLOCK算法见3.3.4</p>
<h4 id="CLOCK"><a href="#CLOCK" class="headerlink" title="CLOCK"></a><strong>CLOCK</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107154512018.png" alt="image-20221107154512018" style="zoom: 67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107154528175.png" alt="image-20221107154528175" style="zoom: 67%;" /></p>
<h4 id="Belady’s-Anomaly-Belady异常"><a href="#Belady’s-Anomaly-Belady异常" class="headerlink" title="Belady’s Anomaly(Belady异常)"></a><strong>Belady’s Anomaly(Belady异常)</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160528527.png" alt="image-20221107160528527" style="zoom:80%;" /></p>
<h4 id="FIFO算法的Belady异常"><a href="#FIFO算法的Belady异常" class="headerlink" title="FIFO算法的Belady异常"></a><strong>FIFO算法的Belady异常</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160611184.png" alt="image-20221107160611184" style="zoom:80%;" /></p>
<h4 id="Comparison-of-Placement-Algorithms"><a href="#Comparison-of-Placement-Algorithms" class="headerlink" title="Comparison of Placement Algorithms"></a><strong>Comparison of Placement Algorithms</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221107160636982.png" alt="image-20221107160636982" style="zoom:80%;" /></p>
<h4 id="Basic-Replacement-Algorithms"><a href="#Basic-Replacement-Algorithms" class="headerlink" title="Basic Replacement Algorithms"></a><strong>Basic Replacement Algorithms</strong></h4><ul>
<li>Page Buffering<ul>
<li>Replaced page is added to one of two lists<ul>
<li>free page list if page has not been modified</li>
<li>modified page list</li>
</ul>
</li>
<li>Replaced page remains in memory<ul>
<li>If referenced again, it is returned at little cost</li>
<li>Modified pages are written out in cluster</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Resident-Set-Size-驻留集规模"><a href="#Resident-Set-Size-驻留集规模" class="headerlink" title="Resident Set Size(驻留集规模)"></a><strong>Resident Set Size(驻留集规模)</strong></h4><ul>
<li>Fixed-allocation<ul>
<li>gives a process a fixed number of pages within which to execute</li>
<li>when a page fault occurs, one of the pages of that process must be replaced</li>
</ul>
</li>
<li>Variable-allocation<ul>
<li>number of pages allocated to a process varies over the lifetime of the process</li>
</ul>
</li>
</ul>
<p><strong>Fixed Allocation, Local Scope</strong></p>
<ul>
<li>Number of frames allocated to process is fixed</li>
<li>Page to be replaced is chosen from among the frames allocated to the process</li>
</ul>
<p><strong>Variable Allocation, Global Scope</strong></p>
<ul>
<li>Number of frames allocated to process is variable</li>
<li>Page to be replaced is chosen from all frames</li>
<li>Easiest to implement</li>
<li>Adopted by many operating systems</li>
<li>Operating system keeps list of free frames</li>
<li>Free frame is added to resident set of process when a page fault occurs</li>
</ul>
<p><strong>Variable Allocation, Local Scope</strong></p>
<ul>
<li>Number of frames allocated to process is variable</li>
<li>Page to be replaced is chosen from among the frames allocated to the process</li>
<li>When new process added, allocate number of page frames based on application type, program request, or other criteria</li>
<li>When page fault occurs, select page from among the resident set of the process that suffers the fault</li>
<li>Reevaluate allocation from time to time</li>
</ul>
<blockquote>
<p>根据页面置换算法可借用的外界条件，将页面置换算法分为:</p>
<p>局部页面置换算法：置换页面的选择范围仅限于当前进程占用的内存页面</p>
<p>全局页面置换算法：置换页面的选择范围是所有可换出的内存页面(并不是所有的内存页面都可以换出内存，比如内核关键代码所在内存页面；因此对这些页面，会将其页表项的锁定位置1，从而操作系统在换出内存页面时就不会考虑这些页面)。</p>
</blockquote>
<h4 id="局部页面替换算法"><a href="#局部页面替换算法" class="headerlink" title="局部页面替换算法"></a><strong>局部页面替换算法</strong></h4><ol>
<li>局部最佳页面替换算法</li>
<li>工作集模型和工作集置换算法</li>
</ol>
<h4 id="局部最佳页面替换算法"><a href="#局部最佳页面替换算法" class="headerlink" title="局部最佳页面替换算法"></a><strong>局部最佳页面替换算法</strong></h4><ul>
<li>1976年Prieve提出一种局部最佳页面替换算法MIN(Local Minimum)，它与全局最佳替换算法类似，需事先知道程序的页面引用串，再根据进程行为改变驻留页面数量</li>
<li>实现思想：进程在时刻 t 访问某页面，如果该页面不在主存中，导致一次缺页，把该页面装入一个空闲页框</li>
<li><p>不论发生缺页与否，算法在每一步要考虑引用串，<strong>如果该页面在时间间隔(t, t+τ)内未被再次引用，那么就移出；否则，该页被保留在进程驻留集中</strong> (<strong>看未来</strong>)</p>
</li>
<li><p>τ为一个系统常量，间隔(t, t+τ)称作滑动窗口。例子中τ=3</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108015614001.png" alt="image-20221108015614001" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108015707685.png" alt="image-20221108015707685" style="zoom:80%;" /></p>
<p>缺页总数为5次，驻留集大小在1-2之间变化，任何时刻至多两个页框被占用，通过增加τ值，缺页数目可减少，但代价是花费更多页框。 </p>
<h4 id="工作集模型和工作集置换算法"><a href="#工作集模型和工作集置换算法" class="headerlink" title="工作集模型和工作集置换算法"></a><strong>工作集模型和工作集置换算法</strong></h4><ul>
<li>进程工作集指“在某一段时间间隔内进程运行所需访问的页面集合”</li>
<li>实现思想：工作集模型用来对局部最佳页面替换算法进行模拟实现，<strong>不向前查看页面引用串，而是基于程序局部性原理向后看</strong></li>
<li>任何给定时刻，<strong>进程不久的将来所需主存页框数，可通过考查其过去最近的时间内的主存需求做出估计</strong></li>
</ul>
<h4 id="进程工作集"><a href="#进程工作集" class="headerlink" title="进程工作集"></a><strong>进程工作集</strong></h4><ul>
<li>指“在某一段时间间隔内进程运行所需访问的页面集合”，<strong>W(t，Δ)表示在时刻 t-Δ 到时刻 t 之间( (t-Δ，t))所访问的页面集合，进程在时刻 t 的工作集</strong></li>
<li><p>Δ 是系统定义的一个常量。变量 Δ 称为“工作集窗口尺寸”，可通过窗口来观察进程行为，还把工作集中所包含的页面数目称为“工作集尺寸”</p>
</li>
<li><p>Δ=3</p>
</li>
</ul>
<h4 id="Working-set-model"><a href="#Working-set-model" class="headerlink" title="Working-set model"></a><strong>Working-set model</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020047797.png" alt="image-20221108020047797" style="zoom:80%;" /></p>
<h4 id="工作集替换示例"><a href="#工作集替换示例" class="headerlink" title="工作集替换示例"></a><strong>工作集替换示例</strong></h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020225281.png" alt="image-20221108020225281" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020242078.png" alt="image-20221108020242078" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020302415.png" alt="image-20221108020302415" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020317071.png" alt="image-20221108020317071" style="zoom: 67%;" /></p>
<h4 id="The-Page-Fault-Frequency-Strategy"><a href="#The-Page-Fault-Frequency-Strategy" class="headerlink" title="The Page-Fault Frequency Strategy"></a><strong>The Page-Fault Frequency Strategy</strong></h4><ul>
<li>Define an upper bound U and lower bound L for page fault rates</li>
<li>Allocate more frames to a process if fault rate is higher than U</li>
<li>Allocate less frames if fault rate is &lt; L</li>
<li>The <strong>resident set size should be close to the working set size W</strong></li>
<li>We suspend the process if the PFF &gt; U and no more free frames are available</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221108020434064.png" alt="image-20221108020434064" style="zoom:67%;" /></p>
<h4 id="通过工作集确定驻留集大小"><a href="#通过工作集确定驻留集大小" class="headerlink" title="通过工作集确定驻留集大小"></a><strong>通过工作集确定驻留集大小</strong></h4><ol>
<li>监视每个进程的工作集，只有属于工作集的页面才能留在主存；</li>
<li>定期地从进程驻留集中删去那些不在工作集中的页面；</li>
<li>仅当一个进程的工作集在主存时，进程才能执行。</li>
</ol>
<h3 id="补充7：TLB快表，页表，缺页"><a href="#补充7：TLB快表，页表，缺页" class="headerlink" title="补充7：TLB快表，页表，缺页"></a>补充7：TLB快表，页表，缺页</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134658588.png" alt="image-20221114134658588"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134717530.png" alt="image-20221114134717530"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134738142.png" alt="image-20221114134738142"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114134854425.png" alt="image-20221114134854425" style="zoom:80%;" /></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/" rel="prev" title="计算机操作系统(2) 处理器管理">
      <i class="fa fa-chevron-left"></i> 计算机操作系统(2) 处理器管理
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" rel="next" title="计算机操作系统(4) 设备管理">
      计算机操作系统(4) 设备管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">第三章 存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">3.1 存储管理基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">3.1.1 存储管理的主要模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">逻辑地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">段式程序设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">物理地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%A4%8D%E7%94%A8"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">主存储器的复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">存储管理的基本模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">存储管理模式示意图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.1.2.</span> <span class="nav-text">3.1.2 存储管理的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%8E%BB%E9%85%8D"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">主存储器空间的分配与去配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">主存储器空间的共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">存储保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">主存储器空间的扩充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.1.3 虚拟存储器的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%9D%E6%83%B3%E7%9A%84%E6%8F%90%E5%87%BA"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">虚拟存储器思想的提出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">虚拟存储器的基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">虚拟存储器的实现思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%A4%BA%E6%84%8F"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">虚拟存储器示意</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%92%91"><span class="nav-number">1.1.4.</span> <span class="nav-text">3.1.4 存储管理的硬件支撑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E5%B1%82%E6%AC%A1"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">存储器的组织层次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%B6%89%E5%8F%8A%E7%9A%84%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">存储管理涉及的存储对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8-Cache"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">高速缓存存储器(Cache)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">高速缓存存储器的构成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">高速缓存存储器的组织</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%BA%A7"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">高速缓存存储器的分级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%B1%BB%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">各类处理器架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%92%91"><span class="nav-number">1.1.4.8.</span> <span class="nav-text">地址转换&#x2F;存储保护的硬件支撑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%92%91"><span class="nav-number">1.1.4.9.</span> <span class="nav-text">存储管理与硬件支撑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%8D%95%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">3.2 单连续分区存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E5%8D%95%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.1.</span> <span class="nav-text">3.2.1 单连续分区存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">单连续分区存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%94%A8%E6%88%B7%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">单用户连续分区存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%94%A8%E6%88%B7%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%A4%BA%E6%84%8F"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">单用户连续分区存储管理示意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">固定分区存储管理的基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%BB%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">固定分区方式的主存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">固定分区方式的地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">可变分区存储管理概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">3.2.2 可变分区存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">可变分区存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">可变分区方式的内存分配示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%BB%E5%AD%98%E5%88%86%E9%85%8D%E8%A1%A8"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">可变分区方式的主存分配表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">可变分区方式的内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">可变分区方式的内存回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">地址转换与存储保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E9%9B%B6%E5%A4%B4"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">可变分区方式的内存零头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%8A%80%E6%9C%AF-%E7%A8%8B%E5%BA%8F%E6%B5%AE%E5%8A%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">移动技术(程序浮动技术)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.2.9.</span> <span class="nav-text">移动技术的工作流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">3.3 页式存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.3.1 页式存储管理的基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">页式存储管理的基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">页式存储管理中的地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%80%9D%E8%B7%AF"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">页式存储管理的地址转换思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%8E%BB%E9%85%8D"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">页式存储管理的内存分配&#x2F;去配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">页的共享</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.3.2 页式存储管理的地址转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%BB%A3%E4%BB%B7"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">页式存储管理的地址转换代价</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%BF%AB%E8%A1%A8"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">页式存储管理的快表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E5%BF%AB%E8%A1%A8%E5%90%8E%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%BB%A3%E4%BB%B7"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">引入快表后的地址转换代价</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">基于快表的地址转换流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%A1%A8"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">多道程序环境下的进程表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">多道程序环境下的地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3.3 页式虚拟存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">页式虚拟存储管理的基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">页式虚拟存储管理的页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">页式虚拟存储管理的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">页式虚拟存储管理的地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">缺页中断的处理流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9ATLB-%E5%BF%AB%E8%A1%A8"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">补充：TLB(快表)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9APaging-Hardware-With-TLB"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">补充：Paging Hardware With TLB</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.3.4 页面调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">页面调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E7%8E%87"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">缺页中断率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E7%8E%87%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">影响缺页中断率的因素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">用户编程的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OPT%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">OPT页面调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BAFIFO%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.4.6.</span> <span class="nav-text">先进先出FIFO页面调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E7%94%A8LRU%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.4.7.</span> <span class="nav-text">最近最少用LRU页面调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.4.8.</span> <span class="nav-text">LRU算法的模拟实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8LFU%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.4.9.</span> <span class="nav-text">最不常用LFU页面调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9FCLOCK%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.4.10.</span> <span class="nav-text">时钟CLOCK页面调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLOCK%E7%AE%97%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.4.11.</span> <span class="nav-text">CLOCK算法的工作流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8-%E8%AF%A6%E8%A7%81%E8%A1%A5%E5%85%854"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.3.5 反置页表(详见补充4)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%8F%90%E5%87%BA"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">反置页表的提出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">反置页表的基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8%E7%9A%84%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">反置页表的页表项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">基于反置页表的地址转换过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8%E4%B8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E7%A4%BA%E6%84%8F"><span class="nav-number">1.3.5.5.</span> <span class="nav-text">反置页表下的地址转换示意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">3.4 段式存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.4.1 段式存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">段式程序设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">程序的分段结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">段式存储管理的基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">段式存储管理的地址转换流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">段的共享</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.4.2 段式虚拟存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">段式虚拟存储管理的基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%AE%B5%E8%A1%A8%E6%89%A9%E5%85%85"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">段式虚拟存储管理的段表扩充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">段式虚拟存储管理的地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.4.3 段页式存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">段页式存储管理的基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%AE%B5%E8%A1%A8%E5%92%8C%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">段页式存储管理的段表和页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">段页式存储管理的地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">段页式虚拟存储管理的地址转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9"><span class="nav-number">1.5.</span> <span class="nav-text">补充内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%851%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5-%E8%A1%A5%E5%85%85%E5%B1%80%E9%83%A8%E6%80%A7%E7%89%B9%E5%BE%81"><span class="nav-number">1.5.1.</span> <span class="nav-text">补充1：虚拟存储器的概念(补充局部性特征)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">抖动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86-1"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">程序局部性原理(1)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E4%B8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">分页下的运行情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86-2"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">程序局部性原理(2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86-3"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">程序局部性原理(3)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9C%80%E8%A6%81"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">虚拟内存的技术需要</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%852%EF%BC%9A%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">补充2：伙伴系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">伙伴系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Linux伙伴系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E5%9F%BA%E4%BA%8E%E4%BC%99%E4%BC%B4%E7%9A%84slab%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">Linux基于伙伴的slab分配器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%853%EF%BC%9A%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%9A%84%E5%AF%BB%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="nav-number">1.5.3.</span> <span class="nav-text">补充3：分段和分页的寻址计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">分段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">分页和分段的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%EF%BC%9A%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-gt-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">分页：逻辑地址-&gt;物理地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">分页地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%854%EF%BC%9A%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E4%B8%8E%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.5.4.</span> <span class="nav-text">补充4：多级页表与反置页表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">4.1 多级页表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.5.4.1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.4.1.2.</span> <span class="nav-text">多级页表的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8-32%E4%BD%8D%E5%9C%B0%E5%9D%80"><span class="nav-number">1.5.4.1.3.</span> <span class="nav-text">两级页表(32位地址)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.4.1.4.</span> <span class="nav-text">多级页表的地址转换过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.5.4.1.5.</span> <span class="nav-text">二级页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SUN-SPARC%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E5%88%86%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.4.1.6.</span> <span class="nav-text">SUN SPARC计算机三级分页结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.5.4.1.7.</span> <span class="nav-text">多级页表的本质</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8-Inverted-Page-Table"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">4.2 反置页表(Inverted Page Table)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.4.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E6%88%90"><span class="nav-number">1.5.4.2.2.</span> <span class="nav-text">组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.4.2.3.</span> <span class="nav-text">线性反置页表的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B-%E5%BC%95%E5%85%A5hash"><span class="nav-number">1.5.4.2.4.</span> <span class="nav-text">改进(引入hash)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.4.2.5.</span> <span class="nav-text">反置页表地址转换过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.5.4.2.6.</span> <span class="nav-text">线性反置页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%BA%BF%E6%80%A7%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.5.4.2.7.</span> <span class="nav-text">哈希线性反置页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%BD%8D%E7%A4%BA%E5%9B%BE%E5%92%8C%E9%93%BE%E8%A1%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.4.2.8.</span> <span class="nav-text">主存分配的位示图和链表方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.4.2.9.</span> <span class="nav-text">段页式存储管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%855%EF%BC%9A%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.5.</span> <span class="nav-text">补充5：页的大小设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%856%EF%BC%9A%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.6.</span> <span class="nav-text">补充6：页面替换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CLOCK"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">CLOCK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Belady%E2%80%99s-Anomaly-Belady%E5%BC%82%E5%B8%B8"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">Belady’s Anomaly(Belady异常)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FIFO%E7%AE%97%E6%B3%95%E7%9A%84Belady%E5%BC%82%E5%B8%B8"><span class="nav-number">1.5.6.3.</span> <span class="nav-text">FIFO算法的Belady异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparison-of-Placement-Algorithms"><span class="nav-number">1.5.6.4.</span> <span class="nav-text">Comparison of Placement Algorithms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Basic-Replacement-Algorithms"><span class="nav-number">1.5.6.5.</span> <span class="nav-text">Basic Replacement Algorithms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Resident-Set-Size-%E9%A9%BB%E7%95%99%E9%9B%86%E8%A7%84%E6%A8%A1"><span class="nav-number">1.5.6.6.</span> <span class="nav-text">Resident Set Size(驻留集规模)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.6.7.</span> <span class="nav-text">局部页面替换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.6.8.</span> <span class="nav-text">局部最佳页面替换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.6.9.</span> <span class="nav-text">工作集模型和工作集置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="nav-number">1.5.6.10.</span> <span class="nav-text">进程工作集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Working-set-model"><span class="nav-number">1.5.6.11.</span> <span class="nav-text">Working-set model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%9B%BF%E6%8D%A2%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.5.6.12.</span> <span class="nav-text">工作集替换示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Page-Fault-Frequency-Strategy"><span class="nav-number">1.5.6.13.</span> <span class="nav-text">The Page-Fault Frequency Strategy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%A1%AE%E5%AE%9A%E9%A9%BB%E7%95%99%E9%9B%86%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.5.6.14.</span> <span class="nav-text">通过工作集确定驻留集大小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%857%EF%BC%9ATLB%E5%BF%AB%E8%A1%A8%EF%BC%8C%E9%A1%B5%E8%A1%A8%EF%BC%8C%E7%BC%BA%E9%A1%B5"><span class="nav-number">1.5.7.</span> <span class="nav-text">补充7：TLB快表，页表，缺页</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
