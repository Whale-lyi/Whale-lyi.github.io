<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="码农预备役">
<meta property="og:type" content="website">
<meta property="og:title" content="Whale&#39;s Blog">
<meta property="og:url" content="https://whale-lyi.github.io/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="码农预备役">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Whale">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://whale-lyi.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/03/13/MySQL-2-%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/13/MySQL-2-%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">MySQL(2) 事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-03-13 17:06:46" itemprop="dateCreated datePublished" datetime="2024-03-13T17:06:46+08:00">2024-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-03-14 16:10:01" itemprop="dateModified" datetime="2024-03-14T16:10:01+08:00">2024-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>事务：一组操作的集合，同时成功/失败</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 方式一：设置事务提交方式</span><br><span class="hljs-comment">-- 查看事务提交方式</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@AUTOCOMMIT</span>;<br><span class="hljs-comment">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="hljs-keyword">SET</span> @<span class="hljs-variable">@AUTOCOMMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br><span class="hljs-comment">-- 事务演示</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><span class="hljs-keyword">commit</span>;<br><br><br><span class="hljs-comment">-- 方式二：开启事务</span><br><span class="hljs-keyword">START</span> TRANSACTION; <span class="hljs-comment">-- 或者 BEGIN TRANSACTION;</span><br><span class="hljs-comment">-- 事务演示</span><br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure>
<h2 id="1-ACID特性"><a href="#1-ACID特性" class="headerlink" title="1. ACID特性"></a>1. ACID特性</h2><h3 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity 原子性"></a>Atomicity 原子性</h3><p>事务是不可分割的最小操作单元，要么全部成功，要么全部失败</p>
<h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h3><p>事务完成时，必须使所有数据都保持一致状态</p>
<h3 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h3><p>数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p>
<h3 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h3><p>事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p>
<h2 id="2-并发事务问题"><a href="#2-并发事务问题" class="headerlink" title="2. 并发事务问题"></a>2. 并发事务问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读到另一个事务还没提交的数据</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202403141526258.png" alt="img"></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>一个事务先后读取同一条记录，但两次读取的数据不同</p>
<blockquote>
<p>脏读: 读到的是其他事务未提交的数据</p>
<p>不可重复读: 读到的是其他事务已提交的数据。</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202403141526926.png" alt="img"></p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202403141557246.png" alt="img"></p>
<h2 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h2><div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
</div>
<p>查看事务隔离级别：</p>
<p><code>SELECT @@TRANSACTION_ISOLATION;</code></p>
<p>设置事务隔离级别：</p>
<p><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code></p>
<ul>
<li>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/03/13/MySQL-1-%E5%AD%90%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/13/MySQL-1-%E5%AD%90%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">MySQL(1) 子查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-03-13 15:48:44 / Modified: 17:06:35" itemprop="dateCreated datePublished" datetime="2024-03-13T15:48:44+08:00">2024-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p>
<p>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</p>
<p>根据子查询结果可以分为：</p>
<ul>
<li>标量子查询（子查询结果为单个值）</li>
<li>列子查询（子查询结果为一列）</li>
<li>行子查询（子查询结果为一行）</li>
<li>表子查询（子查询结果为多行多列）</li>
</ul>
<p>根据子查询位置可分为：</p>
<ul>
<li><p>WHERE 之后</p>
</li>
<li><p>FROM 之后</p>
</li>
<li><p>SELECT 之后</p>
<ul>
<li><p>例如查询所有部门信息并统计部门人数</p>
</li>
<li><p>```sql<br>select d.id, d.name, (</p>
<pre><code>select count(*) from emp e where e.dept_id = d.id
</code></pre><p>) ‘人数’<br>from dept d;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>### 标量子查询<br><br>子查询返回的结果是单个值（数字、字符串、日期等）<br><br>常用的操作符：`= &lt;&gt; &gt; &gt;= &lt; &lt;=`<br><br>```sql<br>-- 查询销售部所有员工<br>select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);<br><br>-- 查询xxx入职之后的员工信息<br>select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><p>返回的结果是一列（可以是多行）</p>
<p>常用的操作符：</p>
<ul>
<li><code>IN</code>: 在指定的集合范围内，多选一</li>
<li><p><code>NOT IN</code>: 不在指定的集合范围内</p>
</li>
<li><p><code>ANY</code>: 子查询返回列表中，有任意一个满足即可</p>
</li>
<li><code>SOME</code>: 与ANY等同，使用SOME的地方都可以使用ANY</li>
<li><code>ALL</code>: 子查询返回列表的所有值都必须满足</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询销售部和市场部的所有员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> dept <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>);<br><br><span class="hljs-comment">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span>(<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> dept <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>));<br><br><span class="hljs-comment">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span> (<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> dept <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>));<br></code></pre></td></tr></table></figure>
<h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><p>返回的结果是一行（可以是多列）</p>
<p>常用的操作符：<code>=, &lt;&gt;, IN, NOT IN</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询与xxx的薪资及直属领导相同的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> (salary, manager) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> salary, manager <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><p>返回的结果是多行多列, 常用于 FROM 之后</p>
<p>常用的操作符：<code>IN</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee<br><span class="hljs-keyword">where</span> (job, salary) <span class="hljs-keyword">in</span> (<br>    <span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx1&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx2&#x27;</span><br>);<br><br><span class="hljs-comment">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.<span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> (<br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span><br>) e <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d<br><span class="hljs-keyword">on</span> e.dept <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/02/18/Redis-3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/18/Redis-3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="post-title-link" itemprop="url">Redis(3) 分布式锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-02-18 19:18:45 / Modified: 19:49:29" itemprop="dateCreated datePublished" datetime="2024-02-18T19:18:45+08:00">2024-02-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Redisson-分布式锁"><a href="#1-Redisson-分布式锁" class="headerlink" title="1. Redisson 分布式锁"></a>1. Redisson 分布式锁</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402181920501.png" alt="image-20240218192041327"></p>
<p><strong>可重入</strong>：利用hash结构记录线程id和重入次数</p>
<p><strong>可重试</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</p>
<p><strong>超时续约</strong>：利用watchDog，开启一个定时任务，每隔一段时间（releaseTime / 3），重置超时时间</p>
<p><strong>主从一致性问题</strong>：利用MultiLock锁，Redis不再区分主从节点，只有所有的节点都写入成功，才是加锁成功，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</p>
<h3 id="MultiLock原理"><a href="#MultiLock原理" class="headerlink" title="MultiLock原理"></a>MultiLock原理</h3><p>构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonClient2.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonClient3.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>lock = redissonClient.getMultiLock(lock1, lock2, lock3);<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RedissonMultiLock</span><span class="hljs-params">(RLock... locks)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locks.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Lock objects are not defined&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.locks.addAll(Arrays.asList(locks));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>联锁的tryLock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">newLeaseTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;<br>    <span class="hljs-comment">//如果传入了释放时间</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1L</span>) &#123;<br>        <span class="hljs-comment">//再判断一下是否有等待时间</span><br>        <span class="hljs-keyword">if</span> (waitTime == -<span class="hljs-number">1L</span>) &#123;<br>            <span class="hljs-comment">//如果没传等待时间，不重试，则只获得一次</span><br>            newLeaseTime = unit.toMillis(leaseTime);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//想要重试，耗时较久，万一释放时间小于等待时间，则会有问题，所以这里将等待时间乘以二</span><br>            newLeaseTime = unit.toMillis(waitTime) * <span class="hljs-number">2L</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取当前时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//剩余等待时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">remainTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">if</span> (waitTime != -<span class="hljs-number">1L</span>) &#123;<br>        remainTime = unit.toMillis(waitTime);<br>    &#125;<br>    <span class="hljs-comment">//锁等待时间，与剩余等待时间一样    </span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">lockWaitTime</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.calcLockWaitTime(remainTime);<br>    <span class="hljs-comment">//锁失败的限制，源码返回是的0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">failedLocksLimit</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.failedLocksLimit();<br>    <span class="hljs-comment">//已经获取成功的锁</span><br>    List&lt;RLock&gt; acquiredLocks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-built_in">this</span>.locks.size());<br>    <span class="hljs-comment">//迭代器，用于遍历</span><br>    ListIterator&lt;RLock&gt; iterator = <span class="hljs-built_in">this</span>.locks.listIterator();<br><br>    <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> (RLock)iterator.next();<br><br>        <span class="hljs-type">boolean</span> lockAcquired;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//没有等待时间和释放时间，调用空参的tryLock</span><br>            <span class="hljs-keyword">if</span> (waitTime == -<span class="hljs-number">1L</span> &amp;&amp; leaseTime == -<span class="hljs-number">1L</span>) &#123;<br>                lockAcquired = lock.tryLock();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//否则调用带参的tryLock</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">awaitTime</span> <span class="hljs-operator">=</span> Math.min(lockWaitTime, remainTime);<br>                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RedisResponseTimeoutException var21) &#123;<br>            <span class="hljs-built_in">this</span>.unlockInner(Arrays.asList(lock));<br>            lockAcquired = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var22) &#123;<br>            lockAcquired = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断获取锁是否成功</span><br>        <span class="hljs-keyword">if</span> (lockAcquired) &#123;<br>            <span class="hljs-comment">//成功则将锁放入成功锁的集合</span><br>            acquiredLocks.add(lock);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果获取锁失败</span><br>            <span class="hljs-comment">//判断当前锁的数量，减去成功获取锁的数量，如果为0，则所有锁都成功获取，跳出循环</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.locks.size() - acquiredLocks.size() == <span class="hljs-built_in">this</span>.failedLocksLimit()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//否则将拿到的锁都释放掉</span><br>            <span class="hljs-keyword">if</span> (failedLocksLimit == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">this</span>.unlockInner(acquiredLocks);<br>                <span class="hljs-comment">//如果等待时间为-1，则不想重试，直接返回false</span><br>                <span class="hljs-keyword">if</span> (waitTime == -<span class="hljs-number">1L</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                failedLocksLimit = <span class="hljs-built_in">this</span>.failedLocksLimit();<br>                <span class="hljs-comment">//将已经拿到的锁都清空</span><br>                acquiredLocks.clear();<br>                <span class="hljs-comment">//将迭代器往前迭代，相当于重置指针，放到第一个然后重试获取锁</span><br>                <span class="hljs-keyword">while</span>(iterator.hasPrevious()) &#123;<br>                    iterator.previous();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --failedLocksLimit;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果剩余时间不为-1，很充足</span><br>        <span class="hljs-keyword">if</span> (remainTime != -<span class="hljs-number">1L</span>) &#123;<br>            <span class="hljs-comment">//计算现在剩余时间</span><br>            remainTime -= System.currentTimeMillis() - time;<br>            time = System.currentTimeMillis();<br>            <span class="hljs-comment">//如果剩余时间为负数，则获取锁超时了</span><br>            <span class="hljs-keyword">if</span> (remainTime &lt;= <span class="hljs-number">0L</span>) &#123;<br>                <span class="hljs-comment">//将之前已经获取到的锁释放掉，并返回false</span><br>                <span class="hljs-built_in">this</span>.unlockInner(acquiredLocks);<br>                <span class="hljs-comment">//联锁成功的条件是：每一把锁都必须成功获取，一把锁失败，则都失败</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果设置了锁的有效期</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1L</span>) &#123;<br>        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(acquiredLocks.size());<br>        <span class="hljs-comment">//迭代器用于遍历已经获取成功的锁</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var24</span> <span class="hljs-operator">=</span> acquiredLocks.iterator();<br><br>        <span class="hljs-keyword">while</span>(var24.hasNext()) &#123;<br>            <span class="hljs-type">RLock</span> <span class="hljs-variable">rLock</span> <span class="hljs-operator">=</span> (RLock)var24.next();<br>            <span class="hljs-comment">//设置每一把锁的有效期</span><br>            RFuture&lt;Boolean&gt; future = ((RedissonLock)rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);<br>            futures.add(future);<br>        &#125;<br><br>        var24 = futures.iterator();<br><br>        <span class="hljs-keyword">while</span>(var24.hasNext()) &#123;<br>            RFuture&lt;Boolean&gt; rFuture = (RFuture)var24.next();<br>            rFuture.syncUninterruptibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//但如果没设置有效期，则会触发WatchDog机制，自动帮我们设置有效期，所以大多数情况下，我们不需要自己设置有效期</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/02/17/Redis-2-%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/17/Redis-2-%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Redis(2) 缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-02-17 14:43:48 / Modified: 17:02:02" itemprop="dateCreated datePublished" datetime="2024-02-17T14:43:48+08:00">2024-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-缓存更新"><a href="#1-缓存更新" class="headerlink" title="1. 缓存更新"></a>1. 缓存更新</h2><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是Redis为了节约内存而设计出来的，当我们向Redis插入太多数据，会导致内存占用过多，所以Redis会对部分数据进行更新，或者将其淘汰</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">内存淘汰</th>
<th style="text-align:center">超时剔除</th>
<th style="text-align:center">主动更新</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">说明</td>
<td style="text-align:center">不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。</td>
<td style="text-align:center">给缓存数据添加TTL时间， 到期后自动删除缓存。下次查询时更新缓存。</td>
<td style="text-align:center">编写业务逻辑，在修改数据库的同时更新缓存。</td>
</tr>
<tr>
<td style="text-align:center">一致性</td>
<td style="text-align:center">差</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">好</td>
</tr>
<tr>
<td style="text-align:center">维护成本</td>
<td style="text-align:center">无</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
</tr>
</tbody>
</table>
</div>
<p>业务场景</p>
<ul>
<li>低一致性需求：使用内存淘汰机制，例如店铺类型的查询缓存（因为这个很长一段时间都不需要更新）</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案，例如店铺详情查询的缓存</li>
</ul>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><ol>
<li>Cache Aside Pattern (人工编码方式)：缓存调用者在更新数据库的同时更新缓存，也称之为双写方案</li>
<li>Read/Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。<ul>
<li>缺点：但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li>
</ul>
</li>
<li>Write Behind Caching Pattern (写回法)：调用者只操作缓存，由其他线程异步地将缓存数据持久化到数据库，保证最终一致。<ul>
<li>优点：即使多次更新缓存，最终只需要更新一次到数据库</li>
<li>缺点：维护异步的任务比较复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li>
</ul>
</li>
</ol>
<p>综上所述，在企业的实际应用中，方案一更加可靠</p>
<h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><p><strong>问题1：删除缓存还是更新缓存</strong>(删除)</p>
<ul>
<li>更新缓存：每次更新数据库都需要更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，再次查询时更新缓存</li>
</ul>
<p><strong>问题2：如何保证缓存与数据库操作的同时成功或失败</strong></p>
<ul>
<li>单体系统：将缓存与数据库操作放在同一个事务</li>
<li>分布式系统：利用TCC等分布式事务方案</li>
</ul>
<p><strong>问题3：先操作缓存还是先操作数据库</strong>(数据库)</p>
<p>先删除缓存，再操作数据库</p>
<ul>
<li>删除缓存的操作很快，但是更新数据库的操作相对较慢，如果此时有一个线程2刚好进来查询缓存，由于我们刚刚才删除缓存，所以线程2需要查询数据库，并写入缓存，但是我们更新数据库的操作还未完成，所以线程2查询到的数据是脏数据，出现线程安全问题</li>
</ul>
<p>先操作数据库，再删除缓存</p>
<ul>
<li>假设线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短，但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题</li>
</ul>
<p>分析可得，先操作数据库，再删除缓存，出现线程安全问题的概率更低</p>
<h2 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2. 缓存穿透"></a>2. 缓存穿透</h2><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远都不会生效，会频繁的去访问数据库。</p>
<p>常见的解决方案：</p>
<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402171555801.png" alt="image-20240217155552738" style="zoom:80%;" /></p>
<ul>
<li>实现简单、维护方便</li>
<li>额外的内存消耗、可能造成短期的不一致</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904007790673933">布隆过滤器</a></h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402171555793.png" alt="image-20240217155529635" style="zoom:80%;" /></p>
<p>布隆过滤器其实采用的是哈希思想来解决这个问题，它实际上是一个初始值都为 0 的位图数组和一系列随机映射函数。布隆过滤器可以用于检索一个元素<strong>一定不存在或者可能存在</strong>一个集合中。</p>
<p>布隆过滤器会通过 3 个操作完成标记：</p>
<ul>
<li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li>
<li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li>
<li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li>
</ul>
<p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p>
<p>优点：内存占用较少，没有多余key</p>
<p>缺点：实现复杂、存在误判可能</p>
<blockquote>
<p>以上两种都属于被动的解决方案</p>
<p>可以通过增加id的复杂度，避免被猜测id规律，做好数据的基础格式校验</p>
<p>加强用户权限校验</p>
<p>做好热点参数的限流</p>
</blockquote>
<h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h2><ul>
<li>缓存雪崩是指在同一时间段，大量缓存的key同时失效，或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</li>
<li>解决方案<ul>
<li>给不同的Key的TTL添加随机值，让其在不同时间段分批失效</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
</li>
</ul>
<h2 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4. 缓存击穿"></a>4. 缓存击穿</h2><ul>
<li>缓存击穿也叫热点Key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击</li>
<li>举个不太恰当的例子：一件秒杀中的商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿</li>
<li>常见的解决方案有两种<ol>
<li>互斥锁：性能较差</li>
<li>逻辑过期</li>
</ol>
</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402171659737.png" alt="image-20240217165923508" style="zoom:80%;" /></p>
<h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402171701748.png" alt="image-20240217170100642"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">解决方案</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">互斥锁</td>
<td style="text-align:center">没有额外的内存消耗<br />保证一致性<br />实现简单</td>
<td style="text-align:center">线程需要等待，性能受影响<br />可能有死锁风险</td>
</tr>
<tr>
<td style="text-align:center">逻辑过期</td>
<td style="text-align:center">线程无需等待，性能较好</td>
<td style="text-align:center">不保证一致性<br />有额外内存消耗<br />实现复杂</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/02/04/JUC-13-AbstractQueuedSynchronizer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/04/JUC-13-AbstractQueuedSynchronizer/" class="post-title-link" itemprop="url">JUC(13) AbstractQueuedSynchronizer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-04 23:53:58" itemprop="dateCreated datePublished" datetime="2024-02-04T23:53:58+08:00">2024-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-12 23:16:32" itemprop="dateModified" datetime="2024-02-12T23:16:32+08:00">2024-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-AQS"><a href="#1-AQS" class="headerlink" title="1. AQS"></a>1. AQS</h2><h3 id="1-1-AQS理论知识"><a href="#1-1-AQS理论知识" class="headerlink" title="1.1 AQS理论知识"></a>1.1 AQS理论知识</h3><p>抽象的队列同步器</p>
<ul>
<li>是用来实现锁或者其他同步器组件的公共基础部分的抽象实现</li>
<li>是重量级基础框架及整个JUC体系的基石, 主要用于解决锁分配给”谁“的问题。</li>
<li>通过内置的CLH(FIFO)队列的变种来完成资源获取线程的排队工作, 将每条将要去抢占资源的线程封装成一个Node节点来实现锁的分配, 有一个int类变量表示持有锁的状态(<code>private volatile int state</code>), 通过CAS完成对state值的修改(0表示空闲, 大于等于1表示占有)<ul>
<li>CLH: Craig、Landin and Hagersten 队列, 是一个单向链表, AQS中的队列是CLH变体的虚拟双向队列FIFO</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.concurrent.locks;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedLongSynchronizer</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402111707435.png" alt="CLH 队列"></p>
<h3 id="1-2-AQS是JUC的基石"><a href="#1-2-AQS是JUC的基石" class="headerlink" title="1.2 AQS是JUC的基石"></a>1.2 AQS是JUC的基石</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402051511268.png" alt="image-20240205151132153"></p>
<ul>
<li>锁：面向锁的使用者, 定义了使用层API, 隐藏了实现细节</li>
<li>同步器：面向锁的实现者, DougLee提出了统一规范并简化了锁的实现, 将其抽象出来, 屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等, 是一切锁和同步组件实现的公共基础部分</li>
</ul>
<h3 id="1-3-AQS内部体系架构"><a href="#1-3-AQS内部体系架构" class="headerlink" title="1.3 AQS内部体系架构"></a>1.3 AQS内部体系架构</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402111709356.png" alt="img" style="zoom:67%;" /></p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">/** Marker to indicate a node is waiting in shared mode 共享模式*/</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode 独占模式*/</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">/** 线程被取消 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** 后续线程需要唤醒 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** 等待condition唤醒 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/** 共享式同步状态获取将会无条件的传播下去 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">/** 初始为0, 状态是上述几种 */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>    <span class="hljs-comment">// 前置节点</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">// 后继节点</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br><br>    Node nextWaiter;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>    &#125;<br><br>    <span class="hljs-comment">// @return the predecessor of this node</span><br>    <span class="hljs-keyword">final</span> Node <span class="hljs-title function_">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> prev;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    Node() &#123;&#125;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br><br>    Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>        <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>        <span class="hljs-built_in">this</span>.thread = thread;<br>    &#125;<br><br>    Node(Thread thread, <span class="hljs-type">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br>        <span class="hljs-built_in">this</span>.waitStatus = waitStatus;<br>        <span class="hljs-built_in">this</span>.thread = thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402111739635.png" alt="img" style="zoom:67%;" /></p>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>以 <code>ReentrantLock</code> 为例, Lock接口的实现类, 基本都是通过<strong>聚合</strong>了一个<strong>队列同步器的子类</strong>完成线程访问控制的</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402111722344.png" alt="img" style="zoom:50%;" /></p>
<blockquote>
</blockquote>
<h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(); <span class="hljs-comment">// 非公平锁</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-2-lock-amp-unlock"><a href="#2-2-lock-amp-unlock" class="headerlink" title="2.2 lock() &amp; unlock()"></a>2.2 lock() &amp; unlock()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-acquire"><a href="#2-3-acquire" class="headerlink" title="2.3 acquire()"></a>2.3 acquire()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><span class="hljs-comment">// AQS中直接抛出异常, 并没有实现, 子类要重写该方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402112111573.png" alt="img"></p>
<h4 id="tryAcquire-amp-hasQueuedPredecessors"><a href="#tryAcquire-amp-hasQueuedPredecessors" class="headerlink" title="tryAcquire() &amp; hasQueuedPredecessors()"></a>tryAcquire() &amp; hasQueuedPredecessors()</h4><p>公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="hljs-comment">// 这是与非公平锁唯一的区别</span><br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="hljs-comment">// 体现了可重入性</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对比公平锁和非公平锁的 <code>tryAcquire()</code> 方法, 其实差异就在于非公平锁获取锁时比公平锁中少了一个判断<code>!hasQueuedPredecessors()</code></p>
<p>hasQueuedPredecessors() 是公平锁加锁时判断等待队列中是否存在有效节点的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果当前线程前面有一个排队的线程, 则返回 true</span><br><span class="hljs-comment">// 如果当前线程位于队列的顶部或队列为空, 则返回 false</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// The correctness of this depends on head being initialized</span><br>    <span class="hljs-comment">// before tail and on head.next being accurate if the current</span><br>    <span class="hljs-comment">// thread is first in queue.</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    Node s;<br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>        ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="addWaiter-amp-enq"><a href="#addWaiter-amp-enq" class="headerlink" title="addWaiter() &amp; enq()"></a>addWaiter() &amp; enq()</h4><p>如果 <code>tryAcquire</code> 失败, 则会执行 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates and enqueues node for current thread and given mode.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the new node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node); <span class="hljs-comment">// 入队</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts node into queue, initializing if necessary.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 自旋</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>())) <span class="hljs-comment">// 头节点是虚节点</span><br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>双向链表中, 第一个节点为虚节点(也叫哨兵节点), 其实并不存储任何信息, 只是占位。真正的第一个有数据的节点, 是从第二个节点开始的</p>
<p>enq中不断通过自旋执行入队</p>
<h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Acquires in exclusive uninterruptible mode for thread already in</span><br><span class="hljs-comment"> * queue. Used by condition wait methods as well as acquire.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arg the acquire argument</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if interrupted while waiting</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否中断, 例如系统出问题了</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor(); <span class="hljs-comment">// 获得前置节点</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">//如果执行到这里, 说明前面持有资源的线程已经unpark了</span><br>                setHead(node); <span class="hljs-comment">// 将node内容清空, 变为虚节点</span><br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>shouldParkAfterFailedAcquire()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus; <span class="hljs-comment">// 获得前置节点的状态</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * This node has already set status asking a release</span><br><span class="hljs-comment">         * to signal it, so it can safely park.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">         * indicate retry.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">         * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">         */</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="hljs-comment">// 这里会将前置节点的status从初始化的0变为-1, 用于后续唤醒操作</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>parkAndCheckInterrupt()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Convenience method to park and then check if interrupted</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if interrupted</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 线程挂起, 程序不会继续向下执行</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted(); <span class="hljs-comment">// 在调用unpark方法后, 会继续执行</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>cancelAcquire()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cancels an ongoing attempt to acquire.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// Ignore if node doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    node.thread = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Skip cancelled predecessors</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>        node.prev = pred = pred.prev;<br><br>    <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span><br>    <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span><br>    <span class="hljs-comment">// or signal, so no further action is necessary.</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br><br>    <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span><br>    <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span><br>    <span class="hljs-comment">// Before, we are free of interference from other threads.</span><br>    node.waitStatus = Node.CANCELLED;<br><br>    <span class="hljs-comment">// If we are the tail, remove ourselves.</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>        <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>        <span class="hljs-type">int</span> ws;<br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                compareAndSetNext(pred, predNext, next);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            unparkSuccessor(node);<br>        &#125;<br><br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-4-release"><a href="#2-4-release" class="headerlink" title="2.4 release()"></a>2.4 release()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// 释放锁</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h); <span class="hljs-comment">// 唤醒头结点的后置节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>   <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>   <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>       free = <span class="hljs-literal">true</span>;<br>       setExclusiveOwnerThread(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 将持有资源的线程设置为null</span><br>   &#125;<br>   setState(c);<br>   <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a>unparkSuccessor()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123; <span class="hljs-comment">// node是头节点</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment"> * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment"> * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br><span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>    compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>); <span class="hljs-comment">// 哨兵节点状态置0</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment"> * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment"> * traverse backwards from tail to find the actual</span><br><span class="hljs-comment"> * non-cancelled successor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br><span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>    s = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>        <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>            s = t;<br>&#125;<br><span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>    LockSupport.unpark(s.thread); <span class="hljs-comment">// 为线程发放许可</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时唤醒节点B(队列中的第一个节点), 之前线程B在 <code>parkAndCheckInterrupt()</code> 被挂起</p>
<p>返回<code>return Thread.interrupted();</code>, 因为线程B从未中断过, 所以返回false。</p>
<ul>
<li><code>interrupted()</code>执行后具有清除状态标志值并设置为false的功能</li>
</ul>
<p><code>acquireQueued()</code> 因为返回 false, 所以继续循环, 获取B节点前驱节点p, p就是头结点, 然后执行 <code>tryAcquire()</code> 尝试获取锁, 因为刚才已经把锁释放了, 所以state等于0, <code>tryAcquire()</code> 能够获取锁成功。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/01/30/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/30/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">Java对象内存布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-30 23:40:38" itemprop="dateCreated datePublished" datetime="2024-01-30T23:40:38+08:00">2024-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-01 15:22:12" itemprop="dateModified" datetime="2024-02-01T15:22:12+08:00">2024-02-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-对象的内存布局"><a href="#1-对象的内存布局" class="headerlink" title="1. 对象的内存布局"></a>1. 对象的内存布局</h2><p>在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头(Header)、实例数据(Instance Data) 和对齐填充(Padding)</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401311100552.png" alt="img" style="zoom:67%;" /></p>
<h3 id="1-1-对象头"><a href="#1-1-对象头" class="headerlink" title="1.1 对象头"></a>1.1 对象头</h3><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节</p>
<h4 id="对象标记-Mark-Word"><a href="#对象标记-Mark-Word" class="headerlink" title="对象标记(Mark Word)"></a>对象标记(Mark Word)</h4><p>存储对象自身的运行时数据，如</p>
<ul>
<li><p>HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</p>
</li>
<li><p>这部分数据长度在 32 位和 64 位的虚拟机(未开启压缩指针)中分别为 32 个比特和 64 个比特</p>
</li>
<li>这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。</li>
<li>它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401311403433.png" alt="image-20240131140355382"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401311443678.png" alt="img" style="zoom: 50%;" /></p>
<p>对象分代年龄最大值为15，即(1111)</p>
<h4 id="类元信息-类型指针"><a href="#类元信息-类型指针" class="headerlink" title="类元信息(类型指针)"></a>类元信息(类型指针)</h4><p>对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<p>指向方法区中类的 Klass 类元信息</p>
<p><strong>压缩指针</strong></p>
<ul>
<li><code>java -XX:+PrintCommandLineFlags -version</code> 可查看虚拟机开启了哪些参数配置<ul>
<li><code>-XX:+UseCompressedClassPointers</code> 默认开启压缩指针，只占用 4 字节</li>
<li><code>-XX:-UseCompressedClassPointers</code> 关闭压缩指针</li>
</ul>
</li>
</ul>
<h3 id="1-2-实例数据"><a href="#1-2-实例数据" class="headerlink" title="1.2 实例数据"></a>1.2 实例数据</h3><p>存放类的属性（Field）数据信息，包括父类的属性信息</p>
<h3 id="1-3-对齐填充"><a href="#1-3-对齐填充" class="headerlink" title="1.3 对齐填充"></a>1.3 对齐填充</h3><p>虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐，这部分内存按8字节补充对齐。</p>
<h2 id="2-JOL"><a href="#2-JOL" class="headerlink" title="2. JOL"></a>2. JOL</h2><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(ClassLayout.parseInstance(o).toPrintable());<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">java.lang.Object object internals:</span><br><span class="hljs-comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="hljs-comment">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="hljs-comment">  8   4        (object header: class)    0xf80001e5</span><br><span class="hljs-comment"> 12   4        (object alignment gap)    </span><br><span class="hljs-comment">Instance size: 16 bytes</span><br><span class="hljs-comment">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">Customer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>System.out.println(ClassLayout.parseInstance(c).toPrintable());<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">top.whale.Customer object internals:</span><br><span class="hljs-comment">OFF  SZ      TYPE DESCRIPTION               VALUE</span><br><span class="hljs-comment">  0   8           (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="hljs-comment">  8   4           (object header: class)    0xf800c143</span><br><span class="hljs-comment"> 12   4       int Customer.id               0</span><br><span class="hljs-comment"> 16   1   boolean Customer.flag             false</span><br><span class="hljs-comment"> 17   7           (object alignment gap)    </span><br><span class="hljs-comment">Instance size: 24 bytes</span><br><span class="hljs-comment">Space losses: 0 bytes internal + 7 bytes external = 7 bytes total</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/01/10/JUC-12-ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/10/JUC-12-ThreadLocal/" class="post-title-link" itemprop="url">JUC(12) ThreadLocal</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-10 17:56:50" itemprop="dateCreated datePublished" datetime="2024-01-10T17:56:50+08:00">2024-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-30 23:36:14" itemprop="dateModified" datetime="2024-01-30T23:36:14+08:00">2024-01-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>面试题</p>
<ul>
<li>ThreadLocal中ThreadLocalMap的数据结构和关系</li>
<li>ThreadLocal的key是弱引用, 这是为什么？</li>
<li>ThreadLocal内存泄漏问题你知道吗？</li>
<li>ThreadLocal中最后为什么要加remove方法？</li>
</ul>
</blockquote>
<h2 id="1-ThreadLocal简介"><a href="#1-ThreadLocal简介" class="headerlink" title="1. ThreadLocal简介"></a>1. ThreadLocal简介</h2><p>ThreadLocal 提供线程局部变量。这些变量与正常的变量不同, 因为每一个线程在访问 ThreadLocal 实例的时候(通过其get或set方法)<strong>都有自己的、独立初始化的变量副本</strong>。ThreadLocal 实例通常是类中的私有静态字段, 使用它的目的是希望将状态(例如, 用户ID或事物ID)与线程关联起来。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111110081.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>&#123;<br>    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        threadLocal.set(threadLocal.get() + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyData</span> <span class="hljs-variable">myData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyData</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                threadPool.submit(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">beforeInt</span> <span class="hljs-operator">=</span> myData.threadLocal.get();<br>                        myData.add();<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">afterInt</span> <span class="hljs-operator">=</span> myData.threadLocal.get();<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; beforeInt: &quot;</span> + beforeInt + <span class="hljs-string">&quot; afterInt: &quot;</span> + afterInt);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        myData.threadLocal.remove();<br>                    &#125;<br>                &#125;);<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">pool-1-thread-1 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-3 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-2 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-2 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-3 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-1 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-2 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-1 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-3 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-2 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>如果不在 finally 块中调用 remove 会导致原先的值没有被清理, 默认值不再是 0, 而是上一个线程设置的值</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111543993.png" alt="image-20240111154336936"></p>
<p>因为每个 Thread 内有自己的<strong>实例副本</strong>且该副本只有当前线程自己使用</p>
<p>既然其他 ThreadLocal 不可访问, 那就不存在多线程间共享问题</p>
<p>统一设置初始值, 但是每个线程对这个值得修改都是各自线程互相独立的</p>
<p>如何才能不争抢</p>
<ul>
<li><p>加入synchronized或者Lock控制资源的访问顺序</p>
</li>
<li><p>ThreadLocal</p>
</li>
</ul>
<h2 id="2-ThreadLocal源码分析"><a href="#2-ThreadLocal源码分析" class="headerlink" title="2. ThreadLocal源码分析"></a>2. ThreadLocal源码分析</h2><h3 id="2-1-Thread、ThreadLocal、ThreadLocalMap关系"><a href="#2-1-Thread、ThreadLocal、ThreadLocalMap关系" class="headerlink" title="2.1 Thread、ThreadLocal、ThreadLocalMap关系"></a>2.1 Thread、ThreadLocal、ThreadLocalMap关系</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111613314.png" alt="image-20240111161342274" style="zoom: 80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111620299.png" alt="image-20240111162037251" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111619171.png" alt="img" style="zoom: 50%;" /></p>
<ul>
<li>Thread 对象维护着一个 ThreadLocalMap 的引用</li>
<li>ThreadLocalMap 是 ThreadLocal 的内部类, 用 Entry 来进行存储值</li>
<li>调用 ThreadLocal 的 set() 方法时, 实际上就是往 ThreadLocalMap 设置值, key 是 ThreadLocal 对象, 值 Value 是传递进来的对象</li>
<li>调用 ThreadLocal 的 get() 方法时, 实际上就是从 ThreadLocalMap 获取值, key 是 ThreadLocal 对象</li>
</ul>
<h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><h4 id="ThreadLocalMap-成员变量"><a href="#ThreadLocalMap-成员变量" class="headerlink" title="ThreadLocalMap 成员变量"></a>ThreadLocalMap 成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The initial capacity -- MUST be a power of two.</span><br><span class="hljs-comment">* 初始容量——必须是2的幂。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The table, resized as necessary.</span><br><span class="hljs-comment">* table.length MUST always be a power of two.</span><br><span class="hljs-comment">* 表可根据需要调整大小。表长度必须始终是2的幂。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> Entry[] table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The number of entries in the table.</span><br><span class="hljs-comment">* 表中的实体数。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next size value at which to resize.</span><br><span class="hljs-comment">* 扩容阈值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-get-源码"><a href="#ThreadLocal-get-源码" class="headerlink" title="ThreadLocal#get()源码"></a><code>ThreadLocal#get()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the value in the current thread&#x27;s copy of this</span><br><span class="hljs-comment"> * thread-local variable.  If the variable has no value for the</span><br><span class="hljs-comment"> * current thread, it is first initialized to the value returned</span><br><span class="hljs-comment"> * by an invocation of the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the current thread&#x27;s value of this thread-local</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t); <span class="hljs-comment">// 每个线程私有</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 以当前ThreadLocal对象为key, 获取Entry, 其中存放了value</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>此处说明 ThreadLocalMap 采用的是懒加载模式, 用时再去初始化</p>
</blockquote>
<h4 id="ThreadLocalMap-getEntry-源码"><a href="#ThreadLocalMap-getEntry-源码" class="headerlink" title="ThreadLocalMap#getEntry()源码"></a><code>ThreadLocalMap#getEntry()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the entry associated with key.  This method</span><br><span class="hljs-comment"> * itself handles only the fast path: a direct hit of existing</span><br><span class="hljs-comment"> * key. It otherwise relays to getEntryAfterMiss.  This is</span><br><span class="hljs-comment"> * designed to maximize performance for direct hits, in part</span><br><span class="hljs-comment"> * by making this method readily inlinable.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  key the thread local object</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Entry 是 ThreadLocalMap 的内部类, 继承自<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>, 因此 <code>e.get()</code> 获取的就是该 Entry 对应的 ThreadLocal</p>
<p>算出当前 key 在数组中下标 i, 通过当前线程局部变量的线程局部哈希码与 数组长度 - 1 做与运算。根据下标 i 获取对象 e, 如果 e 不为 null 且 e 的 key 等于当前线程局部变量, 则返回 e, 否则开启线性探测</p>
</blockquote>
<h4 id="线程局部哈希码-threadLocalHashCode-源码"><a href="#线程局部哈希码-threadLocalHashCode-源码" class="headerlink" title="线程局部哈希码 threadLocalHashCode 源码"></a>线程局部哈希码 threadLocalHashCode 源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ThreadLocals rely on per-thread linear-probe hash maps attached</span><br><span class="hljs-comment"> * to each thread (Thread.threadLocals and</span><br><span class="hljs-comment"> * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span><br><span class="hljs-comment"> * searched via threadLocalHashCode.  This is a custom hash code</span><br><span class="hljs-comment"> * (useful only within ThreadLocalMaps) that eliminates collisions</span><br><span class="hljs-comment"> * in the common case where consecutively constructed ThreadLocals</span><br><span class="hljs-comment"> * are used by the same threads, while remaining well-behaved in</span><br><span class="hljs-comment"> * less common cases.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The next hash code to be given out. Updated atomically. Starts at</span><br><span class="hljs-comment"> * zero.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The difference between successively generated hash codes - turns</span><br><span class="hljs-comment"> * implicit sequential thread-local IDs into near-optimally spread</span><br><span class="hljs-comment"> * multiplicative hash values for power-of-two-sized tables.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the next hash code.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>这里定义了一个 AtomicInteger 类型, 每次获取当前值并加上 HASH_INCREMENT, HASH_INCREMENT = 0x61c88647, 这个值和斐波那契散列有关(这是一种乘数散列法, 只不过这个乘数比较特殊, 是2^32乘以黄金分割比例的值, 即是1640531527, 16进制表示为 0x61c88647, 其主要目的就是为了让哈希码能均匀的分布在 2 的 n 次方的数组里, 也就是 Entry[] table 中, 这样做可以尽量避免 hash 冲突</p>
</blockquote>
<h4 id="ThreadLocalMap-getEntryAfterMiss-源码"><a href="#ThreadLocalMap-getEntryAfterMiss-源码" class="headerlink" title="ThreadLocalMap#getEntryAfterMiss()源码"></a><code>ThreadLocalMap#getEntryAfterMiss()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Version of getEntry method for use when key is not found in</span><br><span class="hljs-comment"> * its direct hash slot.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  key the thread local object</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  i the table index for key&#x27;s hash code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  e the entry at table[i]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>开启 while 循环, 当 e 的 key 与当前线程对象相等时, 返回 e</p>
<p>如果 e 的 key 等于 null, 开启探测式清理, 也就是 expungeStaleEntry() 方法</p>
<p>如果 e 的 key 不为 null, 且不等于当前线程对象, 说明哈希冲突了, 开启线性探测</p>
</blockquote>
<h4 id="ThreadLocalMap-expungeStaleEntry-源码"><a href="#ThreadLocalMap-expungeStaleEntry-源码" class="headerlink" title="ThreadLocalMap#expungeStaleEntry()源码"></a><code>ThreadLocalMap#expungeStaleEntry()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span><br><span class="hljs-comment"> * lying between staleSlot and the next null slot.  This also expunges</span><br><span class="hljs-comment"> * any other stale entries encountered before the trailing null.  See</span><br><span class="hljs-comment"> * Knuth, Section 6.4</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> staleSlot index of slot known to have null key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the index of the next null slot after staleSlot</span><br><span class="hljs-comment"> * (all between staleSlot and this slot will have been checked</span><br><span class="hljs-comment"> * for expunging).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// expunge entry at staleSlot</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br><br>                <span class="hljs-comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span><br>                <span class="hljs-comment">// null because multiple entries could have been stale.</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>当前位置的 key 等于 null, value 也置为 null, entry 也置为 null, size—</p>
<p>从当前位置的下一个位置 i 开始循环, 如果 e 等于 null, 退出循环, 否则向 i 的下一个位置继续循环。</p>
<p>如果 e 的 key 等于 null, value 也置为 null, entry 也置为 null, size–-。不为 null, 则计算当前线程局部变量的下标 h。如果 h 与 i (当前下标)不相等, 说明当时插入的时候发生了哈希冲突。开始 rehash, 将当前下标的 entry 清空, 从 h 开始寻找空位, 找到空位后插入当前对象。如果恰好 h 下标为 null, 那么当前线程局部变量则不会发生哈希冲突, 直接插入到 h 位置。</p>
<p>HashMap与ThreadLocalMap解决哈希冲突的区别：</p>
<ul>
<li>HashMap 使用的是链地址法, 当发生哈希冲突的时候, 使用链表来存储相同哈希码的数据, 满足一定条件, 还可以链表红黑树互相转换</li>
<li>ThreadLocalMap 使用的是线性探测法, 当发生哈希冲突的时候, 就往后寻找空位置, 直到寻找到空位置插入。</li>
</ul>
</blockquote>
<h4 id="ThreadLocal-setInitialValue-源码"><a href="#ThreadLocal-setInitialValue-源码" class="headerlink" title="ThreadLocal#setInitialValue()源码"></a><code>ThreadLocal#setInitialValue()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Variant of set() to establish initialValue. Used instead</span><br><span class="hljs-comment"> * of set() in case user has overridden the set() method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the initial value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue(); <span class="hljs-comment">// 如果初始化ThreadLocal时没有重写就返回null</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) &#123;<br>        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-createMap-源码"><a href="#ThreadLocal-createMap-源码" class="headerlink" title="ThreadLocal#createMap()源码"></a><code>ThreadLocal#createMap()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment"> * InheritableThreadLocal.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t the current thread</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstValue value for the initial entry of the map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-set-源码"><a href="#ThreadLocal-set-源码" class="headerlink" title="ThreadLocal#set()源码"></a><code>ThreadLocal#set()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment"> * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment"> * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment"> * method to set the values of thread-locals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment"> *        this thread-local.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocalMap-set-源码"><a href="#ThreadLocalMap-set-源码" class="headerlink" title="ThreadLocalMap#set()源码"></a><code>ThreadLocalMap#set()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Set the value associated with key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key the thread local object</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be set</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>    <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>    <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>    <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>    <span class="hljs-comment">// path would fail more often than not.</span><br><br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value; <span class="hljs-comment">// 覆盖</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i); <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value); <span class="hljs-comment">// 插入</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-remove-源码"><a href="#ThreadLocal-remove-源码" class="headerlink" title="ThreadLocal#remove()源码"></a><code>ThreadLocal#remove()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the current thread&#x27;s value for this thread-local</span><br><span class="hljs-comment"> * variable.  If this thread-local variable is subsequently</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span><br><span class="hljs-comment"> * reinitialized by invoking its &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method,</span><br><span class="hljs-comment"> * unless its value is &#123;<span class="hljs-doctag">@linkplain</span> #set set&#125; by the current thread</span><br><span class="hljs-comment"> * in the interim.  This may result in multiple invocations of the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> initialValue&#125; method in the current thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>     <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>         m.remove(<span class="hljs-built_in">this</span>);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-remove-源码-1"><a href="#ThreadLocal-remove-源码-1" class="headerlink" title="ThreadLocal#remove()源码"></a><code>ThreadLocal#remove()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove the entry for key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear(); <span class="hljs-comment">// this.referent = null;</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-ThreadLocal内存泄漏"><a href="#3-ThreadLocal内存泄漏" class="headerlink" title="3. ThreadLocal内存泄漏"></a>3. ThreadLocal内存泄漏</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111620299.png" alt="image-20240111162037251" style="zoom:67%;" /></p>
<ul>
<li>使用 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code> 将 ThreadLocal 对象变成一个<strong>弱引用</strong>对象</li>
<li>定义 Entry 类来继承 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code></li>
</ul>
<h3 id="3-1-强、软、弱、虚引用"><a href="#3-1-强、软、弱、虚引用" class="headerlink" title="3.1 强、软、弱、虚引用"></a>3.1 强、软、弱、虚引用</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401201853546.png" alt="image-20240120185333481" style="zoom:67%;" /></p>
<blockquote>
<p>Java 允许使用 <code>finalize()</code> 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</p>
</blockquote>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul>
<li>对于强引用的对象, 就算是出现了 OOM 也不会对该对象进行回收</li>
<li>当一个对象被强引用变量引用时, 它处于可达状态, 是不可能被垃圾回收机制回收的, 即使该对象以后永远都不会被用到, JVM 也不会回收, 因此强引用是造成 Java 内存泄露的主要原因之一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>obj = <span class="hljs-literal">null</span>;<br>System.gc();<br></code></pre></td></tr></table></figure>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul>
<li>是一种相对强引用弱化了一些的引用, 需要使用 <code>java.lang.ref.SoftReference</code> 类来实现, 可以让对象豁免一些垃圾回收</li>
<li>对于只有软引用的对象而言, <strong>当系统内存充足时, 不会被回收, 当系统内存不足时, 才会被回收</strong></li>
<li>软引用通常用在对内存敏感的程序中, 比如高速缓存, 内存够用就保留, 不够用就回收。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SoftReference&lt;MyObject&gt; softRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br>softRef.get()<br></code></pre></td></tr></table></figure>
<blockquote>
<p>假如有一个应用需要读取大量的本地图片:</p>
<ul>
<li>如果每次读取图片都从硬盘读取则会严重影响性能</li>
<li>如果一次性全部加载到内存中又可能造成内存溢出。此时使用软引用可以解决这个问题。</li>
</ul>
<p>设计思路是: 用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系, 在内存不足时, JVM会自动回收这些缓存图片对象所占用的空间, 从而有效地避免了OOM的问题。</p>
<p><code>Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;&gt;();</code></p>
</blockquote>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul>
<li>使用 <code>java.lang.ref.WeakReference</code> 类来实现, 比软引用的生命周期更短, 对于只有弱引用的对象而言, 只要垃圾回收机制一运行, 不管JVM的内存空间是否足够, 都会回收该对象占用的内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WeakSoftReference&lt;MyObject&gt; weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br>weakRef.get()<br></code></pre></td></tr></table></figure>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul>
<li><strong>虚引用必须和引用队列(<code>ReferenceQueue</code>)联合使用</strong><ul>
<li>虚引用需要 <code>java.lang.ref.PhantomReference</code> 类来实现, 与其他引用都不同, 虚引用并不决定对象的生命周期。<strong>如果一个对象仅持有虚引用, 那么它就和没有任何引用一样, 在任何时候都有可能被垃圾回收器回收, 它不能单独使用也不能通过它访问对象。</strong></li>
</ul>
</li>
<li><code>PhantomReference#get()</code> 总是返回 null<ul>
<li>虚引用的主要作用是跟踪对象被垃圾回收的状态。<strong>仅仅是提供了一种确保对象被 finalize 后, 做某些事情的通知机制。</strong></li>
</ul>
</li>
<li>处理监控通知使用<ul>
<li>设置虚引用关联对象的唯一目的, 就是在对象被 GC 的时候会收到一个系统通知或者后续添加进一步的处理, 用来实现比 finalize 机制更灵活的回收操作。</li>
</ul>
</li>
</ul>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PhantomReference(T referent, ReferenceQueue&lt;? <span class="hljs-built_in">super</span> T&gt; q)<br></code></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>ReferenceQueue&lt;MyObject&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>PhantomReference&lt;MyObject&gt; phantomReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(myObject, referenceQueue);<br><br>List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]);<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(phantomReference.get() + <span class="hljs-string">&quot; list add ok&quot;</span>);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyObject</span>&gt; reference = referenceQueue.poll();<br>        <span class="hljs-keyword">if</span> (reference != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;有虚对象回收加入了队列&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>
<h3 id="3-2-为什么使用弱引用"><a href="#3-2-为什么使用弱引用" class="headerlink" title="3.2 为什么使用弱引用"></a>3.2 为什么使用弱引用</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401302225249.png" alt="image-20240130222547134"></p>
<p>为什么要用弱引用：</p>
<ul>
<li>当方法执行完毕后, 栈帧销毁, 强引用 tl 也就没有了, 但此时线程的 ThreadLocalMap 里某个 entry 的 key 引用还指向这个对象</li>
<li>若这个 key 是强引用, 就会导致 key 指向的 ThreadLocal 对象及 v 指向的对象不能被 gc 回收, 造成内存泄露</li>
<li>使用弱引用就可以使 ThreadLocal 对象在方法执行完毕后顺利被回收且 Entry 的 key 引用指向为 null</li>
</ul>
<p>但如果当前线程迟迟不结束(例如线程池场景), 这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链</p>
<ul>
<li>value 对象需要 ThreadLocalMap 调用 get, set 时发现 key 为 null 才会去回收整个 entry, 因此弱引用不能 100% 保证内存不泄露, 我们要在不使用某个 ThreadLocal 对象后, 手动调用 remove 方法来删除它</li>
<li><p>在线程池中, 不仅仅是内存泄漏的问题, 因为线程池中的线程是重复使用的, 意味着这个线程的 ThreadLocalMap 对象也是重复使用的, 如果我们不手动调用 remove 方法, 那么后面的线程就有可能获取到上个线程遗留下来的 value 值</p>
</li>
<li><p>此后调用 get, set, remove 方法时, 就会尝试删除 key 为 null 的 Entry, 从而释放 value 对象占用的内存</p>
<ul>
<li>通过 <code>expungeStaleEntry</code>, <code>cleanSomeSlots</code>, <code>replaceStaleEntry</code> 这三个方法回收键为 null 的 Entry 对象的值(即value)以及 entry 对象本身从而防止内存泄漏, 属于安全加固的方法</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/01/09/JUC-11-CAS-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/09/JUC-11-CAS-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/" class="post-title-link" itemprop="url">JUC(11) CAS、自旋锁、原子操作类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-09 01:02:03" itemprop="dateCreated datePublished" datetime="2024-01-09T01:02:03+08:00">2024-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-10 17:55:53" itemprop="dateModified" datetime="2024-01-10T17:55:53+08:00">2024-01-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h2><h3 id="1-1-CAS概述"><a href="#1-1-CAS概述" class="headerlink" title="1.1 CAS概述"></a>1.1 CAS概述</h3><p>CAS(compare and swap)，中文翻译为比较并交换，实现并发算法时常用到的一种技术，用于保证共享变量的原子性更新，它包含三个操作数—-内存位置、预期原值与更新值。</p>
<p>执行CAS操作的时候，将内存位置的值与预期原值进行比较：</p>
<ul>
<li>如果相匹配，那么处理器会自动将该位置更新为新值</li>
<li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</li>
</ul>
<p>CAS 有 3 个操作数，位置内存值 V，旧的预期值 A，要修改的更新值 B。当且仅当旧的预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做或重试。</p>
<p>重试的这种行为称为<strong>自旋</strong>。原理有点类似乐观锁，修改带版本号。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091431044.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">5</span>);<br>    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2022</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicInteger.get());<span class="hljs-comment">//true	2022</span><br>    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2023</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicInteger.get());<span class="hljs-comment">//false	2022</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">true	2022</span><br><span class="hljs-comment">false	2022</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>CAS 是 JDK 提供的<strong>非阻塞</strong>原子性操作，它通过<strong>硬件保证</strong>了比较-更新的原子性。</p>
<p>CAS 是一条 CPU 的原子指令(<code>cmpxchg</code>指令)，不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法(如<code>compareAndSwapXXX</code>)底层实现即为CPU指令<code>cmpxchg</code></p>
<p>执行<code>cmpxchg</code>指令的时候，会判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，只有一个线程会对总线加锁成功，加锁成功之后会执行 CAS 操作，也就是说 <strong>CAS 的原子性实际上是 CPU 实现独占的</strong>，比起用 synchronized 重量级锁，这里的排他时间要短很多，所以在多线程情况下性能会比较好。</p>
<p>底层源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, Object var4, Object var5)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">long</span> var4, <span class="hljs-type">long</span> var6)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>var1: 表示要操作的对象</li>
<li>var2: 表示要操作对象中属性地址的偏移量</li>
<li>var4: 预期原值</li>
<li>var5/6: 更新值</li>
</ul>
<p><strong>原子类靠的是CAS思想，CAS思想实现靠的是Unsafe类。工作中尽量不要使用UnSafe类，使用不当容易出现问题</strong></p>
<h3 id="1-2-CAS原理"><a href="#1-2-CAS原理" class="headerlink" title="1.2 CAS原理"></a>1.2 CAS原理</h3><h4 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h4><p>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe 类存在于 sun.misc 包中，其内部方法操作可以像 C 的指针一样直接操作内存，因此 Java 中 CAS 操作的执行依赖于 Unsafe 类的方法。</p>
<p>注意：<strong>Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的所有方法都直接调用操作系统底层资源执行相应任务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6214790243416807050L</span>;<br><br>    <span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = unsafe.objectFieldOffset<br>                (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>valueOffset</code> 表示该变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的</li>
<li>value 用 volatile 修饰，保证多线程的可见性</li>
</ul>
<blockquote>
<p>问题：我们知道 i++ 是线程不安全的，那 <code>AtomicInteger.getAndIncrement()</code> 如何保证原子性？</p>
<p>AtomicInteger 类主要利用 CAS + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091520326.png" alt="img" style="zoom: 67%;" /></p>
<p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 中的各个方法。调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于 CAS 是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，不会造成所谓的数据不一致问题。</p>
</blockquote>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>假设线程 A 和线程 B 两个线程同时执行 <code>getAndAddInt</code> 操作(分别跑在不同CPU上):</p>
<ol>
<li>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicIntegeri 的 value 为 3，根据 JMM 模型，线程 A 和线程 B 各自持有一份值为 3 的 value 的副本分别到各自的工作内存</li>
<li>线程 A 通过 <code>getIntVolatile(var1, var2)</code> 拿到 value 值 3，这时线程 A 被挂起</li>
<li>线程 B 也通过 <code>getIntVolatile(var1, var2)</code> 方法获取到 value 值 3，此时刚好线程 B 没有被挂起并执行 <code>compareAndSwapInt</code> 方法比较内存值也为 3，成功修改内存值为 4</li>
<li>这时线程 A 恢复，执行 <code>compareAndSwapInt</code> 方法比较，发现自己手里的值数字 3 和主内存的值数字 4 不一致，说明该值已经被其它线程抢先一步修改过了，那 A 线程本次修改失败，只能重新读取重新来一遍了</li>
<li>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总是能够看到，线程 A 继续执行 <code>compareAndSwapInt</code> 进行比较替换，直到成功。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091530818.png" alt="image-20240109153017719"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091532475.png" alt="image-20240109153231399"></p>
<p>以 WIN10 为例</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091534127.png" alt="image-20240109153423046"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091535293.png" alt="image-20240109153542242"></p>
<p>总结：</p>
<ul>
<li>CAS 是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性</li>
<li>实现方式是基于硬件平台的汇编指令，在 intel 的 CPU 中，使用的是汇编指令 <code>compxchg</code> 指令</li>
<li>核心思想就是比较要更新变量 V 的值和预期值 E，相等才会将 V 的值设为新值 N，如果不相等自旋再来</li>
</ul>
<h3 id="1-3-原子引用-AtomicReference"><a href="#1-3-原子引用-AtomicReference" class="headerlink" title="1.3 原子引用 AtomicReference"></a>1.3 原子引用 AtomicReference</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    String userName;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">z3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;z3&quot;</span>, <span class="hljs-number">22</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">li4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;li4&quot;</span>, <span class="hljs-number">25</span>);<br><br>        atomicReference.set(z3);<br>        System.out.println(atomicReference.compareAndSet(z3, li4) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());<br>        System.out.println(atomicReference.compareAndSet(z3, li4) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">true	User(userName=li4, age=25)</span><br><span class="hljs-comment">false	User(userName=li4, age=25)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="1-4-CAS与自旋锁"><a href="#1-4-CAS与自旋锁" class="headerlink" title="1.4 CAS与自旋锁"></a>1.4 CAS与自旋锁</h3><p>CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果，至于自旋锁是指尝试获取锁的线程<strong>不会立即阻塞</strong>，而是<strong>采用循环的方式去尝试获取锁</strong>，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU</p>
<p>例如 <code>Unsafe#getAndAddInt</code> 方法中的 do-while 循环, 当操作成功返回 true 时，循环结束; 当返回 false 时，接着执行循环，继续尝试CAS操作，直到返回true</p>
<p>自己实现一个自旋锁</p>
<ul>
<li>通过 CAS 完成自旋锁，A 线程先进来调用 <code>myLock</code> 方法自己持有锁 5 秒钟，B 随后进来后发现当前有线程持有锁，所以只能通过自旋等待，直到 A 释放锁后 B 随后抢到。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLockDemo</span> &#123;<br>    <br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, thread)) &#123;&#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set successfully&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        atomicReference.compareAndSet(thread, <span class="hljs-literal">null</span>);<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t task over, unLock&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpinLockDemo</span> <span class="hljs-variable">spinLockDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpinLockDemo</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            spinLockDemo.unlock();<br>        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.lock();<br>            spinLockDemo.unlock();<br>        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A	 come in</span><br><span class="hljs-comment">A	 set successfully</span><br><span class="hljs-comment">B	 come in</span><br><span class="hljs-comment">A	 task over, unLock</span><br><span class="hljs-comment">B	 set successfully</span><br><span class="hljs-comment">B	 task over, unLock</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果还想支持可重入，可以增加一个 int 成员变量作为计数器</p>
<p><a target="_blank" rel="noopener" href="https://learnku.com/articles/49689">https://learnku.com/articles/49689</a></p>
</blockquote>
<h3 id="1-5-ABA问题"><a href="#1-5-ABA问题" class="headerlink" title="1.5 ABA问题"></a>1.5 ABA问题</h3><p>CAS 的缺点</p>
<ul>
<li>如果 CAS 失败，会一直进行尝试，长时间不成功会给 CPU 带来很大的开销</li>
<li>CAS 会导致 “ABA问题”</li>
</ul>
<p>ABA 问题是如何产生的</p>
<ul>
<li><p>CAS 算法实现一个重要前提是取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个<strong>时间差</strong>类会导致数据的变化</p>
</li>
<li><p>比如说一个线程 1 从内存位置 V 中取出 A，这时候另一个线程 2 也从内存中取出 A，并且线程2 进行了一些操作将值变成了 B，然后线程 2 又将 V 位置的数据变成 A，这时候线程 1 进行 CAS 操作发现内存中仍然是 A，预期OK，然后线程 1 操作成功</p>
</li>
<li><p>尽管线程 1 的 CAS 操作成功，但是不代表这个过程就是没有问题的</p>
</li>
</ul>
<p>解决方法</p>
<ul>
<li><p>比较 + 版本号</p>
</li>
<li><p>版本号时间戳原子引用(<code>AtomicStampedReference</code>)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        abaHappen();//true	2023</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * t3	首次版本号: 1</span><br><span class="hljs-comment">         * t4	首次版本号: 1</span><br><span class="hljs-comment">         * t3	2次版本号: 2</span><br><span class="hljs-comment">         * t3	3次版本号: 3</span><br><span class="hljs-comment">         * false	100	3</span><br><span class="hljs-comment">         */</span><br>        abaNoHappen();<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abaNoHappen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedReference.getStamp();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;首次版本号: &quot;</span> + stamp);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;2次版本号: &quot;</span> + atomicStampedReference.getStamp());<br>            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;3次版本号: &quot;</span> + atomicStampedReference.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedReference.getStamp();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;首次版本号: &quot;</span> + stamp);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>            System.out.println(b + <span class="hljs-string">&quot;\t&quot;</span> + atomicStampedReference.getReference() + <span class="hljs-string">&quot;\t&quot;</span> + atomicStampedReference.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abaHappen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            atomicInteger.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2023</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicInteger.get());<span class="hljs-comment">//true	2023</span><br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-原子操作类"><a href="#2-原子操作类" class="headerlink" title="2. 原子操作类"></a>2. 原子操作类</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401092007488.png" alt="在这里插入图片描述"></p>
<h3 id="2-1-基本类型原子类"><a href="#2-1-基本类型原子类" class="headerlink" title="2.1 基本类型原子类"></a>2.1 基本类型原子类</h3><p><code>AtomicInteger</code>, <code>AtomicBoolean</code>, <code>AtomicLong</code></p>
<p>常用API:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//获取当前的值，并设置新的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">//获取当前的值，并自增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值，并自减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> <span class="hljs-comment">//获取当前的值，并加上预期的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值(update)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySet</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></code></pre></td></tr></table></figure>
<p>Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumber</span> &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPlusPlus</span><span class="hljs-params">()</span> &#123;<br>        atomicInteger.getAndIncrement();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyNumber</span> <span class="hljs-variable">myNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyNumber</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(SIZE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= SIZE; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">10</span>; j++) &#123;<br>                        myNumber.addPlusPlus();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br><br>        &#125;<br>        countDownLatch.await();<br><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;result: &quot;</span> + myNumber.atomicInteger.get());<span class="hljs-comment">//main	result: 500</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>CountDownLatch 最佳实践：使用带有超时时间的 await 方法，通过判断count是否大于0，来判断是执行完毕还是代码超时。比起不带超时的await方法，优点在于等待时间可控，不会因意外一直等待。</p>
</blockquote>
<h3 id="2-2-数组类型原子类"><a href="#2-2-数组类型原子类" class="headerlink" title="2.2 数组类型原子类"></a>2.2 数组类型原子类</h3><p><code>AtomicIntegerArray</code>, <code>AtomicLongArray</code>, <code>AtomicReferenceArray</code></p>
<p>常用API:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//获取 index=i 位置元素的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndDecrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> delta)</span> <span class="hljs-comment">//获取 index=i 位置元素的值，并加上预期的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值(update)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//最终将 index=i 位置的元素设置为newValue, 使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></code></pre></td></tr></table></figure>
<p>Case:</p>
<p><code>AtomicIntegerArray</code>初始化必须指定数组或数组长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">atomicIntegerArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++)&#123;<br>        System.out.println(atomicIntegerArray.get(i)); <span class="hljs-comment">// 0 0 0 0 0</span><br>    &#125;<br>    <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;);<br>    array.getAndAdd(<span class="hljs-number">0</span>, <span class="hljs-number">999</span>);<br>    System.out.println(array.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 1000</span><br>    array.getAndIncrement(<span class="hljs-number">4</span>);<br>    System.out.println(array.get(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-引用类型原子类"><a href="#2-3-引用类型原子类" class="headerlink" title="2.3 引用类型原子类"></a>2.3 引用类型原子类</h3><ul>
<li><code>AtomicReference</code>: 引用类型原子类</li>
<li><p><code>AtomicStampedReference</code>: 原子更新带有<strong>版本号</strong>的引用类型。该类将整数值与引用关联起来。</p>
<ul>
<li>可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题</li>
<li><strong>解决修改过几次</strong></li>
</ul>
</li>
<li><p><code>AtomicMarkableReference</code>: 原子更新带有<strong>标记</strong>的引用类型。该类将 boolean 标记与引用关联起来</p>
<ul>
<li><strong>解决是否修改过</strong>，它的定义就是将标记戳简化为true/false，类似于一次性筷子</li>
</ul>
</li>
</ul>
<p>Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicMarkableReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;Integer&gt; markableReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markableReference.isMarked();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;默认标识: &quot;</span> + marked); <span class="hljs-comment">//t1	默认标识: false</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            markableReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>, marked, !marked);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markableReference.isMarked();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;默认标识: &quot;</span> + marked);<span class="hljs-comment">//t2	默认标识: false</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> markableReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2000</span>, marked, !marked);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;t2线程CASResult：&quot;</span> + b);<span class="hljs-comment">//t2	t2线程CASResult：false</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + markableReference.isMarked());<span class="hljs-comment">//t2	true</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + markableReference.getReference());<span class="hljs-comment">//t2	1000</span><br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-4-对象的属性修改原子类"><a href="#2-4-对象的属性修改原子类" class="headerlink" title="2.4 对象的属性修改原子类"></a>2.4 对象的属性修改原子类</h3><ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新对象中int类型字段的值</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新对象中Long类型字段的值</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新对象中引用类型字段的值</li>
</ul>
<p>使用目的: 以一种线程安全的方式操作非线程安全对象内的某些字段</p>
<p>使用要求:</p>
<ul>
<li>更新的对象属性必须使用 public volatile 修饰符</li>
<li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 <code>newUpdater()</code> 创建一个更新器，并且需要设置想要更新的类和属性</li>
</ul>
<p>AtomicIntegerFieldUpdater Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    AtomicIntegerFieldUpdater&lt;BankAccount&gt; atomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class, <span class="hljs-string">&quot;money&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferMoney</span><span class="hljs-params">(BankAccount bankAccount)</span> &#123;<br>        atomicIntegerFieldUpdater.getAndIncrement(bankAccount);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">BankAccount</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1000</span>; j++) &#123;<br>                        bankAccount.transferMoney(bankAccount);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br><br>        &#125;<br>        countDownLatch.await(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (countDownLatch.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;============执行超时============&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&#x27;\t&#x27;</span> + <span class="hljs-string">&quot;result: &quot;</span> + bankAccount.money); <span class="hljs-comment">//main	result: 10000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AtomicReferenceFieldUpdater Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 需求：多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作</span><br><span class="hljs-comment"> * 要求只能被初始化一次，只有一个线程操作成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVar</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">isInit</span> <span class="hljs-operator">=</span> Boolean.FALSE;<br>    <br>    AtomicReferenceFieldUpdater&lt;MyVar, Boolean&gt; referenceFieldUpdater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class, Boolean.class, <span class="hljs-string">&quot;isInit&quot;</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (referenceFieldUpdater.compareAndSet(<span class="hljs-built_in">this</span>, Boolean.FALSE, Boolean.TRUE)) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;--------------start init ,need 2 seconds&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;--------------over init&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;--------------已经有线程进行初始化工作了。。。。。&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyVar</span> <span class="hljs-variable">myVar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyVar</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myVar::init, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2	--------------已经有线程进行初始化工作了。。。。。</span><br><span class="hljs-comment">5	--------------已经有线程进行初始化工作了。。。。。</span><br><span class="hljs-comment">4	--------------已经有线程进行初始化工作了。。。。。</span><br><span class="hljs-comment">3	--------------已经有线程进行初始化工作了。。。。。</span><br><span class="hljs-comment">1	--------------start init ,need 2 seconds</span><br><span class="hljs-comment">1	--------------over init</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="2-5-原子操作增强类"><a href="#2-5-原子操作增强类" class="headerlink" title="2.5 原子操作增强类"></a>2.5 原子操作增强类</h3><ul>
<li><code>DoubleAccumulator</code>：一个或多个变量共同维护使用提供的函数更新的运行 double 值</li>
<li><code>DoubleAdder</code>：一个或多个变量共同维护最初的零和 double 总和</li>
<li><code>LongAccumulator</code>：一个或多个变量共同维护使用提供的函数更新的运行 double 值，提供了自定义的函数操作</li>
<li><code>LongAdder</code>：一个或多个变量共同维护最初的零和 long 总和，只能用来计算加法，且从 0 开始计算</li>
</ul>
<blockquote>
<p>面试题:</p>
<ol>
<li>热点商品点赞计算器，点赞数加加统计，不要求实时精确</li>
<li>一个很大的list，里面都是int类型，如何实现加加，思路？</li>
</ol>
</blockquote>
<p>以 <code>LongAdder</code> 为例，常用API:</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401100123470.png" alt="image.png" style="zoom:50%;" /></p>
<p>LongAdder, LongAccumulator Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    longAdder.add(<span class="hljs-number">3</span>);<br>    longAdder.increment();<br>    System.out.println(longAdder.sum()); <span class="hljs-comment">// 4</span><br>    longAdder.decrement();<br>    System.out.println(longAdder.sum()); <span class="hljs-comment">// 3</span><br><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((x, y) -&gt; x - y,<span class="hljs-number">0</span>);<br>    longAccumulator.accumulate(<span class="hljs-number">6</span>); <span class="hljs-comment">// 0 - 6</span><br>    longAccumulator.accumulate(<span class="hljs-number">2</span>); <span class="hljs-comment">// -6 - 2</span><br>    System.out.println(longAccumulator.get()); <span class="hljs-comment">// -8</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>比较不同方式实现高并发点赞消耗时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 需求：50个线程，每个线程100w次，消耗时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickNumber</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickBySynchronized</span><span class="hljs-params">()</span> &#123;<br>        number++;<br>    &#125;<br><br>    <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByAtomicLong</span><span class="hljs-params">()</span> &#123;<br>        atomicLong.getAndIncrement();<br>    &#125;<br><br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAdder</span><span class="hljs-params">()</span> &#123;<br>        longAdder.increment();<br>    &#125;<br><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>(Long::sum, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAccumulator</span><span class="hljs-params">()</span> &#123;<br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccumulatorCompareDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_100W</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ClickNumber</span> <span class="hljs-variable">clickNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClickNumber</span>();<br>        <span class="hljs-type">long</span> startTime;<br>        <span class="hljs-type">long</span> endTime;<br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_NUMBER);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_NUMBER);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_NUMBER);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_NUMBER);<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; _100W; j++) &#123;<br>                        clickNumber.clickBySynchronized();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch1.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch1.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;costTime: &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; 毫秒&quot;</span> + <span class="hljs-string">&quot;\t clickBySynchronized: &quot;</span> + clickNumber.number);<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; _100W; j++) &#123;<br>                        clickNumber.clickByAtomicLong();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch2.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch2.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;costTime: &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; 毫秒&quot;</span> + <span class="hljs-string">&quot;\t clickByAtomicLong: &quot;</span> + clickNumber.atomicLong.get());<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; _100W; j++) &#123;<br>                        clickNumber.clickByLongAdder();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch3.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch3.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;costTime: &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; 毫秒&quot;</span> + <span class="hljs-string">&quot;\t clickByLongAdder: &quot;</span> + clickNumber.longAdder.sum());<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; _100W; j++) &#123;<br>                        clickNumber.clickByLongAccumulator();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch4.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch4.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;costTime: &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; 毫秒&quot;</span> + <span class="hljs-string">&quot;\t clickByLongAccumulator: &quot;</span> + clickNumber.longAccumulator.get());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">costTime: 2522 毫秒	 clickBySynchronized: 50000000</span><br><span class="hljs-comment">costTime: 492 毫秒	 clickByAtomicLong: 50000000</span><br><span class="hljs-comment">costTime: 82 毫秒	 clickByLongAdder: 50000000</span><br><span class="hljs-comment">costTime: 54 毫秒	 clickByLongAccumulator: 50000000</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="2-6-原子操作增强类原理解析"><a href="#2-6-原子操作增强类原理解析" class="headerlink" title="2.6 原子操作增强类原理解析"></a>2.6 原子操作增强类原理解析</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401101344658.png" alt="img"></p>
<p><code>LongAdder</code> 是 <code>Striped64</code> 的子类</p>
<ul>
<li>如果是JDK8，推荐使用 <code>LongAdder</code> 对象，比 <code>AtomicLong</code> 性能更好(减少乐观锁的重试次数)</li>
<li>低更新争用下，<code>LongAdder</code> 与 <code>AtomicLong</code> 具有相似的特征；但在高争用的情况下，<code>LongAdder</code> 预期吞吐量明显更高，但代价是空间消耗更高</li>
</ul>
<h4 id="Striped64"><a href="#Striped64" class="headerlink" title="Striped64"></a>Striped64</h4><p>关键内部类与成员变量</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401101357105.png" alt="image-20240110135746035"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401101400905.png" alt="img" style="zoom: 50%;" /></p>
<p>Cell 是 java.util.concurrent.atomic 下 Striped64 的一个内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>    Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>        <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>    &#125;<br><br>    <span class="hljs-comment">// Unsafe mechanics</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            UNSAFE = sun.misc.Unsafe.getUnsafe();<br>            Class&lt;?&gt; ak = Cell.class;<br>            valueOffset = UNSAFE.objectFieldOffset<br>                (ak.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>@sun.misc.Contended</code> 用于避免<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyfonly/p/5800758.html">伪共享</a>, 单独占一个缓存行</p>
</blockquote>
<h4 id="LongAdder-为什么这么快"><a href="#LongAdder-为什么这么快" class="headerlink" title="LongAdder 为什么这么快"></a><code>LongAdder</code> 为什么这么快</h4><ul>
<li><p><code>LongAdder</code> 的基本思路就是<strong>分散热点</strong>，将 value 值分散到一个 Cell 数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多，如果要获取真正的 long 值，只要将各个槽中的变量值累加返回</p>
</li>
<li><p><code>sum()</code> 会将<strong>所有的 Cell 数组中的 value 和 base 累加作为返回值</strong>，核心的思想就是将之前 <code>AtomicLong</code> 一个 value 的更新压力分散到多个 value 中去，从而降级更新热点。</p>
</li>
<li><p>内部有一个base变量，一个Cell[]数组</p>
<ul>
<li><p>base变量：低并发，直接累加到该变量上</p>
</li>
<li><p>Cell[]数组：高并发，累加进各个线程自己的槽Cell[i]中</p>
</li>
</ul>
</li>
<li><p>$Sum = Base + \textstyle\sum_{i=1}^nCell[i].value$</p>
</li>
</ul>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p><code>LongAdder</code> 在无竞争的情况下，跟 <code>AtomicLong</code> 一样，对同一个 base 进行操作，当出现竞争关系时则是采用化整为零分散热点的做法，用空间换时间，用一个数组 cells，将一个 value 值拆分进这个数组 cells。多个线程需要同时对 value 进行操作的时候，可以对线程 id 进行 hash 得到 hash 值，再根据 hash 值映射到这个数组 cells 的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组 cells 的所有值和 base 都加起来作为最终结果</p>
<p>以 increment 为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Equivalent to &#123;<span class="hljs-doctag">@code</span> add(1)&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    add(<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * as 表示 cells 引用</span><br><span class="hljs-comment"> * b 表示获取的 base 值</span><br><span class="hljs-comment"> * v 表示期望值</span><br><span class="hljs-comment"> * m 表示 cells 数组的长度</span><br><span class="hljs-comment"> * a 表示当前线程命中的 cell 单元格</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>    Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;<br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended = a.cas(v = a.value, v + x)))<br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>单线程时 cells 为 null, 运行 <code>casBase</code>, 即只修改 base 值, 随后就结束方法</li>
<li>如果出现了多线程, <code>casBase</code> 可能返回 false, 执行 if 内部<ul>
<li>默认 <code>uncontended = true</code>, 没有冲突, <code>as == null</code> 为真, 执行 <code>longAccumulate</code>，初始化创建大小为 2 的Cell数组</li>
</ul>
</li>
<li>接下来执行 add 方法因为 as 不再为 null, 会直接执行 if 内部<ul>
<li><code>a = as[getProbe() &amp; m]) == null</code> 会判断 Cell 数组中的某个下标处是否为空</li>
<li>如果为空, 执行 longAccumulate, uncontended 为 ture</li>
<li>如果不为空, 执行 <code>!(uncontended = a.cas(v = a.value, v + x))</code><ul>
<li>将该槽位中的值加 x, 如果成功执行了, 则 uncontended 为 true, 方法结束</li>
<li>如果出现了冲突, uncontended 为 false, 执行 longAccumulate, 要进行扩容</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>条件递增，逐步解析</p>
<ul>
<li>最初无竞争只更新 base</li>
<li>如果更新 base 失败后，首次新建 Cell 数组</li>
<li>当多个线程竞争同一个 Cell 比较激烈时，可能需要对 Cell 数组扩容</li>
</ul>
</blockquote>
<h5 id="longAccumulate"><a href="#longAccumulate" class="headerlink" title="longAccumulate"></a>longAccumulate</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Handles cases of updates involving initialization, resizing,</span><br><span class="hljs-comment"> * creating new Cells, and/or contention. See above for</span><br><span class="hljs-comment"> * explanation. This method suffers the usual non-modularity</span><br><span class="hljs-comment"> * problems of optimistic retry code, relying on rechecked sets of</span><br><span class="hljs-comment"> * reads.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x the value</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fn the update function, or null for add (this convention</span><br><span class="hljs-comment"> * avoids the need for an extra field or function in LongAdder).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wasUncontended false if CAS failed before call</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn,</span><br><span class="hljs-params">                          <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;<br>    <span class="hljs-comment">// 存储线程的probe值，可以理解为hash值</span><br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// getProbe返回0说明随机数未初始化</span><br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br>        <span class="hljs-comment">// CASE1: cells已经被初始化了</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 1.1</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    <span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);   <span class="hljs-comment">// Optimistically create</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Cell[] rs; <span class="hljs-type">int</span> m, j;<br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                                rs[j] = r;<br>                                created = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (created)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                collide = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 1.2</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                wasUncontended = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <span class="hljs-comment">// 1.3</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                                         fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//1.4</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-comment">//1.5</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//1.6</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="hljs-comment">// 扩容</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 当前的 cells 与最先赋值的 as 是同一个，表示没有被其他线程扩容过</span><br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                collide = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">// CASE2: cells没有加锁且没有初始化，则尝试对他进行加锁，并初始化cells数组</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123; <span class="hljs-comment">// double check，防止创建多个数组</span><br>                    Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 初始化创建大小为2的Cell数组</span><br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);<br>                    cells = rs;<br>                    init = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// CASE3: cells正在进行初始化，则尝试直接在基数base上进行累加操作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                                    fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>首先给当前线程分配一个 hash 值，然后进入一个 for(;;)自旋，分为三个分支</p>
<ul>
<li>CASE1: cells已经被初始化了，其中又分为了 6 个 if 语句<ol>
<li>判断了当前线程 hash 后指向的数据位置元素是否为空，如果空则将Cell数据放入数组，跳出循环，不空则继续循环</li>
<li>wasUncontended 表示 cells 初始化后，当前线程竞争修改失败，这里只是将其设置为 true，紧接着执行 advanceProbe(h) 重置当前线程的 hash，重新循环</li>
<li>说明当前线程对应的数组中有了数据，也重置过 hash 值，这时通过 CAS 对当前数中的 value 进行累加 x 操作，如果 CAS 成功则跳出循环</li>
<li>如果 n 大于 CPU 最大数量，不可扩容，并通过 advanceProbe(h) 重置 hash，重新循环</li>
<li>如果扩容意向 collide 为 false 则修改为 true，然后重新计算线程 hash 继续循环。</li>
<li>扩容</li>
</ol>
</li>
<li>CASE2: cells没有加锁且没有初始化，则尝试对他进行加锁，并初始化cells数组</li>
<li>CASE3: cells正在进行初始化，则尝试直接在基数base上进行累加操作</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401101742044.png" alt="img" style="zoom:80%;" /></p>
<h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the current sum.  The returned value is &lt;em&gt;NOT&lt;/em&gt; an</span><br><span class="hljs-comment"> * atomic snapshot; invocation in the absence of concurrent</span><br><span class="hljs-comment"> * updates returns an accurate result, but concurrent updates that</span><br><span class="hljs-comment"> * occur while the sum is being calculated might not be</span><br><span class="hljs-comment"> * incorporated.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the sum</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>sum() 会将所有 Cell 数组中的 value 和 base 累加作为返回值。核心思想就是将之前 AtomicLong 一个 value 的更新压力分散到多个 value 中去，从而降级更新热点。</li>
<li><strong><code>sum()</code> 执行时，并没有限制对 base 和 cells 的更新，所以 <code>LongAdder</code> 不是强一致性的，它是最终一致性的</strong>，对cell的读取无法保证是最后一次写入的值，所以在没有并发的场景下，可以获得正确的结果</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>AtomicLong</code></p>
<ul>
<li>原理：CAS + 自旋</li>
<li>场景：低并发下的全局计算，AtomicLong 能保证并发情况下计数的准确性，其内部通过 CAS 来解决并发安全性问题</li>
<li>缺陷：高并发后性能急剧下降：AtomicLong 的自旋会成为瓶颈 (N 个线程 CAS 操作修改线程的值，每次只有一个成功过，其他 N-1 失败，失败的不停自旋直至成功，这样大量失败自旋的情况，一下子 CPU 就打高了)</li>
</ul>
<p><code>LongAdder</code></p>
<ul>
<li>原理：CAS + Base + Cell数组分散 (空间换时间并分散了热点数据)</li>
<li>场景：当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用。保证性能，精度代价</li>
<li>缺陷：sum 求和后还有计算线程修改结果的话，最后结果不够准确</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/01/08/JUC-10-volatile%E4%B8%8EJMM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/08/JUC-10-volatile%E4%B8%8EJMM/" class="post-title-link" itemprop="url">JUC(10) volatile与JMM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-08 15:25:42" itemprop="dateCreated datePublished" datetime="2024-01-08T15:25:42+08:00">2024-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-09 01:00:39" itemprop="dateModified" datetime="2024-01-09T01:00:39+08:00">2024-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-被volatile修饰的变量有两大特点"><a href="#1-被volatile修饰的变量有两大特点" class="headerlink" title="1. 被volatile修饰的变量有两大特点"></a>1. 被volatile修饰的变量有两大特点</h2><ul>
<li><p>特点：</p>
<ul>
<li><p>可见性</p>
</li>
<li><p>有序性：有排序要求，有时需要禁止指令重排</p>
<ul>
<li>不存在数据依赖关系可以重排，否则禁重排，重排后的指令也不能改变原有串行语义</li>
</ul>
</li>
</ul>
</li>
<li><p>内存语义：</p>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量的值</li>
<li>例如如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</li>
</ul>
</li>
<li><p>volatile凭什么可以保证可见性和有序性？</p>
<ul>
<li>内存屏障 Memory Barrier</li>
</ul>
</li>
</ul>
<h2 id="2-内存屏障"><a href="#2-内存屏障" class="headerlink" title="2. 内存屏障"></a>2. 内存屏障</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>内存屏障（也称内存栅栏，屏障指令等）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。内存屏障其实就是<strong>一种JVM指令</strong>，Java内存模型的重排规则会<strong>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</strong>，通过这些内存屏障指令，<strong>volatile实现了Java内存模型中的可见性和有序性（禁重排），但volatile无法保证原子性</strong></p>
<ul>
<li>内存屏障之前的所有写操作都要回写到主内存</li>
<li>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果（实现了可见性）</li>
</ul>
<blockquote>
<p><strong>写屏障(Store Memory Barrier)</strong>：告诉处理器在写屏障之前将所有存储在缓存(store buffers)中的数据同步到主内存，也就是说当看到Store屏障指令，就必须把该指令之前的所有写入指令执行完毕才能继续往下执行</p>
<p><strong>读屏障(Load Memory Barrier)</strong>：处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在Load屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。</p>
</blockquote>
<p>因此重排序时，<strong>不允许把内存屏障之后的指令重排序到内存屏障之前</strong>。一句话：对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读</p>
<h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>粗分两种：</p>
<ul>
<li>读屏障（Load Barrier）：在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。</li>
<li>写屏障（Store Barrier）：在写指令之后插入写屏障，强制把缓冲区的数据刷回到主内存中。</li>
</ul>
<p>细分四种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>屏障类型</strong></th>
<th><strong>指令示例</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LoadLoad</code></td>
<td>Load1;<br />LoadLoad;<br />Load2;</td>
<td>保证Load1的读取操作在Load2及后续读取操作之前执行</td>
</tr>
<tr>
<td><code>StoreStore</code></td>
<td>Store1;<br />StoreStore;<br />Store2;</td>
<td>在store2及其后的写操作执行前，保证Store1的写操作已经刷新到主内存</td>
</tr>
<tr>
<td><code>LoadStore</code></td>
<td>Load1;<br />LoadStore;<br />Store2;</td>
<td>在Store2及其后的写操作执行前，保证Load1的读操作已经结束</td>
</tr>
<tr>
<td><code>StoreLoad</code></td>
<td>Store1;<br />StoreLoad;<br />Load2;</td>
<td>保证Store1的写操作已经刷新到主内存后，Load2及其后的读操作才能执行</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-详解"><a href="#2-3-详解" class="headerlink" title="2.3 详解"></a>2.3 详解</h3><h4 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h4><p>通过内存屏障禁止重排</p>
<ul>
<li><p>重排序有可能影响程序的执行和实现，因此，我们有时候希望告诉JVM别自动重排序，我这里不需要重排序，一切听我的。</p>
</li>
<li><p>对于编译器的重排序，JMM会根据重排序的规则，禁止特定类型的编译器重排序</p>
</li>
<li><p>对于处理器的重排序，Java编译器在生成指令序列的适当位置，插入内存屏障指令，来禁止特定类型的处理器排序。</p>
</li>
</ul>
<h4 id="JMM-针对编译器制定的-volatile-重排序规则表"><a href="#JMM-针对编译器制定的-volatile-重排序规则表" class="headerlink" title="JMM 针对编译器制定的 volatile 重排序规则表"></a>JMM 针对编译器制定的 volatile 重排序规则表</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082018812.png" alt="image-20240108201812771"></p>
<ul>
<li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序，这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li>
<li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序，这个操作保证了volatile写之前的操作不会被重排到volatile写之后</li>
<li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排</li>
</ul>
<h4 id="JMM-将内存屏障插入策略分为-4-种规则"><a href="#JMM-将内存屏障插入策略分为-4-种规则" class="headerlink" title="JMM 将内存屏障插入策略分为 4 种规则"></a>JMM 将内存屏障插入策略分为 4 种规则</h4><blockquote>
<p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM 采取保守策略。下面是基于保守策略的 JMM 内存屏障插入策略。</p>
</blockquote>
<ul>
<li><p>读屏障：在每个<strong>volatile读操作的后面</strong>插入一个<code>LoadLoad</code>屏障和一个<code>LoadStore</code>屏障</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081952339.png" alt="image.png"></p>
</li>
<li><p>写屏障：在每个<strong>volatile写操作的前面</strong>插入<code>StoreStore</code>屏障；在每个<strong>volatile写操作的后面</strong>插入<code>StoreLoad</code>屏障；</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081952773.png" alt="image.png"></p>
</li>
</ul>
<blockquote>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的 volatile 内存语义。</p>
</blockquote>
<h2 id="3-volatile特性"><a href="#3-volatile特性" class="headerlink" title="3. volatile特性"></a>3. volatile特性</h2><h3 id="3-1-保证可见性"><a href="#3-1-保证可见性" class="headerlink" title="3.1 保证可见性"></a>3.1 保证可见性</h3><p>保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不加volatile，没有可见性，程序无法停止</span><br><span class="hljs-comment"> * 加了volatile，保证可见性，程序可以停止</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileSeeDemo</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * t1	-------come in</span><br><span class="hljs-comment">     * main	 修改完成</span><br><span class="hljs-comment">     * t1	-------flag被设置为false，程序停止</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------come in&quot;</span>);<br>            <span class="hljs-keyword">while</span> (flag) &#123;&#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------flag被设置为false，程序停止&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//更新flag值</span><br>        flag = <span class="hljs-literal">false</span>;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 修改完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>volatile变量的读写过程</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082159430.png" alt="img"></p>
<ul>
<li>read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存.</li>
<li>load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</li>
<li>use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</li>
<li>assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</li>
<li>store: 作用于工作内存，将赋值完毕的工作变量的值传送到主内存</li>
<li>write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量</li>
</ul>
<blockquote>
<p>由于上述 6 条只能保证单条指令的原子性，针对多条指令的组合性原子保证，JVM提供了另外两个原子指令:</p>
</blockquote>
<ul>
<li>lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</li>
<li>unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</li>
</ul>
<h3 id="3-2-没有原子性"><a href="#3-2-没有原子性" class="headerlink" title="3.2 没有原子性"></a>3.2 没有原子性</h3><p>volatile变量的复合操作不具有原子性，比如number++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileNoAtomicTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000</span>;j++)&#123;<br>                    number.add();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(number.number);<br>    &#125;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span>  <span class="hljs-type">int</span> number;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>            number++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在不给方法加锁的情况下，仅仅凭借volatile 修饰无法保证线程安全，最终的值也不是10000</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082214122.png" alt="img"></p>
<p>对于 volatile 变量具备可见性，JVM 只是保证从主内存加载到线程工作内存的值是最新的，也仅仅是数据加载时是最新的。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存 volatile 修饰变量发生修改之后，<strong>线程工作内存的操作将会作废去读主内存最新值，操作出现写丢失问题</strong>。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致。由此可见 volatile 解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步。</p>
<p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。i++ 不具备原子性，该操作是先读取值，然后写回一个新值，分 3 步完成。如果第二个线程在第一个线程读取旧值和写回新值期间读取 i 的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加 1 操作，这也就造成了线程安全失败，因此对于 add 方法必须使用 synchronized 修饰以便保证线程安全</p>
<p>volatile变量不适合参与到依赖当前值的运算</p>
<h3 id="3-3-指令禁重排"><a href="#3-3-指令禁重排" class="headerlink" title="3.3 指令禁重排"></a>3.3 指令禁重排</h3><p><strong>重排序</strong></p>
<p>重排序是指编译器和处理器为了犹化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序</p>
<ul>
<li>不存在数据依赖关系，可以重排序;</li>
<li>存在数据依赖关系，禁止重排序</li>
</ul>
<p>但重排后的指令绝对不能改变原有的串行语义!这点在并发设计中必须要重点考虑!</p>
<p><strong>重排序的分类和执行流程</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090002842.png" alt="image-20240109000227777"></p>
<ul>
<li>编译器优化的重排序: 编译器在不改变单线程中行语义的前提下，可以重新调整指令的执行顺序</li>
<li>指令级并行的重排序: 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序: 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行</li>
</ul>
<p>数据依赖性: 若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性</p>
<p>但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境</p>
<p>下面三种情况，只要重排序两个操作的执行次序，程序的执行结果就会被改变</p>
<ul>
<li>写后读、写后写、读后写</li>
</ul>
<p><strong>volatile有关的禁止指令重排行为 与 四大屏障的插入情况</strong></p>
<p>详见 2.3</p>
<p>代码说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 线程 A 运行</span><br>        i = <span class="hljs-number">2</span>;<br>    	flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 线程 B 运行</span><br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果 flag 没有被 volatile 修饰，且 i 和 flag 没有数据依赖性，假如 write 方法中发生了指令重排，可能导致 i 没有被赋值就被 read 打印</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090018466.png" alt="image-20240109001829395" style="zoom: 67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090019875.png" alt="image-20240109001925798" style="zoom:67%;" /></p>
<h2 id="4-如何正确使用volatile"><a href="#4-如何正确使用volatile" class="headerlink" title="4. 如何正确使用volatile"></a>4. 如何正确使用volatile</h2><p>单一赋值可以，但是含复合运算赋值不可以（i++之类）</p>
<p>状态标志，判断业务是否结束</p>
<ul>
<li>作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束</li>
</ul>
<p>开销较低的读，写锁策略</p>
<ul>
<li>当读远多于写，结合使用内部锁和volatile变量来减少同步的开销</li>
<li>原理是：利用volatile保证读操作的可见性，利用synchronized保证符合操作的原子性</li>
</ul>
<p>DCL双端锁的发布</p>
<ul>
<li>实例化对象时会分为三步：<ol>
<li>分配对象内存空间</li>
<li>初始化对象</li>
<li>设置 instance 指向刚分配的内存地址</li>
</ol>
</li>
<li>多线程环境下，在实例化对象时，由于重排序导致 2，3 乱序，即先分配地址再初始化，后果就是其他线程可能会获得一个未完全初始化的实例</li>
<li>要通过 volatile 声明来实现线程安全的延迟初始化</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090034422.png" alt="img" style="zoom: 50%;" /></p>
<h2 id="5-小总结"><a href="#5-小总结" class="headerlink" title="5. 小总结"></a>5. 小总结</h2><p><strong>volatile可见性</strong></p>
<ol>
<li>写操作的话，这个变量的最新值会立即刷新回到主内存中</li>
<li>读操作的话，总是能够读取到这个变量的最新值，也就是这个变量最后被修改的值</li>
<li>当某个线程收到通知，去读取volatile修饰的变量的值的时候，线程私有工作内存的数据失效，需要重新回到主内存中去读取最新的数据。</li>
</ol>
<blockquote>
<p>在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</p>
<p>lock 前缀的指令在多核处理器下会引发两件事情:</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>
</ul>
<p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p>
<p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
</blockquote>
<p><strong>volatile没有原子性</strong></p>
<p><strong>volatile禁重排</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090053498.png" alt="image.png" style="zoom:33%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090054393.png" alt="image.png" style="zoom: 50%;" /></p>
<p><strong>为什么添加了volatile关键字,系统底层就加入了内存屏障</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090055930.png" alt="img" style="zoom:50%;" /></p>
<p><strong>讲讲内存屏障</strong></p>
<p>是一种屏障指令，它使得CPU或编译器对屏障指令的前和后所发出的内存操作执行一个排序的约束。也称为内存栅栏或栅栏指令。</p>
<p>用于组织屏障两边的指令重排序</p>
<ul>
<li>写操作时加入屏障，强制将线程私有工作内存的数据刷回主物理内存</li>
<li>读操作时加入屏障，线程私有工作内存的数据失效，重新回到主物理内存中获取最新值</li>
</ul>
<p>四大指令</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090059511.png" alt="image.png" style="zoom:33%;" /></p>
<p>总结</p>
<ul>
<li>volatile写之前的操作，都禁止重排序到volatile之后</li>
<li>volatile读之后的操作，都禁止重排序到volatile之前</li>
<li>volatile写之后volatile读，禁止重排序</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/01/08/JUC-9-JMM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/08/JUC-9-JMM/" class="post-title-link" itemprop="url">JUC(9) JMM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-01-08 01:28:06 / Modified: 15:20:15" itemprop="dateCreated datePublished" datetime="2024-01-08T01:28:06+08:00">2024-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>面试题</p>
<ul>
<li>你知道什么是Java内存模型JMM吗？</li>
<li>JMM和volatile他们两个之间的关系？</li>
<li>JMM有哪些特征或者它的三大特征是什么？</li>
<li>为什么要有JMM，它为什么出现？作用和功能是什么？</li>
<li>happens-before先行并发原则你有了解过吗？</li>
</ul>
</blockquote>
<h2 id="1-JMM"><a href="#1-JMM" class="headerlink" title="1. JMM"></a>1. JMM</h2><h3 id="1-1-计算机硬件存储体系"><a href="#1-1-计算机硬件存储体系" class="headerlink" title="1.1 计算机硬件存储体系"></a>1.1 计算机硬件存储体系</h3><p>CPU的运行并不是直接操作内存而是先把内存里面的数据读到缓存，而内存的读和写操作的时候会造成不一致的问题。JVM规范中试图定义一种Java内存模型来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现让Java程序再各种平台下都能达到一致性的<strong>内存访问效果</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081324075.png" alt="img" style="zoom:80%;" /></p>
<h3 id="1-2-JMM概述"><a href="#1-2-JMM概述" class="headerlink" title="1.2 JMM概述"></a>1.2 JMM概述</h3><p>JMM(Java内存模型Java Memory Model, 简称JMM)本身是一种<strong>抽象的</strong>概念并不真实存在它仅仅<strong>描述的是一组约定或规范</strong>，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</p>
<p>原则:</p>
<ul>
<li>JMM的关键技术点都是围绕多线程的<strong>原子性、可见性和有序性</strong>展开的</li>
</ul>
<p>作用:</p>
<ul>
<li>通过JMM来实现线程和主内存之间的抽象关系。</li>
<li>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li>
</ul>
<h2 id="2-JMM规范下，三大特性"><a href="#2-JMM规范下，三大特性" class="headerlink" title="2. JMM规范下，三大特性"></a>2. JMM规范下，三大特性</h2><p>可见性、原子性、有序性</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>是指当一个线程修改了某一个共享变量的值，其他线程是否能够<strong>立即</strong>知道该变更，JMM规定了所有的变量都存储在<strong>主内存</strong>中</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081354774.png" alt="img" style="zoom: 33%;" /></p>
<p>系统中主内存<strong>共享变量</strong>数据修改被写入的时机是不确定的，<strong>多线程并发下很可能出现“脏读”</strong>，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的<strong>主内存副本拷贝</strong>，线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行，而不能够直接写入主内存中的变量，不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>对于一个线程的执行代码而言，我们总是习惯性地认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行<strong>重新排序</strong>。Java规范规定JVM线程内部维持<strong>顺序化语义</strong>，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序<strong>不一致，此过程叫指令的重排序</strong></p>
<p>优缺点：</p>
<ul>
<li><p>JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令更符合CPU的执行特性，最大限度的发挥机器性能。</p>
</li>
<li><p>但是指令重排<strong>可以保证串行语义一致</strong>，但没有义务保证多线程的语义也一致（即可能产生“脏读”），简单而言就是两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。</p>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081422853.png" alt="img"></p>
<ul>
<li>单线程环境里确实能够保证程序最终执行结果和代码顺序执行的结果一致</li>
<li>处理器在进行重排序时必须考虑到指令之间的<strong>数据依赖性</strong></li>
<li>多线程环境中线程交替执行，由于编译器优化重排的存在，可能出现乱序现象，两个线程使用的变量能否保证一致性是无法确定的，结果无法预测</li>
</ul>
<h2 id="3-JMM规范下，多线程对变量的读写过程"><a href="#3-JMM规范下，多线程对变量的读写过程" class="headerlink" title="3. JMM规范下，多线程对变量的读写过程"></a>3. JMM规范下，多线程对变量的读写过程</h2><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有的地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读写赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存存储着主内存中的变量副本拷贝，因此不同的线程无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081429603.png" alt="image.png" style="zoom: 50%;" /></p>
<p>JMM定义了线程和主内存之间的抽象关系：</p>
<ul>
<li>线程之间的共享变量存储在主内存中（从硬件角度讲就是内存条）</li>
<li>每个线程都有一个自己的本地工作内存，本地工作内存中存储了该线程用来读写共享变量的副本（<strong>从硬件角度来说就是CPU的缓存</strong>）</li>
</ul>
<p>小总结：</p>
<ul>
<li>我们定义的所有共享变量都储存在物理主内存中</li>
<li>每个线程都有自己独立的工作内存，里面保证该线程使用到的共享变量的副本（主内存中该变量的一份拷贝）</li>
<li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存在读写（不能越级）</li>
<li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能互相访问）。</li>
</ul>
<h2 id="4-JMM规范下，多线程先行发生原则之happens-before"><a href="#4-JMM规范下，多线程先行发生原则之happens-before" class="headerlink" title="4. JMM规范下，多线程先行发生原则之happens-before"></a>4. JMM规范下，多线程先行发生原则之happens-before</h2><p>在JVM中，如果<strong>一个操作执行的结果需要对另一个操作可见或者代码重排序</strong>，那么这两个操作之间必须存在happens-before（先行发生）原则，逻辑上的先后关系。</p>
<blockquote>
<p>x, y 案例说明：</p>
<ul>
<li><p>A 线程执行：x = 5</p>
</li>
<li><p>B 线程执行：y = x</p>
</li>
</ul>
<p>如果线程 A 的操作 happens-before（先行发生）线程 B，那么可以确定线程 B 执行 y = 5 一定成立</p>
<p>如果他们不存在 happens-before 原则，那么 y = 5 不一定成立</p>
<p>happens-before原则<strong>包含可见性和有序性的约束</strong></p>
</blockquote>
<p>如果Java内存模型中所有的有序性都仅靠 volatile 和 synchronized 来完成，那么有很多操作都将变得非常繁琐，但是我们在编写Java并发代码的时候并没有察觉到这一点。</p>
<p>我们没有时时、处处、次次添加 volatile 和 synchronized 来完成程序，这是因为Java语言中JMM原则下，有一个“先行发生”（happens-before）原则限制。</p>
<p>这个原则非常重要：它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型晦涩难懂的底层编译原理之中。</p>
<h3 id="4-1-happens-before-总原则"><a href="#4-1-happens-before-总原则" class="headerlink" title="4.1 happens-before 总原则"></a>4.1 happens-before 总原则</h3><ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li>
<li>如果两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排之后的执行结果与按照happens-before关系来执行的<strong>结果一致</strong>，那么这种重排序<strong>并不非法</strong>。</li>
</ul>
<h3 id="4-2-happens-before-8-条原则"><a href="#4-2-happens-before-8-条原则" class="headerlink" title="4.2 happens-before 8 条原则"></a>4.2 happens-before 8 条原则</h3><blockquote>
<p>从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：</p>
</blockquote>
<ol>
<li><p><strong>次序规则</strong>：<strong>一个线程内</strong>，按照代码的顺序，写在前面的操作先行发生于写在后面的操作，也就是说前一个操作的结果可以被后续的操作获取（保证语义串行性，按照代码顺序执行）</p>
</li>
<li><p><strong>锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作（后面指时间上的先后）</p>
</li>
<li><p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的后面同样指时间上的先后</p>
</li>
<li><p><strong>传递规则</strong>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
</li>
<li><p><strong>线程启动规则</strong>（Thread start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作</p>
</li>
<li><p><strong>线程中断规则</strong>（Thread Interruption Rule）：</p>
<ol>
<li><p>对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>
</li>
<li><p>可以通过<code>Thread.interrupted()</code>检测到是否发生中断</p>
</li>
<li><p>也就是说你要先调用<code>interrupt()</code>方法设置过中断标志位，我才能检测到中断发生</p>
</li>
</ol>
</li>
<li><p><strong>线程终止规则</strong>（Thread Termination Rule）：线程中的所有操作都优先发生于对此线程的终止检测，我们可以通过<code>isAlive()</code>等手段检测线程是否已经终止执行</p>
</li>
<li><p><strong>对象终结规则</strong>（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize(）方法的开始，即对象没有完成初始化之前，是不能调用finalized()方法的</p>
</li>
</ol>
<h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><ul>
<li><p>在Java语言里面，Happens-before的语义本质上是一种可见性</p>
</li>
<li><p>A happens-before B, 意味着 A 发生过的事情对 B 而言是可见的，无论 A 事件和 B 事件是否发生在同一线程里</p>
</li>
<li><p>JVM的设计分为两部分：</p>
<ul>
<li><p>一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了</p>
</li>
<li><p>另一部分是针对 JVM 实现的，为了尽可能少的对编译器和处理器做约束从而提升性能，JMM 在不影响程序执行结果的前提下对其不做要求，即允许优化重排序，我们只要关注前者就好了，也就是理解 happens-before 规则即可，其他繁杂的内容由 JMM 规范结合操作系统给我们搞定，我们只写好代码即可</p>
</li>
</ul>
</li>
</ul>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> ++value;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>问题描述：假设存在线程A和B，线程A先（时间上的先后）调用了<code>setValue()</code>方法，然后线程B调用了同一个对象的<code>getValue()</code>方法，那么线程B收到的返回值是什么？</p>
<p>答案：不一定</p>
<blockquote>
<p>分析happens-before规则（规则5，6，7，8可以忽略，和代码无关）</p>
<ol>
<li><p>由于两个方法由不同线程调用，不满足一个线程的条件，不满足程序次序规则</p>
</li>
<li><p>两个方法都没有用锁，不满足锁定规则</p>
</li>
<li><p>变量没有使用volatile修饰，所以不满足volatile变量规则</p>
</li>
<li><p>传递规则肯定不满足</p>
</li>
</ol>
<p>综上：无法通过 happens-before 原则推导出 A happens-before B，虽然可以确定时间上线程 A 优于线程 B，但就是无法确定线程 B 获得的结果是什么，所以<strong>这段代码不是线程安全的</strong></p>
<p>注意：</p>
<ul>
<li><strong>如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证他们的有序性，虚拟机可以随意对他们进行重排序</strong></li>
</ul>
</blockquote>
<p>改进方法：</p>
<ul>
<li>把 getter/setter 方法都定义为 synchronized 方法<ul>
<li>不好，重量级锁，并发性下降</li>
</ul>
</li>
<li>把 value 定义为 volatile 变量，由于 setter 方法对 value 的修改不依赖 value 的原值，满足 volatile 关键字使用场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 利用volatile保证读取操作的可见性，</span><br><span class="hljs-comment">* 利用synchronized保证符合操作的原子性</span><br><span class="hljs-comment">* 结合使用锁和volatile变量来减少同步的开销</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> ++value;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/01/01/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/01/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">软件质量管理往年题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-01 15:22:45" itemprop="dateCreated datePublished" datetime="2024-01-01T15:22:45+08:00">2024-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-03 22:05:24" itemprop="dateModified" datetime="2024-01-03T22:05:24+08:00">2024-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">软件质量管理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-选择"><a href="#1-选择" class="headerlink" title="1. 选择"></a>1. 选择</h2><ol>
<li><p>“Measure twice, cut once” 描述的是下述哪个软件开发场景：B</p>
<p>A. 软件设计； </p>
<p><strong>B. 代码评审；</strong></p>
<p>C. 需求开发； </p>
<p>D. V&amp;V；</p>
</li>
<li><p>整体来看, 我们可以把软件的发展分为三大阶段, 以下不属于三大主要阶段的是：C</p>
<p>A. 软硬件一体化；(1950s - 1970s)</p>
<p>B. 网络化和服务化；(1990s - )</p>
<p><strong>C. 云计算化和云原生；</strong> </p>
<p>D.软件成为独立产品；(1970s - 1990s)</p>
</li>
<li><p>以下描述中, 不属于软件开发本质困难或者本质挑战的是：A</p>
<p><strong>A. 质量难题；</strong> </p>
<p>B. 复杂性； </p>
<p>C. 不可见； </p>
<p>D. 一致性；</p>
</li>
<li><p>以下描述中, 哪一种实践是软硬件一体化阶段的典型实践：A</p>
<p><strong>A. Code and Fix；</strong> </p>
<p>B. 迭代式开发； </p>
<p>C. 瀑布生命周期模型； </p>
<p>D. 成熟度模型；</p>
<blockquote>
<p>D 大概是软件成为独立的产品</p>
</blockquote>
</li>
<li><p>对比TSP和SCRUM, 下列说法不恰当的是：C</p>
<p>A. 都是过程框架, 需要填补具体实践之后才是一个可以工作的过程； </p>
<p>B. 一种是计划驱动方法, 另外一种是敏捷方法； </p>
<p><strong>C. SCRUM适合迭代式场景, TSP适合瀑布场景；</strong> </p>
<p>D. 两种方法都需要进行度量数据收集、分析, 从而支持管理决策；</p>
<blockquote>
<p>两者都适合迭代式开发</p>
<p>B 待定, 真实商业场景的所有项目都是计划驱动的</p>
</blockquote>
</li>
<li><p>以下特征适用麦克勒格Y理论(McGregors Theory Y)激励的场合是：D</p>
<p>A. 关注工作环境, 薪金等； </p>
<p>B. 更喜欢经常的指导, 避免承担责任, 缺乏主动性 </p>
<p>C. 自我中心, 对组织需求反应淡漠, 反对变革 </p>
<p><strong>D. 能够自我约束, 自我导向与控制, 渴望承担责任</strong></p>
<blockquote>
<p>X 人性本恶</p>
<p>Y 人性本善</p>
</blockquote>
</li>
<li><p>以下关于马斯洛的需求层次理论描述不正确的是：AD</p>
<p><strong>A. 自我实现是寻求自尊(Esteem)</strong></p>
<p>B. 激励来自为没有满足的需求而努力奋斗 </p>
<p>C. 低层次的需求必须在高层次需求满足之前得到满足 </p>
<p><strong>D. 满足高层次的需求的途径比满足低层次的途径更少</strong></p>
<blockquote>
<p>A 自我实现是第五层, 自尊在第四层；</p>
</blockquote>
</li>
<li><p>以下关于团队动力学的论述, 不恰当的是： A</p>
<p><strong>A. 马斯洛的需求层次理论可以用来更好地维持激励水平；</strong> </p>
<p>B. 智力工作的激励方式中, 应该尽可能使用鼓励承诺这种方式； </p>
<p>C. 麦克勒格的X理论适合用马斯洛底层需求激励； </p>
<p>D. 海兹伯格的激励理论区分为内在因素和外在因素两种</p>
<blockquote>
<p>马斯洛的需求层次理论可用于指导激励手段的选择, 不是激励维持手段</p>
</blockquote>
</li>
<li><p>下述关于WBS的描述中, 哪些说法不正确的？A</p>
<p><strong>A. WBS应该对应OBS</strong> </p>
<p>B. WBS提供了范围管理的基础 </p>
<p>C. WBS工作分解最底层的要素是实现目标的充分必要条件 </p>
<p>D. WBS分解的时候, 同一层不能应用不同标准</p>
</li>
<li><p>下述关于EVM的描述中, 哪些说法不正确的？ B</p>
<p>A. EVM不适用于质量管理 </p>
<p><strong>B. EVM的中级实现中引入成本信息</strong> </p>
<p>C. EVM高度依赖估算准确 </p>
<p>D. EVM可以适应需求变更</p>
<blockquote>
<p>挣值管理。顺序：进度信息、日程偏差、实际成本。</p>
</blockquote>
</li>
<li><p>下列关于挣值管理方法的描述中正确的是：ABC</p>
<p><strong>A. 挣值管理中进度的计算可以区分悲观和乐观两种方式；</strong></p>
<p><strong>B. 挣值管理的简单、中级和高级实现三种方式中, 只有高级实现才会涉及成本因素；</strong></p>
<p><strong>C. 挣值管理与项目类型无关；</strong></p>
<p>D. 挣值管理不适用与需求频繁变更的软件项目管理当中</p>
<blockquote>
<p>D 适合</p>
</blockquote>
</li>
<li><p>关于PSP质量管理策略, 下列说法中正确的是： ABD</p>
<p><strong>A. 用缺陷管理替代质量管理, 既有必要性, 也有合理性；</strong> </p>
<p><strong>B. 基本无缺陷的开发是通过开展高质量的评审来实现的；</strong></p>
<p>C. 经过训练, 评审是所有消除缺陷的手段当中最高效的； </p>
<p><strong>D. PSP质量策略主要解决的是外部质量, 而非内部质量；</strong></p>
<blockquote>
<p>C 编译最高效</p>
<p>D PSP 使用面向用户的视图, 主要解决外部质量, 关注的缺陷就是外部质量</p>
</blockquote>
</li>
<li><p>【答案待定】关于DRL, 下列说法中不正确的是：CDE</p>
<p>A. 这是一种模块级开发中质量控制的指标 </p>
<p>B. DRL以单元测试每小时发现缺陷率作为基准, 考察上游其他缺陷消除阶段的消除效率； </p>
<p><strong>C. DRL以单元测试发现的缺陷个数作为基准, 考察上游其他缺陷消除阶段消除缺陷的效率；</strong> </p>
<p><strong>D. DRL只能预测, 不能度量</strong></p>
<p><strong>【2022】E. DRL期望值是大于2.0</strong></p>
<blockquote>
<p>C 每小时</p>
<p>D 可以度量</p>
<p>E 22年考试新增选项, 对错待定。A/FR的期望值是2.0</p>
</blockquote>
</li>
<li><p>关于PQI, 下列说法中不正确的是：BCD</p>
<p>A. PQI表征模块级别开发中的过程规范化程度 </p>
<p><strong>B. PQI越高越好, 可以充分保障质量；</strong> </p>
<p><strong>C. PQI越低越好；</strong> </p>
<p><strong>D. PQI不能用作质量规划</strong></p>
<blockquote>
<p>BC 越高成本也越高, 大于0.4即可</p>
<p>D 可以用作质量规划</p>
</blockquote>
</li>
<li><p>关于PQI, 下列说法中正确的是：AB</p>
<p><strong>A. PQI可以辅助判断模块开发质量</strong> </p>
<p><strong>B. PQI可以提供过程改进的依据</strong> </p>
<p>C. PQI确保大于1, 从而确保开发质量； </p>
<p>D. PQI只能预测, 不能度量</p>
</li>
<li><p>关于Yield, 下列说法中正确的是：ABCD</p>
<p><strong>A. Yield可以辅助判断模块开发质量</strong> </p>
<p><strong>B. Yield可以提供过程改进的依据</strong> </p>
<p><strong>C. Yield区分为Process Yield和Phase Yield；</strong> </p>
<p><strong>D. Yield只能预测, 不能度量</strong></p>
</li>
<li><p>关于评审速度, 下列说法中正确的是：C</p>
<p>A. 进行代码评审的时候, 控制评审速度不超过每小时1000LOC就能实现大部分质量要求； </p>
<p>B. 实战中, 评审速度应该根据资源水平而定, 时间充分就评审慢一些； </p>
<p><strong>C. 文档评审速度应该控制每小时不超过4页；</strong> </p>
<p>D. 评审速度与人的技能有关, 技能强的人可以突破 每小时1000 LOC代码这个限制；</p>
<blockquote>
<p>200LOC/h, 4page/h</p>
</blockquote>
</li>
<li><p>关于Humphrey 梳理的Quality Journey, 下列说法中正确的是：CD</p>
<p>A. Quality Journey中列出的步骤可以在适当的时候更换顺序； </p>
<p>B. 由于需求是一切工程活动的基础, 因此加强需求开发应该是Quality Journey早期的必备步骤； </p>
<p><strong>C. Quality Journey仍然仅仅是在“用缺陷管理替代质量管理”这一基本策略之下进行讨论；</strong> </p>
<p><strong>D. Quality Journey中测试应该先于评审得到贯彻和改善</strong></p>
<blockquote>
<p>A 不能更换</p>
<p>B 质量路径与需求无关</p>
</blockquote>
</li>
<li><p>下述设计模板中用来记录内部动态信息的是：B</p>
<p>A. OST； </p>
<p><strong>B. SST；</strong> </p>
<p>C. LST； </p>
<p>D. FST；</p>
</li>
<li><p>下述关于PSP四大设计模板和UML典型设计图 的描述中完全正确的是：B</p>
<p>A.OST在UML中没有对应的设计图；</p>
<p><strong>B.UML中的类结构以及类之间的关系, 在PSP四大设计模板中无法体现；</strong></p>
<p>C.LST在UML中可以通过类图来体现； </p>
<p>D.FST在UML中可以通过类图来体现；</p>
<blockquote>
<p>A 用例图和时序图</p>
<p>C UML中没有对应图示</p>
<p>D UML类图中记录了方法的型构, 然而方法的行为没有描述, 而在PSP的FST中有相应的内容</p>
</blockquote>
</li>
<li><p>一个完全正确的状态机应该满足：ABCE</p>
<p><strong>A.没有死循环和陷阱；</strong></p>
<p><strong>B.状态转化条件满足正交性；</strong> </p>
<p><strong>C.状态转化条件满足完整性；</strong> </p>
<p>D.状态转化条件满足独立性；</p>
<p><strong>E.符合设计意图</strong></p>
</li>
<li><p>下列关于各种设计验证手段的描述中正确的是：C</p>
<p>A.执行表是唯一一种提供全面设计验证的手段； </p>
<p>B.跟踪表是唯一一种提供全面设计验证的手段； </p>
<p><strong>C.受限于手工方式, 都易于出错；</strong> </p>
<p>D.符号化执行不适合复杂的数学计算；</p>
<blockquote>
<p>D 待定</p>
</blockquote>
</li>
<li><p>关于使用程序正确性证明手段验证while-do循环设计的描述中, 正确的是：ABCD</p>
<p><strong>A. 如果设计是正确的, 那么应满足的条件之一是循环判断条件最后一定可以变为false；</strong> </p>
<p><strong>B. 如果设计是正确的, 那么应满足的条件之一是循环判断条件为真的时候, 单独的循环结构执行结果与循环体再加一个循环结构, 其执行结果一致；</strong> </p>
<p><strong>C. 如果设计是正确的, 那么应满足的条件之一是循环判断条件为false的时候, 循环体内所有变量不能被修改；</strong> </p>
<p><strong>D. 该方法并不能保证循环体算法实现设计意图。</strong></p>
</li>
<li><p>下述关于质量的描述中, 哪些说法不正确的？C</p>
<p>A.质量是一种多重属性的组合</p>
<p>B.最终用户一般不能感知内部质量</p>
<p><strong>C.安全和保密一般不是质量要素</strong></p>
<p>D.质量与主观感受有关</p>
</li>
<li><p>下述关于质量控制指标, 哪些说法正确？C</p>
<p>A.A/FR应该是越高越好</p>
<p>B.Yield是一种精确度量模块质量的手段</p>
<p><strong>C.评审活动应该早于编译或者测试活动而开展</strong></p>
<p>D.PQI只能事后统计, 不能用于指导质量计划</p>
<blockquote>
<p>A 越高成本也高</p>
<p>B 发展趋势, 不精确</p>
<p>D 可以指导</p>
</blockquote>
</li>
<li><p>下述设计验证手段的描述, 哪些是正确的？A</p>
<p><strong>A.符号化执行容易引入人为错误</strong></p>
<p>B.状态机验证是唯一一种提供一般意义的上的正确性检验的验证手段</p>
<p>C.执行表的对设计缺陷的验证能力强于跟踪表</p>
<p>D.正确性检验是唯一可靠的设计验证手段</p>
<blockquote>
<p>B 应该是符号化执行, 跟踪表基于符号化执行</p>
<p>C 弱于</p>
<p>D 不是唯一</p>
</blockquote>
</li>
<li><p>下面描述属于典型客户需求的是：ABC</p>
<p><strong>A.客户期望；</strong> </p>
<p><strong>B.预算限制；</strong> </p>
<p><strong>C.法律法规限制；</strong> </p>
<p>D.系统功能描述</p>
</li>
<li><p>在团队设计活动中, 应该注意设计标准, 下列属于典型的设计标准应该约定的是：ABCD</p>
<p><strong>A.命名规范；</strong> </p>
<p><strong>B.接口标准；</strong> </p>
<p><strong>C.出错或者异常处理信息；</strong> </p>
<p><strong>D.设计表示方式</strong></p>
</li>
<li><p>典型地, 在团队设计活动中, 应该注意哪些内容：ABCD</p>
<p><strong>A.设计标准的应用；</strong> </p>
<p><strong>B.复用的考虑；</strong> </p>
<p><strong>C.可测试性支持；</strong> </p>
<p><strong>D.可用性支持</strong></p>
</li>
<li><p>关于集成策略, 下述描述中正确的是：BCD</p>
<p>A. 当待集成组件质量普遍不高的时候, 不可以使用扁平化策略；</p>
<p><strong>B. 当需要尽早获取可以工作的组件的时候,  应该使用集簇式策略；</strong> </p>
<p><strong>C. 当待集成组件质量普通较高的时候, 可以使用大爆炸式集成策略；</strong> </p>
<p><strong>D. 持续集成本质上就是逐一添加策略。</strong></p>
<blockquote>
<p>A 应该使用扁平化, 不该使用大爆炸</p>
</blockquote>
</li>
<li><p>当考虑集成策略的时候, 应该注意如下哪些方面？：ABCD</p>
<p><strong>A. 待集成组件的质量状态；</strong> </p>
<p><strong>B. 待集成组件的获取方式；</strong></p>
<p><strong>C. 待集成组件的功能和关系；</strong> </p>
<p><strong>D. 待集成组件的数量；</strong></p>
</li>
<li><p>关于扁平化集成策略和集簇式集成策略, 下述说法中正确的是：BC</p>
<p>A. 扁平化策略可以较早地充分地暴露系统级别的错误； </p>
<p><strong>B. 扁平化策略对于系统级别错误的暴露能力有限；</strong> </p>
<p><strong>C. 集簇式集成策略有助于复用策略的实现；</strong> </p>
<p>D. 扁平化策略和集簇式策略的优缺点正好相反；</p>
<blockquote>
<p>A 较早但并不充分</p>
<p>D 大爆炸和逐一添加才是相反的</p>
</blockquote>
</li>
<li><p>下述活动是典型的验证(Verification)的是：BC </p>
<p>A. 需求评审； </p>
<p><strong>B. 详细设计评审；</strong> </p>
<p><strong>C. 单元测试；</strong> </p>
<p>D. 试运行；</p>
<blockquote>
<p>一头一尾(需求评审, 验收测试)是确认, 其他是验证</p>
</blockquote>
</li>
<li><p>下述活动是典型的确认(Validation)的是：A</p>
<p><strong>A. 验收测试；</strong> </p>
<p>B. 代码评审； </p>
<p>C. 系统测试； </p>
<p>D. 持续集成；</p>
</li>
<li><p>下述产物中属于典型的确认(Validation)对象的是：BCD</p>
<p>A.接口设计文档；</p>
<p><strong>B.源代码；</strong> </p>
<p><strong>C.用户手册；</strong> </p>
<p><strong>D.系统使用培训材料(视频、录像等)；</strong></p>
<blockquote>
<p>需要向客户提交的工作产品是确认的对象</p>
</blockquote>
</li>
<li><p>下述关于需求开发的描述中, 哪些是正确的？BC</p>
<p>A. 客户需求是指客户提出的关于软件功能的具体要求 </p>
<p><strong>B. 工期或者预算往往都是客户需求的一个方面</strong></p>
<p><strong>C. 产品需求需要跟客户充分讨论才能获取</strong></p>
<p>D. 客户应该在需求开发活动中起到主导作用</p>
</li>
<li><p>下述产物中属于典型的配置项是：ABCD</p>
<p><strong>A. 接口设计文档；</strong> </p>
<p><strong>B. 源代码；</strong> </p>
<p><strong>C. 用户手册；</strong> </p>
<p><strong>D. 系统使用培训材料(视频、录像等)；</strong></p>
</li>
<li><p>团队内部的配置审计通常应该关注什么：ABCD</p>
<p><strong>A. 物理审计；</strong></p>
<p><strong>B. 配置项列表；</strong> </p>
<p><strong>C. 配置管理记录；</strong> </p>
<p><strong>D. 基线计划；</strong></p>
</li>
<li><p>下列关于决策分析的论述中, 不恰当的是：BD</p>
<p>A. 决策分析指南中最关键的是明确需要开展决策分析活动的判定标准, 即什么场合之下需要开展正式的决策分析活动； </p>
<p><strong>B.评价方法是体现决策者利益诉求的关键, 因此, 需要谨慎设计；</strong> </p>
<p>C.候选方案的识别应该晚于于评价标准； </p>
<p><strong>D.现实生活中的项目投标就是一个典型的决策分析活动；</strong></p>
<blockquote>
<p>B 评价标准</p>
<p>D 招标</p>
<p>决策分析顺序：建立决策分析指南、建立评价标准、识别候选方案、选择评价方法、评价候选方案、选择解决方案</p>
</blockquote>
</li>
<li><p>下列关于根因分析的论述中, 不恰当的是：AD</p>
<p><strong>A. 根因分析必须基于丰富的数据来选择合适的问题；</strong> </p>
<p>B. 鱼骨图是根因分析的有效手段； </p>
<p>C. 典型地, 可以从技术、人员、培训以及过程角度开展根因分析； </p>
<p><strong>D. 根因分析活动终止的唯一特征就是找到相应的根因的明确解决方案；</strong></p>
<blockquote>
<p>A 没有数据也可以依靠主观判断</p>
<p>D 或者解决方案明确不存在</p>
</blockquote>
</li>
<li><p>【答案待定】以下关于规模估算和度量的描述中, 正确的是：B</p>
<p>A. 功能点是一种可提供精确规模度量结果的方式</p>
<p><strong>B. 规模数据扮演了沟通历史数据的桥梁的角色</strong></p>
<p>C. 规模估算通常不用于质量计划当中</p>
<p>D. PROBE 只用于规模估算</p>
<blockquote>
<p>A FP基于主观而非客观数据</p>
<p>CD 待定</p>
</blockquote>
</li>
<li><p>【答案待定】关于 PSP 缺陷日志, 哪些信息是至关重要的: ACD</p>
<p><strong>A.缺陷发现时间</strong></p>
<p>B.缺陷重现方式</p>
<p><strong>C.缺陷根因描述</strong></p>
<p><strong>D.缺陷关联的其他缺陷</strong></p>
</li>
<li><p>关于Brooks提及的软件开发本质难题, 下列说法中不准确的是。AB</p>
<p><strong>A.本质难题总共有四个, 分别为复杂、不可见、可变和质量挑战</strong></p>
<p><strong>B.既然是本质难题, 那就说明是根植于软件开发本身, 因而是不可能在软件开发当中得到缓解</strong></p>
<p>C.严格来说, 只有不可见才是真正的“本质”难题, 其他三个因项目而异</p>
<p>D.四大本质难题贯穿软件发展的不同历史段, 但是在不同历史阶段, 相互凸显程度不一样</p>
</li>
<li><p>下列软件应用和开发的典型特征中属于软硬件一体化阶段的是？BC</p>
<p>A.可以通过引入操作系统, 摆脱了硬件束缚</p>
<p><strong>B.几乎不需要考虑需求变更</strong></p>
<p><strong>C.缺乏科班的软件工程师</strong></p>
<p>D.系统兼容对应软件开发的成败非常关键</p>
<blockquote>
<p>AD 软件成为独立的产品</p>
</blockquote>
</li>
<li><p>下列哪些项不属于管理活动应该包含的要素？ABD</p>
<p><strong>A.成本</strong></p>
<p><strong>B.质量</strong></p>
<p>C.目标</p>
<p><strong>D.工期</strong></p>
<blockquote>
<p>管理的三大关键要素：目标、状态、纠偏</p>
<p>软件项目管理的三大目标：成本、质量、工期</p>
</blockquote>
</li>
<li><p>下列名词和术语中不属于软件过程的有哪些？BD</p>
<p>A.SCRUM</p>
<p><strong>B.CMM/CMMI</strong></p>
<p>C.GATE方法</p>
<p><strong>D.IDEAL</strong></p>
<blockquote>
<p>CMM/CMMI, IDEAL模型是一种软件过程管理/改进模型</p>
</blockquote>
</li>
<li><p>【2015B】CMM的创始⼈是哪位<strong>_</strong>? C</p>
<p>A. Boehm</p>
<p>B. Juran</p>
<p><strong>C. Humphrey</strong></p>
<p>D. Crosby</p>
</li>
<li><p>【2015B】XP规定开发⼈员每周⼯作时间不超过___⼩时, 连续加班不可以超过两周, 以免降低⽣产率？(B)</p>
<p>A. 30</p>
<p><strong>B. 40</strong></p>
<p>C. 50</p>
<p>D. 60</p>
</li>
<li><p>下列不属于看板方法典型实践的是？BD</p>
<p>A.可视化工作流</p>
<p><strong>B.站立式会议</strong></p>
<p>C.限定WIP</p>
<p><strong>D.重构</strong></p>
<blockquote>
<p>KanBan方法活动：可视化工作流、限制WIP、管理周期时间</p>
<p>B 站立式会议属于TSP实现策略中复用策略</p>
</blockquote>
</li>
<li><p>下列术语描述的技术或者方法是同类型的是？CD</p>
<p>A.CMMI SPICE PDCA</p>
<p>B.IDEAL XP SCRUM</p>
<p><strong>C.Cleanroom Gate TSP</strong></p>
<p><strong>D.Waterfall SCRUM XP</strong></p>
<blockquote>
<p>C 软件过程</p>
<p>D 软件实践</p>
</blockquote>
</li>
<li><p>在TSP的团队组建过程中, 确定软件开发策略的是第几次会议？C</p>
<p>A.第一次</p>
<p>B.第二次</p>
<p><strong>C.第三次</strong></p>
<p>D.第四次</p>
</li>
<li><p>完成一份完整的项目日程计划, 需要下列哪些信息？ABD</p>
<p><strong>A.任务清单</strong></p>
<p><strong>B.任务顺序</strong></p>
<p>C.质量要求</p>
<p><strong>D.人员资源水平</strong></p>
</li>
<li><p>下列描述当中, 属于过程经理的工作内容有哪些？AC</p>
<p><strong>A.建立团队的开发标准</strong></p>
<p>B.主持项日周例会</p>
<p><strong>C.记录周例会的会议记录</strong></p>
<p>D.制定开发计划</p>
</li>
<li><p>下列关于挣值管理方法的描述中错误的是？C</p>
<p>A.这是一种可以用来跟踪项目预算消耗的方法</p>
<p>B.这种方法高度依赖估算准确性</p>
<p><strong>C.这种方法可以支持质量管理</strong></p>
<p>D.这种方法可以用来跟踪项目进度</p>
<blockquote>
<p>C：挣值管理方法不支持质量管理, 因为它们关注的是成本节约而不是质量改进。他们必须找到将质量考虑在内的正确解决方案来支持质量管理。</p>
</blockquote>
</li>
<li><p>为了制定 Schedule plan, 下述描述中, 哪一项是不需要的 A</p>
<p><strong>A. Task size</strong></p>
<p>B. Task Order</p>
<p>C. Schedule Hour</p>
<p>D. Task hour for each task</p>
</li>
<li><p>在上题中, 还需要补充下述哪一项数据就可以定义 Schedule Plan 了 A</p>
<p><strong>A. Task List</strong></p>
<p>B. Plan Value</p>
<p>C. Earned Value</p>
<p>D. Nothing</p>
</li>
<li><p>PROBE方法估算规模的时候, 下列说法不恰当的是：AC</p>
<p><strong>A. PROBE A 方法要求三组以及三组以上的代理规模数据和实际规模数据, 且要求其相关性R²大于等于 7；</strong></p>
<p>B. PROBE C 方法仅仅需要根据上一次项目中估算值和实际值的比例进行调整即可；</p>
<p><strong>C. 应用 PROBE A 方法的估算结果一定会好于 PROBE B 方法；</strong></p>
<p>D. PROBE 方法的优势之一是采取了相对大小, 而非绝对大小, 辅助估算着思考和判断；</p>
<blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401030016721.png" alt="image-20240102211558227"></p>
</blockquote>
</li>
<li><p>【答案待定】下列指标中适合用作风险参数的是：ABC</p>
<p><strong>A.发生概率；</strong></p>
<p><strong>B.影响程度；</strong></p>
<p><strong>C.风险系数；</strong></p>
<p>D.触发阈值</p>
</li>
<li><p>【答案待定】下列描述中属于定量管理场景的是：AD</p>
<p><strong>A.我们通过控制关键子过程的性能来确保项目整体目标的达成；</strong></p>
<p>B.我们分析了导致生产效率不稳定的因素, 并采取措施避免再次发生；</p>
<p>C.我们通过每天站立式会议和周例会控制项目进度偏差不超过 20%；</p>
<p><strong>D.我们通过挣值管理方法来确保进度和成本与预期相符；</strong></p>
</li>
<li><p>完全基于 Phase Yield 来构建一个缺陷预测模型, 下列数据中必不可少的是：B</p>
<p>A.每个注入缺陷阶段缺陷注入速度(个/小时)；</p>
<p><strong>B.每个缺陷消除阶段消除的缺陷个数；</strong></p>
<p>C.每个阶段中从上游阶段遗留下来的缺陷比例；</p>
<p>D.每个缺陷消除阶段消除缺陷的比例；</p>
<blockquote>
<p>Phase Yield = 100 * (某阶段发现的缺陷个数)/(某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数)</p>
</blockquote>
</li>
<li><p>【答案待定】通过软件过程建模和仿真, 有助于完成下列哪些工作：ABD</p>
<p><strong>A.编制项目计划；</strong></p>
<p><strong>B.编制项目质量管理计划；</strong></p>
<p>C.项目经理培训；</p>
<p><strong>D.组织技术革新；</strong></p>
</li>
<li><p>下列步骤当中, 不属于建模典型步骤的是：C</p>
<p>A.定义和选择结果变量；</p>
<p>B.对过程进行抽象；</p>
<p><strong>C.规划过程改进计划；</strong></p>
<p>D.选择输入参数；</p>
<blockquote>
<p>仿真建模步骤：确定建模范围、定义结果变量、过程抽象、选择和定义输入参数</p>
</blockquote>
</li>
<li><p>下列方法中, 属于仿真技术的有哪些：BC</p>
<p>A.专家系统；</p>
<p><strong>B.蒙特卡洛方法；</strong></p>
<p><strong>C.系统动力学方法；</strong></p>
<p>D.假设检验方法；</p>
</li>
<li><p>上图是控制图的示例图, 中心线(CL)两侧按照±σ, ±2σ和±3σ分成 ABC 三个区域, 以下描述中, 属于要进一步探索的异常过程症状的是：C</p>
<p>A.连续 4 个点呈现上升或者下降趋势；</p>
<p>B.连续 8 个点在中心线两侧, 但是没有一个点在 C 区域；</p>
<p><strong>C.连续 3 个点中有 2 个落在中心线同侧的 B 区以外；</strong></p>
<p>D.连续 6 个点在中心线同一侧；</p>
<blockquote>
<p>8种异常状况</p>
<ol>
<li>1 点落在 A 区以外</li>
<li>连续 9 点落在中心线同一侧</li>
<li>连续 6 点递增或递减</li>
<li>连续 14 点相邻点上下交替</li>
<li>连续 3 个点中有 2 个落在中心线同侧的 B 区以外</li>
<li>连续 5 点中有 4 点落在中心线同侧的 C 区以外</li>
<li>连续 15 点在 C 区中心线上下</li>
<li>连续 8 点在中心线两侧, 且无一在 C 区中</li>
</ol>
</blockquote>
</li>
<li><p>下列关于 CMMI 五个成熟度级别的描述中, 不属于任何级别的是：A</p>
<p><strong>A. Performed；</strong></p>
<p>B. Managed；</p>
<p>C. Optimizing；</p>
<p>D. Defined</p>
</li>
</ol>
<h2 id="2-判断"><a href="#2-判断" class="headerlink" title="2. 判断"></a>2. 判断</h2><ol>
<li><p>软件过程管理是软件项目管理应该要实现目标。</p>
<p><strong>错误的。</strong>软件过程管理和软件项目管理完全是两回事, 因此并不是实现目标</p>
</li>
<li><p>“在公司导入敏捷过程是我们今年过程改进的主要目标。”</p>
<p><strong>正确的。</strong>过程管理和过程改进是类似的, 这个说法是合理的</p>
</li>
<li><p>XP与CMM/CMMI是对立的两种软件开发方法。</p>
<p><strong>错误的。</strong>CMM和CMMI并不是软件开发方法, 而是软件过程管理和改进, CMM和CMMI是没有较大区别的</p>
</li>
<li><p>CMM/CMMI不适合当今互联网环境的项目管理需求。</p>
<p><strong>正确的。</strong>CMM/CMMI是用来做过程管理和改进的, 根本不是满足项目管理需求的手段</p>
</li>
<li><p>PDCA和IDEAL不适合在敏捷环境中使用。</p>
<p><strong>错误的。</strong>PDCA, IDEAL是软件过程改进参考元模型, 因此是适合在敏捷环境中使用的</p>
</li>
<li><p>不同的软件开发过程应该使用不同的生命周期模型, 反之亦如此。</p>
<p><strong>错误的。</strong>生命周期模型是由人类划分的, 不一定</p>
</li>
<li><p>CMMI是过程改进模型而非软件过程或者软件过程模型。</p>
<p><strong>正确的。</strong>CMMI是软件过程管理模型, 与过程改进模型意义相近</p>
</li>
<li><p>CMMI不是过程优劣的标准, 也不适合用作公司之间的能力比较</p>
<p><strong>正确的。</strong>CMMI本身是有评级。(美国国防部订单招标要求企业至少达到CMMI的3级。因为公司的能力需要绝对东西, 也就是能力强, 能力弱, 而CMMI衡量的是相对的水平, CMMI仅仅关注在本公司的目标下的等级</p>
</li>
</ol>
<h2 id="3-主观题"><a href="#3-主观题" class="headerlink" title="3. 主观题"></a>3. 主观题</h2><p>【2022】结合“软件开发作为一种知识工作, 需要领导者而不是一般的经理”, 阐述知识工作领导者应该具备的品质或者特点(至少三项)。</p>
<ul>
<li>诚实、有能力、有远见、能鼓舞人心</li>
</ul>
<p>【2022】【2021】【2020】敏捷宣言有哪些内容？我们该如何正确理解敏捷宣言</p>
<ul>
<li>敏捷宣言<ul>
<li>个体和互动 胜过 流程和工具</li>
<li>可以工作的软件 胜过 详尽的文档</li>
<li>客户合作 胜过 合同谈判</li>
<li>响应变化 胜过 遵循计划</li>
</ul>
</li>
<li>尽管右项有其价值, 我们更看重左项的价值</li>
</ul>
<p>【2022】挣值管理有三种实现方式, 分别是简单、中级以及高级, 请分别阐述上述三种方式的基本要点</p>
<p>【2021】给一个挣值管理的图, 项目进度如何？是提前还是落后？项目有什么风险？</p>
<ul>
<li>简单：仅仅关注进度信息<ul>
<li>首先需要建立WBS, 定义工作范围</li>
<li>其次为WBS中每一项工作定义一个计划价值(PV)</li>
<li>最后按照一定的规则将某一数值赋给已经完成的工作或者正在进行的工作, 该值称为挣值(EV)</li>
</ul>
</li>
<li>中级<ul>
<li>在简单实现的基础上, 加入日程偏差的计算</li>
</ul>
</li>
<li>高级<ul>
<li>在中级实现的基础上，还需要考察项目的实际成本</li>
</ul>
</li>
</ul>
<blockquote>
<p>一点小补充</p>
<ul>
<li>0-100原则: 任务完成时才将PV转化为EV</li>
<li>50-50原则: 只需要开始某项任务, 即可以赋原PV值的50%作为EV值, 完成时, 再加上另外的50%</li>
<li><p>实际完成的工作所需成本AC不对EV值产生任何影响</p>
</li>
<li><p>典型计算方式有</p>
<ul>
<li><p>日程偏差SV = EV – PV</p>
<ul>
<li>SV<0表示进度落后；SV=0表示进度正常；SV>0表示进度超前。</li>
</ul>
</li>
<li><p>日程偏差指数SPI = EV/PV；</p>
</li>
<li>成本差异CV = EV - AC</li>
<li>成本差异指数CPI = EV/AC<ul>
<li>CPI<1说明成本超支；CPI=1说明成本与预期一致；CPI>1说明成本低于预期。</li>
</ul>
</li>
<li>预计完成成本EAC = AC+(BAC-EV)/CPI = BAC/CPI<ul>
<li>BAC(项目总预算)表示按照PV值的曲线, 当项目完成的时候所需预算或者时间</li>
</ul>
</li>
</ul>
</li>
<li>高级：添加预测线(BAC), 当任务足够多的时候, 我们就可以让预测线尽可能平直, 同时我们延伸挣值(EV), 找到与预测线(BAC)的交点, 我们就可以明确项目的落后时间</li>
</ul>
</blockquote>
<p>【2022】【2021】软件项目规模估算基本要点有哪些</p>
<ul>
<li>尽可能划分详细一些</li>
<li>建立对结果的信心</li>
<li>依赖数据</li>
<li>估算要的是过程, 而非结果, 估算的过程是相关干系人达成一致共识的过程</li>
</ul>
<p>【2022】CMMI—DEV V1.3 版本五个不同的成熟度等级分别是什么？为什么四级和五级被称为高等级？与普通等级的本质差别是什么？</p>
<p>【2020】请描述 CMMI 模型的 5 个等级的特征, 并且解释为何 CMMI 模型不应该是敏捷方法的对立面</p>
<ul>
<li>等级一：初始级<ul>
<li>开发相对混乱, 依赖个人英雄主义, 没有过程概念, 救火文化盛行</li>
</ul>
</li>
<li>等级二：已管理级<ul>
<li>项目小组体现出项目管理的特征, 有项目计划和跟踪、需求管理、配置管理等</li>
</ul>
</li>
<li>等级三：已定义级<ul>
<li>公司层面有标准流程和相应的规范, 每个项目小组可以基于此定义自己的过程, 使得优秀的做法可以在公司共享。</li>
</ul>
</li>
<li>等级四：定量管理级<ul>
<li>构建预测模型, 以统计过程控制的手段来管理过程</li>
</ul>
</li>
<li>等级五：优化级<ul>
<li>继续应用统计方法识别过程偏差, 找到问题根源并消除, 避免未来继续发生类似问题。</li>
</ul>
</li>
</ul>
<p>CMMI 是过程改进模型, 大部分敏捷方法都是开发方法, 因此两者是不同性质的事物, 将两者对立是不合适的。</p>
<blockquote>
<p>问道ChatGPT：</p>
<p>四级和五级被称为高等级, 主要是因为它们代表了对过程的高度管理和优化。</p>
<p>与普通等级的本质差别在于, 四级和五级强调量化和持续改进。在这两个级别中, 组织不仅仅是在执行标准过程, 而且还在努力通过数据和创新来持续优化。</p>
</blockquote>
<p>【2022】随着 ChatGPT 的横空出世, 以大模型为代表的 AI 技术势必对各行各业带来前所未有的影响。具体到软件工程, 人工智能技术的应用也日渐常见, 请结合这一背景畅想下本课程涉及的若干话题可能在这一波 AI 浪潮中的挑战和机遇。至少应该包括如下话题：项目管理、质量管理、过程改进。</p>
<ul>
<li>瞎编吧</li>
</ul>
<blockquote>
<p>问道ChatGPT：</p>
<p>项目管理：</p>
<ul>
<li>挑战：整合大模型如ChatGPT带来的复杂性, 需要更高水平的规划和监控。</li>
<li>机遇：ChatGPT可提供更准确的项目信息, 帮助项目经理更好地决策和监测进度。</li>
</ul>
<p>质量管理：</p>
<ul>
<li>挑战：引入AI增加了质量管理的复杂性, 需要确保AI系统质量和行为预测的准确性。</li>
<li>机遇：AI可用于自动测试和代码审查, 提高软件质量, 分析用户反馈以快速识别和解决问题。</li>
</ul>
<p>过程改进：</p>
<ul>
<li>挑战：引入AI可能需要重新评估软件开发过程, 同时需关注数据隐私和伦理问题。</li>
<li>机遇：AI分析大规模数据, 帮助团队发现潜在改进点, 自动化任务使团队更专注于创新和质量提升。</li>
</ul>
</blockquote>
<p>【2021】【2020】我们该如何正确理解瀑布模型？</p>
<ul>
<li>瀑布模型不是单一模型, 是一系列模型, 覆盖最简单场景到最复杂场景</li>
<li>软件项目应该结合实际情况选择合适过程元素的瀑布模型, 基本原则是, 项目面临困难和挑战越多, 选择的模型应该越复杂</li>
<li>软件项目团队往往低估项目的挑战, 选择了过于简单的不适用的瀑布模型</li>
</ul>
<p>【2021】简述至少 5 个 DevOps 实践、方法、技术</p>
<ul>
<li>CI: 将代码频繁集成到共享存储库中, 并通过自动化构建和测试来验证正确性</li>
<li>CD: 通过自动化部署和测试实现将软件更频繁、可靠地推送到生产环境</li>
<li>容器: 使用容器技术（如Docker）封装应用程序和其依赖, 实现一致的运行环境</li>
<li>编排工具: 编排工具（例如Kubernetes）用于自动化和管理容器化应用程序的部署、伸缩和运维</li>
<li>微服务架构: 将应用程序拆分为小型、独立的服务, 每个服务都有自己的数据存储和通信机制</li>
</ul>
<p>【2021】TSP中的典型角色, 描述其中五个角色的职责</p>
<ul>
<li>项目组长<ul>
<li>激励团队成员努力工作</li>
<li>主持项目周例会</li>
<li>每周汇报项目状态</li>
<li>分配工作任务</li>
<li>维护项目资料</li>
<li>组织项目总结</li>
</ul>
</li>
<li>计划经理<ul>
<li>带领项目小组开发项目计划</li>
<li>带领项目小组平衡计划</li>
<li>跟踪项目进度</li>
<li>参与项目总结</li>
</ul>
</li>
<li>开发经理<ul>
<li>带领团队制定开发策略。</li>
<li>带领团队开展产品规模估算和所需时间资源的估算。</li>
<li>带领团队开发需求规格说明。</li>
<li>带领团队开发高层设计。</li>
<li>带领团队开发设计规格说明。</li>
<li>带领团队实现软件产品。</li>
<li>带领团队开展集成测试和系统测试。</li>
<li>带领团队开发用户支持文档。</li>
<li>参与项目总结。</li>
</ul>
</li>
<li>质量经理<ul>
<li>带领团队开发和跟踪质量计划</li>
<li>向项目组长警示质量问题</li>
<li>软件产品提交配置管理之前, 对其进行评审, 以消除质量问题</li>
<li>项目小组评审的组织者和协调者</li>
<li>参与项目总结。</li>
</ul>
</li>
<li>过程经理<ul>
<li>带领团队定义和记录开发过程并且支持过程改进。</li>
<li>建立和维护团队的开发标准。</li>
<li>记录和维护项目的会议记录。</li>
<li>参与项目总结。</li>
</ul>
</li>
<li>支持经理<ul>
<li>带领团队识别开发过程中所需要的各类工具和设施。</li>
<li>主持配置管理委员会, 管理配置管理系统。</li>
<li>维护软件项目的词汇表。</li>
<li>维护项目风险和问题跟踪系统。</li>
<li>支持软件开发过程中复用策略的应用。</li>
<li>参与项目总结。</li>
</ul>
</li>
</ul>
<p>【2021】基于Yield构建预测模型, 描述如何建模？需要哪些数据, 有什么要求？⽤什么⽅法构建模型并预测</p>
<p>【2013】基于Yield指标构建缺陷预测模型, 并列举该模型的可能改进方案</p>
<ul>
<li>总体思想：利用回归技术预测软件开发过程中各阶段的Inject Rate(缺陷注入率)和Yield(缺陷消除率)</li>
<li>Yield指标只能用来估算, 不可以用来度量。结合Yield指标和上图, 只需要知道如下指标就可以基于Yield指标构建一个基本的缺陷预测模型：<ul>
<li>注入阶段注入多少缺陷</li>
<li>缺陷注入的密度（需求每一页注入多少缺陷）</li>
<li>缺陷注入的速度（每小时注入多少缺陷）</li>
<li>消除阶段的缺陷注入密度和速度。</li>
<li>历史数据中的软件规模、文档规模、开发人员规模</li>
</ul>
</li>
<li>步骤<ul>
<li>确定纳入影响因子的数据以及数据度量方法</li>
<li>从系统历史库中收集历史数据, 并进行整理</li>
<li>依照回归技术进行计算</li>
<li>在项目进行过程中不断收集数据, 与预测数据进行比较, 调整回归参数</li>
<li>项目过程中依据实际数据与预测数据的误差进行风险的预防、识别和控制</li>
</ul>
</li>
<li>改进方案<ul>
<li>可能的改进是假设注入水平和消除水平都符合正态分布, 计算均值和标准差, 因此, 可以用蒙特卡罗方法模拟结果。</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401030016585.png" alt="image-20240102224326843"></p>
<blockquote>
<p>三个消除步骤是需求评审、设计评审和测试评审</p>
</blockquote>
<p>【2020】请结合软件发展的三大阶段, 描述不同阶段的典型软件开发方法和实践</p>
<p>【2018】软件发展三大阶段的特点和主流开发方法</p>
<ul>
<li>软硬件一体化：<ul>
<li>特点：软件支持硬件完成计算任务、功能单一、复杂度有限、几乎不需要需求变更</li>
<li>开发方法：线性顺序过程, measure twice cut once, code and fix</li>
</ul>
</li>
<li>软件成为独立产品：<ul>
<li>特点：摆脱了硬件的束缚(操作系统)、功能强大、个人电脑出现、需求多变、兼容性要求、来自市场的压力</li>
<li>开发方法：形式化方法、结构化程序设计、瀑布生命周期模型、成熟度运动</li>
</ul>
</li>
<li>网络化和服务化：<ul>
<li>特点：功能更复杂、规模更大、用户数量急剧增加、快速演化和需求不确定、分发方式的变化、进一步的服务化和网络化、盛行开源和共享文化</li>
<li>开发方法：迭代式开发、敏捷运动、开源软件开发方式、DevOps</li>
</ul>
</li>
</ul>
<p>【2020】【2018】生命周期模型和软件过程这两个概念有什么区别和联系</p>
<ul>
<li>生命周期模型是对一个软件开发过程的人为划分。</li>
<li>生命周期模型是软件开发过程的框架, 是对软件开发过程的一种粗粒度划分。</li>
<li>生命周期模型往往不包括技术实践。</li>
</ul>
<p>【2020】请简要描述按照通用计划框架, 为了开发合理的项目计划, 应该要做哪些估算？PROBE 方法充当什么角色。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401030016602.png" alt="image-20240102225415965"></p>
<ul>
<li>虚线框即为 PROBE, 用来完成规模和资源的评估</li>
</ul>
<p>【2020】请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？</p>
<ul>
<li>软件开发是一项既复杂又富有创造性的知识工作</li>
<li>软件开发是一种智力劳动</li>
<li>自主团队具备如下的特点：<ul>
<li>自行定义项目的目标</li>
<li>自行决定团队组成形式以及成员的角色</li>
<li>自行决定项目的开发策略</li>
<li>自行定义项目的开发过程</li>
<li>自行制定项目的开发计划</li>
<li>自行度量、管理和控制项目工作</li>
</ul>
</li>
</ul>
<p>【2020】请描述一下 PROBE 方法的基本原理和过程, 并解释在应用 PROBE A 方法估算时间的时候, 为什么不用历史数据中的生产效率数据</p>
<ul>
<li>原理<ul>
<li>设立合理的代理作为精确度量和早期规划需要的度量之间的桥梁</li>
<li>相对大小, 而非绝对大小</li>
</ul>
</li>
<li>过程<br><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401030016593.png" alt="image-20240102230117270"></li>
<li>不适用生产效率的理由: 在估算资源需求(例如, 人时)的时候, 生产效率一般在分母上, 考虑到个体软件工程师生产效率波动, 易导致的估算偏差范围变大。</li>
</ul>
<p>【2020】请描述 PROBE ABCD 方法在估算规模的时候，对历史数据的质量有什么要求？</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401030016661.png" alt="image-20240102230231336"></p>
<blockquote>
<p>应该不会考吧，我都没在ppt里找到这图</p>
</blockquote>
<p>【2018】软件项目管理和软件过程管理</p>
<ul>
<li>软件项目管理是应用工具、方法、技术和人员能力来完成软件项目，实现项目目标的过程</li>
<li>软件过程管理是为了让软件过程在开发效率、质量等方面有更好性能绩效</li>
</ul>
<p>【2018】什么是面向用户的质量观？这对质量管理的策略有什么影响？</p>
<ul>
<li>将质量定义为满足用户需求的程度</li>
<li>需要开发者在开发过程中考虑用户的优先级，衡量质量的高低。</li>
</ul>
<p>【2014】马斯洛的“人的需求层次理论”描述的需求层次有哪几个？这样分层对软件开发有什么启发？</p>
<ul>
<li>生理需求、安全感、爱和归属感、获得尊敬、自我实现</li>
<li>马斯洛的需求层次理论可用于指导激励手段的选择</li>
</ul>
<p>【2015B】【2016】请结合 SCRUM 这种敏捷方法论述敏捷方法应该具备的特征？同时解释为何常见的若干种描述敏捷方法对立面的方法的特征（例如，严格、重型、计划驱动等等）并不合适？</p>
<ul>
<li>特征<ul>
<li>小周期迭代</li>
<li>快速响应变更</li>
<li>价值交付</li>
<li>自动化</li>
</ul>
</li>
<li>特征解释：<ul>
<li>严格：所有优秀的工程方法和实践都是严格的。</li>
<li>重型：轻量级和重型其实并没有刻画具体方法，何为重型，并没有严格定义；而且，对于变更这件事情，几乎所有方法都是限制，因此，很难说敏捷方法是轻量级方法。</li>
<li>计划驱动：所有正式的项目都是计划驱动的，否则计划的作用无法体现</li>
</ul>
</li>
</ul>
<h2 id="4-十大问题相关"><a href="#4-十大问题相关" class="headerlink" title="4. 十大问题相关"></a>4. 十大问题相关</h2><blockquote>
<p>部分问题的答案往年题考过了，不在这里再次总结了，仅列举一下，包括：</p>
<p>软件项目管理和软件过程管理、估算要点、敏捷宣言、瀑布模型、CMM/CMMI</p>
</blockquote>
<p>如果规模估算和时间估算都和实际情况相同，能否认为估算准确</p>
<ul>
<li>规模估算可以认为估算准确</li>
<li>时间估算结果相同有可能是只给了这么长时间</li>
</ul>
<p>什么叫做XX管理? 管理的要素有哪些? 如何区分有管理(或者好的管理)还是没有管理(或者不好的管理) ? 这种判断如果只能事后从结果判断，有意义吗?</p>
<ul>
<li>管理三要素：目标、状态、纠偏</li>
<li>目标：需要量化，不能说是高质量开发，太模糊。好的例子是每千行缺陷数不超过1个</li>
<li>状态：要做状态追踪，在项目没有完成时能否回答最终的目标能否实现<ul>
<li>例如单元测试时就回答最终每千行缺陷数能不能不超过1个</li>
<li>可以通过构建预测模型来实现(第八讲)</li>
<li>也可以通过数据，例如把单元测试的代码覆盖率，跟最终的交付的结果，去做一个线性回归或相关性检验，看是否强相关，然后直接控制该项数值</li>
<li>还可以通过历史经验，例如A/FR为2.0，PQI在0.4以上</li>
</ul>
</li>
<li>纠偏：第二步中不能回答要进行纠偏</li>
</ul>
<p>接上一问题，什么叫做软件质量? 当您宣称做了质量管理，实际上真的对质量有管理吗?</p>
<ul>
<li>$Z \leftarrow Y_{i}$, $Y_i \leftarrow X_i$ <ul>
<li>Z 由 Y 支持, Y 由 X 支持</li>
<li>Y 关键子过程</li>
<li>X 关键子过程的关键影响因素</li>
</ul>
</li>
<li>质量计划需要有质量实践(Y, 例如单元测试阶段)，还需要每个质量实践做到的程度(X)</li>
</ul>
<p>追求高质量，质量路径</p>
<ul>
<li>各种测试</li>
<li>进入测试之前的产物质量提升</li>
<li>评审过程度量和稳定</li>
<li>质量意识和主人翁态度</li>
<li>个体review的度量和稳定</li>
<li>诉诸设计</li>
<li>缺陷预防</li>
<li>用户质量观</li>
</ul>
<p>从没有度量就没有管理/改进，到软件项目度量毫无意义，到包含2200多指标项的研发效能度量，到研发效能引发血案，这是想闹哪样? 究竟要不要度量?</p>
<ul>
<li>要度量</li>
<li>使用 GQM 方法(一种建立软件度量体系的方法)，从目标出发<ul>
<li>概念层（Goal）</li>
<li>操作层（Question）</li>
<li>量化层（Metrix）</li>
</ul>
</li>
</ul>
<blockquote>
<p>例子一：PM</p>
<ul>
<li>G：确保稳定性、可预测性的开发过程来满足计划的里程碑</li>
<li>Q：我的项目是否按照计划的轨迹前进，计划的里程碑都能实现嘛？</li>
<li>M：软件项目开发工作的挥发性（分支、流、统计变更管理 UCM 活动）</li>
</ul>
<p>例子二：QM</p>
<ul>
<li>G：最大化所有团队贡献者的生产力</li>
<li>Q：开发人员能够完成分配给他们的任务吗，或者他们遇到障碍了吗？</li>
<li>M：由个体或者工作组产生的项目工作的量级</li>
</ul>
</blockquote>
<p>定量管理的本质是什么? 用数据就是定量管理了? DevOps模式下，还需要定量管理吗?</p>
<ul>
<li>不是用数据就是定量管理</li>
<li>定量管理范式<ul>
<li>构建定量模型：子过程能力基线、过程模型</li>
<li>应用模型：监控影响子过程的关键因素</li>
</ul>
</li>
<li>重点：构建<strong>预测模型</strong>，通过模型指导项目实践</li>
<li>通过各种统计方法优化模型</li>
<li>DevOps也需要定量管理，而且会做得更好<ul>
<li>DevOps模式相较于传统模式：<ul>
<li>数据中人的干扰较少(传统模式中使用控制图来消除)</li>
<li>数据量大</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>关于工程实践。需求分析究竟要解决什么问题? 设计究竟要设计什么? 测试的目的是什么?为实现这个目的，测试实践的重点应该是什么?</p>
<ul>
<li>需求：客户需求 vs. 产品需求<ul>
<li>客户需求：描述客户的期望，即客户对产品的要求。</li>
<li>产品需求：描述开发团队所提供的解决方案。</li>
<li>产品组件需求：描述组成产品的各个组件的需求规格。</li>
</ul>
</li>
<li>设计：OST, FST, SST, LST<ul>
<li>填满四个象限</li>
<li>设计标准、复用性、可测试性、可用性</li>
</ul>
</li>
<li>测试：V &amp; V<ul>
<li>验证(Verification)和确认(Validation)都是为了提升最终产品的质量而采取的措施。</li>
<li>验证：确保选定的工作产品与事先指定给该工作产品的需求一致。</li>
<li>确认：确保完成的产品或产品组件在将要使用的环境中正常工作。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/31/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/31/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">人机交互期末复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-31 20:42:32" itemprop="dateCreated datePublished" datetime="2023-12-31T20:42:32+08:00">2023-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-05 11:35:56" itemprop="dateModified" datetime="2024-01-05T11:35:56+08:00">2024-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/" itemprop="url" rel="index"><span itemprop="name">NJU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/" itemprop="url" rel="index"><span itemprop="name">人机交互</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="人机交互概述"><a href="#人机交互概述" class="headerlink" title="人机交互概述"></a>人机交互概述</h2><h3 id="1-人机交互的发展历史"><a href="#1-人机交互的发展历史" class="headerlink" title="1. 人机交互的发展历史"></a>1. 人机交互的发展历史</h3><ul>
<li>早期的机器采用批处理</li>
<li>带有命令行界面的终端</li>
<li>带指向装置的图形用户界面</li>
<li>多模态用户界面</li>
</ul>
<blockquote>
<p>旧的交互形式作为特例保存下来</p>
<p>图形交互相较于命令行交互的优点</p>
<ul>
<li>基于识别而非记忆</li>
</ul>
</blockquote>
<h3 id="2-人机交互与软件工程"><a href="#2-人机交互与软件工程" class="headerlink" title="2. 人机交互与软件工程"></a>2. 人机交互与软件工程</h3><ul>
<li>前者是对后者的促进和补充</li>
<li>二者结合存在许多困难</li>
</ul>
<h2 id="人机交互的基础知识"><a href="#人机交互的基础知识" class="headerlink" title="人机交互的基础知识"></a>人机交互的基础知识</h2><h3 id="3-交互框架"><a href="#3-交互框架" class="headerlink" title="3. 交互框架"></a>3. 交互框架</h3><p><strong>执行/评估活动周期</strong> EEC：最有影响力的框架，定义了活动的四个组成部分：</p>
<ol>
<li>目标（Goal） ≠ 意图（Intention）</li>
<li>执行（Execution）</li>
<li>客观因素（World）</li>
<li>评估（Evaluation）</li>
</ol>
<p>问题：</p>
<ol>
<li>执行隔阂：用户想要执行的动作和系统允许的动作有差异，比如想要提交找不到提交按钮；</li>
<li>评估隔阂：系统状态的实际表现与用户预期之间的差别</li>
</ol>
<h3 id="4-交互形式"><a href="#4-交互形式" class="headerlink" title="4. 交互形式"></a>4. 交互形式</h3><p><strong>界面类型</strong></p>
<ul>
<li><p>基于命令的界面；</p>
</li>
<li><p>WIMP（Window, Icon, Menu, Pointing） 和 GUI（Graphical User Interface）：</p>
<ul>
<li><p>如何进行窗口管理，找到内容并在不同窗口之间流畅切换</p>
</li>
<li><p>确定菜单选项的最佳术语</p>
</li>
<li>消除图标的歧义</li>
</ul>
</li>
<li><p>多媒体界面；</p>
<ul>
<li>多媒体内容设计</li>
<li>何时使用音频与图形、声音与动画等</li>
</ul>
</li>
<li><p>虚拟现实和增强现实；</p>
<ul>
<li>如何防止用户体验不好的事情</li>
<li>确保用户使用最有效的导航方式，如第一人称、第三人称</li>
<li>如何使用户与虚拟环境中的其他人协作和沟通</li>
</ul>
</li>
<li><p>信息可视化和仪表盘；</p>
<ul>
<li>设计一个易于理解和容易推理的可视化</li>
<li>是否使用动画或可交互</li>
<li>2D 或 3D？</li>
<li>何种隐喻？</li>
</ul>
</li>
<li><p>笔式交互和触摸交互；</p>
</li>
<li><p>手势界面；</p>
<ul>
<li>计算机如何识别和描绘用户的手势</li>
<li>如何确定手势运动的开始和结束</li>
</ul>
</li>
<li><p>实物界面 Tangible Interface；</p>
<ul>
<li>物理活动和效果之间应该如何组合</li>
<li>使用何种实物来使用户能够以自然的方式执行活动</li>
</ul>
</li>
<li><p>可穿戴计算：舒适、卫生、续航、交互方式的选择……；</p>
</li>
<li><p>脑机界面；</p>
</li>
<li><p>GUI 的演化：更少的记忆、更多的识别、更少的键盘和点击、更不易出错、以及更可视的上下文</p>
</li>
</ul>
<h3 id="5-信息处理模型"><a href="#5-信息处理模型" class="headerlink" title="5. 信息处理模型"></a>5. 信息处理模型</h3><p><strong>人类处理机模型(大头娃娃模型)</strong></p>
<ul>
<li>感知处理器：将信息输出到声音存储和视觉存储区域</li>
<li>认知处理器：将输入输出到工作记忆</li>
<li>动作处理器：执行动作</li>
</ul>
<p><strong>格式塔心理学</strong></p>
<ul>
<li><p>相近性原则：空间上比较靠近的物体容易被视为整体</p>
<ul>
<li>设计界⾯时，应按照相关性对组件进⾏分组</li>
<li>合理运用接近性法则，它能让界面层次清晰有序。</li>
<li>例如列表页设计，将相关的信息组合在一起并重复排列出来，就能明显感知不同小组之间的界限，当同一小组内元素关系明确时，将其更加靠拢，用户视觉就会更聚焦。</li>
</ul>
</li>
<li><p>相似性原则：人们习惯将看上去相似的物体看成一个整体</p>
<ul>
<li>功能相近的组件应该使用相同或相近的表现形式</li>
<li>使用不同的大小、颜色、形状来创建对比或视觉权重，呈现出不一样的视觉效果，以达到弱化（降低视觉）或凸显（强化视觉）某些内容。</li>
</ul>
</li>
<li><p>连续性原则：共线或具有相同方向的物体会被组合在一起</p>
<ul>
<li>组件对齐有助于增强用户的主观感知效果</li>
</ul>
</li>
<li><p>完整性和闭合性原则：人们倾向于忽视轮廓的间隙而将其视作一个完整的整体</p>
<ul>
<li>页面上的空白可帮助实现分组</li>
</ul>
</li>
</ul>
<p><strong>记忆特性</strong></p>
<ul>
<li>感觉记忆(瞬时记忆)：相当于cpu</li>
<li>短时记忆：相当于内存</li>
<li>长时记忆：容量几乎无限，不会遗忘，只是有时无法提取</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312302151406.png" alt="img"></p>
<h2 id="交互设计目标与原则"><a href="#交互设计目标与原则" class="headerlink" title="交互设计目标与原则"></a>交互设计目标与原则</h2><h3 id="6-可用性目标"><a href="#6-可用性目标" class="headerlink" title="6. 可用性目标"></a>6. 可用性目标</h3><p>目的是为交互设计人员提供一个评估交互式产品和用户体验各方面的具体方法</p>
<p>不仅涉及人与正在发⽣交互的系统，还包括系统对使⽤它的人产⽣的作⽤</p>
<ul>
<li>易学性</li>
<li>易记性</li>
<li>效用性</li>
<li>高效率</li>
<li>安全性</li>
</ul>
<h3 id="7-用户体验目标"><a href="#7-用户体验目标" class="headerlink" title="7. 用户体验目标"></a>7. 用户体验目标</h3><p>在特定的时间和地点使用或与一个产品交互时，选择传达用户的感受、目前状态、情绪、感觉等最佳词汇的过程，可以帮助设计者了解用户体验的多面性变化性的本质。</p>
<p>可用性是人为划分出来的客观的部分，用户体验是<strong>主观</strong>的部分。但实际上两者都有主观和客观的部分。</p>
<p>可用性目标和用户体验目标的矛盾性：</p>
<ul>
<li>许多玩家喜欢找最具挑战、非简单的游戏：违反可用性</li>
<li>用塑料锤砸屏幕上的地鼠较用鼠标点击更费劲且更易出错，但会带来一个更愉快和有趣的体验</li>
</ul>
<p>有些可用性和用户体验目标是不兼容的：如设计一个既安全又有趣的过程控制系统可能是不可能或不可取的</p>
<h3 id="8-简易可用性工程"><a href="#8-简易可用性工程" class="headerlink" title="8. 简易可用性工程"></a>8. 简易可用性工程</h3><p><strong>可用性度量</strong>：易学性、易记性、使用效率、错误率、用户体验/满意度</p>
<p><strong>四种主要技术</strong></p>
<ul>
<li><p>用户和任务观察</p>
<ul>
<li><p>了解产品的目标用户是可用性工程的第一个步骤</p>
</li>
<li><p>注意：</p>
<ul>
<li><p>要<strong>直接与潜在用户</strong>进行接触</p>
</li>
<li><p>不要满足于间接的接触和道听途说</p>
</li>
<li><p>“你”不是用户！</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>场景</p>
<ul>
<li>简便易行的<strong>原型工具</strong>，过程中低保真原型，最后是高保真原型。</li>
<li>通过省略整个系统的若干部分来减少实现的复杂性</li>
<li>水平原型：减少功能的深度并获得界面的表层</li>
<li>垂直原型：减少功能的数量而对所选功能进行完整实现</li>
<li>可以是纸质模型，也可以是简单的 RAD 原型</li>
</ul>
</li>
<li><p><strong>边做边说</strong></p>
<ul>
<li>让真实用户在使用系统执行一组特定任务的时候，讲出他们的所思所想</li>
<li><strong>最有价值的单个可用性工程方法</strong></li>
<li>可了解用户为什么这样做，并确定其可能对系统产生的误解</li>
<li>实验人员需要<strong>不断地提示用户</strong>，或请他们事先观摩</li>
<li>边做边说的问题：学习成本高（需要专业训练），不是所有用户都会希望边说变说法</li>
</ul>
</li>
<li><p><strong>启发式评估</strong></p>
<ul>
<li>常见的评估方法：调查问卷（可以快速获取大量数据、但是如果确认问卷调查对象身份是个问题）</li>
<li>研究表明，能够发现许多可用性问题：<strong>剩下的可以通过简化的边做边说方法来发现</strong></li>
<li>启发式评估需要有相关的专家用户（不需要找真实的用户），这些专家可以把自己设定为<strong>用户视角</strong>。</li>
<li>为避免个人的偏见，应当让多个不同的人来进行经验性评估。</li>
<li>被测试的用户：没有用过、有一段时间没有使用的、经常使用的，这个用户群体和想要衡量的指标有关（比如易用性就需要研究有一段时间没有使用的用户）</li>
</ul>
</li>
</ul>
<h3 id="9-交互设计原则"><a href="#9-交互设计原则" class="headerlink" title="9. 交互设计原则"></a>9. 交互设计原则</h3><p><strong>启发式原则</strong></p>
<ol>
<li>系统状态的可见度</li>
<li>系统和现实世界的吻合</li>
<li>用户享有控制权和自主权</li>
<li>一致性和标准化</li>
<li>避免出错</li>
<li>依赖识别而非记忆</li>
<li>使用的灵活性和高效性：满足不同用户的需要</li>
<li>审美感和最小化设计</li>
<li>帮助用户识别、诊断和恢复错误</li>
<li>帮助和文档</li>
</ol>
<blockquote>
<p>十条原则，分别指什么问题</p>
<p>例题：哪些地方违反什么原则</p>
</blockquote>
<p>黄金规则，七项原理：不详细考，找到对应的启发式原则</p>
<h2 id="交互设计过程"><a href="#交互设计过程" class="headerlink" title="交互设计过程"></a><del>交互设计过程</del></h2><ul>
<li><del>设计过程的基本活动和特征</del></li>
<li><del>主要问题</del><ul>
<li><del>用户、需求、候选方案、决策</del></li>
</ul>
</li>
<li><del>交互设计生命周期</del><ul>
<li><del>星型模型</del></li>
<li><del>可用性工程生命周期模型</del></li>
</ul>
</li>
</ul>
<h2 id="交互式系统的需求"><a href="#交互式系统的需求" class="headerlink" title="交互式系统的需求"></a>交互式系统的需求</h2><h3 id="10-产品特性"><a href="#10-产品特性" class="headerlink" title="10. 产品特性"></a>10. 产品特性</h3><p>功能不同：</p>
<ul>
<li>智能冰箱：应能够提示牛奶已用完</li>
<li>字处理器：系统应支持多种格式</li>
</ul>
<p>物理条件不同：</p>
<ul>
<li>移动设备运行的系统应尽可能小，屏幕显示限制</li>
</ul>
<p>使用环境不同：</p>
<ul>
<li>物理环境：如操作环境中的采光、噪音和尘土状况</li>
<li>社会环境：是否要共享数据，同步还是异步？</li>
<li>组织环境：用户支持的质量、响应速度如何？是否提供培训资源或设施？</li>
<li>技术环境：产品应能运行于何种平台上？应与何种技术兼容？</li>
</ul>
<h3 id="11-用户特性"><a href="#11-用户特性" class="headerlink" title="11. 用户特性"></a>11. 用户特性</h3><p>心理学原理部分，假设每个人都有相似的能力和局限性</p>
<ul>
<li>合理的，心理学原理可以适用于大多数人。</li>
</ul>
<p>交互产品设计人员应该意识到个性的差异</p>
<ul>
<li>用户并不是完全相同的</li>
<li>在设计中尽可能地体现这些差异</li>
</ul>
<p>用户差异</p>
<ul>
<li>体验水平、年龄、文化、健康</li>
</ul>
<p>⽤户分类：</p>
<ul>
<li>新⼿⽤户：让新⼿快速且⽆痛成为中间⽤户；（敏感，易有挫败感）</li>
<li>中间⽤户：让中间⽤户感到愉快；（需要⼯具，知道如何使⽤参考资料，可以区分经常使⽤和很少使⽤ 的功能，⾼级功能的存在让永久的中间⽤户放⼼）</li>
<li>专家⽤户：避免为想成为专家的⽤户设置障碍；（对缺少经验的⽤户有影响，欣赏更新且更强⼤的功 能，不会受到复杂性增加的⼲扰）</li>
</ul>
<h3 id="12-用户建模"><a href="#12-用户建模" class="headerlink" title="12. 用户建模"></a>12. 用户建模</h3><ul>
<li><p>重要，但人物角色不好考</p>
</li>
<li><p>考过分析给出的人物角色有什么问题</p>
</li>
</ul>
<blockquote>
<p>举例</p>
<p>设计运行在笔记本电脑上的一个演示程序包：</p>
<ul>
<li>销售部的一位同事</li>
<li>公司的销售代表<ul>
<li>能快捷方便地创建标准格式的简单幻灯片</li>
<li>能使用带有项目的文字内容或简单图表</li>
<li>图形依靠软件提供的标准图形库</li>
</ul>
</li>
<li>人物角色：日常最低要求演示者<ul>
<li>经常使用；快速、方便操作；简单使用；</li>
<li>简洁、标准格式：带有项目符号的列表、条形图、饼图、图形等；标准图形库</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="13-需求获取、分析和验证"><a href="#13-需求获取、分析和验证" class="headerlink" title="13. 需求获取、分析和验证"></a>13. 需求获取、分析和验证</h3><p><strong>需求获取</strong></p>
<ul>
<li>场景<ul>
<li>表示任务和工作结构的“非正式的叙述性描述”</li>
<li>“讲故事”是人们解释自己做什么或者希望执行某个任务的最自然方式</li>
<li>场景说明通常来自专题讨论或者访谈，目的是解释或讨论有关用户目标的一些问题</li>
</ul>
</li>
<li>观察<ul>
<li>直接观察：陪同他们工作而直接获得信息、可能影响被观察者的日常活动</li>
<li>间接观察：用视频/录音获得信息、观察者更舒适</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312310001968.png" alt="image-20231231000158885"></p>
<p><strong>需求分析</strong></p>
<p>层次化任务分析（HTA）是应用最广的任务分析技术</p>
<ul>
<li>把任务分解为若干子任务，再把子任务进一步分解为更细致的子任务。之后，把他们组织成一个“执行次序”，说明在实际情形下如何执行各项任务</li>
</ul>
<blockquote>
<p>举例1：图书馆目录服务</p>
<p>“借书”的子任务</p>
<ul>
<li>访问图书馆目录</li>
<li>根据姓名、书名、主题等检索</li>
<li>记录图书位置</li>
<li>找到书架并取书（假定书在书架上）</li>
<li>到柜台办理借阅手续</li>
</ul>
<p>执行次序</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311337442.png" alt="image-20231231133755380"></p>
<p>图形描述</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311338329.png" alt="img"></p>
<p>举例2：安排会议</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311340055.png" alt="image-20231231134038007"></p>
</blockquote>
<p><strong>原型</strong>：低保真原型，高保真原型</p>
<ul>
<li>低保真原型：多数项目的首选<ul>
<li>与最终产品不太相似的原型</li>
<li>使用与最终产品不同的材料，如纸张、纸板。如 PalmPilot 掌上电脑的木雕原型</li>
<li>优点是简单、快速、便宜、易于制作和修改</li>
<li>草图、故事板、绿野仙踪</li>
</ul>
</li>
<li>高保真原型：<ul>
<li>与最终产品更为接近，使用相同的材料。如使用 Visual Basic 开发的软件系统原型</li>
<li>制作时间长，难以修改</li>
<li>风险：用户会认为原型就是系统，开发人员可能认为已找到了一个用户满意的设计</li>
</ul>
</li>
<li>鼓励初期使用低保真原型的原因</li>
</ul>
<h2 id="交互式系统的设计"><a href="#交互式系统的设计" class="headerlink" title="交互式系统的设计"></a>交互式系统的设计</h2><p><del>设计框架</del></p>
<h3 id="14-简化交互设计策略"><a href="#14-简化交互设计策略" class="headerlink" title="14. 简化交互设计策略"></a>14. 简化交互设计策略</h3><ul>
<li>删除: 删除杂乱的特性<ul>
<li>最明显的简化设计方法</li>
</ul>
</li>
<li>组织: 分块，确定清晰的分类标准<ul>
<li>最快捷的简化设计方式</li>
</ul>
</li>
<li>隐藏:<ul>
<li>是一种低成本的简化方案</li>
<li>隐藏什么<ul>
<li>主流用户很少使用，但自身需要更新的功能</li>
<li>事关细节（对服务器进行配置或设计邮件签名）</li>
<li>选项和偏好（修改绘图应用的单位）</li>
<li>特定于地区的信息（如时间和日期需频繁自动更新的信息）</li>
</ul>
</li>
</ul>
</li>
<li>转移：不同平台<ul>
<li>被精简掉的按钮全部通过电视屏幕上的菜单来管理</li>
<li>遥控器使用起来非常方便<ul>
<li>用户需熟悉和记住的按钮只有几个，不会按错</li>
</ul>
</li>
<li>利用电视屏幕比在遥控器上增加液晶面板便宜得多<ul>
<li>如何把屏幕菜单设计得简单易用是个挑战</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312302204195.png" alt="img"></p>
<blockquote>
<p>是什么，什么时候使用四种策略</p>
<p>例题：给出场景选出最恰当的策略</p>
</blockquote>
<h3 id="15-设计中的折中"><a href="#15-设计中的折中" class="headerlink" title="15. 设计中的折中"></a>15. 设计中的折中</h3><ul>
<li>个性化和配置</li>
<li>本地化和国际化</li>
<li>审美学与实用性</li>
</ul>
<h3 id="16-细节"><a href="#16-细节" class="headerlink" title="16. 细节"></a>16. 细节</h3><ul>
<li><p>让软件体贴、加快响应时间、减轻记忆负担、减少等待感、设计模式</p>
</li>
<li><p>简答、填空，不考大题</p>
</li>
</ul>
<h2 id="交互设计模型与理论"><a href="#交互设计模型与理论" class="headerlink" title="交互设计模型与理论"></a>交互设计模型与理论</h2><h3 id="17-预测模型"><a href="#17-预测模型" class="headerlink" title="17. 预测模型"></a>17. 预测模型</h3><p><strong>GOMS</strong>：采用“分而治之”的思想，将一个任务进行多层次的细化，把每个操作的时间相加就可以得到一项任务的时间</p>
<ul>
<li>Goal-目标：用户要达到什么目的</li>
<li>Operator-操作：任务执行的底层行为，不能分解：为达到目标而使用的认知过程和物理行为。如点击鼠标</li>
<li>Method-方法：如何完成目标的过程，即对应目标的子目标序列和所需操作。如移动鼠标，输入关键字，点击 Go 按钮</li>
<li>Selection-选择规则：确定当有多种方法时选择和方法。GOMS 认为方法的选择不是随机的</li>
</ul>
<blockquote>
<p>举例：使用GOMS模型描述在Word中删除文本的过程</p>
<p>目标：删除Word中的文本</p>
<p>方法1：使用菜单删除文本</p>
<ul>
<li>步骤1：思考，需要选定待删除的文本</li>
<li>步骤2：思考，应使用“剪裁”命令</li>
<li>步骤3：思考，“剪裁”命令在“编辑”菜单中</li>
<li>步骤4：选定待删除文本，执行“剪裁”命令</li>
<li>步骤5：达到目标，返回</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311426338.png" alt="image-20231231142600294"></p>
</blockquote>
<p><strong>KLM</strong>，击键层次模型，对用户执行情况进行量化预测，仅涉及任务性能的一个方面：时间</p>
<p>执行时间预测方法: 列出操作次序，累加每一项操作的预计时间</p>
<p>$T_{execute} = T_k+T_P+T_h+T_d+T_m+T_r$</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311434279.png" alt="image-20231231143406228"></p>
<blockquote>
<p>举例1: DOS环境下执行“ipconfig”命令</p>
<ul>
<li><p>M K[i] K[p] K[c] K[o] K[n] K[f] K[i] K[g] K[回车]</p>
</li>
<li><p>简略表达版本：M9K[ipconfig回车]</p>
</li>
<li><p>$T_{execute}$ = 1.35 + 9 × 0.28 = 3.87s</p>
</li>
</ul>
<p>举例2：菜单选择</p>
<ul>
<li>H[鼠标] M P[网络连接图标] P1[右键] P[修复] P1[左键]</li>
<li>$T_{execute}$ = 0.40 + 1.35 + 2P + 2K=4.35秒</li>
</ul>
</blockquote>
<p><strong>Fitts定律</strong></p>
<ul>
<li>能够预测使用某种定位设备指向某个目标的时间, 人机交互中，根据目标大小及至目标的距离，计算指向该目标的时间</li>
<li><p>$MT = a + b * ID, ID = log_{2}(A/W + 1), IP=ID/MT$</p>
<ul>
<li>MT: 运动时间，s</li>
<li>ID：困难指数, bit</li>
<li>IP: 性能指数, bit/s</li>
<li>常数a和b来自实验数据的线性回归</li>
<li>运动距离或振幅(A)，目标的宽度(W)</li>
</ul>
</li>
<li><p>Fitts定律建议</p>
<ul>
<li>小距离，大目标具有优势, 更容易点击<ul>
<li>对选择任务而言，其移动时间随到目标距离的增加而增加，随目标的大小减小而增加</li>
</ul>
</li>
<li>屏幕元素应该尽可能多的占据屏幕空间</li>
<li>最好的像素是光标所处的像素</li>
<li>屏幕元素应尽可能利用屏幕边缘的优势</li>
<li>大菜单，如饼型菜单，比其他类型的菜单使用简单</li>
</ul>
</li>
</ul>
<h2 id="评估的基础知识"><a href="#评估的基础知识" class="headerlink" title="评估的基础知识"></a>评估的基础知识</h2><h3 id="18-评估泛型和方法"><a href="#18-评估泛型和方法" class="headerlink" title="18. 评估泛型和方法"></a>18. 评估泛型和方法</h3><p><strong>快速评估</strong></p>
<ul>
<li><p>设计人员非正式地向用户或顾问了解反馈信息，以证实设计构思是否符合用户需要</p>
<ul>
<li>可在任何阶段进行</li>
<li>强调“快速了解”，而非仔细记录研究发现：如在设计初期了解用户对新产品的意见、在设计末期了解用户对图标设计的看法等</li>
<li>得到的数据通常是非正式、叙述性的：可以口语、书面笔记、草图、场景的形式反馈到设计过程</li>
<li>是设计网站时常用的方法</li>
</ul>
</li>
<li><p>基本特征：快速</p>
</li>
</ul>
<p><strong>可用性测试</strong></p>
<ul>
<li>20 世纪 80 年代的主导方法</li>
<li>评测典型用户执行典型任务时的情况：包括用户出错次数、完成任务的时间等</li>
<li>基本特征：是在评估人员的密切控制之下实行的，是可以普适的。</li>
<li>主要任务：量化表示用户的执行情况</li>
<li>缺点：<ul>
<li>测试用户的数量通常较少</li>
<li>不适合进行细致的统计分析</li>
</ul>
</li>
</ul>
<p><strong>实地研究</strong></p>
<ul>
<li>基本特征：在自然工作环境中进行</li>
<li>目的：理解用户的实际工作情形以及技术对他们的影响</li>
<li>作用：<ul>
<li>探索新技术的应用契机</li>
<li>确定产品的需求</li>
<li>促进技术的引入</li>
<li>评估技术的应用</li>
</ul>
</li>
<li>重难点<ul>
<li>如何不对受试者造成影响</li>
<li>控制权在用户，很难预测即将发生和出现的情况</li>
</ul>
</li>
<li>分类<ul>
<li>评估⼈员作为“局外⼈”</li>
<li>评测⼈员作为“局内⼈”或测试⽤户</li>
</ul>
</li>
</ul>
<p><strong>预测性评估</strong></p>
<ul>
<li>研究人员通过想象或对界面的使用过程进行建模<ul>
<li>专家们根据自己对典型用户的了解预测可用性问题的可用性评估</li>
<li>逐步通过场景或基于问题回答的走查法</li>
<li>用于比较相同应用不同界面的原型法，如使用 Fitts 定律预测使用设备定位目标的时间</li>
</ul>
</li>
<li>基本特征<ul>
<li><strong>用户可以不在场</strong></li>
<li>使得整个过程快速、成本较低</li>
</ul>
</li>
<li>启发式评估是典型的预测性评估⽅法<ul>
<li>启发式原则应定制</li>
<li>可能误导设计⼈员且有些结果可能并不准确</li>
</ul>
</li>
</ul>
<h3 id="19-实证研究"><a href="#19-实证研究" class="headerlink" title="19. 实证研究"></a>19. 实证研究</h3><p>实验通常从研究假设开始</p>
<ul>
<li>假设是一种可以通过实证研究直接检验的精确问题陈述</li>
<li>一个具体的研究假设奠定了一个实验以及统计学显著性检验的基础</li>
</ul>
<p><strong>零假设Null Hypothesis和备择假设Alternative Hypothesis</strong></p>
<ul>
<li>零假设通常指不同的实验条件不会产生差异；而备择假设往往是一个与零假设相反的陈述。</li>
<li>实验的目标是找到统计学证据来反驳或否定零假设，以支持备择假设</li>
</ul>
<blockquote>
<p>举例: 一个网站的开发人员正尝试弄清楚在网站的主页上是用下拉菜单还是用弹出菜单。</p>
<ul>
<li>H0：下拉菜单和弹出菜单在定位页面的时间开销上没有差异；</li>
<li>H1：下拉菜单和弹出菜单在定位页面的时间开销上存在差异。</li>
<li>备择假设和零假设应该是互斥的</li>
</ul>
<p>可以同时研究多对零假设和备择假设</p>
<ul>
<li>H0：下拉菜单和弹出菜单在用户满意度评价上没有差异</li>
<li>H1：下拉菜单和弹出菜单在用户满意度评价上存在差异</li>
</ul>
</blockquote>
<p>一个成功的实验，从一个或多个好的假设开始是至关重要的</p>
<ul>
<li>用精确而清晰的语言提出；</li>
<li>专注于一个可以在单次实验中检验的问题；</li>
<li>明确说明实验的对照组或实验条件。</li>
</ul>
<p>一个定义明确的假设会明确说明研究的<strong>因变量和自变量</strong></p>
<ul>
<li><p><strong>自变量</strong>是指研究者感兴趣的因素或因变量变化的可能”原因”</p>
<ul>
<li>“Independent”用于说明该变量与受试者的行为无关，即参与者无法对自变量施加任何影响</li>
<li>一个自变量至少需要2个不同的取值，这些取值被称为实验条件test conditions</li>
<li>人的特性是天然的自变量，如年龄、性别、身高等，但它们不能被“操纵”</li>
</ul>
</li>
<li><p><strong>因变量</strong>是指研究者感兴趣的结果或效果，其中术语“因”用于说明该变量依赖于受试者的行为或自变量的变化。</p>
<ul>
<li>如：任务完成时间、速度、准确性、错误率、任务重试的次数、按退格键次数等。</li>
<li>因变量必须被明确定义！</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何区分</p>
<ul>
<li><p>自变量通常是研究人员可以控制的实验条件；而因变量通常是研究者需要测量的实验结果</p>
</li>
<li><p>举例：下拉菜单和弹出菜单在定位页面的时间开销上没有差异。找出自变量和因变量</p>
</li>
</ul>
<p>典型技术相关自变量</p>
<ul>
<li>不同类型的技术或设备。如打字与语音听写，鼠标与操纵杆、触摸板等指向设备等。</li>
<li>不同类型的设计。如下拉式菜单与弹出式菜单，字体大小，对比度，背景色，网站架构等。</li>
</ul>
<p>典型因变量</p>
<ul>
<li>效率、准确性、主观满意度、易学性和易记性、体力或认知需求</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311656626.png" alt="image-20231231165658564"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311658698.png" alt="image-20231231165832638"></p>
<p><strong>组间设计与组内设计</strong></p>
<p>组间设计</p>
<ul>
<li>每个参与者只暴露在一种实验条件下</li>
<li>参与组的数量直接对应于实验条件的数量</li>
<li>优点：设计更简洁、避免了学习效应</li>
<li>缺点：结果受个体差异影响大、样本量大</li>
<li>一般用于：任务简单，个体差异有限；受学习效果影响较大的任务</li>
</ul>
<p>组内设计</p>
<ul>
<li>优点：样本量小、隔离了个体差异</li>
<li>学习效果的影响、疲劳问题</li>
<li>一般用于：个体差异较大、学习效果不太容易受到影响的任务、或目标参与者群体很小的任务</li>
<li>控制学习效果（将实验条件的顺序随机化）、解决疲劳问题（控制实验长度）</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311703593.png" alt="image-20231231170309544"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311707443.png" alt="image-20231231170732385"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311707032.png" alt="image-20231231170745967"></p>
<h3 id="评估方法的选择"><a href="#评估方法的选择" class="headerlink" title="评估方法的选择"></a><del>评估方法的选择</del></h3><ul>
<li>不同方法的适用阶段</li>
<li>评估方法的组合</li>
<li>似乎没讲？</li>
</ul>
<h3 id="20-DECIDE评估框架"><a href="#20-DECIDE评估框架" class="headerlink" title="20. DECIDE评估框架"></a>20. DECIDE评估框架</h3><blockquote>
<p>要贴合实际，不能光写定义</p>
<ul>
<li>D - Define the problem（定义问题）：明确定义需要做出决策的问题或挑战。</li>
<li>E - Explore the alternatives（探索备选方案）：识别和研究可行的备选方案或解决方案。</li>
<li>C - Consider the consequences（考虑后果）：评估每个备选方案的可能后果和影响。</li>
<li>I - Identify the values（确定价值观）：明确和权衡决策过程中的价值观和优先级。</li>
<li>D - Decide（做出决策）：基于分析和评估，选择最佳的备选方案或决策。</li>
<li>E - Evaluate the decision（评估决策）：跟踪和评估已做出的决策的效果和成果。</li>
</ul>
</blockquote>
<p>六个步骤</p>
<ol>
<li><p>确定目标</p>
<ul>
<li>举例：设计界面时，需量化评价界面质量，适合进行可用性测试；为儿童设计新产品时，要使产品吸引人，适合采用实地研究技术，观察儿童交谈</li>
</ul>
</li>
<li><p>发掘问题</p>
<ul>
<li>根据目标确定问题</li>
<li>目标：找出为什么客户愿意通过柜台购买纸质机票，而非通过互联网购买电子机票</li>
<li>问题：用户对新票据的态度如何，是否担心电子机票不能登机；用户是否能够通过互联网订票；是否担心交易的安全性；订票系统的界面是否友好，是否便于完成购票过程</li>
</ul>
</li>
<li><p>选择评估范型和技术</p>
</li>
<li><p>明确实际问题</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312312013138.png" alt="image-20231231201304075"></p>
</li>
<li><p>处理道德问题</p>
<ul>
<li>应保护个人隐私</li>
</ul>
</li>
<li><p>评估、解释并表示数据</p>
</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312312014921.png" alt="image-20231231201443857"></p>
<h3 id="21-小规模实验的重要性"><a href="#21-小规模实验的重要性" class="headerlink" title="21. 小规模实验的重要性"></a>21. 小规模实验的重要性</h3><blockquote>
<p> <strong>要开展小规模实验</strong>，这句话有分，用来验证实验的正确性和可行性</p>
</blockquote>
<h2 id="观察用户"><a href="#观察用户" class="headerlink" title="观察用户"></a>观察用户</h2><h3 id="22-观察方式"><a href="#22-观察方式" class="headerlink" title="22. 观察方式"></a>22. 观察方式</h3><p><strong>实验室观察</strong></p>
<p>在专门为可用性测试而安装配置的固定设备的环境下进行的观察：在一些情况下，在实验室中观察是唯一的选择：如空间站等危险环境下的系统</p>
<p>优点</p>
<ul>
<li>提供了可控且一致的评估环境</li>
<li>易于分析比较</li>
</ul>
<p>缺点</p>
<ul>
<li>可控且一致的评估环境<ul>
<li>人为环境、不自然</li>
<li>可能降低测试结论的普遍性和一般性</li>
</ul>
</li>
<li>不利于观察多人之间的协作</li>
</ul>
<p><strong>实地观察</strong></p>
<p>指在用户的实际环境中观察用户在使用软件时的情况</p>
<p>举例：超市收银系统</p>
<p>工作环境非常吵杂、收银员一般是站着操作、必须尽快地为每一个顾客结账、某些顾客可能不想要某个已经扫描过的商品、某些顾客在结账时发现自己还想买一样东西，于是先把已经扫描过的东西放下，转身回去继续购买、某些商品的标签打印得不清楚，条码扫描不起作用，收银员必须手工输入商品信息</p>
<p>观察结论：操作效率要非常高，使得收银员可以非常快速地完成各种常用操作、要尽可能预防各种操作失误的产生、可以不必太多关注系统的可学习性，假定收银员一定是经过了良好的培训后才允许上岗的、屏幕上显示信息时要一目了然，让收银员可以轻松、正确地识别出各种信息</p>
<h3 id="23-观察框架"><a href="#23-观察框架" class="headerlink" title="23. 观察框架"></a>23. 观察框架</h3><ul>
<li>减少干扰、完成目标</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311910984.png" alt="image-20231231191039891"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312311910414.png" alt="image-20231231191045358"></p>
<h3 id="24-数据记录方式"><a href="#24-数据记录方式" class="headerlink" title="24. 数据记录方式"></a>24. 数据记录方式</h3><ul>
<li>纸笔<ul>
<li>最原始、最廉价</li>
<li>前提: 对观察对象有一定的了解，从而有明确的观察侧重点</li>
<li>优点: 事后对观察结果进行分析的工作量小</li>
<li>缺点: 观察者容易疲劳，而且记录速度有限, 建议将记录者和评估者分开</li>
</ul>
</li>
<li>音视频<ul>
<li>适用场合: 对于观察对象不太了解，或者是需要观察的内容较多; 特别是在采用边做边说法时</li>
<li>缺点: 所含的信息量很大，所以数据分析非常耗时</li>
</ul>
</li>
<li>日志<ul>
<li>间接观察的适用场合<ul>
<li>直接观察可能影响用户</li>
<li>或者评估人员无法在现场进行研究</li>
<li>可根据搜集到的数据，推断实际情形，并找出可用性和用户体验方面的问题</li>
</ul>
</li>
<li>优点<ul>
<li>体现了用户是如何完成真实任务的</li>
<li>使得从工作在不同环境下的大量用户那里自动收集数据变得相当容易<ul>
<li>适用于用户分散、无法当面测试的情形, 如互联网应用和网站设计项目等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="询问用户和专家"><a href="#询问用户和专家" class="headerlink" title="询问用户和专家"></a>询问用户和专家</h2><h3 id="25-访谈"><a href="#25-访谈" class="headerlink" title="25. 访谈"></a>25. 访谈</h3><p>有目的的对话过程</p>
<p><strong>指导原则</strong></p>
<ul>
<li>避免过长的问题</li>
<li>避免使用复合句<ul>
<li>“这款手机与你先前拥有的手机相比，你觉得如何”</li>
<li>“你觉得这款手机怎么样？你是否有其他的手机？若是的话，你觉得它怎么样？”</li>
</ul>
</li>
<li>避免使用可能让用户感觉尴尬的术语或他们无法理解的语言</li>
<li>避免使用有诱导性的问题：你为什么喜欢这种交互方式？</li>
<li>尽可能保证问题是中性的</li>
</ul>
<p><strong>步骤</strong></p>
<ul>
<li>开始</li>
<li>热身</li>
<li>主要访谈</li>
<li>冷却</li>
<li>结束访谈</li>
</ul>
<p><strong>访谈类型</strong></p>
<ul>
<li>非结构化访谈：<ul>
<li>问题是开放式的，不限定内容和格式</li>
<li>受访人自行选择详细回答还是简要回答</li>
<li>访问人应确保能够搜集到重要问题的回答</li>
</ul>
</li>
<li>结构化访谈：<ul>
<li>根据预先确定的一组问题进行访谈</li>
<li>问题通常是“封闭式”的，它要求准确的回答</li>
</ul>
</li>
<li>半结构化访谈：<ul>
<li>开放式问题+封闭式问题</li>
<li>注意不要暗示答案</li>
</ul>
</li>
<li>集体访谈：<ul>
<li>基本思想：个别成员的看法是在应用的上下文中通过与其他用户的交流而形成的</li>
<li>“焦点小组”是集体访谈的一种形式</li>
</ul>
</li>
</ul>
<p><strong>焦点小组</strong></p>
<ul>
<li><p>非正式的评估方法</p>
<ul>
<li><p>在界面设计之前和经过一段使用之后评估用户的需要和感受</p>
</li>
<li><p>是市场、政治和社会科学研究经常使用的方法</p>
</li>
<li><p>人数限制：由大约 6 到 9 个典型用户组成</p>
</li>
<li><p>如在评估大学的网站时，可考虑由行政人员、教师和学生们组成 3 个分别的焦点小组</p>
</li>
</ul>
</li>
<li><p>主持人工作：</p>
<ul>
<li><p>事先列出一张讨论问题和数据收集目标的清单</p>
</li>
<li><p>保持所谈论的内容不离题</p>
</li>
<li><p>保证小组的每个成员都积极参与谈论</p>
</li>
<li><p>讨论结果的分析报告</p>
</li>
</ul>
</li>
<li><p>焦点小组存在风险</p>
</li>
</ul>
<h3 id="26-问卷调查"><a href="#26-问卷调查" class="headerlink" title="26. 问卷调查"></a>26. 问卷调查</h3><p>问卷调查是用于搜集统计数据和用户意见的常用方法</p>
<p><strong>问卷设计原则</strong></p>
<ul>
<li>应确保问题明确，具体</li>
<li>在可能时，采用封闭式问题并提供充分的答案选项</li>
<li>对于征求用户意见的问题，应提供一个“无看法”的答案选项</li>
<li>注意提问次序，先提出一般化问题，再提出具体问题</li>
<li>避免使用复杂的多重问题</li>
<li>在使用等级标度时，应设定适当的等级范围，并确保它们不重叠：做到直观、一致</li>
<li>避免使用术语</li>
<li>明确说明如何完成问卷：如说明应在选项前的方框内打“√”</li>
<li>在设计问卷时，既要做到紧凑，也应适当留空</li>
</ul>
<p><strong>问卷组织</strong></p>
<ul>
<li><p>问卷调查中的两个关键问题：</p>
<ul>
<li><p>如何寻找有代表性的用户</p>
</li>
<li><p>如何达到合理的回复率</p>
</li>
</ul>
</li>
<li><p>有助于提高回复率的措施：</p>
<ul>
<li>精心设计问卷，避免用户因为厌烦而拒绝回复</li>
<li>参照 QUIS，提供简要描述，说明用户若没有时间完成整份问卷，可以只完成简短的部分</li>
<li>提供一个带有回复地址并粘好了邮票的信封</li>
<li>解释为什么要进行这些问卷调查，并说明将为参与者保密</li>
<li>在发出问卷之后，通过后续邮件、电话或电子邮件联系参与者</li>
<li>采取一些激励措施（如有偿调查等）</li>
<li>进行小规模测验</li>
</ul>
</li>
</ul>
<h3 id="27-认知走查"><a href="#27-认知走查" class="headerlink" title="27. 认知走查"></a>27. 认知走查</h3><ul>
<li>逐步检查使用系统执行任务的过程，从中找出可用性问题</li>
<li>无需用户参与</li>
<li>认知走查的主要目标是确定使一个系统如何易于学习</li>
<li>试图想象出人们在第一次使用某个产品时的想法以及所采取的动作，它的大作流程是怎样的</li>
<li>评估的具体过程就是把用户在完成这个功能时所做的所有动作讲述成一个令人可以信服的故事</li>
</ul>
<p>步骤</p>
<ol>
<li>标识并记录典型用户的特性：有关用户自身心理、心理特点以及他们的知识和经验的描述</li>
<li>基于评估重点，设计样本任务：应该是大多数用户要做的典型任务</li>
<li>制作界面原型（或界面描述），明确用户执行任务的具体步骤</li>
<li>由设计人员和专家级评估人员（一位或多位）共同进行分析</li>
<li>评估人员结合应用的上下文，逐步检查每项任务的操作步骤</li>
<li>在完成逐步检查之后，汇总关键信息</li>
<li>修改设计，更正发现的问题</li>
</ol>
<p>认知走查的记录工作非常重要！</p>
<h3 id="28-启发式评估"><a href="#28-启发式评估" class="headerlink" title="28. 启发式评估"></a>28. 启发式评估</h3><p>一种灵活而又相当廉价的评估方式，由可用性专家完成。</p>
<p><strong>评估原则</strong></p>
<ol>
<li>系统状态的可见度</li>
<li>系统和现实世界的吻合</li>
<li>用户享有控制权和自主权</li>
<li>一致性和标准化</li>
<li>避免出错</li>
<li>依赖识别而非记忆</li>
<li>使用的灵活性和高效性：满足不同用户的需要</li>
<li>审美感和最小化设计</li>
<li>帮助用户识别、诊断和恢复错误</li>
<li>帮助和文档</li>
</ol>
<p><strong>评估步骤</strong></p>
<ol>
<li>彻底检查界面</li>
<li>将界面与启发式规则进行对比</li>
<li>列举可用性问题</li>
<li>应用启发式规则对每一个问题进行解释与确认</li>
</ol>
<h2 id="用户测试"><a href="#用户测试" class="headerlink" title="用户测试"></a>用户测试</h2><blockquote>
<p>用户测试和启发式评估都很重要</p>
<p>如果不要求得到定量结果可以不开展用户测试</p>
</blockquote>
<h3 id="29-用户测试"><a href="#29-用户测试" class="headerlink" title="29. 用户测试"></a>29. 用户测试</h3><p><strong>背景</strong></p>
<ul>
<li>在受控环境中（类似于实验室环境）测量典型用户执行典型任务的情况</li>
<li>目的是获得客观的性能数据，从而评价产品或系统的可用性，如易用性、易学性等</li>
<li>最适合对原型和能够运行的系统进行测试</li>
<li>可对设计提供重要的反馈</li>
<li>在可用性研究中，往往把用户测试和其他技术相结合</li>
</ul>
<p><strong>测试设计</strong></p>
<p>用户测试须考虑实际限制并做出适当的折衷：</p>
<ul>
<li>应确保不同参与者的测试条件相同</li>
<li>应确保评估目标特征具有代表性</li>
<li>实验可重复，但通常不能得到完全相同的结果</li>
<li>以 DECIDE 框架为基础</li>
</ul>
<p><strong>测试设计步骤</strong></p>
<ol>
<li><p>定义目标和问题：</p>
<ol>
<li>目标描述了开展一个测试的原因，定义了测试在整个项目中的价值</li>
<li>目标是对关注点的说明和解答<ol>
<li>举例：对菜单结构的关注</li>
<li>用户在第一次尝试使用时将能选择正确的菜单</li>
<li>用户在少于 5 秒的时间内，能够导航到正确的 3 级菜单</li>
</ol>
</li>
</ol>
</li>
<li><p>选择参与者：</p>
<ol>
<li>参与者的选择对于任何实验的成功至关重要</li>
<li>了解用户的特性有助于选择典型用户：要尽可能接近实际用户</li>
<li>通常也需要平衡性别比例</li>
<li>至少 4~5 位，5~12 位用户就足够了</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312312021757.png" alt="image-20231231202108700"></p>
</li>
<li><p>设计测试任务</p>
<ol>
<li>测试任务应当与定义的目标相关</li>
<li>测试任务通常是简单任务：如查找信息</li>
<li>有时采用较为复杂的任务：如加入在线社团等</li>
<li>任务不能仅限于所要测试的功能，应使用户全面的使用设计的各个区域<ol>
<li>如关注搜索功能的可用性，可请求参与者搜索找出产品 X</li>
<li>更好的方法就是请求参与者找出产品 X 并同产品 Y 进行比较</li>
</ol>
</li>
<li>每项任务的时间应介于 5~20 分钟</li>
<li>应当以某些合乎逻辑的方法安排任务：开始时，先提出简单问题有助于增强用户的自信心</li>
</ol>
</li>
<li><p>明确测试步骤</p>
<ol>
<li>在测试之前，准备好测试进度表和说明，设置好各种设备</li>
<li>正式测试前应进行小规模测试</li>
<li>在必要时，评估人员应询问参与者遇到了什么问题</li>
<li>若用户确实无法完成某些任务，应让他们继续下一项任务</li>
<li>测试过程应控制在 1 小时之内</li>
<li>必须分析所有搜集到的数据</li>
</ol>
</li>
<li><p>数据搜集与分析</p>
<ol>
<li>确定如何度量观测的结果</li>
<li>使用的度量类型依赖于所选择的任务</li>
<li>常用的定量度量<ol>
<li>完成任务的时间</li>
<li>停止使用产品一段时间后，完成任务的时间</li>
<li>执行每项任务时的出错次数和错误类型</li>
<li>单位时间内的出错次数</li>
<li>求助在线帮助或手册的次数</li>
<li>用户犯某个特定错误的次数</li>
<li>成功完成任务的用户数</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="以用户为中心"><a href="#以用户为中心" class="headerlink" title="以用户为中心"></a>以用户为中心</h2><p>TODO：这部分ppt没找到</p>
<h3 id="30-用户参与设计"><a href="#30-用户参与设计" class="headerlink" title="30. 用户参与设计"></a>30. 用户参与设计</h3><ul>
<li>重要性</li>
<li>形式</li>
<li>上下文询问法</li>
</ul>
<h3 id="31-正确看待“以用户为中心”"><a href="#31-正确看待“以用户为中心”" class="headerlink" title="31. 正确看待“以用户为中心”"></a>31. 正确看待“以用户为中心”</h3><p>英文：UCD User-Centered Design</p>
<p>局限性：缺少创新，无法充分调动主观能动性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/29/JUC-8-LockSupport%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/29/JUC-8-LockSupport%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/" class="post-title-link" itemprop="url">JUC(8) LockSupport与线程中断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-29 17:23:02" itemprop="dateCreated datePublished" datetime="2023-12-29T17:23:02+08:00">2023-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-05 00:03:15" itemprop="dateModified" datetime="2024-02-05T00:03:15+08:00">2024-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-线程中断机制"><a href="#1-线程中断机制" class="headerlink" title="1. 线程中断机制"></a>1. 线程中断机制</h2><p>面试题：</p>
<ul>
<li>Java.lang.Thread下的三个方法的用法和区别</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312292357410.png" alt="img"></p>
<ul>
<li>如何中断一个运行中的线程？</li>
<li>如何停止一个运行中的线程？</li>
</ul>
<h3 id="1-1-什么是中断机制"><a href="#1-1-什么是中断机制" class="headerlink" title="1.1 什么是中断机制"></a>1.1 什么是中断机制</h3><ul>
<li>首先，一个线程不应该由其他线程来强制中断或停止，而是<strong>应该由线程自己自行停止</strong>，所以<code>Thread.stop</code>, <code>Thread.suspend</code>, <code>Thread.resume</code>都已经被废弃了</li>
<li>其次，在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的协商机制——<strong>中断</strong>，也即<strong>中断标识协商机制</strong><ul>
<li><strong>中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自行实现。</strong>若要中断一个线程，你需要手动调用该线程 interrupt 方法，该方法也仅仅是<strong>将该线程对象的中断标识设置为true</strong>，接着你需要自己写代码不断检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，此时究竟应该做什么需要你自己写代码实现</li>
<li>每个线程对象都有一个中断标识位，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断</li>
<li>通过调用线程对象的 interrupt 方法将该线程的标识位设置为true；可以在别的线程中调用，也可以在自己的线程中调用</li>
</ul>
</li>
</ul>
<h3 id="1-2-中断API"><a href="#1-2-中断API" class="headerlink" title="1.2 中断API"></a>1.2 中断API</h3><ul>
<li><p><code>public void interrupt()</code></p>
<ul>
<li><p>实例方法 Just to set the interrupt flag</p>
</li>
<li><p>实例方法仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程</p>
</li>
</ul>
</li>
<li><p><code>public static boolean interrupted()</code></p>
<ul>
<li><p>静态方法 <code>Thread.interrupted();</code></p>
</li>
<li><p>判断当前线程是否被中断并清除当前中断状态(做了两件事情)</p>
<ul>
<li><p>返回当前线程的中断状态，测试当前线程是否已被中断</p>
</li>
<li><p>将当前线程的中断状态清零并重新设置为false，清除线程的中断状态</p>
</li>
</ul>
</li>
<li><p>如果连续两次调用此方法，则第二次返回false</p>
</li>
</ul>
</li>
<li><p><code>public boolean isInterrupted()</code></p>
<ul>
<li><p>实例方法</p>
</li>
<li><p>判断当前线程是否被中断(通过检查中断标志位)</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-面试题中断机制考点"><a href="#1-3-面试题中断机制考点" class="headerlink" title="1.3 面试题中断机制考点"></a>1.3 面试题中断机制考点</h3><h4 id="如何停止运行中的线程？"><a href="#如何停止运行中的线程？" class="headerlink" title="如何停止运行中的线程？"></a>如何停止运行中的线程？</h4><ul>
<li>通过一个volatile变量实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isStop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//volatile表示的变量具有可见性</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (isStop) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; isStop的值被改为true，t1程序停止&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;-----------hello volatile&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; isStop = <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -----------hello volatile</span><br><span class="hljs-comment"> * -----------hello volatile</span><br><span class="hljs-comment"> * -----------hello volatile</span><br><span class="hljs-comment"> * -----------hello volatile</span><br><span class="hljs-comment"> * t1 isStop的值被改为true，t1程序停止</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<ul>
<li>通过AtomicBoolean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">atomicBoolean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (atomicBoolean.get()) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; atomicBoolean的值被改为true，t1程序停止&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;-----------hello atomicBoolean&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; atomicBoolean.set(<span class="hljs-literal">true</span>), <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -----------hello atomicBoolean</span><br><span class="hljs-comment"> * -----------hello atomicBoolean</span><br><span class="hljs-comment"> * -----------hello atomicBoolean</span><br><span class="hljs-comment"> * -----------hello atomicBoolean</span><br><span class="hljs-comment"> * t1 atomicBoolean的值被改为true，t1程序停止</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<ul>
<li>通过Thread类自带的中断api实例方法实现<ul>
<li>在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑stop线程。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; isInterrupted()的值被改为true，t1程序停止&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;-----------hello isInterrupted()&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-comment">//t2向t1放出协商，将t1中的中断标识位设为true，希望t1停下来</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; t1.interrupt(), <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -----------hello isInterrupted()</span><br><span class="hljs-comment"> * -----------hello isInterrupted()</span><br><span class="hljs-comment"> * -----------hello isInterrupted()</span><br><span class="hljs-comment"> * -----------hello isInterrupted()</span><br><span class="hljs-comment"> * t1 isInterrupted()的值被改为true，t1程序停止</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h4 id="当前线程中断标识为true，是不是线程就立刻停止"><a href="#当前线程中断标识为true，是不是线程就立刻停止" class="headerlink" title="当前线程中断标识为true，是不是线程就立刻停止"></a>当前线程中断标识为true，是不是线程就立刻停止</h4><p>答案是不立刻停止，具体来说，当对一个线程调用interrupt时：</p>
<ul>
<li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响，所以interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行，<strong>对于不活动的线程没有任何影响</strong>。</li>
<li>如果线程处于阻塞状态(例如sleep, wait, join等)，在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态(<strong>中断标志也将被清除</strong>)，并抛出一个InterruptedException异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 中断标志位为：true 程序停止&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//sleep方法抛出InterruptedException后，中断标识也被清空置为false，如果没有在</span><br>            <span class="hljs-comment">//catch方法中必须调用interrupt方法再次将中断标识置为true，否则将导致无限循环</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;-------------hello InterruptDemo3&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t1::interrupt, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="静态方法Thread-interrupted-谈谈你的理解"><a href="#静态方法Thread-interrupted-谈谈你的理解" class="headerlink" title="静态方法Thread.interrupted(), 谈谈你的理解"></a>静态方法<code>Thread.interrupted()</code>, 谈谈你的理解</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> currentThread().isInterrupted(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>返回当前线程中断标志位，并且清空中断标志位</strong><ul>
<li>也就是说，如果连续两次调用该方法，第二次调用将返回false</li>
<li>除非当前线程在第一次和第二次调用之间再次被 interrupt</li>
</ul>
</li>
</ul>
<h2 id="2-线程等待唤醒机制"><a href="#2-线程等待唤醒机制" class="headerlink" title="2. 线程等待唤醒机制"></a>2. 线程等待唤醒机制</h2><p>三种实现方式：</p>
<ol>
<li>关键字 <code>synchronized</code> 与 <code>wait()/notify()</code> 一起使用可以实现等待/通知模式</li>
<li><code>Lock</code> 接口中的 <code>newContition()</code> 方法返回 Condition 对象，Condition 类使用 <code>await()/signal()</code> 也可以实现等待/通知模式</li>
<li>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li>
</ol>
<h3 id="2-1-synchronized实现"><a href="#2-1-synchronized实现" class="headerlink" title="2.1 synchronized实现"></a>2.1 synchronized实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span>&#123;<br>    <span class="hljs-comment">// 设置临界资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 实现+1操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 操作：判断、干活、通知</span><br>        <span class="hljs-keyword">while</span> (number != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// number不为0，等待</span><br>            <span class="hljs-comment">// wait 有一个特点，在哪里睡，就在哪里醒</span><br>            <span class="hljs-built_in">this</span>.wait();	<br>        &#125;<br>        number++;<br>        System.out.print(Thread.currentThread().getName()+<span class="hljs-string">&quot;::&quot;</span>+number);<br>        <span class="hljs-comment">// 唤醒其他线程</span><br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br><br>    <span class="hljs-comment">// 实现-1操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decr</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (number != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">this</span>.wait();<br>        &#125;<br>        number--;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;::&quot;</span>+number);<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>上述代码中进行判断时必须使用 while 而不是 if，否则会产生<strong>虚假唤醒</strong>问题，即唤醒后不需要再进行判断而可以直接执行</p>
</blockquote>
<h3 id="2-2-Lock实现"><a href="#2-2-Lock实现" class="headerlink" title="2.2 Lock实现"></a>2.2 Lock实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span> &#123;<br>    <span class="hljs-comment">// 设置临界资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 创建一个Condition</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">// 实现+1操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">0</span>) &#123;<br>                condition.await();<br>            &#125;<br>            number++;<br>            System.out.print(Thread.currentThread().getName() + <span class="hljs-string">&quot;::&quot;</span> + number + <span class="hljs-string">&quot;---&gt;&quot;</span>);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现-1操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decr</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (number != <span class="hljs-number">1</span>) &#123;<br>                condition.await();<br>            &#125;<br>            number--;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;::&quot;</span> + number);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>定制化通信</strong></p>
<blockquote>
<p>案例：启动三个线程，按照如下要求：<br>AA打印5次，BB打印10次，CC打印15次，一共进行10轮</p>
<p>具体思路：每个线程添加一个标志位，是该标志位则执行操作，并且修改为下一个标志位，通知下一个标志位的线程。创建一个可重入锁与三个开锁通知</p>
<p>该案例被称为<strong>单标志法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Share</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 创建三个Comdition对象，为了定向唤醒相乘</span><br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Aprint</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(flag!=<span class="hljs-number">1</span>) &#123;<br>                c1.await();<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ::本次第&quot;</span> + i + <span class="hljs-string">&quot;次打印，是第&quot;</span> + loop+ <span class="hljs-string">&quot;次循环&quot;</span>);<br>            &#125;<br>            flag = <span class="hljs-number">2</span>; <span class="hljs-comment">//修改标志位，定向唤醒 线程b</span><br>            c2.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Bprint</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(flag!=<span class="hljs-number">2</span>) &#123;<br>                c2.await();<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ::本次第&quot;</span> + i + <span class="hljs-string">&quot;次打印，是第&quot;</span> + loop+ <span class="hljs-string">&quot;次循环&quot;</span>);<br>            &#125;<br>            flag = <span class="hljs-number">3</span>; <span class="hljs-comment">//修改标志位，定向唤醒 线程c</span><br>            c3.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Cprint</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(flag!=<span class="hljs-number">3</span>) &#123;<br>                c3.await();<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">15</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ::本次第&quot;</span> + i + <span class="hljs-string">&quot;次打印，是第&quot;</span> + loop+ <span class="hljs-string">&quot;次循环&quot;</span>);<br>            &#125;<br>            flag = <span class="hljs-number">1</span>; <span class="hljs-comment">//修改标志位，定向唤醒 线程a</span><br>            c1.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>单标志法的问题</p>
<ul>
<li>该算法可确保每次只允许一个进程进入临界区，但进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也无法进入临界区</li>
</ul>
<h3 id="2-3-LockSupport实现"><a href="#2-3-LockSupport实现" class="headerlink" title="2.3 LockSupport实现"></a>2.3 LockSupport实现</h3><blockquote>
<p>上述两种方法使用都有限制</p>
<ul>
<li>线程需要先获得并持有锁，必须在锁块(synchronized 或 lock)中</li>
<li>必须要先等待后唤醒，线程才能够被唤醒</li>
</ul>
</blockquote>
<p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。其中的 <code>park()</code> 和 <code>unpark()</code> 的作用分别是阻塞线程和解除阻塞线程</p>
<p>LockSupport类使用了一种名为Permit(许可)的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可(Permit)，<strong>但与Semaphore不同的是，许可证不会累积，最多只有一个</strong></p>
<p>主要方法(全部都是静态方法, 底层使用 <code>UNSAFE</code> 类实现)</p>
<ul>
<li>阻塞：<ul>
<li>Permit许可证默认没有不能放行，所以一开始调 <code>park()</code> 方法当前线程就会阻塞，直到别的线程给当前线程的发放 Permit，park 方法才会被唤醒。</li>
<li><code>park()</code>: 阻塞当前线程</li>
</ul>
</li>
<li>唤醒：<ul>
<li>调用 <code>unpark(thread)</code> 方法后，就会发放 thread 线程的许可证，会自动唤醒 park 线程，即之前阻塞中的 <code>LockSuppot.park()</code> 方法会立即返回。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * t1	 ----------come in</span><br><span class="hljs-comment">     * t2	 ----------发出通知</span><br><span class="hljs-comment">     * t1	 ----------被唤醒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t ----------come in&quot;</span>);<br>        LockSupport.park();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t ----------被唤醒&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        LockSupport.unpark(t1);<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t ----------发出通知&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul>
<li><strong>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语</strong>，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻塞后也有对应的唤醒方法。归根结底，LockSupport时调用Unsafe中的native代码</li>
<li>LockSupport提供 <code>park()</code> 和 <code>unpark()</code> 方法实现阻塞线程和解除线程阻塞的过程，LockSupport和每个使用它的线程都有一个许可(Permit)关联，每个线程都有一个相关的permit，permit最多只有一个，重复调用 unpark 也不会积累凭证。</li>
<li><p>形象理解：线程阻塞需要消耗凭证(Permit)，这个凭证最多只有一个</p>
</li>
<li><p>当调用park时，如果有凭证，则会直接消耗掉这个凭证然后正常退出。如果没有凭证，则必须阻塞等待凭证可用；</p>
</li>
<li>当调用unpark时，它会增加一个凭证，但凭证最多只能有1个，累加无效。</li>
</ul>
<p>面试题</p>
<ul>
<li><p>为什么LockSupport可以突破wait/notify的原有调用顺序？</p>
<ul>
<li>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞，先发放了凭证后续可以畅通无阻。</li>
</ul>
</li>
<li><p>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</p>
<ul>
<li>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证，而调用两次park却需要消费两个凭证，证不够，不能放行。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/29/JUC-7-Fork-Join/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/29/JUC-7-Fork-Join/" class="post-title-link" itemprop="url">JUC(7) Fork/Join</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-29 15:17:14 / Modified: 16:24:29" itemprop="dateCreated datePublished" datetime="2023-12-29T15:17:14+08:00">2023-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Fork/Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork/Join 框架要完成两件事情：</p>
<ul>
<li>任务分割：首先 Fork/Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割<ul>
<li>Fork：把一个复杂任务进行分拆，大事化小</li>
</ul>
</li>
<li>执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。<ul>
<li>Join：把分拆任务的结果进行合并</li>
</ul>
</li>
</ul>
<p>Java Fork/Join 框架实现方式</p>
<ul>
<li><p><code>ForkJoinTask</code>: 我们要使用 Fork/Join 框架，首先需要创建一个 ForkJoin 任务。该类提供了在任务中执行 fork 和 join 的机制。通常情况下我们不需要直接集成 ForkJoinTask 类，只需要继承它的子类，Fork/Join 框架提供了两个子类</p>
<ul>
<li><code>RecursiveAction</code>: 用于没有返回结果的任务</li>
<li><code>RecursiveTask</code>: 用于有返回结果的任务<ul>
<li>继承后可以实现递归(自己调自己)调用的任务</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ForkJoinPool</code>: <code>ForkJoinTask</code> 需要通过 <code>ForkJoinPool</code> 来执行</p>
<ul>
<li><code>ForkJoinPool</code> 由 <code>ForkJoinTask</code> 数组和 <code>ForkJoinWorkerThread</code> 数组组成</li>
<li><code>ForkJoinTask</code> 数组负责存放以及将程序提交给 <code>ForkJoinPool</code></li>
<li><code>ForkJoinWorkerThread</code> 负责执行这些任务</li>
</ul>
</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291549444.png" alt="image-20231229154916392" style="zoom:80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291550057.png" alt="image-20231229155049016" style="zoom:80%;" /></p>
<h2 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2. 核心方法"></a>2. 核心方法</h2><h3 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h3><p>当我们调用 <code>ForkJoinTask</code> 的 <code>fork</code> 方法时，程序会把任务放在 <code>ForkJoinWorkerThread</code> 的 <code>workQueue</code> 中，异步地执行这个任务，然后立即返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> &#123;<br>    Thread t;<br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">else</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>push</code> 方法把当前任务存放在 <code>ForkJoinTask</code> 数组队列里。然后再调用 <code>ForkJoinPool</code> 的 <code>signalWork()</code> 方法唤醒或创建一个工作线程来执行任务。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> base, s = top, n;<br>    <span class="hljs-keyword">if</span> ((a = array) != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// ignore if queue removed</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> a.length - <span class="hljs-number">1</span>;     <span class="hljs-comment">// fenced write for task visibility</span><br>        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);<br>        U.putOrderedInt(<span class="hljs-built_in">this</span>, QTOP, s + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> ((n = s - b) &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((p = pool) != <span class="hljs-literal">null</span>)<br>                p.signalWork(p.workQueues, <span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= m)<br>            growArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-2-join"><a href="#2-2-join" class="headerlink" title="2.2 join"></a>2.2 join</h3><p>Join 方法的主要作用是阻塞当前线程并等待获取结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <span class="hljs-keyword">return</span> (s = status) &lt; <span class="hljs-number">0</span> ? s :<br>        ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) ?<br>        (w = (wt = (ForkJoinWorkerThread)t).workQueue).<br>        tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span> ? s :<br>        wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>) :<br>        externalAwaitDone();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doExec</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; <span class="hljs-type">boolean</span> completed;<br>    <span class="hljs-keyword">if</span> ((s = status) &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            completed = exec();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable rex) &#123;<br>            <span class="hljs-keyword">return</span> setExceptionalCompletion(rex);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (completed)<br>            s = setCompletion(NORMAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它首先调用 <code>doJoin()</code> 方法，得到当前任务的状态来判断返回什么结果，任务状态有 4 种:</p>
<ul>
<li>已完成（NORMAL）直接返回任务结果</li>
<li>被取消（CANCELLED）直接抛出 CancellationException</li>
<li>信号（SIGNAL）</li>
<li>出现异常（EXCEPTIONAL）直接抛出对应的异常</li>
</ul>
<p><code>doJoin()</code> 方法流程如下</p>
<ol>
<li>首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态</li>
<li>如果没有执行完，则从任务数组里取出任务并执行。</li>
<li>如果任务顺利执行完成，则设置任务状态为 NORMAL，如果出现异常，则记录异常，并将任务状态设置为 EXCEPTIONAL。</li>
</ol>
<h2 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h2><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。</p>
<p>getException 方法返回 Throwable 对象，如果任务被取消了则返回 CancellationException。如果任务没有完成或者没有抛出异常则返回 null</p>
<h2 id="4-案例"><a href="#4-案例" class="headerlink" title="4. 案例"></a>4. 案例</h2><p>1加到100，要求相加的一列数的首尾两个数差值不能大于10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-comment">// 拆分差值不能超过10</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> begin;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> end;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> result;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-built_in">this</span>.begin = begin;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 判断两个值的差值是否大于10</span><br>        <span class="hljs-keyword">if</span>((end-begin)&lt;=<span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 相加操作</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i &lt;= end ; i++) &#123;<br>                result = result + i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 大于10 继续拆分</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (begin + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 拆分左边</span><br>            <span class="hljs-type">MyTask</span> <span class="hljs-variable">task01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(begin, middle);<br>            <span class="hljs-comment">// 拆分右边</span><br>            <span class="hljs-type">MyTask</span> <span class="hljs-variable">task02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(middle + <span class="hljs-number">1</span>, end);<br>            <span class="hljs-comment">// 调用方法拆分</span><br>            task01.fork();<br>            task02.fork();<br>            <span class="hljs-comment">// 合并结果</span><br>            result = task01.join() + task02.join();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 创建MyTask对象</span><br>        <span class="hljs-type">MyTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-comment">// 创建分支合并池对象</span><br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(task);<br><br>        <span class="hljs-comment">// 获取最终合并之后结果</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">reslut</span> <span class="hljs-operator">=</span> forkJoinTask.get();<br>        System.out.println(reslut);<br>        <span class="hljs-comment">// 关闭池对象</span><br>        forkJoinPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2023/12/29/JUC-6-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/29/JUC-6-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">JUC(6) 线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-12-29 14:34:37 / Modified: 15:15:20" itemprop="dateCreated datePublished" datetime="2023-12-29T14:34:37+08:00">2023-12-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>线程池</strong>(thread pool)一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度</p>
<p><strong>线程池的优势</strong>：线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超过数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>线程池的特点：</p>
<ul>
<li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>
<li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>Java 中的线程池是通过 <code>Executor</code> 框架实现的，该框架中用到了 <code>Executor</code>，<code>Executors</code>，<code>ExecutorService</code>，<code>ThreadPoolExecutor</code> 这几个类</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291440375.png" alt="image-20231229144024317" style="zoom:80%;" /></p>
<h2 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2. 使用方式"></a>2. 使用方式</h2><p>创建线程池</p>
<ul>
<li><p><code>Executors.newFixedThreadPool(int)</code>：一池N线程</p>
<ul>
<li>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</li>
<li>如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务。在某个线程被显式地关闭之前，池中的线程将一直存在。</li>
<li>线程池中的线程处于一定的量，可以很好的控制线程的并发量</li>
<li>线程可以重复被使用，在显式关闭之前，都将一直存在</li>
<li>超出一定量的线程被提交时候需在队列中等待</li>
</ul>
</li>
<li><p><code>Executors.newSingleThreadExecutor()</code>：一池一线程</p>
<ul>
<li>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。</li>
<li>如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务</li>
</ul>
</li>
<li><p><code>Executors.newCachedThreadPool()</code>：一池可扩容根据需求创建线程</p>
<ul>
<li>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>
<li>线程池中数量没有固定，可达到最大值(<code>Interger. MAX_VALUE</code>)</li>
<li>线程池中的线程可进行缓存重复利用和回收(回收默认时间为 1 分钟)</li>
<li>当线程池中没有可用线程，会重新创建一个线程</li>
</ul>
</li>
<li><code>Executors.newScheduledThreadPool(int corePoolSize)</code>(了解)<ul>
<li>线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</li>
<li>线程池中具有指定数量的线程，即便是空线程也将保留</li>
<li>可定时或者延迟执行线程活动</li>
<li>适用于需要多个后台线程执行周期任务的场景</li>
</ul>
</li>
<li><code>Executors.newWorkStealingPool(int parallelism)</code><ul>
<li>parallelism：并行级别，通常默认为 JVM 可用的处理器个数</li>
<li>底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务</li>
<li>适用于大耗时，可并行执行的场景</li>
</ul>
</li>
</ul>
<p>执行线程：</p>
<ul>
<li><code>void execute(Runnable command)</code> 参数为Runnable接口类，可以设置lambda</li>
</ul>
<p>关闭线程：</p>
<ul>
<li><code>shutdown()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool1</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool2</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool3</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-comment">// 是个顾客请求</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">// 到此时执行execute()方法才创建线程</span><br>            threadPool1.execute(()-&gt;&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 办理业务&quot;</span>);<br>            &#125;);<br>        &#125;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 关闭线程</span><br>        threadPool1.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>threadPool1 执行结果</th>
<th>threadPool2 执行结果</th>
<th>threadPool3 执行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291457725.png" alt="image-20231229145713692"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291457280.png" alt="image-20231229145743251"></td>
<td><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291458811.png" alt="image-20231229145809781"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-线程池参数"><a href="#3-线程池参数" class="headerlink" title="3. 线程池参数"></a>3. 线程池参数</h2><h3 id="3-1-参数解释"><a href="#3-1-参数解释" class="headerlink" title="3.1 参数解释"></a>3.1 参数解释</h3><p>通过查看上面三种方式创建对象的类源代码，都有 <code>new ThreadPoolExecutor</code></p>
<p>具体查看该类的源代码，涉及七个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, // 常驻(核心)</span>线程数量<br>                          <span class="hljs-type">int</span> maximumPoolSize, <span class="hljs-comment">// 最大线程数量</span><br>                          <span class="hljs-type">long</span> keepAliveTime, <span class="hljs-comment">// 空闲线程存活时间</span><br>                          TimeUnit unit, <span class="hljs-comment">// 时间单位</span><br>                          BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-comment">// 阻塞队列(存放提交但未执行任务的队列)</span><br>                          ThreadFactory threadFactory, <span class="hljs-comment">// 线程工厂，用于创建线程</span><br>                          RejectedExecutionHandler handler <span class="hljs-comment">// 拒绝策略(线程满了)</span><br>                         ) &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.acc = System.getSecurityManager() == <span class="hljs-literal">null</span> ?<br>            <span class="hljs-literal">null</span> :<br>            AccessController.getContext();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2-工作流程"><a href="#3-2-工作流程" class="headerlink" title="3.2 工作流程"></a>3.2 工作流程</h3><p>当提交任务数大于 <code>corePoolSize</code> 的时候，会优先将任务放到 <code>workQueue</code> 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到 <code>maximumPoolSize</code> 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p>
<p>当提交的任务数大于 <code>workQueue.size() + maximumPoolSize</code>，就会触发线程池的拒绝策略。</p>
<p>示例：阻塞队列为3，常驻线程数2，最大线程数5，现在来了9个任务</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291507007.png" alt="img" style="zoom:80%;" /></p>
<p>第1-2个线程进入线程池创建</p>
<p>第3-5个线程进入阻塞队列</p>
<p>第6-8个线程会为他们创建新线程执行（直接运行线程6而非线程3）</p>
<p>第9个线程会被拒绝</p>
<h3 id="3-3-拒绝策略"><a href="#3-3-拒绝策略" class="headerlink" title="3.3 拒绝策略"></a>3.3 拒绝策略</h3><p>AbortPolicy(默认): 丢弃任务，并<strong>抛出拒绝执行 RejectedExecutionException 异常信息</strong>。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</p>
<p>CallerRunsPolicy: 当触发拒绝策略，只要线程池没有关闭的话，则<strong>使用调用线程直接运行任务</strong>。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</p>
<p>DiscardOldestPolicy: 当触发拒绝策略，只要线程池没有关闭的话，<strong>丢弃阻塞队列 workQueue 中最老的一个任务</strong>，并将新任务加入，尝试再次提交</p>
<p>DiscardPolicy: 直接丢弃</p>
<h2 id="4-自定义线程池"><a href="#4-自定义线程池" class="headerlink" title="4. 自定义线程池"></a>4. 自定义线程池</h2><p>实际在开发中不允许使用 <code>Executors</code> 创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，规避资源耗尽风险</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202312291513055.png" alt="image-20231229151351014"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 定义线程池</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-comment">// 常驻线程数量（核心）2个</span><br>            <span class="hljs-number">2</span>,<br>            <span class="hljs-comment">// 最大线程数量5个</span><br>            <span class="hljs-number">5</span>,<br>            <span class="hljs-comment">// 线程存活时间:2秒</span><br>            <span class="hljs-number">2L</span>,<br>            TimeUnit.SECONDS,<br>            <span class="hljs-comment">// 阻塞队列</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>            <span class="hljs-comment">// 默认线程工厂</span><br>            Executors.defaultThreadFactory(),<br>            <span class="hljs-comment">// 拒绝策略。抛出异常</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()<br>    );<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; i++) &#123;<br>            threadPool.execute(()-&gt;&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 办理业务&quot;</span>);<br>            &#125;);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 关闭线程池</span><br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
