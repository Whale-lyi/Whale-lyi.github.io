<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Redis(3) 分布式锁 | Whale&#39;s Blog | Stay hungry, Stay foolish</title>

  
  <meta name="author" content="Whale">
  

  
  <meta name="description" content="码农预备役">
  

  
  
  <meta name="keywords" content="Redis">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Redis(3) 分布式锁"/>

  <meta property="og:site_name" content="Whale&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whale&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Whale&#39;s Blog</a>
    </h1>
    <p class="site-description">Stay hungry, Stay foolish</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Redis(3) 分布式锁</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/02/18/Redis-3-分布式锁/" rel="bookmark">
        <time class="entry-date published" datetime="2024-02-18T11:18:45.000Z">
          2024-02-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-Redisson-分布式锁"><a href="#1-Redisson-分布式锁" class="headerlink" title="1. Redisson 分布式锁"></a>1. Redisson 分布式锁</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202402181920501.png" alt="image-20240218192041327"></p>
<p><strong>可重入</strong>：利用hash结构记录线程id和重入次数</p>
<p><strong>可重试</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</p>
<p><strong>超时续约</strong>：利用watchDog，开启一个定时任务，每隔一段时间（releaseTime / 3），重置超时时间</p>
<p><strong>主从一致性问题</strong>：利用MultiLock锁，Redis不再区分主从节点，只有所有的节点都写入成功，才是加锁成功，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</p>
<h3 id="MultiLock原理"><a href="#MultiLock原理" class="headerlink" title="MultiLock原理"></a>MultiLock原理</h3><p>构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonClient2.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonClient3.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>lock = redissonClient.getMultiLock(lock1, lock2, lock3);<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RedissonMultiLock</span><span class="hljs-params">(RLock... locks)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locks.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Lock objects are not defined&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.locks.addAll(Arrays.asList(locks));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>联锁的tryLock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">newLeaseTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;<br>    <span class="hljs-comment">//如果传入了释放时间</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1L</span>) &#123;<br>        <span class="hljs-comment">//再判断一下是否有等待时间</span><br>        <span class="hljs-keyword">if</span> (waitTime == -<span class="hljs-number">1L</span>) &#123;<br>            <span class="hljs-comment">//如果没传等待时间，不重试，则只获得一次</span><br>            newLeaseTime = unit.toMillis(leaseTime);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//想要重试，耗时较久，万一释放时间小于等待时间，则会有问题，所以这里将等待时间乘以二</span><br>            newLeaseTime = unit.toMillis(waitTime) * <span class="hljs-number">2L</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取当前时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//剩余等待时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">remainTime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">if</span> (waitTime != -<span class="hljs-number">1L</span>) &#123;<br>        remainTime = unit.toMillis(waitTime);<br>    &#125;<br>    <span class="hljs-comment">//锁等待时间，与剩余等待时间一样    </span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">lockWaitTime</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.calcLockWaitTime(remainTime);<br>    <span class="hljs-comment">//锁失败的限制，源码返回是的0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">failedLocksLimit</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.failedLocksLimit();<br>    <span class="hljs-comment">//已经获取成功的锁</span><br>    List&lt;RLock&gt; acquiredLocks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-built_in">this</span>.locks.size());<br>    <span class="hljs-comment">//迭代器，用于遍历</span><br>    ListIterator&lt;RLock&gt; iterator = <span class="hljs-built_in">this</span>.locks.listIterator();<br><br>    <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> (RLock)iterator.next();<br><br>        <span class="hljs-type">boolean</span> lockAcquired;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//没有等待时间和释放时间，调用空参的tryLock</span><br>            <span class="hljs-keyword">if</span> (waitTime == -<span class="hljs-number">1L</span> &amp;&amp; leaseTime == -<span class="hljs-number">1L</span>) &#123;<br>                lockAcquired = lock.tryLock();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//否则调用带参的tryLock</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">awaitTime</span> <span class="hljs-operator">=</span> Math.min(lockWaitTime, remainTime);<br>                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RedisResponseTimeoutException var21) &#123;<br>            <span class="hljs-built_in">this</span>.unlockInner(Arrays.asList(lock));<br>            lockAcquired = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var22) &#123;<br>            lockAcquired = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断获取锁是否成功</span><br>        <span class="hljs-keyword">if</span> (lockAcquired) &#123;<br>            <span class="hljs-comment">//成功则将锁放入成功锁的集合</span><br>            acquiredLocks.add(lock);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果获取锁失败</span><br>            <span class="hljs-comment">//判断当前锁的数量，减去成功获取锁的数量，如果为0，则所有锁都成功获取，跳出循环</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.locks.size() - acquiredLocks.size() == <span class="hljs-built_in">this</span>.failedLocksLimit()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//否则将拿到的锁都释放掉</span><br>            <span class="hljs-keyword">if</span> (failedLocksLimit == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">this</span>.unlockInner(acquiredLocks);<br>                <span class="hljs-comment">//如果等待时间为-1，则不想重试，直接返回false</span><br>                <span class="hljs-keyword">if</span> (waitTime == -<span class="hljs-number">1L</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                failedLocksLimit = <span class="hljs-built_in">this</span>.failedLocksLimit();<br>                <span class="hljs-comment">//将已经拿到的锁都清空</span><br>                acquiredLocks.clear();<br>                <span class="hljs-comment">//将迭代器往前迭代，相当于重置指针，放到第一个然后重试获取锁</span><br>                <span class="hljs-keyword">while</span>(iterator.hasPrevious()) &#123;<br>                    iterator.previous();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --failedLocksLimit;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果剩余时间不为-1，很充足</span><br>        <span class="hljs-keyword">if</span> (remainTime != -<span class="hljs-number">1L</span>) &#123;<br>            <span class="hljs-comment">//计算现在剩余时间</span><br>            remainTime -= System.currentTimeMillis() - time;<br>            time = System.currentTimeMillis();<br>            <span class="hljs-comment">//如果剩余时间为负数，则获取锁超时了</span><br>            <span class="hljs-keyword">if</span> (remainTime &lt;= <span class="hljs-number">0L</span>) &#123;<br>                <span class="hljs-comment">//将之前已经获取到的锁释放掉，并返回false</span><br>                <span class="hljs-built_in">this</span>.unlockInner(acquiredLocks);<br>                <span class="hljs-comment">//联锁成功的条件是：每一把锁都必须成功获取，一把锁失败，则都失败</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果设置了锁的有效期</span><br>    <span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1L</span>) &#123;<br>        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(acquiredLocks.size());<br>        <span class="hljs-comment">//迭代器用于遍历已经获取成功的锁</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var24</span> <span class="hljs-operator">=</span> acquiredLocks.iterator();<br><br>        <span class="hljs-keyword">while</span>(var24.hasNext()) &#123;<br>            <span class="hljs-type">RLock</span> <span class="hljs-variable">rLock</span> <span class="hljs-operator">=</span> (RLock)var24.next();<br>            <span class="hljs-comment">//设置每一把锁的有效期</span><br>            RFuture&lt;Boolean&gt; future = ((RedissonLock)rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);<br>            futures.add(future);<br>        &#125;<br><br>        var24 = futures.iterator();<br><br>        <span class="hljs-keyword">while</span>(var24.hasNext()) &#123;<br>            RFuture&lt;Boolean&gt; rFuture = (RFuture)var24.next();<br>            rFuture.syncUninterruptibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//但如果没设置有效期，则会触发WatchDog机制，自动帮我们设置有效期，所以大多数情况下，我们不需要自己设置有效期</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Backend/">Backend</a>, <a href="/categories/Backend/Redis/">Redis</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Redis/">Redis</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Whale
    
  </p>
</footer>
    
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>