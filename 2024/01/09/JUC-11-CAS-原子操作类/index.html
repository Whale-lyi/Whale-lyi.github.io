<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="南京大学软件学院大三在读" />
  
  
  <title>
    
      JUC(11) CAS、自旋锁、原子操作类 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">JUC(11) CAS、自旋锁、原子操作类</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2024-01-10 17:55:53
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Language/" title="Language">
                    <b>#</b> Language
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/Language/Java/" title="Java">
                    <b>#</b> Java
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h2><h3 id="1-1-CAS概述"><a href="#1-1-CAS概述" class="headerlink" title="1.1 CAS概述"></a>1.1 CAS概述</h3><p>CAS(compare and swap)，中文翻译为比较并交换，实现并发算法时常用到的一种技术，用于保证共享变量的原子性更新，它包含三个操作数—-内存位置、预期原值与更新值。</p>
<p>执行CAS操作的时候，将内存位置的值与预期原值进行比较：</p>
<ul>
<li>如果相匹配，那么处理器会自动将该位置更新为新值</li>
<li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</li>
</ul>
<p>CAS 有 3 个操作数，位置内存值 V，旧的预期值 A，要修改的更新值 B。当且仅当旧的预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做或重试。</p>
<p>重试的这种行为称为<strong>自旋</strong>。原理有点类似乐观锁，修改带版本号。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091431044.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">5</span>);<br>    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2022</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicInteger.get());<span class="hljs-comment">//true	2022</span><br>    System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2023</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicInteger.get());<span class="hljs-comment">//false	2022</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">true	2022</span><br><span class="hljs-comment">false	2022</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>CAS 是 JDK 提供的<strong>非阻塞</strong>原子性操作，它通过<strong>硬件保证</strong>了比较-更新的原子性。</p>
<p>CAS 是一条 CPU 的原子指令(<code>cmpxchg</code>指令)，不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法(如<code>compareAndSwapXXX</code>)底层实现即为CPU指令<code>cmpxchg</code></p>
<p>执行<code>cmpxchg</code>指令的时候，会判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，只有一个线程会对总线加锁成功，加锁成功之后会执行 CAS 操作，也就是说 <strong>CAS 的原子性实际上是 CPU 实现独占的</strong>，比起用 synchronized 重量级锁，这里的排他时间要短很多，所以在多线程情况下性能会比较好。</p>
<p>底层源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, Object var4, Object var5)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">long</span> var4, <span class="hljs-type">long</span> var6)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>var1: 表示要操作的对象</li>
<li>var2: 表示要操作对象中属性地址的偏移量</li>
<li>var4: 预期原值</li>
<li>var5/6: 更新值</li>
</ul>
<p><strong>原子类靠的是CAS思想，CAS思想实现靠的是Unsafe类。工作中尽量不要使用UnSafe类，使用不当容易出现问题</strong></p>
<h3 id="1-2-CAS原理"><a href="#1-2-CAS原理" class="headerlink" title="1.2 CAS原理"></a>1.2 CAS原理</h3><h4 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h4><p>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe 类存在于 sun.misc 包中，其内部方法操作可以像 C 的指针一样直接操作内存，因此 Java 中 CAS 操作的执行依赖于 Unsafe 类的方法。</p>
<p>注意：<strong>Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的所有方法都直接调用操作系统底层资源执行相应任务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6214790243416807050L</span>;<br><br>    <span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = unsafe.objectFieldOffset<br>                (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>valueOffset</code> 表示该变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的</li>
<li>value 用 volatile 修饰，保证多线程的可见性</li>
</ul>
<blockquote>
<p>问题：我们知道 i++ 是线程不安全的，那 <code>AtomicInteger.getAndIncrement()</code> 如何保证原子性？</p>
<p>AtomicInteger 类主要利用 CAS + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091520326.png" alt="img" style="zoom: 67%;" /></p>
<p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 中的各个方法。调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于 CAS 是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，不会造成所谓的数据不一致问题。</p>
</blockquote>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>假设线程 A 和线程 B 两个线程同时执行 <code>getAndAddInt</code> 操作(分别跑在不同CPU上):</p>
<ol>
<li>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicIntegeri 的 value 为 3，根据 JMM 模型，线程 A 和线程 B 各自持有一份值为 3 的 value 的副本分别到各自的工作内存</li>
<li>线程 A 通过 <code>getIntVolatile(var1, var2)</code> 拿到 value 值 3，这时线程 A 被挂起</li>
<li>线程 B 也通过 <code>getIntVolatile(var1, var2)</code> 方法获取到 value 值 3，此时刚好线程 B 没有被挂起并执行 <code>compareAndSwapInt</code> 方法比较内存值也为 3，成功修改内存值为 4</li>
<li>这时线程 A 恢复，执行 <code>compareAndSwapInt</code> 方法比较，发现自己手里的值数字 3 和主内存的值数字 4 不一致，说明该值已经被其它线程抢先一步修改过了，那 A 线程本次修改失败，只能重新读取重新来一遍了</li>
<li>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总是能够看到，线程 A 继续执行 <code>compareAndSwapInt</code> 进行比较替换，直到成功。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091530818.png" alt="image-20240109153017719"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091532475.png" alt="image-20240109153231399"></p>
<p>以 WIN10 为例</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091534127.png" alt="image-20240109153423046"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401091535293.png" alt="image-20240109153542242"></p>
<p>总结：</p>
<ul>
<li>CAS 是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性</li>
<li>实现方式是基于硬件平台的汇编指令，在 intel 的 CPU 中，使用的是汇编指令 <code>compxchg</code> 指令</li>
<li>核心思想就是比较要更新变量 V 的值和预期值 E，相等才会将 V 的值设为新值 N，如果不相等自旋再来</li>
</ul>
<h3 id="1-3-原子引用-AtomicReference"><a href="#1-3-原子引用-AtomicReference" class="headerlink" title="1.3 原子引用 AtomicReference"></a>1.3 原子引用 AtomicReference</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    String userName;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">z3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;z3&quot;</span>, <span class="hljs-number">22</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">li4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;li4&quot;</span>, <span class="hljs-number">25</span>);<br><br>        atomicReference.set(z3);<br>        System.out.println(atomicReference.compareAndSet(z3, li4) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());<br>        System.out.println(atomicReference.compareAndSet(z3, li4) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">true	User(userName=li4, age=25)</span><br><span class="hljs-comment">false	User(userName=li4, age=25)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="1-4-CAS与自旋锁"><a href="#1-4-CAS与自旋锁" class="headerlink" title="1.4 CAS与自旋锁"></a>1.4 CAS与自旋锁</h3><p>CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了操作的原子性，以达到锁的效果，至于自旋锁是指尝试获取锁的线程<strong>不会立即阻塞</strong>，而是<strong>采用循环的方式去尝试获取锁</strong>，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU</p>
<p>例如 <code>Unsafe#getAndAddInt</code> 方法中的 do-while 循环, 当操作成功返回 true 时，循环结束; 当返回 false 时，接着执行循环，继续尝试CAS操作，直到返回true</p>
<p>自己实现一个自旋锁</p>
<ul>
<li>通过 CAS 完成自旋锁，A 线程先进来调用 <code>myLock</code> 方法自己持有锁 5 秒钟，B 随后进来后发现当前有线程持有锁，所以只能通过自旋等待，直到 A 释放锁后 B 随后抢到。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLockDemo</span> &#123;<br>    <br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-literal">null</span>, thread)) &#123;&#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set successfully&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        atomicReference.compareAndSet(thread, <span class="hljs-literal">null</span>);<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t task over, unLock&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpinLockDemo</span> <span class="hljs-variable">spinLockDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpinLockDemo</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            spinLockDemo.unlock();<br>        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            spinLockDemo.lock();<br>            spinLockDemo.unlock();<br>        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A	 come in</span><br><span class="hljs-comment">A	 set successfully</span><br><span class="hljs-comment">B	 come in</span><br><span class="hljs-comment">A	 task over, unLock</span><br><span class="hljs-comment">B	 set successfully</span><br><span class="hljs-comment">B	 task over, unLock</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果还想支持可重入，可以增加一个 int 成员变量作为计数器</p>
<p><a target="_blank" rel="noopener" href="https://learnku.com/articles/49689">https://learnku.com/articles/49689</a></p>
</blockquote>
<h3 id="1-5-ABA问题"><a href="#1-5-ABA问题" class="headerlink" title="1.5 ABA问题"></a>1.5 ABA问题</h3><p>CAS 的缺点</p>
<ul>
<li>如果 CAS 失败，会一直进行尝试，长时间不成功会给 CPU 带来很大的开销</li>
<li>CAS 会导致 “ABA问题”</li>
</ul>
<p>ABA 问题是如何产生的</p>
<ul>
<li><p>CAS 算法实现一个重要前提是取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个<strong>时间差</strong>类会导致数据的变化</p>
</li>
<li><p>比如说一个线程 1 从内存位置 V 中取出 A，这时候另一个线程 2 也从内存中取出 A，并且线程2 进行了一些操作将值变成了 B，然后线程 2 又将 V 位置的数据变成 A，这时候线程 1 进行 CAS 操作发现内存中仍然是 A，预期OK，然后线程 1 操作成功</p>
</li>
<li><p>尽管线程 1 的 CAS 操作成功，但是不代表这个过程就是没有问题的</p>
</li>
</ul>
<p>解决方法</p>
<ul>
<li><p>比较 + 版本号</p>
</li>
<li><p>版本号时间戳原子引用(<code>AtomicStampedReference</code>)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        abaHappen();//true	2023</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * t3	首次版本号: 1</span><br><span class="hljs-comment">         * t4	首次版本号: 1</span><br><span class="hljs-comment">         * t3	2次版本号: 2</span><br><span class="hljs-comment">         * t3	3次版本号: 3</span><br><span class="hljs-comment">         * false	100	3</span><br><span class="hljs-comment">         */</span><br>        abaNoHappen();<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abaNoHappen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedReference.getStamp();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;首次版本号: &quot;</span> + stamp);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;2次版本号: &quot;</span> + atomicStampedReference.getStamp());<br>            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="hljs-number">1</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;3次版本号: &quot;</span> + atomicStampedReference.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicStampedReference.getStamp();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;首次版本号: &quot;</span> + stamp);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, stamp, stamp + <span class="hljs-number">1</span>);<br>            System.out.println(b + <span class="hljs-string">&quot;\t&quot;</span> + atomicStampedReference.getReference() + <span class="hljs-string">&quot;\t&quot;</span> + atomicStampedReference.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abaHappen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            atomicInteger.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            atomicInteger.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2023</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicInteger.get());<span class="hljs-comment">//true	2023</span><br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-原子操作类"><a href="#2-原子操作类" class="headerlink" title="2. 原子操作类"></a>2. 原子操作类</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401092007488.png" alt="在这里插入图片描述"></p>
<h3 id="2-1-基本类型原子类"><a href="#2-1-基本类型原子类" class="headerlink" title="2.1 基本类型原子类"></a>2.1 基本类型原子类</h3><p><code>AtomicInteger</code>, <code>AtomicBoolean</code>, <code>AtomicLong</code></p>
<p>常用API:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//获取当前的值，并设置新的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">//获取当前的值，并自增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值，并自减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> <span class="hljs-comment">//获取当前的值，并加上预期的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值(update)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySet</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></code></pre></td></tr></table></figure>
<p>Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumber</span> &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPlusPlus</span><span class="hljs-params">()</span> &#123;<br>        atomicInteger.getAndIncrement();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyNumber</span> <span class="hljs-variable">myNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyNumber</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(SIZE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= SIZE; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">10</span>; j++) &#123;<br>                        myNumber.addPlusPlus();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br><br>        &#125;<br>        countDownLatch.await();<br><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;result: &quot;</span> + myNumber.atomicInteger.get());<span class="hljs-comment">//main	result: 500</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>CountDownLatch 最佳实践：使用带有超时时间的 await 方法，通过判断count是否大于0，来判断是执行完毕还是代码超时。比起不带超时的await方法，优点在于等待时间可控，不会因意外一直等待。</p>
</blockquote>
<h3 id="2-2-数组类型原子类"><a href="#2-2-数组类型原子类" class="headerlink" title="2.2 数组类型原子类"></a>2.2 数组类型原子类</h3><p><code>AtomicIntegerArray</code>, <code>AtomicLongArray</code>, <code>AtomicReferenceArray</code></p>
<p>常用API:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//获取 index=i 位置元素的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndDecrement</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> delta)</span> <span class="hljs-comment">//获取 index=i 位置元素的值，并加上预期的值</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值(update)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazySet</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> newValue)</span><span class="hljs-comment">//最终将 index=i 位置的元素设置为newValue, 使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></code></pre></td></tr></table></figure>
<p>Case:</p>
<p><code>AtomicIntegerArray</code>初始化必须指定数组或数组长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">atomicIntegerArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++)&#123;<br>        System.out.println(atomicIntegerArray.get(i)); <span class="hljs-comment">// 0 0 0 0 0</span><br>    &#125;<br>    <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;);<br>    array.getAndAdd(<span class="hljs-number">0</span>, <span class="hljs-number">999</span>);<br>    System.out.println(array.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 1000</span><br>    array.getAndIncrement(<span class="hljs-number">4</span>);<br>    System.out.println(array.get(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-3-引用类型原子类"><a href="#2-3-引用类型原子类" class="headerlink" title="2.3 引用类型原子类"></a>2.3 引用类型原子类</h3><ul>
<li><code>AtomicReference</code>: 引用类型原子类</li>
<li><p><code>AtomicStampedReference</code>: 原子更新带有<strong>版本号</strong>的引用类型。该类将整数值与引用关联起来。</p>
<ul>
<li>可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题</li>
<li><strong>解决修改过几次</strong></li>
</ul>
</li>
<li><p><code>AtomicMarkableReference</code>: 原子更新带有<strong>标记</strong>的引用类型。该类将 boolean 标记与引用关联起来</p>
<ul>
<li><strong>解决是否修改过</strong>，它的定义就是将标记戳简化为true/false，类似于一次性筷子</li>
</ul>
</li>
</ul>
<p>Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicMarkableReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;Integer&gt; markableReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markableReference.isMarked();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;默认标识: &quot;</span> + marked); <span class="hljs-comment">//t1	默认标识: false</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            markableReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>, marked, !marked);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markableReference.isMarked();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;默认标识: &quot;</span> + marked);<span class="hljs-comment">//t2	默认标识: false</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> markableReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2000</span>, marked, !marked);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;t2线程CASResult：&quot;</span> + b);<span class="hljs-comment">//t2	t2线程CASResult：false</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + markableReference.isMarked());<span class="hljs-comment">//t2	true</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + markableReference.getReference());<span class="hljs-comment">//t2	1000</span><br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-4-对象的属性修改原子类"><a href="#2-4-对象的属性修改原子类" class="headerlink" title="2.4 对象的属性修改原子类"></a>2.4 对象的属性修改原子类</h3><ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新对象中int类型字段的值</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新对象中Long类型字段的值</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新对象中引用类型字段的值</li>
</ul>
<p>使用目的: 以一种线程安全的方式操作非线程安全对象内的某些字段</p>
<p>使用要求:</p>
<ul>
<li>更新的对象属性必须使用 public volatile 修饰符</li>
<li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 <code>newUpdater()</code> 创建一个更新器，并且需要设置想要更新的类和属性</li>
</ul>
<p>AtomicIntegerFieldUpdater Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    AtomicIntegerFieldUpdater&lt;BankAccount&gt; atomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class, <span class="hljs-string">&quot;money&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferMoney</span><span class="hljs-params">(BankAccount bankAccount)</span> &#123;<br>        atomicIntegerFieldUpdater.getAndIncrement(bankAccount);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">BankAccount</span> <span class="hljs-variable">bankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankAccount</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1000</span>; j++) &#123;<br>                        bankAccount.transferMoney(bankAccount);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br><br>        &#125;<br>        countDownLatch.await(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (countDownLatch.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;============执行超时============&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&#x27;\t&#x27;</span> + <span class="hljs-string">&quot;result: &quot;</span> + bankAccount.money); <span class="hljs-comment">//main	result: 10000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AtomicReferenceFieldUpdater Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 需求：多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作</span><br><span class="hljs-comment"> * 要求只能被初始化一次，只有一个线程操作成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVar</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">isInit</span> <span class="hljs-operator">=</span> Boolean.FALSE;<br>    <br>    AtomicReferenceFieldUpdater&lt;MyVar, Boolean&gt; referenceFieldUpdater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class, Boolean.class, <span class="hljs-string">&quot;isInit&quot;</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (referenceFieldUpdater.compareAndSet(<span class="hljs-built_in">this</span>, Boolean.FALSE, Boolean.TRUE)) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;--------------start init ,need 2 seconds&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;--------------over init&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;--------------已经有线程进行初始化工作了。。。。。&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyVar</span> <span class="hljs-variable">myVar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyVar</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myVar::init, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2	--------------已经有线程进行初始化工作了。。。。。</span><br><span class="hljs-comment">5	--------------已经有线程进行初始化工作了。。。。。</span><br><span class="hljs-comment">4	--------------已经有线程进行初始化工作了。。。。。</span><br><span class="hljs-comment">3	--------------已经有线程进行初始化工作了。。。。。</span><br><span class="hljs-comment">1	--------------start init ,need 2 seconds</span><br><span class="hljs-comment">1	--------------over init</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="2-5-原子操作增强类"><a href="#2-5-原子操作增强类" class="headerlink" title="2.5 原子操作增强类"></a>2.5 原子操作增强类</h3><ul>
<li><code>DoubleAccumulator</code>：一个或多个变量共同维护使用提供的函数更新的运行 double 值</li>
<li><code>DoubleAdder</code>：一个或多个变量共同维护最初的零和 double 总和</li>
<li><code>LongAccumulator</code>：一个或多个变量共同维护使用提供的函数更新的运行 double 值，提供了自定义的函数操作</li>
<li><code>LongAdder</code>：一个或多个变量共同维护最初的零和 long 总和，只能用来计算加法，且从 0 开始计算</li>
</ul>
<blockquote>
<p>面试题:</p>
<ol>
<li>热点商品点赞计算器，点赞数加加统计，不要求实时精确</li>
<li>一个很大的list，里面都是int类型，如何实现加加，思路？</li>
</ol>
</blockquote>
<p>以 <code>LongAdder</code> 为例，常用API:</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401100123470.png" alt="image.png" style="zoom:50%;" /></p>
<p>LongAdder, LongAccumulator Case:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    longAdder.add(<span class="hljs-number">3</span>);<br>    longAdder.increment();<br>    System.out.println(longAdder.sum()); <span class="hljs-comment">// 4</span><br>    longAdder.decrement();<br>    System.out.println(longAdder.sum()); <span class="hljs-comment">// 3</span><br><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((x, y) -&gt; x - y,<span class="hljs-number">0</span>);<br>    longAccumulator.accumulate(<span class="hljs-number">6</span>); <span class="hljs-comment">// 0 - 6</span><br>    longAccumulator.accumulate(<span class="hljs-number">2</span>); <span class="hljs-comment">// -6 - 2</span><br>    System.out.println(longAccumulator.get()); <span class="hljs-comment">// -8</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>比较不同方式实现高并发点赞消耗时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 需求：50个线程，每个线程100w次，消耗时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickNumber</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickBySynchronized</span><span class="hljs-params">()</span> &#123;<br>        number++;<br>    &#125;<br><br>    <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByAtomicLong</span><span class="hljs-params">()</span> &#123;<br>        atomicLong.getAndIncrement();<br>    &#125;<br><br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAdder</span><span class="hljs-params">()</span> &#123;<br>        longAdder.increment();<br>    &#125;<br><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>(Long::sum, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAccumulator</span><span class="hljs-params">()</span> &#123;<br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccumulatorCompareDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_100W</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ClickNumber</span> <span class="hljs-variable">clickNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClickNumber</span>();<br>        <span class="hljs-type">long</span> startTime;<br>        <span class="hljs-type">long</span> endTime;<br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_NUMBER);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_NUMBER);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_NUMBER);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_NUMBER);<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; _100W; j++) &#123;<br>                        clickNumber.clickBySynchronized();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch1.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch1.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;costTime: &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; 毫秒&quot;</span> + <span class="hljs-string">&quot;\t clickBySynchronized: &quot;</span> + clickNumber.number);<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; _100W; j++) &#123;<br>                        clickNumber.clickByAtomicLong();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch2.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch2.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;costTime: &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; 毫秒&quot;</span> + <span class="hljs-string">&quot;\t clickByAtomicLong: &quot;</span> + clickNumber.atomicLong.get());<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; _100W; j++) &#123;<br>                        clickNumber.clickByLongAdder();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch3.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch3.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;costTime: &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; 毫秒&quot;</span> + <span class="hljs-string">&quot;\t clickByLongAdder: &quot;</span> + clickNumber.longAdder.sum());<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; _100W; j++) &#123;<br>                        clickNumber.clickByLongAccumulator();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch4.countDown();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch4.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;costTime: &quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; 毫秒&quot;</span> + <span class="hljs-string">&quot;\t clickByLongAccumulator: &quot;</span> + clickNumber.longAccumulator.get());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">costTime: 2522 毫秒	 clickBySynchronized: 50000000</span><br><span class="hljs-comment">costTime: 492 毫秒	 clickByAtomicLong: 50000000</span><br><span class="hljs-comment">costTime: 82 毫秒	 clickByLongAdder: 50000000</span><br><span class="hljs-comment">costTime: 54 毫秒	 clickByLongAccumulator: 50000000</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="2-6-原子操作增强类原理解析"><a href="#2-6-原子操作增强类原理解析" class="headerlink" title="2.6 原子操作增强类原理解析"></a>2.6 原子操作增强类原理解析</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401101344658.png" alt="img"></p>
<p><code>LongAdder</code> 是 <code>Striped64</code> 的子类</p>
<ul>
<li>如果是JDK8，推荐使用 <code>LongAdder</code> 对象，比 <code>AtomicLong</code> 性能更好(减少乐观锁的重试次数)</li>
<li>低更新争用下，<code>LongAdder</code> 与 <code>AtomicLong</code> 具有相似的特征；但在高争用的情况下，<code>LongAdder</code> 预期吞吐量明显更高，但代价是空间消耗更高</li>
</ul>
<h4 id="Striped64"><a href="#Striped64" class="headerlink" title="Striped64"></a>Striped64</h4><p>关键内部类与成员变量</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401101357105.png" alt="image-20240110135746035"></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401101400905.png" alt="img" style="zoom: 50%;" /></p>
<p>Cell 是 java.util.concurrent.atomic 下 Striped64 的一个内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>    Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>        <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>    &#125;<br><br>    <span class="hljs-comment">// Unsafe mechanics</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            UNSAFE = sun.misc.Unsafe.getUnsafe();<br>            Class&lt;?&gt; ak = Cell.class;<br>            valueOffset = UNSAFE.objectFieldOffset<br>                (ak.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>@sun.misc.Contended</code> 用于避免<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyfonly/p/5800758.html">伪共享</a>, 单独占一个缓存行</p>
</blockquote>
<h4 id="LongAdder-为什么这么快"><a href="#LongAdder-为什么这么快" class="headerlink" title="LongAdder 为什么这么快"></a><code>LongAdder</code> 为什么这么快</h4><ul>
<li><p><code>LongAdder</code> 的基本思路就是<strong>分散热点</strong>，将 value 值分散到一个 Cell 数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多，如果要获取真正的 long 值，只要将各个槽中的变量值累加返回</p>
</li>
<li><p><code>sum()</code> 会将<strong>所有的 Cell 数组中的 value 和 base 累加作为返回值</strong>，核心的思想就是将之前 <code>AtomicLong</code> 一个 value 的更新压力分散到多个 value 中去，从而降级更新热点。</p>
</li>
<li><p>内部有一个base变量，一个Cell[]数组</p>
<ul>
<li><p>base变量：低并发，直接累加到该变量上</p>
</li>
<li><p>Cell[]数组：高并发，累加进各个线程自己的槽Cell[i]中</p>
</li>
</ul>
</li>
<li><p>$Sum = Base + \textstyle\sum_{i=1}^nCell[i].value$</p>
</li>
</ul>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p><code>LongAdder</code> 在无竞争的情况下，跟 <code>AtomicLong</code> 一样，对同一个 base 进行操作，当出现竞争关系时则是采用化整为零分散热点的做法，用空间换时间，用一个数组 cells，将一个 value 值拆分进这个数组 cells。多个线程需要同时对 value 进行操作的时候，可以对线程 id 进行 hash 得到 hash 值，再根据 hash 值映射到这个数组 cells 的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组 cells 的所有值和 base 都加起来作为最终结果</p>
<p>以 increment 为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Equivalent to &#123;<span class="hljs-doctag">@code</span> add(1)&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    add(<span class="hljs-number">1L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * as 表示 cells 引用</span><br><span class="hljs-comment"> * b 表示获取的 base 值</span><br><span class="hljs-comment"> * v 表示期望值</span><br><span class="hljs-comment"> * m 表示 cells 数组的长度</span><br><span class="hljs-comment"> * a 表示当前线程命中的 cell 单元格</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>    Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;<br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended = a.cas(v = a.value, v + x)))<br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>单线程时 cells 为 null, 运行 <code>casBase</code>, 即只修改 base 值, 随后就结束方法</li>
<li>如果出现了多线程, <code>casBase</code> 可能返回 false, 执行 if 内部<ul>
<li>默认 <code>uncontended = true</code>, 没有冲突, <code>as == null</code> 为真, 执行 <code>longAccumulate</code>，初始化创建大小为 2 的Cell数组</li>
</ul>
</li>
<li>接下来执行 add 方法因为 as 不再为 null, 会直接执行 if 内部<ul>
<li><code>a = as[getProbe() &amp; m]) == null</code> 会判断 Cell 数组中的某个下标处是否为空</li>
<li>如果为空, 执行 longAccumulate, uncontended 为 ture</li>
<li>如果不为空, 执行 <code>!(uncontended = a.cas(v = a.value, v + x))</code><ul>
<li>将该槽位中的值加 x, 如果成功执行了, 则 uncontended 为 true, 方法结束</li>
<li>如果出现了冲突, uncontended 为 false, 执行 longAccumulate, 要进行扩容</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>条件递增，逐步解析</p>
<ul>
<li>最初无竞争只更新 base</li>
<li>如果更新 base 失败后，首次新建 Cell 数组</li>
<li>当多个线程竞争同一个 Cell 比较激烈时，可能需要对 Cell 数组扩容</li>
</ul>
</blockquote>
<h5 id="longAccumulate"><a href="#longAccumulate" class="headerlink" title="longAccumulate"></a>longAccumulate</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Handles cases of updates involving initialization, resizing,</span><br><span class="hljs-comment"> * creating new Cells, and/or contention. See above for</span><br><span class="hljs-comment"> * explanation. This method suffers the usual non-modularity</span><br><span class="hljs-comment"> * problems of optimistic retry code, relying on rechecked sets of</span><br><span class="hljs-comment"> * reads.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x the value</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fn the update function, or null for add (this convention</span><br><span class="hljs-comment"> * avoids the need for an extra field or function in LongAdder).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wasUncontended false if CAS failed before call</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn,</span><br><span class="hljs-params">                          <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;<br>    <span class="hljs-comment">// 存储线程的probe值，可以理解为hash值</span><br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// getProbe返回0说明随机数未初始化</span><br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br>        <span class="hljs-comment">// CASE1: cells已经被初始化了</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 1.1</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    <span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);   <span class="hljs-comment">// Optimistically create</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Cell[] rs; <span class="hljs-type">int</span> m, j;<br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                                rs[j] = r;<br>                                created = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (created)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                collide = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 1.2</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                wasUncontended = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <span class="hljs-comment">// 1.3</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                                         fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//1.4</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-comment">//1.5</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//1.6</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="hljs-comment">// 扩容</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 当前的 cells 与最先赋值的 as 是同一个，表示没有被其他线程扩容过</span><br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                collide = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">// CASE2: cells没有加锁且没有初始化，则尝试对他进行加锁，并初始化cells数组</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123; <span class="hljs-comment">// double check，防止创建多个数组</span><br>                    Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 初始化创建大小为2的Cell数组</span><br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);<br>                    cells = rs;<br>                    init = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// CASE3: cells正在进行初始化，则尝试直接在基数base上进行累加操作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                                    fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>首先给当前线程分配一个 hash 值，然后进入一个 for(;;)自旋，分为三个分支</p>
<ul>
<li>CASE1: cells已经被初始化了，其中又分为了 6 个 if 语句<ol>
<li>判断了当前线程 hash 后指向的数据位置元素是否为空，如果空则将Cell数据放入数组，跳出循环，不空则继续循环</li>
<li>wasUncontended 表示 cells 初始化后，当前线程竞争修改失败，这里只是将其设置为 true，紧接着执行 advanceProbe(h) 重置当前线程的 hash，重新循环</li>
<li>说明当前线程对应的数组中有了数据，也重置过 hash 值，这时通过 CAS 对当前数中的 value 进行累加 x 操作，如果 CAS 成功则跳出循环</li>
<li>如果 n 大于 CPU 最大数量，不可扩容，并通过 advanceProbe(h) 重置 hash，重新循环</li>
<li>如果扩容意向 collide 为 false 则修改为 true，然后重新计算线程 hash 继续循环。</li>
<li>扩容</li>
</ol>
</li>
<li>CASE2: cells没有加锁且没有初始化，则尝试对他进行加锁，并初始化cells数组</li>
<li>CASE3: cells正在进行初始化，则尝试直接在基数base上进行累加操作</li>
</ul>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401101742044.png" alt="img" style="zoom:80%;" /></p>
<h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the current sum.  The returned value is &lt;em&gt;NOT&lt;/em&gt; an</span><br><span class="hljs-comment"> * atomic snapshot; invocation in the absence of concurrent</span><br><span class="hljs-comment"> * updates returns an accurate result, but concurrent updates that</span><br><span class="hljs-comment"> * occur while the sum is being calculated might not be</span><br><span class="hljs-comment"> * incorporated.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the sum</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>    Cell[] as = cells; Cell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>sum() 会将所有 Cell 数组中的 value 和 base 累加作为返回值。核心思想就是将之前 AtomicLong 一个 value 的更新压力分散到多个 value 中去，从而降级更新热点。</li>
<li><strong><code>sum()</code> 执行时，并没有限制对 base 和 cells 的更新，所以 <code>LongAdder</code> 不是强一致性的，它是最终一致性的</strong>，对cell的读取无法保证是最后一次写入的值，所以在没有并发的场景下，可以获得正确的结果</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>AtomicLong</code></p>
<ul>
<li>原理：CAS + 自旋</li>
<li>场景：低并发下的全局计算，AtomicLong 能保证并发情况下计数的准确性，其内部通过 CAS 来解决并发安全性问题</li>
<li>缺陷：高并发后性能急剧下降：AtomicLong 的自旋会成为瓶颈 (N 个线程 CAS 操作修改线程的值，每次只有一个成功过，其他 N-1 失败，失败的不停自旋直至成功，这样大量失败自旋的情况，一下子 CPU 就打高了)</li>
</ul>
<p><code>LongAdder</code></p>
<ul>
<li>原理：CAS + Base + Cell数组分散 (空间换时间并分散了热点数据)</li>
<li>场景：当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用。保证性能，精度代价</li>
<li>缺陷：sum 求和后还有计算线程修改结果的话，最后结果不够准确</li>
</ul>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/01/08/JUC-10-volatile%E4%B8%8EJMM/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2024-01-10 17:55:53
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Language/" title="Language">
                        <b>#</b> Language
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/Language/Java/" title="Java">
                        <b>#</b> Java
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2024/01/10/JUC-12-ThreadLocal/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CAS"><span class="toc-text">1. CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-CAS%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 CAS概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-CAS%E5%8E%9F%E7%90%86"><span class="toc-text">1.2 CAS原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsafe"><span class="toc-text">Unsafe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8-AtomicReference"><span class="toc-text">1.3 原子引用 AtomicReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-CAS%E4%B8%8E%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">1.4 CAS与自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-ABA%E9%97%AE%E9%A2%98"><span class="toc-text">1.5 ABA问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="toc-text">2. 原子操作类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">2.1 基本类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">2.2 数组类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">2.3 引用类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">2.4 对象的属性修改原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%BC%BA%E7%B1%BB"><span class="toc-text">2.5 原子操作增强类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%BC%BA%E7%B1%BB%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">2.6 原子操作增强类原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-text">架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Striped64"><span class="toc-text">Striped64</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LongAdder-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-text">LongAdder 为什么这么快</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#add"><span class="toc-text">add</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#longAccumulate"><span class="toc-text">longAccumulate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sum"><span class="toc-text">sum</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + JUC(11)%20CAS%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2024%2F01%2F09%2FJUC-11-CAS-%25E5%258E%259F%25E5%25AD%2590%25E6%2593%258D%25E4%25BD%259C%25E7%25B1%25BB%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2024/01/09/JUC-11-CAS-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
