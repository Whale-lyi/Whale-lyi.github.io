<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"whale-lyi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. 被volatile修饰的变量有两大特点 特点：  可见性  有序性：有排序要求，有时需要禁止指令重排  不存在数据依赖关系可以重排，否则禁重排，重排后的指令也不能改变原有串行语义     内存语义：  当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC(10) volatile与JMM">
<meta property="og:url" content="https://whale-lyi.github.io/2024/01/08/JUC-10-volatile%E4%B8%8EJMM/index.html">
<meta property="og:site_name" content="Whale&#39;s Blog">
<meta property="og:description" content="1. 被volatile修饰的变量有两大特点 特点：  可见性  有序性：有排序要求，有时需要禁止指令重排  不存在数据依赖关系可以重排，否则禁重排，重排后的指令也不能改变原有串行语义     内存语义：  当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082018812.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081952339.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081952773.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082159430.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082214122.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090002842.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090018466.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090019875.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090034422.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090053498.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090054393.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090055930.png">
<meta property="og:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090059511.png">
<meta property="article:published_time" content="2024-01-08T07:25:42.000Z">
<meta property="article:modified_time" content="2024-01-08T17:00:39.702Z">
<meta property="article:author" content="Whale">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082018812.png">

<link rel="canonical" href="https://whale-lyi.github.io/2024/01/08/JUC-10-volatile%E4%B8%8EJMM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JUC(10) volatile与JMM | Whale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://whale-lyi.github.io/2024/01/08/JUC-10-volatile%E4%B8%8EJMM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Whale">
      <meta itemprop="description" content="码农预备役">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whale's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JUC(10) volatile与JMM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-08 15:25:42" itemprop="dateCreated datePublished" datetime="2024-01-08T15:25:42+08:00">2024-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-09 01:00:39" itemprop="dateModified" datetime="2024-01-09T01:00:39+08:00">2024-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-被volatile修饰的变量有两大特点"><a href="#1-被volatile修饰的变量有两大特点" class="headerlink" title="1. 被volatile修饰的变量有两大特点"></a>1. 被volatile修饰的变量有两大特点</h2><ul>
<li><p>特点：</p>
<ul>
<li><p>可见性</p>
</li>
<li><p>有序性：有排序要求，有时需要禁止指令重排</p>
<ul>
<li>不存在数据依赖关系可以重排，否则禁重排，重排后的指令也不能改变原有串行语义</li>
</ul>
</li>
</ul>
</li>
<li><p>内存语义：</p>
<ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量的值</li>
<li>例如如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</li>
</ul>
</li>
<li><p>volatile凭什么可以保证可见性和有序性？</p>
<ul>
<li>内存屏障 Memory Barrier</li>
</ul>
</li>
</ul>
<h2 id="2-内存屏障"><a href="#2-内存屏障" class="headerlink" title="2. 内存屏障"></a>2. 内存屏障</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>内存屏障（也称内存栅栏，屏障指令等）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。内存屏障其实就是<strong>一种JVM指令</strong>，Java内存模型的重排规则会<strong>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</strong>，通过这些内存屏障指令，<strong>volatile实现了Java内存模型中的可见性和有序性（禁重排），但volatile无法保证原子性</strong></p>
<ul>
<li>内存屏障之前的所有写操作都要回写到主内存</li>
<li>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果（实现了可见性）</li>
</ul>
<blockquote>
<p><strong>写屏障(Store Memory Barrier)</strong>：告诉处理器在写屏障之前将所有存储在缓存(store buffers)中的数据同步到主内存，也就是说当看到Store屏障指令，就必须把该指令之前的所有写入指令执行完毕才能继续往下执行</p>
<p><strong>读屏障(Load Memory Barrier)</strong>：处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在Load屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。</p>
</blockquote>
<p>因此重排序时，<strong>不允许把内存屏障之后的指令重排序到内存屏障之前</strong>。一句话：对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读</p>
<h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>粗分两种：</p>
<ul>
<li>读屏障（Load Barrier）：在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。</li>
<li>写屏障（Store Barrier）：在写指令之后插入写屏障，强制把缓冲区的数据刷回到主内存中。</li>
</ul>
<p>细分四种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>屏障类型</strong></th>
<th><strong>指令示例</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LoadLoad</code></td>
<td>Load1;<br />LoadLoad;<br />Load2;</td>
<td>保证Load1的读取操作在Load2及后续读取操作之前执行</td>
</tr>
<tr>
<td><code>StoreStore</code></td>
<td>Store1;<br />StoreStore;<br />Store2;</td>
<td>在store2及其后的写操作执行前，保证Store1的写操作已经刷新到主内存</td>
</tr>
<tr>
<td><code>LoadStore</code></td>
<td>Load1;<br />LoadStore;<br />Store2;</td>
<td>在Store2及其后的写操作执行前，保证Load1的读操作已经结束</td>
</tr>
<tr>
<td><code>StoreLoad</code></td>
<td>Store1;<br />StoreLoad;<br />Load2;</td>
<td>保证Store1的写操作已经刷新到主内存后，Load2及其后的读操作才能执行</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-详解"><a href="#2-3-详解" class="headerlink" title="2.3 详解"></a>2.3 详解</h3><h4 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h4><p>通过内存屏障禁止重排</p>
<ul>
<li><p>重排序有可能影响程序的执行和实现，因此，我们有时候希望告诉JVM别自动重排序，我这里不需要重排序，一切听我的。</p>
</li>
<li><p>对于编译器的重排序，JMM会根据重排序的规则，禁止特定类型的编译器重排序</p>
</li>
<li><p>对于处理器的重排序，Java编译器在生成指令序列的适当位置，插入内存屏障指令，来禁止特定类型的处理器排序。</p>
</li>
</ul>
<h4 id="JMM-针对编译器制定的-volatile-重排序规则表"><a href="#JMM-针对编译器制定的-volatile-重排序规则表" class="headerlink" title="JMM 针对编译器制定的 volatile 重排序规则表"></a>JMM 针对编译器制定的 volatile 重排序规则表</h4><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082018812.png" alt="image-20240108201812771"></p>
<ul>
<li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序，这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li>
<li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序，这个操作保证了volatile写之前的操作不会被重排到volatile写之后</li>
<li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排</li>
</ul>
<h4 id="JMM-将内存屏障插入策略分为-4-种规则"><a href="#JMM-将内存屏障插入策略分为-4-种规则" class="headerlink" title="JMM 将内存屏障插入策略分为 4 种规则"></a>JMM 将内存屏障插入策略分为 4 种规则</h4><blockquote>
<p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM 采取保守策略。下面是基于保守策略的 JMM 内存屏障插入策略。</p>
</blockquote>
<ul>
<li><p>读屏障：在每个<strong>volatile读操作的后面</strong>插入一个<code>LoadLoad</code>屏障和一个<code>LoadStore</code>屏障</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081952339.png" alt="image.png"></p>
</li>
<li><p>写屏障：在每个<strong>volatile写操作的前面</strong>插入<code>StoreStore</code>屏障；在每个<strong>volatile写操作的后面</strong>插入<code>StoreLoad</code>屏障；</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401081952773.png" alt="image.png"></p>
</li>
</ul>
<blockquote>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的 volatile 内存语义。</p>
</blockquote>
<h2 id="3-volatile特性"><a href="#3-volatile特性" class="headerlink" title="3. volatile特性"></a>3. volatile特性</h2><h3 id="3-1-保证可见性"><a href="#3-1-保证可见性" class="headerlink" title="3.1 保证可见性"></a>3.1 保证可见性</h3><p>保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不加volatile，没有可见性，程序无法停止</span><br><span class="hljs-comment"> * 加了volatile，保证可见性，程序可以停止</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileSeeDemo</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * t1	-------come in</span><br><span class="hljs-comment">     * main	 修改完成</span><br><span class="hljs-comment">     * t1	-------flag被设置为false，程序停止</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------come in&quot;</span>);<br>            <span class="hljs-keyword">while</span> (flag) &#123;&#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t-------flag被设置为false，程序停止&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//更新flag值</span><br>        flag = <span class="hljs-literal">false</span>;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 修改完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>volatile变量的读写过程</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082159430.png" alt="img"></p>
<ul>
<li>read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存.</li>
<li>load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</li>
<li>use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</li>
<li>assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</li>
<li>store: 作用于工作内存，将赋值完毕的工作变量的值传送到主内存</li>
<li>write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量</li>
</ul>
<blockquote>
<p>由于上述 6 条只能保证单条指令的原子性，针对多条指令的组合性原子保证，JVM提供了另外两个原子指令:</p>
</blockquote>
<ul>
<li>lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</li>
<li>unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</li>
</ul>
<h3 id="3-2-没有原子性"><a href="#3-2-没有原子性" class="headerlink" title="3.2 没有原子性"></a>3.2 没有原子性</h3><p>volatile变量的复合操作不具有原子性，比如number++</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileNoAtomicTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000</span>;j++)&#123;<br>                    number.add();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(number.number);<br>    &#125;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span>  <span class="hljs-type">int</span> number;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>            number++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在不给方法加锁的情况下，仅仅凭借volatile 修饰无法保证线程安全，最终的值也不是10000</span><br></code></pre></td></tr></table></figure>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401082214122.png" alt="img"></p>
<p>对于 volatile 变量具备可见性，JVM 只是保证从主内存加载到线程工作内存的值是最新的，也仅仅是数据加载时是最新的。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存 volatile 修饰变量发生修改之后，<strong>线程工作内存的操作将会作废去读主内存最新值，操作出现写丢失问题</strong>。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致。由此可见 volatile 解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步。</p>
<p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。i++ 不具备原子性，该操作是先读取值，然后写回一个新值，分 3 步完成。如果第二个线程在第一个线程读取旧值和写回新值期间读取 i 的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加 1 操作，这也就造成了线程安全失败，因此对于 add 方法必须使用 synchronized 修饰以便保证线程安全</p>
<p>volatile变量不适合参与到依赖当前值的运算</p>
<h3 id="3-3-指令禁重排"><a href="#3-3-指令禁重排" class="headerlink" title="3.3 指令禁重排"></a>3.3 指令禁重排</h3><p><strong>重排序</strong></p>
<p>重排序是指编译器和处理器为了犹化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序</p>
<ul>
<li>不存在数据依赖关系，可以重排序;</li>
<li>存在数据依赖关系，禁止重排序</li>
</ul>
<p>但重排后的指令绝对不能改变原有的串行语义!这点在并发设计中必须要重点考虑!</p>
<p><strong>重排序的分类和执行流程</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090002842.png" alt="image-20240109000227777"></p>
<ul>
<li>编译器优化的重排序: 编译器在不改变单线程中行语义的前提下，可以重新调整指令的执行顺序</li>
<li>指令级并行的重排序: 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序: 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行</li>
</ul>
<p>数据依赖性: 若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性</p>
<p>但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境</p>
<p>下面三种情况，只要重排序两个操作的执行次序，程序的执行结果就会被改变</p>
<ul>
<li>写后读、写后写、读后写</li>
</ul>
<p><strong>volatile有关的禁止指令重排行为 与 四大屏障的插入情况</strong></p>
<p>详见 2.3</p>
<p>代码说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 线程 A 运行</span><br>        i = <span class="hljs-number">2</span>;<br>    	flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 线程 B 运行</span><br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果 flag 没有被 volatile 修饰，且 i 和 flag 没有数据依赖性，假如 write 方法中发生了指令重排，可能导致 i 没有被赋值就被 read 打印</p>
</blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090018466.png" alt="image-20240109001829395" style="zoom: 67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090019875.png" alt="image-20240109001925798" style="zoom:67%;" /></p>
<h2 id="4-如何正确使用volatile"><a href="#4-如何正确使用volatile" class="headerlink" title="4. 如何正确使用volatile"></a>4. 如何正确使用volatile</h2><p>单一赋值可以，但是含复合运算赋值不可以（i++之类）</p>
<p>状态标志，判断业务是否结束</p>
<ul>
<li>作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束</li>
</ul>
<p>开销较低的读，写锁策略</p>
<ul>
<li>当读远多于写，结合使用内部锁和volatile变量来减少同步的开销</li>
<li>原理是：利用volatile保证读操作的可见性，利用synchronized保证符合操作的原子性</li>
</ul>
<p>DCL双端锁的发布</p>
<ul>
<li>实例化对象时会分为三步：<ol>
<li>分配对象内存空间</li>
<li>初始化对象</li>
<li>设置 instance 指向刚分配的内存地址</li>
</ol>
</li>
<li>多线程环境下，在实例化对象时，由于重排序导致 2，3 乱序，即先分配地址再初始化，后果就是其他线程可能会获得一个未完全初始化的实例</li>
<li>要通过 volatile 声明来实现线程安全的延迟初始化</li>
</ul>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090034422.png" alt="img" style="zoom: 50%;" /></p>
<h2 id="5-小总结"><a href="#5-小总结" class="headerlink" title="5. 小总结"></a>5. 小总结</h2><p><strong>volatile可见性</strong></p>
<ol>
<li>写操作的话，这个变量的最新值会立即刷新回到主内存中</li>
<li>读操作的话，总是能够读取到这个变量的最新值，也就是这个变量最后被修改的值</li>
<li>当某个线程收到通知，去读取volatile修饰的变量的值的时候，线程私有工作内存的数据失效，需要重新回到主内存中去读取最新的数据。</li>
</ol>
<blockquote>
<p>在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</p>
<p>lock 前缀的指令在多核处理器下会引发两件事情:</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>
</ul>
<p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p>
<p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
</blockquote>
<p><strong>volatile没有原子性</strong></p>
<p><strong>volatile禁重排</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090053498.png" alt="image.png" style="zoom:33%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090054393.png" alt="image.png" style="zoom: 50%;" /></p>
<p><strong>为什么添加了volatile关键字,系统底层就加入了内存屏障</strong></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090055930.png" alt="img" style="zoom:50%;" /></p>
<p><strong>讲讲内存屏障</strong></p>
<p>是一种屏障指令，它使得CPU或编译器对屏障指令的前和后所发出的内存操作执行一个排序的约束。也称为内存栅栏或栅栏指令。</p>
<p>用于组织屏障两边的指令重排序</p>
<ul>
<li>写操作时加入屏障，强制将线程私有工作内存的数据刷回主物理内存</li>
<li>读操作时加入屏障，线程私有工作内存的数据失效，重新回到主物理内存中获取最新值</li>
</ul>
<p>四大指令</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401090059511.png" alt="image.png" style="zoom:33%;" /></p>
<p>总结</p>
<ul>
<li>volatile写之前的操作，都禁止重排序到volatile之后</li>
<li>volatile读之后的操作，都禁止重排序到volatile之前</li>
<li>volatile写之后volatile读，禁止重排序</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/08/JUC-9-JMM/" rel="prev" title="JUC(9) JMM">
      <i class="fa fa-chevron-left"></i> JUC(9) JMM
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/01/09/JUC-11-CAS-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/" rel="next" title="JUC(11) CAS、自旋锁、原子操作类">
      JUC(11) CAS、自旋锁、原子操作类 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%A2%ABvolatile%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E6%9C%89%E4%B8%A4%E5%A4%A7%E7%89%B9%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">1. 被volatile修饰的变量有两大特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">2.</span> <span class="nav-text">2. 内存屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%88%86%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">2.3.1.</span> <span class="nav-text">如何保证有序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM-%E9%92%88%E5%AF%B9%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%B6%E5%AE%9A%E7%9A%84-volatile-%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E8%A1%A8"><span class="nav-number">2.3.2.</span> <span class="nav-text">JMM 针对编译器制定的 volatile 重排序规则表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM-%E5%B0%86%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8F%92%E5%85%A5%E7%AD%96%E7%95%A5%E5%88%86%E4%B8%BA-4-%E7%A7%8D%E8%A7%84%E5%88%99"><span class="nav-number">2.3.3.</span> <span class="nav-text">JMM 将内存屏障插入策略分为 4 种规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-volatile%E7%89%B9%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">3. volatile特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 保证可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%B2%A1%E6%9C%89%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 没有原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%8C%87%E4%BB%A4%E7%A6%81%E9%87%8D%E6%8E%92"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 指令禁重排</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8volatile"><span class="nav-number">4.</span> <span class="nav-text">4. 如何正确使用volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">5. 小总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Whale</p>
  <div class="site-description" itemprop="description">码农预备役</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Whale-lyi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Whale-lyi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Whale</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
