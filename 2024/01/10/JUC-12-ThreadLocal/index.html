<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="南京大学软件学院大三在读" />
  
  
  <title>
    
      JUC(12) ThreadLocal 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">JUC(12) ThreadLocal</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2024-01-30 23:36:14
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Language/" title="Language">
                    <b>#</b> Language
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/Language/Java/" title="Java">
                    <b>#</b> Java
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <blockquote>
<p>面试题</p>
<ul>
<li>ThreadLocal中ThreadLocalMap的数据结构和关系</li>
<li>ThreadLocal的key是弱引用, 这是为什么？</li>
<li>ThreadLocal内存泄漏问题你知道吗？</li>
<li>ThreadLocal中最后为什么要加remove方法？</li>
</ul>
</blockquote>
<h2 id="1-ThreadLocal简介"><a href="#1-ThreadLocal简介" class="headerlink" title="1. ThreadLocal简介"></a>1. ThreadLocal简介</h2><p>ThreadLocal 提供线程局部变量。这些变量与正常的变量不同, 因为每一个线程在访问 ThreadLocal 实例的时候(通过其get或set方法)<strong>都有自己的、独立初始化的变量副本</strong>。ThreadLocal 实例通常是类中的私有静态字段, 使用它的目的是希望将状态(例如, 用户ID或事物ID)与线程关联起来。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111110081.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>&#123;<br>    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        threadLocal.set(threadLocal.get() + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyData</span> <span class="hljs-variable">myData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyData</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                threadPool.submit(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">beforeInt</span> <span class="hljs-operator">=</span> myData.threadLocal.get();<br>                        myData.add();<br>                        <span class="hljs-type">Integer</span> <span class="hljs-variable">afterInt</span> <span class="hljs-operator">=</span> myData.threadLocal.get();<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; beforeInt: &quot;</span> + beforeInt + <span class="hljs-string">&quot; afterInt: &quot;</span> + afterInt);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        myData.threadLocal.remove();<br>                    &#125;<br>                &#125;);<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">pool-1-thread-1 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-3 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-2 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-2 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-3 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-1 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-2 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-1 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-3 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">pool-1-thread-2 beforeInt: 0 afterInt: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>如果不在 finally 块中调用 remove 会导致原先的值没有被清理, 默认值不再是 0, 而是上一个线程设置的值</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111543993.png" alt="image-20240111154336936"></p>
<p>因为每个 Thread 内有自己的<strong>实例副本</strong>且该副本只有当前线程自己使用</p>
<p>既然其他 ThreadLocal 不可访问, 那就不存在多线程间共享问题</p>
<p>统一设置初始值, 但是每个线程对这个值得修改都是各自线程互相独立的</p>
<p>如何才能不争抢</p>
<ul>
<li><p>加入synchronized或者Lock控制资源的访问顺序</p>
</li>
<li><p>ThreadLocal</p>
</li>
</ul>
<h2 id="2-ThreadLocal源码分析"><a href="#2-ThreadLocal源码分析" class="headerlink" title="2. ThreadLocal源码分析"></a>2. ThreadLocal源码分析</h2><h3 id="2-1-Thread、ThreadLocal、ThreadLocalMap关系"><a href="#2-1-Thread、ThreadLocal、ThreadLocalMap关系" class="headerlink" title="2.1 Thread、ThreadLocal、ThreadLocalMap关系"></a>2.1 Thread、ThreadLocal、ThreadLocalMap关系</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111613314.png" alt="image-20240111161342274" style="zoom: 80%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111620299.png" alt="image-20240111162037251" style="zoom:67%;" /></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111619171.png" alt="img" style="zoom: 50%;" /></p>
<ul>
<li>Thread 对象维护着一个 ThreadLocalMap 的引用</li>
<li>ThreadLocalMap 是 ThreadLocal 的内部类, 用 Entry 来进行存储值</li>
<li>调用 ThreadLocal 的 set() 方法时, 实际上就是往 ThreadLocalMap 设置值, key 是 ThreadLocal 对象, 值 Value 是传递进来的对象</li>
<li>调用 ThreadLocal 的 get() 方法时, 实际上就是从 ThreadLocalMap 获取值, key 是 ThreadLocal 对象</li>
</ul>
<h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><h4 id="ThreadLocalMap-成员变量"><a href="#ThreadLocalMap-成员变量" class="headerlink" title="ThreadLocalMap 成员变量"></a>ThreadLocalMap 成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The initial capacity -- MUST be a power of two.</span><br><span class="hljs-comment">* 初始容量——必须是2的幂。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The table, resized as necessary.</span><br><span class="hljs-comment">* table.length MUST always be a power of two.</span><br><span class="hljs-comment">* 表可根据需要调整大小。表长度必须始终是2的幂。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> Entry[] table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The number of entries in the table.</span><br><span class="hljs-comment">* 表中的实体数。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next size value at which to resize.</span><br><span class="hljs-comment">* 扩容阈值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-get-源码"><a href="#ThreadLocal-get-源码" class="headerlink" title="ThreadLocal#get()源码"></a><code>ThreadLocal#get()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the value in the current thread&#x27;s copy of this</span><br><span class="hljs-comment"> * thread-local variable.  If the variable has no value for the</span><br><span class="hljs-comment"> * current thread, it is first initialized to the value returned</span><br><span class="hljs-comment"> * by an invocation of the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the current thread&#x27;s value of this thread-local</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t); <span class="hljs-comment">// 每个线程私有</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 以当前ThreadLocal对象为key, 获取Entry, 其中存放了value</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>此处说明 ThreadLocalMap 采用的是懒加载模式, 用时再去初始化</p>
</blockquote>
<h4 id="ThreadLocalMap-getEntry-源码"><a href="#ThreadLocalMap-getEntry-源码" class="headerlink" title="ThreadLocalMap#getEntry()源码"></a><code>ThreadLocalMap#getEntry()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the entry associated with key.  This method</span><br><span class="hljs-comment"> * itself handles only the fast path: a direct hit of existing</span><br><span class="hljs-comment"> * key. It otherwise relays to getEntryAfterMiss.  This is</span><br><span class="hljs-comment"> * designed to maximize performance for direct hits, in part</span><br><span class="hljs-comment"> * by making this method readily inlinable.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  key the thread local object</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Entry 是 ThreadLocalMap 的内部类, 继承自<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>, 因此 <code>e.get()</code> 获取的就是该 Entry 对应的 ThreadLocal</p>
<p>算出当前 key 在数组中下标 i, 通过当前线程局部变量的线程局部哈希码与 数组长度 - 1 做与运算。根据下标 i 获取对象 e, 如果 e 不为 null 且 e 的 key 等于当前线程局部变量, 则返回 e, 否则开启线性探测</p>
</blockquote>
<h4 id="线程局部哈希码-threadLocalHashCode-源码"><a href="#线程局部哈希码-threadLocalHashCode-源码" class="headerlink" title="线程局部哈希码 threadLocalHashCode 源码"></a>线程局部哈希码 threadLocalHashCode 源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ThreadLocals rely on per-thread linear-probe hash maps attached</span><br><span class="hljs-comment"> * to each thread (Thread.threadLocals and</span><br><span class="hljs-comment"> * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span><br><span class="hljs-comment"> * searched via threadLocalHashCode.  This is a custom hash code</span><br><span class="hljs-comment"> * (useful only within ThreadLocalMaps) that eliminates collisions</span><br><span class="hljs-comment"> * in the common case where consecutively constructed ThreadLocals</span><br><span class="hljs-comment"> * are used by the same threads, while remaining well-behaved in</span><br><span class="hljs-comment"> * less common cases.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The next hash code to be given out. Updated atomically. Starts at</span><br><span class="hljs-comment"> * zero.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The difference between successively generated hash codes - turns</span><br><span class="hljs-comment"> * implicit sequential thread-local IDs into near-optimally spread</span><br><span class="hljs-comment"> * multiplicative hash values for power-of-two-sized tables.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the next hash code.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>这里定义了一个 AtomicInteger 类型, 每次获取当前值并加上 HASH_INCREMENT, HASH_INCREMENT = 0x61c88647, 这个值和斐波那契散列有关(这是一种乘数散列法, 只不过这个乘数比较特殊, 是2^32乘以黄金分割比例的值, 即是1640531527, 16进制表示为 0x61c88647, 其主要目的就是为了让哈希码能均匀的分布在 2 的 n 次方的数组里, 也就是 Entry[] table 中, 这样做可以尽量避免 hash 冲突</p>
</blockquote>
<h4 id="ThreadLocalMap-getEntryAfterMiss-源码"><a href="#ThreadLocalMap-getEntryAfterMiss-源码" class="headerlink" title="ThreadLocalMap#getEntryAfterMiss()源码"></a><code>ThreadLocalMap#getEntryAfterMiss()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Version of getEntry method for use when key is not found in</span><br><span class="hljs-comment"> * its direct hash slot.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  key the thread local object</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  i the table index for key&#x27;s hash code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  e the entry at table[i]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the entry associated with key, or null if no such</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>开启 while 循环, 当 e 的 key 与当前线程对象相等时, 返回 e</p>
<p>如果 e 的 key 等于 null, 开启探测式清理, 也就是 expungeStaleEntry() 方法</p>
<p>如果 e 的 key 不为 null, 且不等于当前线程对象, 说明哈希冲突了, 开启线性探测</p>
</blockquote>
<h4 id="ThreadLocalMap-expungeStaleEntry-源码"><a href="#ThreadLocalMap-expungeStaleEntry-源码" class="headerlink" title="ThreadLocalMap#expungeStaleEntry()源码"></a><code>ThreadLocalMap#expungeStaleEntry()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span><br><span class="hljs-comment"> * lying between staleSlot and the next null slot.  This also expunges</span><br><span class="hljs-comment"> * any other stale entries encountered before the trailing null.  See</span><br><span class="hljs-comment"> * Knuth, Section 6.4</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> staleSlot index of slot known to have null key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the index of the next null slot after staleSlot</span><br><span class="hljs-comment"> * (all between staleSlot and this slot will have been checked</span><br><span class="hljs-comment"> * for expunging).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// expunge entry at staleSlot</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br><br>                <span class="hljs-comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span><br>                <span class="hljs-comment">// null because multiple entries could have been stale.</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>当前位置的 key 等于 null, value 也置为 null, entry 也置为 null, size—</p>
<p>从当前位置的下一个位置 i 开始循环, 如果 e 等于 null, 退出循环, 否则向 i 的下一个位置继续循环。</p>
<p>如果 e 的 key 等于 null, value 也置为 null, entry 也置为 null, size–-。不为 null, 则计算当前线程局部变量的下标 h。如果 h 与 i (当前下标)不相等, 说明当时插入的时候发生了哈希冲突。开始 rehash, 将当前下标的 entry 清空, 从 h 开始寻找空位, 找到空位后插入当前对象。如果恰好 h 下标为 null, 那么当前线程局部变量则不会发生哈希冲突, 直接插入到 h 位置。</p>
<p>HashMap与ThreadLocalMap解决哈希冲突的区别：</p>
<ul>
<li>HashMap 使用的是链地址法, 当发生哈希冲突的时候, 使用链表来存储相同哈希码的数据, 满足一定条件, 还可以链表红黑树互相转换</li>
<li>ThreadLocalMap 使用的是线性探测法, 当发生哈希冲突的时候, 就往后寻找空位置, 直到寻找到空位置插入。</li>
</ul>
</blockquote>
<h4 id="ThreadLocal-setInitialValue-源码"><a href="#ThreadLocal-setInitialValue-源码" class="headerlink" title="ThreadLocal#setInitialValue()源码"></a><code>ThreadLocal#setInitialValue()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Variant of set() to establish initialValue. Used instead</span><br><span class="hljs-comment"> * of set() in case user has overridden the set() method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the initial value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue(); <span class="hljs-comment">// 如果初始化ThreadLocal时没有重写就返回null</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) &#123;<br>        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-createMap-源码"><a href="#ThreadLocal-createMap-源码" class="headerlink" title="ThreadLocal#createMap()源码"></a><code>ThreadLocal#createMap()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment"> * InheritableThreadLocal.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t the current thread</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstValue value for the initial entry of the map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-set-源码"><a href="#ThreadLocal-set-源码" class="headerlink" title="ThreadLocal#set()源码"></a><code>ThreadLocal#set()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment"> * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment"> * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment"> * method to set the values of thread-locals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment"> *        this thread-local.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocalMap-set-源码"><a href="#ThreadLocalMap-set-源码" class="headerlink" title="ThreadLocalMap#set()源码"></a><code>ThreadLocalMap#set()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Set the value associated with key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key the thread local object</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be set</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>    <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>    <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>    <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>    <span class="hljs-comment">// path would fail more often than not.</span><br><br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value; <span class="hljs-comment">// 覆盖</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i); <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value); <span class="hljs-comment">// 插入</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-remove-源码"><a href="#ThreadLocal-remove-源码" class="headerlink" title="ThreadLocal#remove()源码"></a><code>ThreadLocal#remove()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the current thread&#x27;s value for this thread-local</span><br><span class="hljs-comment"> * variable.  If this thread-local variable is subsequently</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span><br><span class="hljs-comment"> * reinitialized by invoking its &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method,</span><br><span class="hljs-comment"> * unless its value is &#123;<span class="hljs-doctag">@linkplain</span> #set set&#125; by the current thread</span><br><span class="hljs-comment"> * in the interim.  This may result in multiple invocations of the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> initialValue&#125; method in the current thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>     <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>) &#123;<br>         m.remove(<span class="hljs-built_in">this</span>);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<h4 id="ThreadLocal-remove-源码-1"><a href="#ThreadLocal-remove-源码-1" class="headerlink" title="ThreadLocal#remove()源码"></a><code>ThreadLocal#remove()</code>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove the entry for key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear(); <span class="hljs-comment">// this.referent = null;</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-ThreadLocal内存泄漏"><a href="#3-ThreadLocal内存泄漏" class="headerlink" title="3. ThreadLocal内存泄漏"></a>3. ThreadLocal内存泄漏</h2><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401111620299.png" alt="image-20240111162037251" style="zoom:67%;" /></p>
<ul>
<li>使用 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code> 将 ThreadLocal 对象变成一个<strong>弱引用</strong>对象</li>
<li>定义 Entry 类来继承 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code></li>
</ul>
<h3 id="3-1-强、软、弱、虚引用"><a href="#3-1-强、软、弱、虚引用" class="headerlink" title="3.1 强、软、弱、虚引用"></a>3.1 强、软、弱、虚引用</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401201853546.png" alt="image-20240120185333481" style="zoom:67%;" /></p>
<blockquote>
<p>Java 允许使用 <code>finalize()</code> 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</p>
</blockquote>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul>
<li>对于强引用的对象, 就算是出现了 OOM 也不会对该对象进行回收</li>
<li>当一个对象被强引用变量引用时, 它处于可达状态, 是不可能被垃圾回收机制回收的, 即使该对象以后永远都不会被用到, JVM 也不会回收, 因此强引用是造成 Java 内存泄露的主要原因之一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>obj = <span class="hljs-literal">null</span>;<br>System.gc();<br></code></pre></td></tr></table></figure>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul>
<li>是一种相对强引用弱化了一些的引用, 需要使用 <code>java.lang.ref.SoftReference</code> 类来实现, 可以让对象豁免一些垃圾回收</li>
<li>对于只有软引用的对象而言, <strong>当系统内存充足时, 不会被回收, 当系统内存不足时, 才会被回收</strong></li>
<li>软引用通常用在对内存敏感的程序中, 比如高速缓存, 内存够用就保留, 不够用就回收。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SoftReference&lt;MyObject&gt; softRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br>softRef.get()<br></code></pre></td></tr></table></figure>
<blockquote>
<p>假如有一个应用需要读取大量的本地图片:</p>
<ul>
<li>如果每次读取图片都从硬盘读取则会严重影响性能</li>
<li>如果一次性全部加载到内存中又可能造成内存溢出。此时使用软引用可以解决这个问题。</li>
</ul>
<p>设计思路是: 用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系, 在内存不足时, JVM会自动回收这些缓存图片对象所占用的空间, 从而有效地避免了OOM的问题。</p>
<p><code>Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;&gt;();</code></p>
</blockquote>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul>
<li>使用 <code>java.lang.ref.WeakReference</code> 类来实现, 比软引用的生命周期更短, 对于只有弱引用的对象而言, 只要垃圾回收机制一运行, 不管JVM的内存空间是否足够, 都会回收该对象占用的内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WeakSoftReference&lt;MyObject&gt; weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>());<br>weakRef.get()<br></code></pre></td></tr></table></figure>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul>
<li><strong>虚引用必须和引用队列(<code>ReferenceQueue</code>)联合使用</strong><ul>
<li>虚引用需要 <code>java.lang.ref.PhantomReference</code> 类来实现, 与其他引用都不同, 虚引用并不决定对象的生命周期。<strong>如果一个对象仅持有虚引用, 那么它就和没有任何引用一样, 在任何时候都有可能被垃圾回收器回收, 它不能单独使用也不能通过它访问对象。</strong></li>
</ul>
</li>
<li><code>PhantomReference#get()</code> 总是返回 null<ul>
<li>虚引用的主要作用是跟踪对象被垃圾回收的状态。<strong>仅仅是提供了一种确保对象被 finalize 后, 做某些事情的通知机制。</strong></li>
</ul>
</li>
<li>处理监控通知使用<ul>
<li>设置虚引用关联对象的唯一目的, 就是在对象被 GC 的时候会收到一个系统通知或者后续添加进一步的处理, 用来实现比 finalize 机制更灵活的回收操作。</li>
</ul>
</li>
</ul>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PhantomReference(T referent, ReferenceQueue&lt;? <span class="hljs-built_in">super</span> T&gt; q)<br></code></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>ReferenceQueue&lt;MyObject&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>PhantomReference&lt;MyObject&gt; phantomReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(myObject, referenceQueue);<br><br>List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]);<br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>        System.out.println(phantomReference.get() + <span class="hljs-string">&quot; list add ok&quot;</span>);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyObject</span>&gt; reference = referenceQueue.poll();<br>        <span class="hljs-keyword">if</span> (reference != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;有虚对象回收加入了队列&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>
<h3 id="3-2-为什么使用弱引用"><a href="#3-2-为什么使用弱引用" class="headerlink" title="3.2 为什么使用弱引用"></a>3.2 为什么使用弱引用</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202401302225249.png" alt="image-20240130222547134"></p>
<p>为什么要用弱引用：</p>
<ul>
<li>当方法执行完毕后, 栈帧销毁, 强引用 tl 也就没有了, 但此时线程的 ThreadLocalMap 里某个 entry 的 key 引用还指向这个对象</li>
<li>若这个 key 是强引用, 就会导致 key 指向的 ThreadLocal 对象及 v 指向的对象不能被 gc 回收, 造成内存泄露</li>
<li>使用弱引用就可以使 ThreadLocal 对象在方法执行完毕后顺利被回收且 Entry 的 key 引用指向为 null</li>
</ul>
<p>但如果当前线程迟迟不结束(例如线程池场景), 这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链</p>
<ul>
<li>value 对象需要 ThreadLocalMap 调用 get, set 时发现 key 为 null 才会去回收整个 entry, 因此弱引用不能 100% 保证内存不泄露, 我们要在不使用某个 ThreadLocal 对象后, 手动调用 remove 方法来删除它</li>
<li><p>在线程池中, 不仅仅是内存泄漏的问题, 因为线程池中的线程是重复使用的, 意味着这个线程的 ThreadLocalMap 对象也是重复使用的, 如果我们不手动调用 remove 方法, 那么后面的线程就有可能获取到上个线程遗留下来的 value 值</p>
</li>
<li><p>此后调用 get, set, remove 方法时, 就会尝试删除 key 为 null 的 Entry, 从而释放 value 对象占用的内存</p>
<ul>
<li>通过 <code>expungeStaleEntry</code>, <code>cleanSomeSlots</code>, <code>replaceStaleEntry</code> 这三个方法回收键为 null 的 Entry 对象的值(即value)以及 entry 对象本身从而防止内存泄漏, 属于安全加固的方法</li>
</ul>
</li>
</ul>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/01/09/JUC-11-CAS-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2024-01-30 23:36:14
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Language/" title="Language">
                        <b>#</b> Language
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/Language/Java/" title="Java">
                        <b>#</b> Java
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2024/01/30/JUC-13-Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ThreadLocal%E7%AE%80%E4%BB%8B"><span class="toc-text">1. ThreadLocal简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2. ThreadLocal源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Thread%E3%80%81ThreadLocal%E3%80%81ThreadLocalMap%E5%85%B3%E7%B3%BB"><span class="toc-text">2.1 Thread、ThreadLocal、ThreadLocalMap关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2.2 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">ThreadLocalMap 成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-get-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocal#get()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap-getEntry-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocalMap#getEntry()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%93%88%E5%B8%8C%E7%A0%81-threadLocalHashCode-%E6%BA%90%E7%A0%81"><span class="toc-text">线程局部哈希码 threadLocalHashCode 源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap-getEntryAfterMiss-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocalMap#getEntryAfterMiss()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap-expungeStaleEntry-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocalMap#expungeStaleEntry()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-setInitialValue-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocal#setInitialValue()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-createMap-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocal#createMap()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-set-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocal#set()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap-set-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocalMap#set()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-remove-%E6%BA%90%E7%A0%81"><span class="toc-text">ThreadLocal#remove()源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-remove-%E6%BA%90%E7%A0%81-1"><span class="toc-text">ThreadLocal#remove()源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">3. ThreadLocal内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-text">3.1 强、软、弱、虚引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-text">虚引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-text">3.2 为什么使用弱引用</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + JUC(12)%20ThreadLocal + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2024%2F01%2F10%2FJUC-12-ThreadLocal%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2024/01/10/JUC-12-ThreadLocal/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
