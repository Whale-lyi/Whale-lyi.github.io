<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="码农预备役" />
  
  
  <title>
    
      JVM(7) 原理 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">JVM(7) 原理</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2024-11-20 17:24:50
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Language/" title="Language">
                    <b>#</b> Language
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/Language/Java/" title="Java">
                    <b>#</b> Java
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="1-栈上的数据存储"><a href="#1-栈上的数据存储" class="headerlink" title="1. 栈上的数据存储"></a>1. 栈上的数据存储</h2><p>局部变量表中, 每个数据元素空间(slot槽)大小如下</p>
<ul>
<li>32位虚拟机：4字节</li>
<li>64位虚拟机：8字节</li>
</ul>
<p>为了支持跨平台特性, 无论是32位还是64位, long 和 double 都会占用 2 个槽</p>
<p>实际编译时, byte boolean等占用1个槽的类型（不含float）会直接当成int处理</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411181603666.png" alt="image-20241118160341564" style="zoom: 67%;" /></p>
<p>栈中的数据要保存到堆上或者从堆中加载到栈上时怎么处理?</p>
<ul>
<li>堆中的数据加载到栈上, 由于栈上的空间大于或者等于堆上的空间, 所以直接处理但是需要注意下符号位。<ul>
<li>boolean、char为无符号, 低位复制, 高位补0</li>
<li>byte、short为有符号, 低位复制, 高位非负则补0, 负则补1</li>
</ul>
</li>
<li>栈中的数据要保存到堆上, byte、char、short由于堆上存储空间较小, 需要将高位去掉。boolean比较特殊, <strong>只取低位的最后一位保存</strong>。</li>
</ul>
<h2 id="2-对象在堆上的存储"><a href="#2-对象在堆上的存储" class="headerlink" title="2. 对象在堆上的存储"></a>2. 对象在堆上的存储</h2><p><a href="https://whale-lyi.github.io/2024/01/30/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Java对象内存布局</a></p>
<h3 id="2-1-指针压缩"><a href="#2-1-指针压缩" class="headerlink" title="2.1 指针压缩"></a>2.1 指针压缩</h3><p>在64位的Java虚拟机中, Klass Pointer以及对象数据中的对象引用都需要占用8个字节, 为了减少这部分的内存使用量, 64位Java虚拟机使用指针压缩技术, 将堆中原本8个字节的指针压缩成4个字节, 此功能默认开启, 可以使用 <code>-XX:-UseCompressedOops</code> 关闭</p>
<p>指针压缩的思想是将寻址的单位放大, 比如原来按1字节去寻址, 现在可以按8字节寻址。如下图所示, 原来按1去寻址, 能拿到1字节开始的数据, 现在按1去寻址, 就可以拿到8个字节开始的数据。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411181655022.png" alt="image-20241118165552948" style="zoom:67%;" /></p>
<p>这样将编号当成地址, 就可以用更小的内存访问更多的数据。但是这样的做法有两个问题:</p>
<ol>
<li>需要进行内存对齐, 指的是将对象的内存占用填充至8字节的倍数。存在空间浪费(对于Hotspot来说不存在, 即便不开启指针压缩, 也需要进行内存对齐)</li>
<li>寻址大小仅仅能支持 2 的 35 次方个字节(32GB, 如果超过32GB指针压缩会自动关闭)。不用压缩指针, 应该是2的64次方 = 16EB, 用了压缩指针就变成了8(字节) = 2的3次方 * 2的32次方 = 2的35次方</li>
</ol>
<h3 id="2-2-内存对齐"><a href="#2-2-内存对齐" class="headerlink" title="2.2 内存对齐"></a>2.2 内存对齐</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/489358606">https://zhuanlan.zhihu.com/p/489358606</a></p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411181726290.png" alt="image-20241118172643208" style="zoom:67%;" /></p>
<h2 id="3-方法调用原理"><a href="#3-方法调用原理" class="headerlink" title="3. 方法调用原理"></a>3. 方法调用原理</h2><p>方法调用的本质是通过字节码指令的执行, 能在栈上创建栈帧, 并执行调用方法中的字节码执行。以invoke开头的字节码指令就是执行方法调用</p>
<p>在JVM中, 一共有五个字节码指令可以执行方法调用:</p>
<ol>
<li><code>invokestatic</code>: 调用静态方法</li>
<li><code>invokespecial</code>: 调用对象的private方法、构造方法, 以及使用 super 关键字调用父类实例的方法、构造方法, 以及所实现接口的默认方法</li>
<li><code>invokevirtual</code>: 调用对象的非private方法</li>
<li><code>invokeinterface</code>: 调用接口对象的方法</li>
<li><code>invokedynamic</code>: 用于调用动态方法, 主要应用于lambda表达式中, 机制极为复杂了解即可</li>
</ol>
<p>Invoke指令执行时, 需要找到方法区中Instance Klass中保存的方法相关的字节码信息。但是方法区中有很多类, 每一个类又包含很多个方法, 怎么精确地定位到方法的位置呢?</p>
<h3 id="3-1-静态绑定"><a href="#3-1-静态绑定" class="headerlink" title="3.1 静态绑定"></a>3.1 静态绑定</h3><p>编译期间, invoke指令会携带一个参数符号引用, 引用到常量池中的方法定义。方法定义中包含了类名 + 方法名 + 返回值 + 参数。</p>
<p>在<strong>方法第一次调用</strong>时, 这些符号引用就会被替换成内存地址的直接引用, 这种方式称之为<strong>静态绑定</strong>。</p>
<p>静态绑定适用于处理静态方法、私有方法、或者使用final修饰的方法, 因为这些方法不能被继承之后重写。</p>
<ul>
<li><code>invokestatic</code></li>
<li><code>invokespecial</code></li>
<li>final修饰的<code>invokevirtual</code></li>
</ul>
<h3 id="3-2-动态绑定"><a href="#3-2-动态绑定" class="headerlink" title="3.2 动态绑定"></a>3.2 动态绑定</h3><p>对于非static、非private、非final的方法, 有可能存在子类重写方法, 那么就需要通过动态绑定来完成方法地址绑定的工作。</p>
<p>动态绑定是基于方法表来完成的, invokevirtual使用了虚方法表(vtable), invokeinterface使用了接口方法表(itable), 整体思路类似。所以接下来使用invokevirtual和虚方法表来解释整个过程。</p>
<p>每个类中都有一个虚方法表, 本质上它是一个数组, 记录了方法的地址。子类方法表中包含父类方法表中的所有方法, 子类如果重写了父类方法, 则使用自己类中方法的地址进行替换。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191433548.png" alt="image-20241119143355436" style="zoom:80%;" /></p>
<p>产生invokevirtual调用时, 先根据对象头中的类型指针找到方法区中InstanceKlass对象, 获得虚方法表。再根据虚方法表获得方法的地址, 最后调用方法。</p>
<h2 id="4-异常捕获原理"><a href="#4-异常捕获原理" class="headerlink" title="4. 异常捕获原理"></a>4. 异常捕获原理</h2><p>在Java中, 程序遇到异常时会向外抛出, 此时可以使用try-catch捕获异常的方式将异常捕获并继续让程序按程序员设计好的方式运行。异常捕获机制的实现, 需要借助于编译时生成的<strong>异常表</strong>。</p>
<p>异常表在编译期生成, 存放的是代码中异常的处理信息, 包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</p>
<p>起始/结束PC: 此条异常捕获生效的字节码起始/结束位置。</p>
<p>跳转PC: 异常捕获之后, 跳转到的字节码位置。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191454808.png" alt="image-20241119145432761" style="zoom:80%;" /></p>
<p>程序运行中触发异常时, Java虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内, Java虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。</p>
<ol>
<li>如果匹配, 跳转到”跳转PC”对应的字节码位置。</li>
<li>如果遍历完都不能匹配, 说明异常无法在当前方法执行时被捕获, 此方法栈帧直接弹出, 在上一层的栈帧中进行异常捕获的查询。</li>
</ol>
<p>多个catch分支情况下, 异常表会从上往下遍历, 先捕获RuntimeException, 如果捕获不了, 再捕获Exception。</p>
<p>同理, multi-catch的写法也是一样的处理过程。</p>
<p>finally的处理方式就相对比较复杂一点了, 分为以下几个步骤:</p>
<ol>
<li>finally中的字节码指令会插入到 try 和 catch 代码块中, 保证在 try 和 catch 执行之后一定会执行 finally 中的代码。</li>
<li>如果抛出的异常范围超过了Exception, 比如Error或者Throwable, 此时也要执行finally, 所以异常表中增加了两个条目。覆盖了try和catch两段字节码指令的范围, any代表可以捕获所有种类的异常。在最后将异常继续向外抛出</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191458586.png" alt="image-20241119145817512" style="zoom:80%;" /></p>
<h2 id="5-JIT即时编译器"><a href="#5-JIT即时编译器" class="headerlink" title="5. JIT即时编译器"></a>5. JIT即时编译器</h2><h3 id="5-1-执行流程"><a href="#5-1-执行流程" class="headerlink" title="5.1 执行流程"></a>5.1 执行流程</h3><p>在Java中, JIT即时编译器是一项用来提升应用程序代码执行效率的技术。字节码指令被Java虚拟机解释执行, 如果有一些指令执行频率高, 称之为热点代码, 这些字节码指令则被JIT即时编译器编译成机器码同时进行一些优化, 最后保存在内存中, 将来执行时直接读取就可以运行在计算机硬件上了。</p>
<p>在Hotspot中, 有三款即时编译器, C1、C2和Graal。C1编译效率比C2快, 但是优化效果不如C2。所以C1适合优化一些执行时间较短的代码, C2适合优化服务端程序中<br>长期执行的代码。</p>
<p>JDK7之后, 采用了分层编译的方式, 在JVM中C1和C2会一同发挥作用, 分层编译将整个优化级别分成了5个等级。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191512879.png" alt="image-20241119151234797" style="zoom:80%;" /></p>
<p>C1即时编译器和C2即时编译器都有独立的线程去进行处理, 内部会保存一个队列, 队列中存放需要编译的任务。一般即时编译器是针对方法级别来进行优化的, 当然也有对循环进行优化的设计。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191514148.png" alt="image-20241119151441082" style="zoom:80%;" /></p>
<p><strong>C1与C2的协作过程</strong></p>
<ol>
<li><p>先由C1执行过程中收集所有运行中的信息, 方法执行次数、循环执行次数、分支执行次数等等, 然后等待执行次数触发阈值(分层即时编译由JVM动态计算)之后, 进入C2即时编译器进行深层次的优化。<br><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191516624.png" alt="image-20241119151635570" style="zoom:67%;" /></p>
</li>
<li><p>方法字节码执行数目过少, 先收集信息, JVM判断C1和C2优化性能差不多, 那之后转为不收集信息, 由C1直接进行优化。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191517199.png" alt="image-20241119151747146" style="zoom: 67%;" /></p>
</li>
<li><p>C1线程都在忙碌的情况下, 直接由C2进行优化。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191518110.png" alt="image-20241119151821060" style="zoom:67%;" /></p>
</li>
<li><p>C2线程忙碌时, 先由2层C1编译收集一些基础信息, 多运行一会儿, 然后再交由3层C1处理, 由于3层C1处理效率不高, 所以尽量减少这一层停留时间(C2忙碌着, 一直收集也没有意义), 最后C2线程不忙碌了再交由C2进行处理。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191519939.png" alt="image-20241119151941882" style="zoom:67%;" /></p>
</li>
</ol>
<blockquote>
<p>虚拟机参数：不加参数（开启完全JIT即时编译）</p>
<ul>
<li><code>-Xint</code>: 关闭JIT, 只使用解释器</li>
<li><code>-XX:TieredStopAtLevel=1</code>: 分层编译下只使用 1 层 C1 进行编译</li>
</ul>
</blockquote>
<h3 id="5-2-JIT优化-方法内联"><a href="#5-2-JIT优化-方法内联" class="headerlink" title="5.2 JIT优化-方法内联"></a>5.2 JIT优化-方法内联</h3><p>方法内联(Method Inline): 方法体中的字节码指令直接复制到调用方的字节码指令中, 节省了创建栈帧的开销。</p>
<p>并不是所有的方法都可以内联, 内联有一定的限制:</p>
<ol>
<li>方法编译之后的字节码指令总大小 &lt; 35字节, 可以直接内联。(通过 <code>-XX:MaxInlineSize=值</code> 控制)</li>
<li>方法编译之后的字节码指令总大小 &lt; 325字节, 并且是一个热方法。(通过 <code>-XX:FreqInlineSize=值</code> 控制)</li>
<li>方法编译生成的机器码不能大于1000字节。(通过 <code>-XX:InlineSmallCode=值</code> 控制)</li>
<li>一个接口的实现必须小于3个, 如果大于三个就不会发生内联。</li>
</ol>
<h3 id="5-3-JIT优化-逃逸分析"><a href="#5-3-JIT优化-逃逸分析" class="headerlink" title="5.3 JIT优化-逃逸分析"></a>5.3 JIT优化-逃逸分析</h3><p>逃逸分析指的是如果JIT发现在方法内创建的对象不会被外部引用, 那么就可以采用锁消除、标量替换等方式进行优化。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除指的是如果对象被判断不会逃逸出去, 那么该对象就不存在并发访问问题, 对象上的锁处理都不会执行, 从而提高性能。比如如下写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>()) &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>锁消除优化在真正的工作代码中并不常见, 一般加锁的对象都是支持多线程去访问的。</p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>逃逸分析真正对性能优化比较大的方式是标量替换, 在Java虚拟机中, 对象中的基本数据类型称为标量, 引用的其他对象称为聚合量。标量替换指的是如果方法中的对象不会逃逸, 那么其中的标量就可以直接在栈上分配。</p>
<blockquote>
<p>根据JIT即时编器优化代码的特性, 在编写代码时注意以下几个事项, 可以让代码执行时拥有更好的性能:</p>
<ol>
<li>尽量编写比较小的方法, 让方法内联可以生效。</li>
<li>高频使用的代码, 特别是第三方依赖库甚至是JDK中的, 如果内容过度复杂是无法内联的, 可以自行实现一个特定的优化版本。</li>
<li>注意下接口的实现数量, 尽量不要超过2个, 否则会影响内联的处理。</li>
<li>高频调用的方法中创建对象临时使用, 尽量不要让对象逃逸。</li>
</ol>
</blockquote>
<h2 id="6-G1垃圾回收器原理"><a href="#6-G1垃圾回收器原理" class="headerlink" title="6. G1垃圾回收器原理"></a>6. G1垃圾回收器原理</h2><h3 id="6-1-年轻代回收"><a href="#6-1-年轻代回收" class="headerlink" title="6.1 年轻代回收"></a>6.1 年轻代回收</h3><h4 id="卡表-Card-Table"><a href="#卡表-Card-Table" class="headerlink" title="卡表(Card Table)"></a>卡表(Card Table)</h4><p>每一个Region都拥有一个自己的卡表, 如果产生了跨代引用(老年代引用年轻代), 此时这个Region对应的卡表上就会将字节内容进行修改, JDK8源码中0代表被引用了称为脏卡。这样就可以标记出当前Region被老年代中的哪些部分引用了。那么要生成记忆集就比较简单了, 只需要遍历整个卡表, 找到所有脏卡。</p>
<p>记忆集(RememberedSet, RS, RSet): 是一种记录了从非收集区域对象引用收集区域对象的这些关系的数据结构。每一个Region都拥有一个自己的记忆集, 如果产生了跨代引用, 记忆集中会记录引用对象所在的卡表位置。标记阶段将记忆集中的对象加入GC ROOT集合中一起扫描, 就可以将被引用的对象标记为存活。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191709778.png" alt="image-20241119170908674"></p>
<blockquote>
<p>将堆内存空间按照每512字节划分为多个卡页, 每个region都有一个卡表(字节数组), 其中使用1字节标识每个卡页中是否有对象引用了本region中的对象, 引用了就设置为0, 即脏卡</p>
<p>根据卡表生成记忆集：将脏卡的在卡表中的下标记录下来即可</p>
</blockquote>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>JVM使用写屏障(Write Barrier)技术, 在执行引用关系建立的代码时, 可以在代码前和代码后插入一段指令, 从而维护卡表。</p>
<p>G1使用写屏障技术, 在执行引用关系建立的代码执行后插入一段指令, 完成卡表的维护工作。</p>
<p>记忆集中不会记录新生代到新生代的引用, 同一个Region中的引用也不会记录。</p>
<h4 id="记忆集生成流程"><a href="#记忆集生成流程" class="headerlink" title="记忆集生成流程"></a>记忆集生成流程</h4><ol>
<li>通过写屏障获得引用变更的信息。</li>
<li>将引用关系记录到卡表中, 并记录到一个脏卡队列中。</li>
<li>JVM中会由 Refinement 线程定期从脏卡队列中获取数据, 生成记忆集。不直接写入记忆集的原因是避免过多线程并发访问记忆集。</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411191732424.png" alt="image-20241119173243346" style="zoom:80%;" /></p>
<h4 id="年轻代回收"><a href="#年轻代回收" class="headerlink" title="年轻代回收"></a>年轻代回收</h4><p>年轻代回收只扫描年轻代对象(Eden + Survivor), 所以从GC Root到年轻代的对象或者年轻代对象引用了其他年轻代的对象都很容易扫描出来。如果有老年代的对象引用了年轻代中的对象, 需要通过<strong>卡表</strong>来实现。</p>
<p>年轻代回收步骤如下, 整个过程是STW的</p>
<ol>
<li>Root扫描, 将所有的静态变量、局部变量扫描出来</li>
<li>处理脏卡队列中的没有处理完的信息, 更新记忆集的数据, 此阶段完成后, 记忆集中包含了所有老年代对当前Region的引用关系</li>
<li>标记存活对象。记忆集中的对象会加入到GC Root对象集合中, 在GC Root引用链上的对象也会被标记为存活对象</li>
<li>根据设定的最大停顿时间, 选择本次收集的区域, 称之为回收集合Collection Set</li>
<li>复制对象:将标记出来的对象复制到新的区中, 将年龄加1, 如果年龄到达15则晋升到老年代。老的区域内存直接清空。</li>
<li>处理软、弱、虚、终结器引用, 以及JNI中的弱引用。</li>
</ol>
<h3 id="6-2-混合回收"><a href="#6-2-混合回收" class="headerlink" title="6.2 混合回收"></a>6.2 混合回收</h3><p>多次回收之后, 会出现很多Old老年代区, 此时总堆占有率达到阈值(默认45%)时会触发混合回收MixedGC。混合回收会由年轻代回收之后或者大对象分配之后触发, 混合回收会回收<strong>整个年轻代 + 部分老年代</strong>。</p>
<p>老年代很多时候会有大量对象, 要标记出所有存活对象耗时较长, 所以整个标记过程要尽量能做到和用户线程并行执行。</p>
<p>混合回收的步骤:</p>
<ol>
<li>初始标记, STW, 采用三色标记法标记从GCRoot可直达的对象</li>
<li>并发标记, 并发执行, 对存活对象进行标记</li>
<li>最终标记, STW, 处理SATB相关的对象标记</li>
<li>筛选回收, STW, 负责更新Region的统计数据, 对各个Region的回收价值和成本进行排序, 根据用户所期望的停顿时间来制定回收计划, 可以自由选择任意多个Region构成回收集, 然后把决定回收的那一部分Region的存活对象复制到空的Region中, 再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动, 是必须暂停用户线程, 由多条收集器线程并行完成的。</li>
</ol>
<h4 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h4><p>初始标记会暂停所有用户线程, 只标记从GC Root可直达的对象, 所以停顿时间不会太长。采用<strong>三色标记法</strong>进行标记, 三色标记法在原有双色标记(黑也就是1代表存活, 白0代表可回收)增加了一种灰色, 采用<strong>队列</strong>的方式保存标记为灰色的对象。</p>
<ul>
<li>黑色: 当前对象在GC Root引用链上, 同时他引用的其他对象也都已经标记完成。</li>
<li>灰色: 当前对象在GC Root引用链上, 他引用的其他对象还未标记完成。</li>
<li>白色: 不在GC Root引用链上。</li>
</ul>
<p>三色标记中的黑色和白色是使用位图(bitmap)来实现的, 比如每8个字节使用1个bit来标识标记的内容(因为内存中是按8字节对齐的), 黑色为1, 白色为0, 灰色不会体现在位图中, 会单独放入一个队列中。如果对象超过8个字节, 仅仅使用第一个bit位处理</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201359459.png" alt="image-20241120135933377" style="zoom:67%;" /></p>
<h4 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h4><p>接下来进入并发标记阶段, 继续进行未完成的标记任务。此阶段和用户线程并发执行。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201401584.png" alt="image-20241120140138498" style="zoom:67%;" /></p>
<p>从灰色队列中获取尚未完成标记的对象B。标记B关联的A和C对象, 由于A对象并未引用其他对象, 可以直接标记成黑色, C对象有引用对象E, 所以先标记成灰色, 而B也完成了所有引用对象的标记, 也标记为黑色。</p>
<p>最后从队列获取C对象, 由于E并未引用其他对象, 标记为黑色, 再将C也标记为黑色。所以剩余对象F就是白色, 可回收。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201404574.png" alt="image-20241120140431491" style="zoom:67%;" /></p>
<h4 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h4><blockquote>
<p><strong>错标问题</strong></p>
<p>三色标记存在一个比较严重的问题, 由于用户线程可能同时在修改对象的引用关系, 就会出现错标的情况, 比如: 这个案例中正常情况下, B和C都会被标记成黑色。但是在BC标记前, 用户线程执行了 <code>B.c=null;</code> 将B到c的引用去除了。同时执行了 <code>A.c=c;</code> 添加了A到C的引用。此时会出现错标的情况, C是白色可回收。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201406953.png" alt="image-20241120140644873" style="zoom:50%;" /></p>
</blockquote>
<p>为了解决该问题, G1使用了SATB(Snapshot At The Beginning, 初始快照)技术</p>
<ol>
<li>标记开始时创建一个快照, 记录当前所有对象, 标记过程中新生成的对象<strong>直接标记为黑色</strong>。</li>
<li>采用前置写屏障技术, 在引用赋值前比如 <code>B.c = null</code> 之前, 将之前引用的对象 c 放入 SATB 待处理队列中。SATB队列每个线程都有一个, 最终会汇总到一个大的SATB队列中。</li>
</ol>
<blockquote>
<p>例如, 假设在标记开始时对象 A 引用对象 B, 在标记过程中对象 A 不再引用对象 B, 但是根据 SATB 的快照, 对象 B 仍然被认为是存活的, 因为它在标记开始时是可达的。</p>
</blockquote>
<h4 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h4><p>最终标记会暂停所有用户线程, 主要是为了处理SATB相关的对象标记。这一步中, 将所有线程的SATB队列中剩余的数据合并到总的SATB队列中, 然后逐一处理。</p>
<p>SATB队列中的对象, 默认按照存活处理, 同时要处理他们引用的对象。</p>
<p>SATB的缺点是在本轮清理时可能会将不存活的对象标记成存活对象, 产生一些所谓的浮动垃圾, 等到下一轮清理时才能回收。</p>
<h4 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h4><ol>
<li>根据最终标记的结果, 可以计算出每一个区域的垃圾对象占用内存大小, 根据停顿时间, 选择转移效率最高(垃圾对象最多)的几个区域。</li>
<li>转移时先转移GC Root直接引用的对象, 然后再转移其他对象。</li>
<li>回收老的区域, 如果外部有其他区域对象引用了转移对象, 也需要重新设置引用关系。</li>
</ol>
<h2 id="7-ZGC原理"><a href="#7-ZGC原理" class="headerlink" title="7. ZGC原理"></a>7. ZGC原理</h2><blockquote>
<p>G1无法在转移时让用户线程和GC线程同时工作的原因</p>
<p>转移完之后，需要将A对对象的引用更改为新对象的引用。但是在更改前，执行A.c.count=2，此时更改的是转移前对象中的属性。更改引用之后,A引用了转移之后的对象，此时获取A.c.count发现属性值依然是1。这样就产生了问题，所以G1为了解决问题，在转移过程中需要进行用户线程的停止。ZGC和Shenandoah解决了这个问题，让转移过程也能够并发执行。</p>
</blockquote>
<h3 id="7-1-着色指针"><a href="#7-1-着色指针" class="headerlink" title="7.1 着色指针"></a>7.1 着色指针</h3><p>在ZGC中，使用了<strong>读屏障Load Barrier</strong>技术，来实现转移后对象的获取。当获取一个对象引用时，会触发读后的屏障指令，如果对象指向的不是转移后的对象，用户线程会将引用指向转移后的对象。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201646134.png" alt="image-20241120164608016" style="zoom:80%;" /></p>
<p>为了判断是否是转移前的对象以及获取转移后的对象地址，ZGC使用到了<strong>着色指针</strong>技术</p>
<p>访问对象引用时，使用的是对象的地址。在64位虚拟机中，是8个字节可以表示接近无限的内存空间。所以一般内存中对象，高几位都是0没有使用。着色指针就是利用了这多余的几位，存储了状态信息。</p>
<p>着色指针将原来的8字节保存地址的指针拆分成了三部分:</p>
<ol>
<li>最低的44位，用于表示对象的地址，所以最多能表示16TB的内存空间</li>
<li>中间4位是颜色位，每一位只能存放0或者1，并且同一时间只有其中一位是1<ol>
<li>终结位: 只能通过终结器访问</li>
<li>重映射位(Remap): 转移完之后，对象的引用关系已经完成变更。</li>
<li>Marked0和Marked1: 标记可达对象</li>
</ol>
</li>
<li>16位未使用</li>
</ol>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201650300.png" alt="image-20241120165051187" style="zoom: 67%;" /></p>
<blockquote>
<p>正常应用程序使用8个字节去进行对象的访问，现在只使用了44位，不会产生问题吗?</p>
<p>应用程序使用的对象地址，只是虚拟内存，操作系统会将虚拟内存转换成物理内存。而ZGC通过操作系统更改了这层逻辑。所以不管颜色位变成多少，指针指向的都是同一个对象。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201652825.png" alt="image-20241120165201715" style="zoom:67%;" /></p>
<p>不支持32位系统，不支持指针压缩</p>
</blockquote>
<h3 id="7-2-内存划分"><a href="#7-2-内存划分" class="headerlink" title="7.2 内存划分"></a>7.2 内存划分</h3><p>在ZGC中，与G1垃圾回收器一样将堆内存划分成很多个区域，这些内存区域被称之为Zpage。</p>
<p>Zpage分成三类大中小，管控粒度比G1更细，这样更容易去控制停顿时间。</p>
<ul>
<li>小区域: 2M，只能保存256KB内的对象。</li>
<li>中区域: 32M，保存256KB-4M的对象。</li>
<li>大区域: 只保存一个大于4M的对象。</li>
</ul>
<h3 id="7-3-执行流程"><a href="#7-3-执行流程" class="headerlink" title="7.3 执行流程"></a>7.3 执行流程</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201712603.png" alt="image-20241120171237467"></p>
<h4 id="初始标记-1"><a href="#初始标记-1" class="headerlink" title="初始标记"></a>初始标记</h4><p>标记GC Roots直接引用的对象为存活对象，数量不多，所以停顿时间非常短</p>
<p>将 M0 位设置为1</p>
<h4 id="并发标记-1"><a href="#并发标记-1" class="headerlink" title="并发标记"></a>并发标记</h4><p>遍历所有对象，标记可以到达的每一个对象是否存活，<strong>用户线程使用读屏障，如果发现对象没有完成标记也会帮忙进行标记</strong>。</p>
<h4 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h4><p>选择需要转移的Zpage，并创建转移表，用于记录转移前对象和转移后对象地址。</p>
<h4 id="转移开始"><a href="#转移开始" class="headerlink" title="转移开始"></a>转移开始</h4><p>转移GC Root直接关联的对象，不转移的对象remapped位设置成1，避免重复进行判断。转移之后将两个对象的地址记入转移映射表。</p>
<h4 id="并发转移"><a href="#并发转移" class="headerlink" title="并发转移"></a>并发转移</h4><p>将剩余对象转移到新的ZPage中，转移之后将两个对象的地址记入转移映射表。</p>
<p>转移完之后，转移前的Zpage就可以清空了，转移表需要保留下来。</p>
<p>此时，如果用户线程访问4’对象引用的5对象, 会通过读屏障，将4对5的引用进行重置，修改为对5’的引用，同时将remap标记为1代表已经重新映射完成。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201705240.png" alt="image-20241120170508134" style="zoom:67%;" /></p>
<p>并发转移阶段结束之后，这一轮的垃圾回收就结束了，但其实并没有完成所有指针的重映射工作，这个工作会<strong>放到下一阶段</strong>，与下一阶段的标记阶段一起完成(因为都需要遍历整个对象图)。</p>
<h4 id="第二次垃圾回收的标记阶段"><a href="#第二次垃圾回收的标记阶段" class="headerlink" title="第二次垃圾回收的标记阶段"></a>第二次垃圾回收的标记阶段</h4><p>使用M1作为标志位，如果M0为1代表上一轮的重映射还没有完成，先完成重映射从转移表中找到老对象转移后的新对象，再进行标记。如果Remap为1，只需要进行标记。</p>
<p>交替使用M0, M1</p>
<h4 id="第二次垃圾回收的并发处理阶段"><a href="#第二次垃圾回收的并发处理阶段" class="headerlink" title="第二次垃圾回收的并发处理阶段"></a>第二次垃圾回收的并发处理阶段</h4><p>将转移映射表删除，释放内存空间。</p>
<blockquote>
<p>并发转移阶段-<strong>并发问题</strong></p>
<p>如果用户线程在帮忙转移时，GC线程也发现这个对象需要复制，那么就会去尝试写入转移映射表，如果发现映射表中已经有相同的老对象，直接放弃。</p>
</blockquote>
<h3 id="7-4-分代ZGC"><a href="#7-4-分代ZGC" class="headerlink" title="7.4 分代ZGC"></a>7.4 分代ZGC</h3><p>在JDK21之后，ZGC设计了年轻代和老年代，这样可以让大部分对象在年轻代回收，减少老年代的扫描次数，同样可以提升一定的性能。同时，年轻代和老年代的垃圾回收可以并行执行。</p>
<p>分代之后的着色指针将原来的8字节保存地址的指针拆分成了三部分:</p>
<ol>
<li>46位用来表示对象地址，最多可以表示64TB的地址空间。</li>
<li>中间的12位为颜色位。</li>
<li>最低4位和最高2位未使用</li>
</ol>
<p>整个分代之后的读写屏障、着色指针的移位使用都变的异常复杂，仅作了解即可。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201715728.png" alt="image-20241120171517640" style="zoom:67%;" /></p>
<h2 id="8-ShenandoahGC"><a href="#8-ShenandoahGC" class="headerlink" title="8. ShenandoahGC"></a>8. ShenandoahGC</h2><p>ShenandoahGC和ZGC不同，ShenandoahGC很多是使用了G1源代码改造而成，所以在很多算法、数据结构的定义上，与G1十分相像，而ZGC是完全重新开发的一套内容。</p>
<ol>
<li>ShenandoahGC的区域定义与G1是一样的。</li>
<li>没有着色指针，通过修改对象头的设计来完成并发转移过程的实现</li>
<li>ShenandoahGC有两个版本，1.0版本存在于JDK8和JDK11中，后续的JDK版本中均使用2.0版本。</li>
</ol>
<h3 id="8-1-1-0版本"><a href="#8-1-1-0版本" class="headerlink" title="8.1 1.0版本"></a>8.1 1.0版本</h3><p>1.0版本，在对象头的前8个字节，增加了一个前向指针。前向指针指向转移之后的对象，如果没有就指向自己。</p>
<p>如果转移阶段未完成，此时转移前的对象和转移后的对象都会存活。如果用户去访问数据，需要使用转移后的数据。ShenandoahGC使用了读前屏障，根据对象的前向指针来获取到转移后的对象并读取。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201718725.png" alt="image-20241120171851621" style="zoom:67%;" /></p>
<p>写入数据时，也会使用写前屏障，判断Mark Word中的GC状态，如果GC状态为0证明没有处于GC过程中，直接写入，如果不为0则根据GC状态值确认当前处于垃圾回收的哪个阶段，让用户线程执行垃圾回收相关的任务。</p>
<h3 id="8-2-2-0版本"><a href="#8-2-2-0版本" class="headerlink" title="8.2 2.0版本"></a>8.2 2.0版本</h3><blockquote>
<p>1.0版本的缺点:</p>
<ol>
<li>对象内存大大增加，每个对象都需要增加8个字节的前向指针，基本上会占用5%-10%的空间。</li>
<li>读屏障中加入了复杂的指令，影响使用效率。</li>
</ol>
</blockquote>
<p>2.0版本优化了前向指针的位置，仅转移阶段将其放入了Mark Word中。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201721320.png" alt="image-20241120172145216" style="zoom:67%;" /></p>
<h3 id="8-3-执行流程"><a href="#8-3-执行流程" class="headerlink" title="8.3 执行流程"></a>8.3 执行流程</h3><p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202411201723391.png" alt="image-20241120172348267"></p>
<blockquote>
<p>并发转移阶段-<strong>并发问题</strong></p>
<p>如果用户线程在帮忙转移时，ShenandoahGC线程也发现这个对象需要复制，那么就会去尝试写入前向指针，使用了类似CAS的方式来实现，只有一个线程能成功修改，其他线程会放弃转移的操作。</p>
</blockquote>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/11/14/JVM-6-Java-Agent/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2024-11-20 17:24:50
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Language/" title="Language">
                        <b>#</b> Language
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/Language/Java/" title="Java">
                        <b>#</b> Java
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2025/04/14/Kafka-1/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%88%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-text">1. 栈上的数据存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%8A%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">2. 对象在堆上的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9"><span class="toc-text">2.1 指针压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">2.2 内存对齐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-text">3. 方法调用原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">3.1 静态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">3.2 动态绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86"><span class="toc-text">4. 异常捕获原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">5. JIT即时编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">5.1 执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-JIT%E4%BC%98%E5%8C%96-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-text">5.2 JIT优化-方法内联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-JIT%E4%BC%98%E5%8C%96-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">5.3 JIT优化-逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-text">标量替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">6. G1垃圾回收器原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-text">6.1 年轻代回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8-Card-Table"><span class="toc-text">卡表(Card Table)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-text">写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B"><span class="toc-text">记忆集生成流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-text">年轻代回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="toc-text">6.2 混合回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0"><span class="toc-text">初始标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-text">并发标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SATB"><span class="toc-text">SATB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E6%A0%87%E8%AE%B0"><span class="toc-text">最终标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB"><span class="toc-text">转移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ZGC%E5%8E%9F%E7%90%86"><span class="toc-text">7. ZGC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%9D%80%E8%89%B2%E6%8C%87%E9%92%88"><span class="toc-text">7.1 着色指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-text">7.2 内存划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">7.3 执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0-1"><span class="toc-text">初始标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0-1"><span class="toc-text">并发标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="toc-text">并发处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%BC%80%E5%A7%8B"><span class="toc-text">转移开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%BD%AC%E7%A7%BB"><span class="toc-text">并发转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-text">第二次垃圾回收的标记阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-text">第二次垃圾回收的并发处理阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%88%86%E4%BB%A3ZGC"><span class="toc-text">7.4 分代ZGC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-ShenandoahGC"><span class="toc-text">8. ShenandoahGC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-0%E7%89%88%E6%9C%AC"><span class="toc-text">8.1 1.0版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-0%E7%89%88%E6%9C%AC"><span class="toc-text">8.2 2.0版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">8.3 执行流程</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + JVM(7)%20%E5%8E%9F%E7%90%86 + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2024%2F11%2F18%2FJVM-7-%25E5%258E%259F%25E7%2590%2586%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2024/11/18/JVM-7-%E5%8E%9F%E7%90%86/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
