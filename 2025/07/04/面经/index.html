<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Whale" />
  <meta name="description" content="码农预备役" />
  
  
  <title>
    
      暑期实习面经 
      
      
      |
    
     Whale&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
    <link rel="icon" href="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <link rel="stylesheet" href="/css/intellij-light.css">
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Whale</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">暑期实习面经</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2025-07-04 22:19:32
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" title="面试">
                    <b>#</b> 面试
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="2-27-阿里云-齐天-一面"><a href="#2-27-阿里云-齐天-一面" class="headerlink" title="2.27-阿里云-齐天-一面"></a>2.27-阿里云-齐天-一面</h2><ol>
<li><p>项目中用到的设计模式介绍一下</p>
</li>
<li><p>设计模式的基本原则</p>
<blockquote>
<p>单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成复用原则、迪米特法则</p>
</blockquote>
</li>
<li><p>Java常用的集合有哪些</p>
</li>
<li><p>HashMap的底层实现</p>
</li>
<li><p>HashMap和HashSet的区别</p>
</li>
<li><p>介绍一下Java反射</p>
</li>
<li><p>反射在实际开发中的优点</p>
</li>
<li><p>Java中的堆栈有什么区别</p>
</li>
<li><p>Java中定义的变量是分配在堆还是栈中</p>
</li>
<li><p>垃圾回收机制讲一下</p>
</li>
<li><p>数据库的事务讲一下</p>
</li>
<li><p>事务的隔离级别</p>
</li>
<li><p>数据库的锁机制</p>
</li>
<li><p>如何保证没有死锁或者出现死锁如何处理</p>
</li>
<li><p>原子性怎么实现的</p>
</li>
<li><p>TCP三次握手和四次挥手，为什么握手是三次，挥手是四次</p>
</li>
<li><p>TCP拥塞控制</p>
</li>
<li><p>Redis常用的数据结构，讲一下跳表，跳表的复杂度</p>
</li>
<li><p>缓存雪崩，击穿，穿透出现场景和解决方案</p>
</li>
<li><p>讲一下实习项目</p>
<ol>
<li>数据加密脱敏</li>
<li>双token机制</li>
<li>一开始如何建立安全连接，用的什么加密方法</li>
<li>Redis滑动窗口，为什么选择这个方法</li>
<li>是否上线，QPS，如何做服务可用性保证，数据一致性如何保证</li>
</ol>
</li>
</ol>
<h2 id="3-6-字节-财经-一面"><a href="#3-6-字节-财经-一面" class="headerlink" title="3.6-字节-财经-一面"></a>3.6-字节-财经-一面</h2><ol>
<li><p>拷打实习</p>
</li>
<li><p>操作系统中同步和互斥的区别</p>
</li>
<li><p>操作系统如何避免死锁</p>
</li>
<li><p>什么是段页式内存管理</p>
</li>
<li><p>段页式中，cpu取数据要访问几次内存</p>
<blockquote>
<p>3 次</p>
</blockquote>
</li>
<li><p>DNS的解析过程</p>
</li>
<li><p>可能在哪些环节出现问题，出现问题如何定位(可以使用哪些命令)</p>
<blockquote>
<ol>
<li><strong>客户端配置环节</strong>：客户端的 DNS 服务器地址配置错误或不完整，可能导致无法正确连接到 DNS 服务器进行解析。此外，本地 DNS 缓存可能会出现数据错误或过时的情况，影响解析结果。</li>
<li><strong>网络连接环节</strong>：从客户端到 DNS 服务器之间的网络路径出现故障，如路由器故障、网络线路中断、防火墙限制等，会导致客户端无法与 DNS 服务器通信，进而无法完成解析。</li>
<li><strong>DNS 服务器环节</strong>：DNS 服务器本身可能出现软件故障、硬件故障或配置错误。例如，DNS 服务器的区域文件配置错误，可能导致特定域名无法正确解析；服务器负载过高，也可能影响解析的效率和成功率。</li>
<li><strong>域名注册环节</strong>：如果域名注册信息不正确、不完整或过期，域名的权威 DNS 服务器信息可能无法被正确获取，导致解析失败。</li>
<li><strong>递归与迭代查询环节</strong>：在递归查询中，本地 DNS 服务器向其他 DNS 服务器请求解析时可能出现问题。迭代查询过程中，各级 DNS 服务器之间传递解析请求和响应时也可能出现错误，比如根 DNS 服务器、顶级域 DNS 服务器等返回错误或不完整的信息。</li>
</ol>
<p>Linux 系统</p>
<ul>
<li><strong>ping</strong>：与 Windows 系统中的 ping 命令功能类似，用于测试网络连通性。</li>
<li><strong>dig</strong>：是 Linux 系统中常用的 DNS 查询工具，功能强大，可用于查询各种 DNS 记录，如 A 记录、MX 记录等。可以指定域名、DNS 服务器等参数进行查询，查看详细的解析结果。</li>
<li><strong>nslookup</strong>：在 Linux 系统中也有该命令，用法与 Windows 系统类似，用于简单的 DNS 查询。</li>
<li><strong>host</strong>：也是一个 DNS 查询工具，可用于查询域名对应的 IP 地址等信息，相对 dig 命令更简洁。</li>
<li><strong>traceroute</strong>：与 Windows 系统中的 tracert 命令功能相同，用于跟踪网络路由路径，排查网络传输过程中的故障点。</li>
</ul>
</blockquote>
</li>
<li><p>http各版本区别</p>
</li>
<li><p>介绍一下代理模式</p>
</li>
<li><p>jdk和cglib哪种效率更高</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/brithToSpring/p/13356626.html">https://www.cnblogs.com/brithToSpring/p/13356626.html</a></p>
<p>jdk6 下，在运行次数较少的情况下，jdk动态代理与 cglib 差距不明显；而当调用次数增加之后，cglib 表现稍微更快一些</p>
<p>jdk7,8下，jdk动态代理性能均高于cglib</p>
</blockquote>
</li>
<li><p>Redis中哈希表发生哈希冲突如何处理</p>
</li>
<li><p>Redis数据的同步和备份是怎么做的</p>
</li>
<li><p>Redis哨兵机制</p>
</li>
<li><p>MySQL如何保证ACID</p>
</li>
<li><p>持久性为什么要用redolog而不直接刷盘</p>
<blockquote>
<p>实现事务的持久性，让 MySQL有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失</p>
<p>将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能。</p>
</blockquote>
</li>
<li><p>执行一条SQL语句的过程</p>
</li>
<li><p>手撕：锯齿层序遍历</p>
</li>
</ol>
<h2 id="3-7-阿里控股-智能引擎-一面"><a href="#3-7-阿里控股-智能引擎-一面" class="headerlink" title="3.7-阿里控股-智能引擎-一面"></a>3.7-阿里控股-智能引擎-一面</h2><ol>
<li><p>C++和Java最典型的区别</p>
</li>
<li><p>Java内存泄露有哪些情况</p>
<blockquote>
<p>长生命周期的对象持有短生命周期对象的引用 （eg.将对象放入静态集合后未及时移除）</p>
<p>未关闭资源</p>
<p>对象存入<code>ThreadLocal</code>后未调用<code>remove()</code></p>
<p>过度使用<code>String.intern()</code>方法</p>
<p>线程池</p>
<p>非静态内部类持有外部类引用</p>
</blockquote>
</li>
<li><p>Java常见的关键字</p>
</li>
<li><p>final的作用</p>
</li>
<li><p>反射了解吗，可以修改final修饰的属性吗</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/noKing/p/9038234.html">https://www.cnblogs.com/noKing/p/9038234.html</a></p>
<p>反射是可以修改<code>final</code>变量的，但是如果是基本数据类型或者<code>String</code>类型的时候，无法通过对象获取修改后的值，因为JVM对其进行了<strong>内联优化</strong>。</p>
<p>即变量的值是修改成功的, 但是方法输出的内容在JVM优化后就被写死了, 所以无论是否被正确修改为其他的值, 方法始终都会打印初始值.</p>
<p>反射无法修改同时被static final修饰的变量，只能先去除final再修改</p>
</blockquote>
</li>
<li><p>JVM层面对final做了哪些处理</p>
<blockquote>
<p><strong>内存模型与可见性</strong>：插入内存屏障，禁止重排序，确保<code>final</code>字段的写操作对其他线程可见。</p>
<p><strong>编译器优化</strong>：内联和常量折叠，优化<code>final</code>字段的访问。</p>
<p><strong>类加载与字节码验证</strong>：确保<code>final</code>字段在构造函数中被正确初始化。</p>
<p><strong>标记位与元数据</strong>：使用<code>ACC_FINAL</code>标记表示<code>final</code>字段，维护字段的元数据。</p>
<p><strong>反射与安全性</strong>：限制反射修改<code>final</code>字段，确保对象的不变性和线程安全性。</p>
</blockquote>
</li>
<li><p>平常怎么使用线程池</p>
</li>
<li><p>使用线程池过程中有没有遇到什么问题</p>
<ol>
<li>回答：ThreadLocal、参数设置</li>
</ol>
</li>
<li><p>线程池参数要怎么设置</p>
</li>
<li><p>拒绝策略如果将任务重新放入线程池会有什么问题</p>
<ol>
<li>回答：依然会被拒绝</li>
</ol>
</li>
<li><p>那要怎么解决呢</p>
<ol>
<li>回答：找个地方暂存，比如消息队列，削峰</li>
</ol>
</li>
<li><p>直接放入消息队列这种做法适用于哪些场景</p>
<blockquote>
<p>突发流量：系统在短时间内接收到大量任务，需要平滑处理。</p>
<p>异步任务：任务可以异步处理，不需要立即返回结果。</p>
<p>高可用性：需要保证任务不丢失，即使系统暂时无法处理。</p>
</blockquote>
</li>
<li><p>一般你是怎么new线程池的</p>
</li>
<li><p>CompletableFuture底层用的什么线程池</p>
</li>
<li><p>ForkJoinPool 和 ThreadPoolExecuter 有什么区别，为什么 JDK 要做一个 ForkJoinPool</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ForkJoinPool.html">https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ForkJoinPool.html</a></p>
<p>基于工作窃取（Work-Stealing）算法。每个线程维护一个双端队列（Deque），优先执行自己队列中的任务，空闲时可以从其他线程的队列尾部“窃取”任务。</p>
<p>ForkJoinPool 适用于分治任务（如递归任务）和任务之间有依赖的场景。支持任务分解（<code>fork()</code>）和合并（<code>join()</code>）。</p>
<p>ThreadPoolExecuter 是一个通用的线程池实现，它遵循传统的生产者 - 消费者模型</p>
</blockquote>
</li>
<li><p>JDK21里的虚拟线程有了解过吗，它也是用ForkJoinPool实现的，为什么不用ThreadPoolExecuter</p>
<blockquote>
<p>任务调度效率：<code>ForkJoinPool</code> 的工作窃取算法适合高并发场景，能够高效调度大量虚拟线程。</p>
<p>线程管理灵活性：<code>ForkJoinPool</code> 能够动态调整线程利用率，适应虚拟线程的高并发需求。</p>
<p>任务挂起与恢复：<code>ForkJoinPool</code> 的任务分解机制能够很好地支持虚拟线程的挂起和恢复。</p>
<p>性能优化：<code>ForkJoinPool</code> 在高并发场景下的性能优于 <code>ThreadPoolExecutor</code>。</p>
</blockquote>
</li>
<li><p>垃圾回收了解吗</p>
</li>
<li><p>为什么Java没有用引用计数，而Python使用了引用计数，引用计数有什么缺点</p>
</li>
<li><p>如何解决循环引用的问题</p>
<blockquote>
<p>可达性分析-标记清除</p>
<p>使用弱引用</p>
</blockquote>
</li>
<li><p>面试官说明时间：引用计数有个问题，每次引用都要+1，涉及到并发问题，对性能有影响，只能用于对性能要求不高的语言</p>
</li>
<li><p>拷打项目</p>
<ol>
<li>用到了什么设计模式</li>
<li>模式背后体现了什么思想</li>
<li>像策略模式这些都用到了继承，你觉得继承有哪些优缺点</li>
<li>面试官说明时间：继承是有很强的语义的，如果设计不好的话很容易走样</li>
</ol>
</li>
<li><p>拷打实习</p>
<ol>
<li>代码里的具体流程</li>
<li>请求用到了什么http库</li>
<li>如果失败了应该尝试重试</li>
<li>那么什么情况下可以重试</li>
<li>请求完OCR后，如果保存到数据库时失败了要怎么处理</li>
</ol>
</li>
</ol>
<h2 id="3-9-美团-AI面试"><a href="#3-9-美团-AI面试" class="headerlink" title="3.9-美团-AI面试"></a>3.9-美团-AI面试</h2><ol>
<li><p>HTTPS和HTTP的区别</p>
</li>
<li><p>如何查看文件内容，列举三个命令</p>
</li>
<li><p>解释数据库分片（Sharding）的概念，它有什么优势和挑战</p>
<blockquote>
<p>数据库分片是一种将大型数据库拆分成多个较小、更易管理的部分（称为“分片”）的技术。每个分片独立存储在不同的服务器或节点上，共同组成完整的数据库。分片可以基于特定规则（如用户ID、地理位置等）进行数据划分，确保每个分片只包含部分数据。</p>
<p>数据库分片通过将数据分散到多个服务器上，提升了性能、扩展性和可用性，但也带来了管理复杂性、数据一致性等挑战。</p>
</blockquote>
</li>
<li><p>ThreadLocal，解决了什么问题</p>
</li>
<li><p>Java封装的目的，为什么有封装</p>
<blockquote>
<p>隐藏对象的内部细节，仅对外暴露必要的接口。保护数据完整性、降低耦合度</p>
</blockquote>
</li>
<li><p>第三方支付接口超时情况下，如何设计对账补偿机制</p>
<blockquote>
<p>支付接口超时，系统标记交易为“超时”。系统主动查询支付状态，若成功则更新为“成功”，否则标记为“失败”。每日对账时，系统比对记录与支付平台数据，发现异常则触发补偿机制。补偿完成后，系统通知用户交易结果。</p>
</blockquote>
</li>
<li><p>在这种设计中，你如何外理由于网络波动或具他不可控因素导致的重复支付问题?你会采取哪些措施来防止重复支付的发生?</p>
<blockquote>
<p>支付接口应支持幂等性，即同一笔交易无论请求多少次，结果都一致。可以通过在请求中传递唯一的交易号（如订单号）来实现。</p>
</blockquote>
</li>
</ol>
<h2 id="3-10-阿里云-齐天-二面"><a href="#3-10-阿里云-齐天-二面" class="headerlink" title="3.10-阿里云-齐天-二面"></a>3.10-阿里云-齐天-二面</h2><ol>
<li><p>常见的树的数据结构有哪些，以及使用场景</p>
</li>
<li><p>有在实际项目中用到吗</p>
</li>
<li><p>讲讲Java中的数据结构</p>
</li>
<li><p>展开讲讲B+树，解决了数据库的什么问题，没有B+树之前怎么解决的，和原来的方法有什么区别</p>
</li>
<li><p>数据库中用B+树做什么</p>
</li>
<li><p>如果需要update一个节点，这时候的树操作是什么样的</p>
<blockquote>
<p>更新后的键值仍然在节点的键值范围内。无需调整树结构，更新完成。</p>
<p>更新后的键值超出节点的键值范围。需要调整树结构，可能涉及节点分裂或合并。</p>
</blockquote>
</li>
<li><p>Java创建线程的方法</p>
</li>
<li><p>线程通信有哪些方式</p>
</li>
<li><p>操作系统也提供线程库，和java的库有什么不一样的地方</p>
</li>
<li><p>用户级和内核级的区别在哪</p>
</li>
<li><p>场景题</p>
<ol>
<li><p>需要爬取阿里云官网的产品文档，同时处理后写到数据库，这里涉及到表结构的设计以及Java的实现(包括并发、多线程)，请给出设计方案</p>
<blockquote>
<p><strong>爬虫模块</strong>：负责从阿里云官网抓取产品文档。</p>
<p><strong>数据处理模块</strong>：负责解析和清洗抓取的数据。</p>
<p><strong>数据库模块</strong>：负责设计表结构并将处理后的数据存储到数据库中。</p>
<p><strong>并发与多线程模块</strong>：确保系统能够高效地处理大量数据。</p>
<p>| 字段名         | 数据类型      | 描述         |<br>| :——————- | :—————— | :—————- |<br>| <code>id</code>           | BIGINT (主键) | 自增ID       |<br>| <code>title</code>        | VARCHAR(255)  | 文档标题     |<br>| <code>content</code>      | TEXT          | 文档内容     |<br>| <code>publish_date</code> | DATETIME      | 文档发布时间 |<br>| <code>url</code>          | VARCHAR(512)  | 文档URL      |<br>| <code>created_at</code>   | DATETIME      | 记录创建时间 |<br>| <code>updated_at</code>   | DATETIME      | 记录更新时间 |</p>
</blockquote>
</li>
<li><p>数据库的类型应该用什么，MySQL中varchar和text默认长度是多少</p>
<blockquote>
<p>varchar: 没有默认长度，最大长度是 65,535 字节</p>
<p>TINYTEXT：最大长度为 255 字节（2^8 - 1）</p>
<p>TEXT：最大长度为 65,535 字节（2^16 - 1）</p>
<p>MEDIUMTEXT：最大长度为 16,777,215 字节（2^24 - 1）</p>
<p>LONGTEXT：最大长度为 4,294,967,295 字节（2^32 - 1）</p>
</blockquote>
</li>
<li><p>使用线程池爬取网页时</p>
<ol>
<li><p>线程池要开多大</p>
<blockquote>
<p>I/O密集型任务: 2N</p>
<p>线程池大小 = CPU 核心数 * (1 + 等待时间 / 计算时间)</p>
</blockquote>
</li>
<li><p>对于这么多网页，线程如何进行调度、分配</p>
<blockquote>
<p>使用阻塞队列存储需要爬取的URL，如果需要优先处理某些 URL，可以使用 <code>PriorityBlockingQueue</code>，并为任务设置优先级。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>如果线程作为一个独立的任务，每次处理完就写入db，会导致db负载比较高，要怎么解决</p>
<blockquote>
<p>将多次写入操作合并为一次批量写入，减少数据库的 I/O 操作次数。</p>
<p>将数据库写入操作放到单独的线程或线程池中执行，避免阻塞主线程。</p>
<p>使用消息队列（如 Kafka、RabbitMQ）来接收处理结果。单独的消费者服务从消息队列中读取数据并写入数据库。</p>
<p>如果仍然需要直接写入数据库，可以使用数据库连接池来优化数据库连接的管理。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>拷打实习</p>
<ol>
<li><p>SSE是一个什么样的协议，格式是什么样子的，如何表达传输开始，传输中，传输结尾</p>
<blockquote>
<p>基于HTTP协议</p>
<p>每一次发送的信息，由若干个<code>message</code>组成，每个<code>message</code>之间用<code>\n\n</code>分隔。每个<code>message</code>内部由若干行组成，每一行都是 <code>[field]: value\n</code> 格式。field取值包括data、event、id、retry</p>
<p><strong>传输开始</strong>：客户端通过<code>EventSource</code>对象发起请求，服务器响应<code>Content-Type: text/event-stream</code>，表示开始SSE连接。</p>
<p><strong>传输中</strong>：服务器持续发送消息，客户端通过<code>onmessage</code>或<code>addEventListener</code>接收。</p>
<p><strong>传输结束</strong>：服务器关闭连接或客户端调用<code>close()</code>方法结束传输。</p>
</blockquote>
</li>
<li><p>遇到了什么技术挑战，技术选型怎么做的，现在重新考虑有什么可以优化的</p>
</li>
</ol>
</li>
</ol>
<h2 id="3-10-腾讯-CDG-金融科技-一面"><a href="#3-10-腾讯-CDG-金融科技-一面" class="headerlink" title="3.10-腾讯-CDG-金融科技-一面"></a>3.10-腾讯-CDG-金融科技-一面</h2><ol>
<li><p>手撕：反转正整数</p>
</li>
<li><p>手撕：合并区间</p>
</li>
<li><p>拷打实习</p>
<ol>
<li><p>RBAC模型是什么</p>
<blockquote>
<p>这种将权限绑定在角色上，再给用户账号赋予角色的方式就叫做基于角色的权限管理（RBAC）</p>
<p><a target="_blank" rel="noopener" href="https://www.woshipm.com/pd/5576757.html">https://www.woshipm.com/pd/5576757.html</a></p>
</blockquote>
</li>
<li><p>双token刷新，为什么要用两个token</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23845083/article/details/144154192">https://blog.csdn.net/qq_23845083/article/details/144154192</a></p>
<p>Access Token用于访问受保护资源，有效期较短，即使泄露，攻击者也只能在短时间内使用。Refresh Token用于获取新的Access Token，有效期较长，但只在特定场景下使用，减少了泄露风险。</p>
<p>用户体验优化，无感刷新</p>
<p>权限控制灵活，可以通过控制Refresh Token的有效期，刷新次数等方式来灵活的管理用户的会话生命周期</p>
</blockquote>
</li>
<li><p>有空了解一下微信接入，也是基于token的</p>
</li>
<li><p>通信使用的是HTTP还是HTTPS</p>
</li>
<li><p>为什么使用 WebSocket 和 SSE</p>
</li>
</ol>
</li>
<li><p>HTTP和HTTPS有什么区别</p>
</li>
<li><p>为什么不直接用服务端公钥加密传输</p>
<blockquote>
<p>非对称加密（如RSA）效率低，公钥加密计算量大，速度慢，不适合加密大量数据</p>
<p>服务器发出的给所有人的结果，都可以使用同一份公钥解密</p>
<p>前向安全，一旦服务端的私钥泄漏了，过去被第三方截获的通讯密文都会被破解</p>
</blockquote>
</li>
</ol>
<h2 id="3-14-腾讯-PCG-应用架构-一面"><a href="#3-14-腾讯-PCG-应用架构-一面" class="headerlink" title="3.14-腾讯-PCG-应用架构-一面"></a>3.14-腾讯-PCG-应用架构-一面</h2><ol>
<li><p>手撕：LRU</p>
</li>
<li><p>手撕：最长无重复子串</p>
</li>
<li><p>内核态和用户态的区别</p>
<blockquote>
<p>内核态和用户态是OS中两种不同的处理器运行状态。用户态中程序不能直接访问硬件资源和执行特权指令，内核态可以访问所有硬件资源并执行任何指令</p>
</blockquote>
</li>
<li><p>系统调用的步骤，如何触发</p>
</li>
<li><p>频繁进行用户态和内核态的转化，对性能有影响吗</p>
</li>
<li><p>进程和线程的区别18057170522</p>
</li>
<li><p>进程和线程的通信方式</p>
<blockquote>
<p>进程通信：<strong>管道/匿名管道(pipe)</strong>、<strong>有名管道(FIFO)</strong>、<strong>信号(Signal)</strong>、<strong>消息(Message)队列</strong>、<strong>共享内存(share memory)</strong>、<strong>信号量(semaphore)</strong>、<strong>套接字(socket)</strong></p>
<p>线程通信：共享内存、锁（互斥锁、读写锁）、条件变量、信号量</p>
<p>实际上只有进程间需要通信，同一进程的线程共享地址空间，没有通信的必要，但要做好同步/互斥，保护共享的全局变量。</p>
</blockquote>
</li>
<li><p>使用多线程和单线程对比有什么优劣</p>
<blockquote>
<p>提高了并发性能，但也有线程同步、死锁等问题</p>
</blockquote>
</li>
<li><p>为什么会产生线程安全问题，直接对一个共享变量读写是否会有问题</p>
<blockquote>
<p>可见性问题</p>
</blockquote>
</li>
<li><p>常见的同步方式</p>
<blockquote>
<p><strong>互斥锁(Mutex)</strong> 、<strong>读写锁（Read-Write Lock）</strong>、<strong>信号量(Semaphore)</strong> 、<strong>屏障（Barrier）</strong> 、<strong>事件(Event)</strong></p>
</blockquote>
</li>
<li><p>虚拟内存，有什么作用</p>
<blockquote>
<ul>
<li><strong>隔离进程</strong>：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
<li><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li>
<li><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li>
<li><strong>多个进程共享物理内存</strong>：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li>
<li><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li>
<li><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
</ul>
</blockquote>
</li>
<li><p>浏览器输入url的过程</p>
</li>
<li><p>三次握手，能否简化为两次</p>
</li>
<li><p>第三次握手丢失服务端会怎么处理</p>
</li>
<li><p>第三次握手可以携带数据吗</p>
</li>
<li><p>四次挥手，二三次能合并吗</p>
</li>
<li><p>拆箱装箱，频繁拆箱装箱是否对性能有影响</p>
</li>
<li><p>String，StringBuilder，StringBuffer</p>
</li>
<li><p>字符串拼接用什么</p>
</li>
<li><p>GC如何判断对象是否存活</p>
</li>
<li><p>内存泄露的场景</p>
</li>
<li><p>类A有一个内部类B，B被外界持有是否会造成内存泄漏</p>
<blockquote>
<p>会的，非静态内部类B的对象会持有A的对象的引用</p>
</blockquote>
</li>
<li><p>循环引用是否会造成内存泄漏</p>
</li>
<li><p>四种引用类型</p>
</li>
<li><p>HashMap是不是线程安全的</p>
</li>
<li><p>HashMap底层数据结构</p>
</li>
<li><p>HashMap的key可以为null吗</p>
</li>
<li><p>HashMap用什么类型作为key性能最好</p>
</li>
<li><p>key使用ArrayList是否会有问题</p>
<blockquote>
<p>会，hashcode会变化</p>
</blockquote>
</li>
<li><p>拷打项目</p>
</li>
</ol>
<h2 id="3-18-阿里控股-智能引擎-二面"><a href="#3-18-阿里控股-智能引擎-二面" class="headerlink" title="3.18-阿里控股-智能引擎-二面"></a>3.18-阿里控股-智能引擎-二面</h2><ol>
<li><p>拷打实习</p>
</li>
<li><p>多线程开多少线程比较好</p>
</li>
<li><p>进程、线程、协程如何理解</p>
<blockquote>
<p>协程是用户态的轻量级线程，由程序自行控制调度，而非操作系统内核。协程的切换完全在用户态完成，无需进入内核态，因此开销极小。</p>
</blockquote>
</li>
<li><p>Java进程最大能用多大的堆，一般会设置多大的堆</p>
</li>
<li><p>看过哪些框架中间件的源码</p>
</li>
<li><p>Object有哪些方法</p>
</li>
<li><p>为什么要同时重写hashcode、equals</p>
</li>
<li><p>hashcode相同，equals为false会导致逻辑错误吗</p>
</li>
<li><p>wait()和sleep()的区别</p>
<blockquote>
<p><strong>所属类</strong></p>
<ul>
<li><strong><code>wait()</code></strong>：<code>wait()</code> 是 <code>Object</code> 类的方法，所有对象都可以调用。</li>
<li><strong><code>sleep()</code></strong>：<code>sleep()</code> 是 <code>Thread</code> 类的静态方法，作用于当前线程。</li>
</ul>
<p><strong>调用方式</strong></p>
<ul>
<li><strong><code>wait()</code></strong>：必须在同步代码块或同步方法中调用，且调用前必须持有对象的锁（即使用 <code>synchronized</code> 关键字）。</li>
<li><strong><code>sleep()</code></strong>：可以在任何地方调用，不需要持有锁。</li>
</ul>
<p><strong>锁的释放</strong></p>
<ul>
<li><strong><code>wait()</code></strong>：调用 <code>wait()</code> 后，线程会释放持有的对象锁，允许其他线程进入同步代码块。</li>
<li><strong><code>sleep()</code></strong>：调用 <code>sleep()</code> 后，线程不会释放任何锁，其他线程无法进入同步代码块。</li>
</ul>
<p><strong>唤醒机制</strong></p>
<ul>
<li><strong><code>wait()</code></strong>：线程可以通过 <code>notify()</code> 或 <code>notifyAll()</code> 方法被唤醒，或者等待超时后自动唤醒。</li>
<li><strong><code>sleep()</code></strong>：线程在指定的时间结束后自动恢复执行，无法被其他线程唤醒。</li>
</ul>
<p><strong>用途</strong></p>
<ul>
<li><strong><code>wait()</code></strong>：通常用于线程间的协作，例如生产者-消费者模式，等待某个条件满足。</li>
<li><strong><code>sleep()</code></strong>：通常用于暂停线程的执行一段时间，例如模拟延迟或定时任务。</li>
</ul>
</blockquote>
</li>
<li><p>笔试：有两个有序数组A，B，定义集合 S = {a + b | a $\in$ A，b $\in$ B}，请给一种算法，求 S 中最小的 K 个元素。<br>例如A = {1, 1, 4}，B = {1，3}，则 S = {2, 4, 5, 7}，则最小的3个元素为{2，4，5}</p>
</li>
</ol>
<h2 id="3-19-美团-核心本地商业-一面"><a href="#3-19-美团-核心本地商业-一面" class="headerlink" title="3.19-美团-核心本地商业-一面"></a>3.19-美团-核心本地商业-一面</h2><ol>
<li>拷打实习</li>
<li>线程池介绍一下，是怎么用的，参数是怎么配置的</li>
<li>垃圾回收算法</li>
<li>垃圾回收器</li>
<li>讲一下Spring Ioc，AOP（项目相关）</li>
<li>有用到过MQ吗，解决了什么问题</li>
<li>手撕：K个一组反转链表</li>
<li>手撕：二叉树的最大路径和</li>
</ol>
<h2 id="3-20-字节-广告业务-一面"><a href="#3-20-字节-广告业务-一面" class="headerlink" title="3.20-字节-广告业务-一面"></a>3.20-字节-广告业务-一面</h2><ol>
<li><p>拷打实习</p>
<ol>
<li><p>限流机制</p>
</li>
<li><p>Sentinel限流怎么实现的</p>
<blockquote>
<p>责任链模式，滑动窗口实现</p>
</blockquote>
</li>
<li><p>漏桶、令牌桶怎么实现的</p>
<blockquote>
<p>漏桶算法的核心思想是将请求看作水，漏桶以一个固定的速率漏水（处理请求）。如果桶满了（请求过多），则丢弃多余的请求。（消息队列的限流本质上就是漏桶算法）</p>
<p>令牌桶算法的核心思想是系统以固定的速率向桶中添加令牌，每个请求需要从桶中获取一个令牌。如果桶中没有足够的令牌，则触发限流。</p>
</blockquote>
</li>
<li><p>线程池大小怎么设置的</p>
<blockquote>
<p>最佳线程数 = N（CPU 核心数）*（1 + WT（线程等待时间）/ST（线程计算时间））</p>
<p>WT（线程等待时间）= 线程运行总时间 - ST（线程计算时间）</p>
</blockquote>
</li>
</ol>
</li>
<li><p>WebFlux内部是怎么实现的</p>
<blockquote>
<p>WebFlux 通过 Reactor 和响应式编程模型实现非阻塞、异步处理，适合高并发场景。其核心在于事件循环、响应式流</p>
<ul>
<li><strong>异步和同步针对调用者</strong>，调用者发送请求，如果等着对方回应之后才去做其他事情就是同步，如果发送请求之后不等着对方回应就去做其他事情就是异步。</li>
<li><strong>阻塞和非阻塞针对被调用者</strong>，被调用者受到请求之后，做完请求任务之后才给出反馈就是阻塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞。</li>
</ul>
</blockquote>
</li>
<li><p>响应式和非响应式的区别</p>
<blockquote>
<p><strong>响应式编程</strong>是一种基于<strong>数据流</strong>和<strong>变化传递</strong>的<strong>声明式</strong>编程范式。</p>
<p>非响应式：同步阻塞，每个请求分配一个线程</p>
<p>响应式：异步非阻塞，事件循环，支持背压，消费者可以控制数据流的速度，避免生产者发送过多数据。</p>
</blockquote>
</li>
<li><p>stream流底层是怎么实现的</p>
<blockquote>
<p>基于流水线和惰性求值</p>
<p>每个中间操作会创建一个新的 <code>Stream</code> 对象(就是<code>ReferencePipeline</code>)，并将其链接到流水线中，形成一个双向链表。</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202503211116460.webp" alt="在这里插入图片描述" style="zoom:50%;" /></p>
<ol>
<li><p>它会从最后一个中间操作开始自下而上进行Sink封装，每个Sink的downstream属性来保存下一个阶段需要执行的操作，第一个封装的Sink的downstream引用的是结束操作，直到所有中间操作封装完成后，返回一个Sink套娃</p>
</li>
<li><p>对Sink套娃从第一个开始，执行<code>begin</code>方法做好数据准备</p>
</li>
<li>之后通过<code>accept</code>方法对元素进行处理，中间操作会不断调用该方法</li>
<li>最后<code>end</code>方法告知Sink所有操作执行完毕</li>
</ol>
</blockquote>
</li>
<li><p>使用stream进行不同集合类型间的转化和直接写有什么区别</p>
<blockquote>
<p>主要区别在于<strong>代码风格</strong>、<strong>可读性</strong>、<strong>灵活性</strong>和<strong>性能</strong></p>
</blockquote>
</li>
<li><p>线程可见性的问题，JMM</p>
</li>
<li><p>联系到硬件上的存储结构，寄存器、Cache、内存</p>
</li>
<li><p>CPU读内存数据的流程</p>
</li>
<li><p>手撕：两数相加II</p>
</li>
</ol>
<h2 id="3-21-蚂蚁-国际-一面"><a href="#3-21-蚂蚁-国际-一面" class="headerlink" title="3.21-蚂蚁-国际-一面"></a>3.21-蚂蚁-国际-一面</h2><ol>
<li><p>用英语介绍项目、自我介绍</p>
</li>
<li><p>介绍一下在学校中最有成就感的事情</p>
</li>
<li><p>拷打项目</p>
<ol>
<li>真实上线的话，目前的秒杀实现能支持吗</li>
<li>Redis出现故障怎么办</li>
<li>缓存和数据库的数据一致性如何保证</li>
<li>库存扣减时，数据库出现故障怎么办</li>
</ol>
</li>
<li><p>线程的同步方式</p>
</li>
<li><p>Java实现多线程的方式，你最常用哪种，为什么</p>
</li>
<li><p>线程池如何设置线程数</p>
</li>
<li><p>索引的作用，优缺点</p>
</li>
<li><p>索引要依据什么去加，保证索引是有效的</p>
</li>
<li><p>数据库的乐观锁和悲观锁是什么</p>
</li>
<li><p>如果有多个连接同时对MySQL中的一条数据做更新操作，如何使用悲观锁的方式保证安全</p>
</li>
<li><p>一锁二判三更新</p>
<blockquote>
<p><strong>一锁</strong>：在操作数据之前，先锁定资源（例如通过分布式锁或数据库行锁）。</p>
<p><strong>二判</strong>：判断当前数据是否符合预期条件（例如版本号、状态等）。</p>
<p><strong>三更新</strong>：如果条件满足，则执行更新操作；否则放弃或重试。</p>
</blockquote>
</li>
<li><p>重写和重载</p>
</li>
<li><p>动态代理的机制是什么样的</p>
</li>
<li><p>Java类的加载过程</p>
</li>
<li><p>了解过分库分表吗</p>
</li>
<li><p>了解过分布式事务吗</p>
</li>
<li><p>有维护过线上的程序吗，如果程序挂掉了如何排查</p>
</li>
<li><p>场景题：设计一个登陆系统</p>
<ol>
<li>加密相关的问题，MD5不安全</li>
<li>如何防止机器模拟登录（人机验证，IP拦截）</li>
</ol>
</li>
<li><p>场景题：设计一个数据预热系统，支持各类数据，数据量比较大</p>
</li>
</ol>
<h2 id="3-21-携程-一面"><a href="#3-21-携程-一面" class="headerlink" title="3.21-携程-一面"></a>3.21-携程-一面</h2><ol>
<li><p>拷打项目</p>
<ol>
<li>Redis使用场景</li>
<li>如何使用RabbitMQ异步发放</li>
</ol>
</li>
<li><p>Redis常见的数据类型</p>
</li>
<li><p>zset可以做哪些功能</p>
</li>
<li><p>Redis为什么快</p>
</li>
<li><p>Redis分布式锁怎么实现，锁的过期时间怎么设置</p>
<blockquote>
<p>setnx 不支持设置过期时间，如果分成两个命令不支持原子性</p>
<p>使用set是原子性的 <code>set key value [EX seconds] [PX milliseconds] [NX|XX]</code></p>
</blockquote>
</li>
<li><p>Redission了解吗</p>
<blockquote>
<p>分布式锁可以直接用Redission的RLock，不显式声明过期时间会自动续期，默认过期时间30s，每 过期时间/3 看门狗执行一次续期</p>
</blockquote>
</li>
<li><p>MySQL索引为什么查询效率快</p>
</li>
<li><p>MySQL三种日志的作用</p>
</li>
<li><p>数据库两张表关联查询，时间很慢可能是哪些原因</p>
<blockquote>
<p>索引失效：隐式类型转换、编码不同</p>
</blockquote>
</li>
<li><p>线程池哪些参数，如何设置</p>
</li>
<li><p>Spring Bean的生命周期</p>
</li>
<li><p>JVM的内存模型</p>
</li>
<li><p>哪些区域可能发生内存溢出</p>
</li>
<li><p>出现内存溢出怎么定义问题</p>
</li>
<li><p>什么情况会导致Full GC</p>
</li>
<li><p>突然出现多次Full GC，同时老年代空间很充足，可能是什么原因</p>
</li>
<li><p>Dubbo了解过吗</p>
</li>
<li><p>ThreadLocal实现原理</p>
</li>
<li><p>项目中用ThreadLocal封装全局上下文如何避免内存泄漏</p>
</li>
<li><p>覆盖索引和回表查询的区别</p>
</li>
<li><p>volatile的作用</p>
</li>
<li><p>基于单例模式谈谈volatile</p>
</li>
<li><p>ArrayList和LinkedList底层实现，适用场景</p>
</li>
<li><p>ConcurrentHashMap底层实现</p>
</li>
<li><p>synchronized和ReentrantLock</p>
</li>
<li><p>幂等性了解吗，怎么实现接口的幂等性</p>
</li>
<li><p>RPC接口超时时间怎么设置的</p>
</li>
<li><p>websocket</p>
</li>
<li><p>设计模式了解哪些，工厂模式一般可以解决什么问题</p>
</li>
</ol>
<h2 id="3-24-腾讯-PCG-QQ-一面"><a href="#3-24-腾讯-PCG-QQ-一面" class="headerlink" title="3.24-腾讯-PCG-QQ-一面"></a>3.24-腾讯-PCG-QQ-一面</h2><ol>
<li><p>拷打实习</p>
<ol>
<li>什么是SSE</li>
<li>限流</li>
</ol>
</li>
<li><p>手撕：合并两个有序列表（空间复杂度O(1)）</p>
</li>
<li><p>手撕：LRU</p>
</li>
<li><p>拷打项目</p>
<ol>
<li><p>分段锁</p>
</li>
<li><p>库存的最终一致性怎么做的</p>
</li>
<li><p>这里有没有必要使用延迟队列</p>
</li>
<li><p>RabbitMQ怎么处理消息丢失、消费失败、消费重复</p>
</li>
<li><p>如何保证幂等性</p>
<blockquote>
<ol>
<li>数据库唯一索引实现幂等性</li>
<li>防重表机制，与唯一索引机制是相同的原理</li>
<li>数据库乐观锁实现幂等性（版本号）</li>
<li>悲观锁实现幂等性</li>
<li>防重Token令牌实现幂等</li>
<li>分布式锁</li>
<li>状态机</li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p>访问一个网站的过程</p>
</li>
<li><p>HTTPS的步骤</p>
</li>
<li><p>TCP在握手阶段如何管理客户端的连接</p>
</li>
<li><p>用户态和内核态区别</p>
</li>
<li><p>什么时候会发生切换</p>
<blockquote>
<p><strong>系统调用（Trap）</strong>：用户态进程 <strong>主动</strong> 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。</p>
<p><strong>中断（Interrupt）</strong>：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p><strong>异常（Exception）</strong>：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</blockquote>
</li>
<li><p>fork()调用，子进程会拷贝哪些资源，不拷贝哪些</p>
<blockquote>
<p>会拷贝的资源</p>
<ol>
<li><strong>进程地址空间</strong>：子进程会得到父进程地址空间的一个副本，这涵盖了代码段、数据段、堆和栈。不过，采用了写时复制（Copy-on-Write, COW）技术，也就是在父进程或子进程对内存进行写入操作之前，父子进程实际上共享同一块物理内存，仅在发生写入操作时才会复制内存页。</li>
<li><strong>文件描述符</strong>：子进程会复制父进程的文件描述符表。这意味着父子进程可以访问相同的文件、管道和网络套接字等。</li>
<li><strong>信号处理函数</strong>：子进程会继承父进程的信号处理函数设置。不过，子进程中的信号掩码（被阻塞的信号集合）会被清空。</li>
<li><strong>环境变量</strong>：子进程会复制父进程的环境变量，这使得子进程能够拥有和父进程相同的环境配置。</li>
<li><strong>进程属性</strong>：子进程会继承父进程的一些属性，像用户 ID、组 ID、工作目录、根目录等。</li>
</ol>
<p>不会拷贝的资源</p>
<ol>
<li><strong>进程 ID</strong>：子进程会有一个全新的、唯一的进程 ID（PID），和父进程的 PID 不同。</li>
<li><strong>父进程 ID</strong>：子进程的父进程 ID（PPID）会被设定为创建它的父进程的 PID。</li>
<li><strong>进程时间</strong>：子进程会有自己独立的 CPU 时间统计，和父进程的时间统计无关。</li>
<li><strong>挂起的信号</strong>：子进程不会继承父进程挂起的信号。</li>
<li><strong>锁</strong>：父进程持有的文件锁、记录锁等不会被子进程继承。</li>
</ol>
</blockquote>
</li>
<li><p>父进程kill掉，对子进程有什么影响</p>
<blockquote>
<p><strong>孤儿进程</strong>：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源</p>
</blockquote>
</li>
<li><p>向HashMap添加元素过程</p>
</li>
<li><p>假如key是User对象，这个对象需要做什么特殊处理吗</p>
<blockquote>
<p>重写hashcode、equals</p>
</blockquote>
</li>
<li><p>java加锁的形式有几种</p>
</li>
<li><p>synchronized可以用在哪些位置，粒度是什么样的</p>
<blockquote>
<p><strong>修饰实例方法</strong> （锁当前对象实例）</p>
<p><strong>修饰静态方法</strong> （锁当前类）</p>
<p><strong>修饰代码块</strong> （锁指定对象/类）</p>
</blockquote>
</li>
<li><p>volatile的作用</p>
</li>
<li><p>可见性是怎么实现的</p>
<blockquote>
<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>内存屏障，属于JVM层面，JVM用内存屏障的概念统一描述所有平台的可见性保证</p>
<p>具体到x86架构下，对 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令，lock 前缀的指令在多核处理器下会引发两件事情:</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。（缓存一致性协议，如MESI）</li>
</ul>
<p>lock前缀指令本身会隐含完整的内存屏障效果</p>
</blockquote>
</li>
<li><p>类加载的过程</p>
</li>
<li><p>JVM的GC算法</p>
</li>
<li><p>GC Root有哪些</p>
<blockquote>
<p>线程Thread对象，引用线程栈桢中的方法参数、局部变量等</p>
<p>系统类加载器加载的 <code>java.lang.Class</code> 对象，引用类中的静态变量</p>
<p>监视器对象，用来保存同步锁synchronized关键字持有的对象</p>
<p>本地方法调用时使用的全局对象</p>
</blockquote>
</li>
<li><p>mysql索引从数据类型看有哪些</p>
</li>
<li><p>B+树和B树的区别</p>
</li>
<li><p>聚簇索引和非聚簇索引的区别</p>
</li>
<li><p>数据库发生慢sql如何分析</p>
</li>
<li><p>索引失效的原因</p>
</li>
<li><p>mysql的事务隔离级别，分别解决了什么问题</p>
</li>
<li><p>不可重复读和幻读具体是什么</p>
</li>
<li><p>mysql的三种日志</p>
</li>
<li><p>redo log具体是怎么运作的</p>
</li>
<li><p>崩溃恢复是怎么实现的，如何判断是否要做恢复</p>
<blockquote>
<ol>
<li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li>
<li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整（这里是通过redolog和binlog共有的字段XID进行查找）：<ol>
<li>如果是，则提交事务</li>
<li>否则，回滚事务。</li>
</ol>
</li>
</ol>
</blockquote>
</li>
<li><p>两阶段提交</p>
</li>
<li><p>Redis中的数据类型、数据结构</p>
</li>
<li><p>Redis的数据持久化</p>
</li>
<li><p>Redis的集群模式</p>
</li>
<li><p>Redis哨兵机制</p>
</li>
<li><p>Redis内存淘汰</p>
</li>
</ol>
<h2 id="3-25-腾讯-PCG-QQ-二面"><a href="#3-25-腾讯-PCG-QQ-二面" class="headerlink" title="3.25-腾讯-PCG-QQ-二面"></a>3.25-腾讯-PCG-QQ-二面</h2><ol>
<li><p>手撕：被三整除求最大和</p>
</li>
<li><p>服务上线后达到千万日活，为了保证高可用，有哪些关键点要考虑</p>
<blockquote>
<p><strong>分布式与微服务化</strong></p>
<ul>
<li><strong>服务拆分</strong>：将单体服务拆解为微服务，避免单点故障扩散（如用户服务、订单服务独立部署）。</li>
<li><strong>无状态设计</strong>：服务无状态化（如Session存储到Redis），便于水平扩展和故障转移。</li>
<li><strong>冗余部署</strong>：多机房/多可用区（AZ）部署，利用负载均衡（如Nginx、AWS ALB）实现流量分发。</li>
</ul>
<p><strong>容错与降级</strong></p>
<ul>
<li><strong>熔断机制</strong>：通过Hystrix、Sentinel等工具在依赖服务故障时快速失败，避免雪崩。</li>
<li><strong>降级策略</strong>：非核心功能降级（如关闭推荐算法，返回静态兜底数据）。</li>
<li><strong>限流保护</strong>：针对API配置QPS限流（如Redis+Lua、Guava RateLimiter）。</li>
</ul>
<p><strong>数据一致性</strong></p>
<ul>
<li><strong>最终一致性</strong>：通过消息队列（Kafka、RocketMQ）实现异步解耦。</li>
<li><strong>分库分表</strong>：数据库按业务分片（如ShardingSphere），避免单库瓶颈。</li>
</ul>
<p><strong>数据库</strong></p>
<ul>
<li><strong>主从复制</strong>：MySQL主从同步+读写分离，从库可读（如ProxySQL路由）。</li>
<li><strong>集群化</strong>：MongoDB/Cassandra多节点分片，ETCD/Raft协议选主。</li>
<li><strong>备份与恢复</strong>：定期全量备份+Binlog增量备份，演练恢复流程。</li>
</ul>
<p><strong>缓存</strong></p>
<ul>
<li><strong>多级缓存</strong>：本地缓存（Caffeine）+分布式缓存（Redis Cluster）。</li>
<li><strong>穿透保护</strong>：缓存空值或布隆过滤器（Bloom Filter）防击穿。</li>
</ul>
<p><strong>全链路监控</strong></p>
<ul>
<li><strong>指标采集</strong>：Prometheus+Grafana监控QPS、延迟、错误率。</li>
<li><strong>日志分析</strong>：ELK或ClickHouse日志中心，快速定位问题。</li>
<li><strong>链路追踪</strong>：Jaeger/SkyWalking跟踪请求链路，识别瓶颈。</li>
</ul>
</blockquote>
</li>
<li><p>服务CPU突然飙高，排查思路是怎么样的</p>
<blockquote>
<p><strong>1. 快速确认现象</strong></p>
<ul>
<li><strong>检查监控系统</strong>：确认CPU飙高的时间点、持续时间、是否伴随其他指标异常（如内存、磁盘IO、网络流量）。</li>
<li><strong>范围确认</strong>：是单台机器还是集群整体？是某个服务还是所有服务？</li>
</ul>
<p><strong>2. 定位高CPU进程/线程</strong></p>
<ul>
<li><p><strong>找到占用CPU最高的进程</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">top -c                <span class="hljs-comment"># 实时进程监控，按CPU排序（显示完整命令）</span><br>htop                  <span class="hljs-comment"># 更友好的交互式工具（需安装）</span><br>ps -aux --<span class="hljs-built_in">sort</span>=-%cpu | <span class="hljs-built_in">head</span> -n 10  <span class="hljs-comment"># 静态快照</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>分析进程内的线程</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">top -H -p &lt;PID&gt;       <span class="hljs-comment"># 查看指定进程的线程CPU占用</span><br>ps -T -p &lt;PID&gt;        <span class="hljs-comment"># 查看线程详情</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3. 深入分析原因（根据进程类型）</strong></p>
<p><strong>java</strong></p>
<ul>
<li><p><strong>获取线程堆栈</strong>：<code>jstack &lt;PID&gt; &gt; jstack.log  # 输出线程栈</code></p>
</li>
<li><p><strong>常见问题</strong>：</p>
<ul>
<li><strong>死循环</strong>：线程卡在某个方法（如while(true)）。</li>
<li><strong>锁竞争</strong>：大量线程阻塞在<code>BLOCKED</code>状态（如<code>synchronized</code>或<code>ReentrantLock</code>）。</li>
<li><strong>GC问题</strong>：频繁Full GC导致CPU高（需结合GC日志分析）。</li>
</ul>
</li>
<li><p><strong>辅助工具</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstat -gcutil &lt;PID&gt; 1000 5  <span class="hljs-comment"># 查看GC情况（1秒间隔，输出5次）</span><br>arthas async-profiler       <span class="hljs-comment"># 火焰图分析（需安装）</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>数据库</strong></p>
<ul>
<li><strong>检查慢查询和锁</strong></li>
</ul>
<p><strong>4. 关联性分析</strong></p>
<ul>
<li><strong>时间关联</strong>：CPU飙高的时间点是否与以下事件重合？<ul>
<li>代码发布、配置变更、流量突增（如活动开始）、定时任务触发。</li>
</ul>
</li>
<li><strong>日志检索</strong>：检查应用日志（如Error日志）、中间件日志（Nginx、Kafka）。</li>
</ul>
<p><strong>5. 临时缓解措施</strong></p>
<ul>
<li><strong>限流降级</strong>：通过网关或服务网格（如Istio）限制流量。</li>
<li><strong>重启策略</strong>：优先重启问题实例（避免雪崩），但需保留现场：</li>
</ul>
<p><strong>6. 根因定位与优化</strong></p>
<p><strong>高频原因</strong></p>
<ol>
<li><strong>代码缺陷</strong>：<ul>
<li>死循环、正则表达式灾难性回溯、算法复杂度突变。</li>
</ul>
</li>
<li><strong>资源竞争</strong>：<ul>
<li>线程池配置不合理（如<code>Executors.newCachedThreadPool()</code>无限制创建线程）。</li>
<li>数据库连接池耗尽（如HikariCP等待连接）。</li>
</ul>
</li>
<li><strong>外部依赖</strong>：<ul>
<li>下游服务超时未设置，导致线程阻塞。</li>
<li>缓存击穿（如Redis失效后大量请求直达数据库）。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>线上突然出现大量状态码500错误，如何定位问题</p>
<blockquote>
<p><strong>1. 紧急止血</strong>：流量降级、回滚策略、扩容备用节点</p>
<p><strong>2. 快速确认问题范围</strong></p>
<ul>
<li><strong>检查监控指标</strong><ul>
<li><strong>错误类型分布</strong>：<ul>
<li>确认500错误是统一错误（如全部<code>NullPointerException</code>）还是混合错误。</li>
<li>检查错误码细分（如502/503/504可能指向不同问题）。</li>
</ul>
</li>
<li><strong>关联指标</strong>：<ul>
<li><strong>流量变化</strong>：是否伴随请求量突增（DDoS或真实流量？）。</li>
<li><strong>资源水位</strong>：CPU、内存、磁盘IO、网络带宽是否异常。</li>
<li><strong>依赖服务</strong>：数据库、缓存、第三方API是否正常。</li>
</ul>
</li>
</ul>
</li>
<li><strong>日志快速检索</strong></li>
</ul>
<p><strong>3. 根因定位（分场景排查）</strong></p>
<ul>
<li><strong>代码缺陷</strong>：同一接口集中报错，日志中出现明确异常栈（如<code>NullPointerException</code>）</li>
<li><strong>依赖服务故障</strong>：错误日志中出现<code>ConnectionTimeout</code>、<code>SocketException</code>等网络相关错误。</li>
<li><strong>资源耗尽</strong>：监控显示CPU 100%、内存OOM、磁盘写满。</li>
<li><strong>数据问题</strong>：数据库查询超时、主从延迟、死锁。</li>
</ul>
<p><strong>4. 深度分析工具</strong></p>
<ul>
<li><strong>日志聚合分析</strong>：使用ELK或Grafana Loki对错误日志聚类</li>
<li><strong>链路追踪</strong>：通过Jaeger/SkyWalking查看异常请求的完整链路</li>
<li><strong>流量回放</strong>：如果是特定请求触发，使用工具（如GoReplay）捕获流量在测试环境复现</li>
</ul>
<p><strong>5. 修复与验证</strong></p>
<ul>
<li><p><strong>热修复</strong>：</p>
<ul>
<li>紧急修复后通过Arthas或JMX动态加载类（仅限简单逻辑）。</li>
</ul>
</li>
<li><p><strong>验证手段</strong>：</p>
<ul>
<li><p>灰度发布：先修复1%的节点观察效果。</p>
</li>
<li><p>压测验证：用JMeter模拟故障场景。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>设计一个通用的缓存组件，要考虑哪些维度</p>
<blockquote>
<p><strong>1. 缓存层级设计</strong></p>
<p>| 层级           | 实现方式             | 特点                         | 适用场景                   |<br>| :——————- | :—————————- | :—————————————- | :————————————- |<br>| <strong>本地缓存</strong>   | Caffeine/Guava Cache | 零网络开销，但无法跨进程共享 | 高频读、数据量小的场景     |<br>| <strong>分布式缓存</strong> | Redis/Memcached      | 跨进程共享，容量大           | 多实例共享数据的场景       |<br>| <strong>多级缓存</strong>   | 本地+分布式组合      | 兼顾性能和一致性             | 高并发读场景（如商品详情） |</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>支持自动分层（如优先读本地，未命中再查分布式缓存）</li>
<li>本地缓存需有容量淘汰策略（如LFU/LRU）</li>
</ul>
<p><strong>2. 缓存读写策略</strong></p>
<p>| 策略              | 实现方式                         | 优缺点                   |<br>| :———————— | :———————————————- | :———————————- |<br>| <strong>Cache-Aside</strong>   | 应用层主动读写缓存               | 灵活，但可能缓存不一致   |<br>| <strong>Read-Through</strong>  | 缓存组件自动读DB（如JCache API） | 代码简洁，但实现复杂     |<br>| <strong>Write-Through</strong> | 写DB时同步更新缓存               | 强一致，但写入延迟高     |<br>| <strong>Write-Behind</strong>  | 异步批量更新DB（如Kafka+消费者） | 高性能，但有数据丢失风险 |</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>默认实现Cache-Aside模式</li>
<li>通过接口抽象支持其他策略的可插拔</li>
</ul>
<p><strong>3. 缓存过期与淘汰</strong></p>
<p>| 机制         | 实现方式                               | 特点               |<br>| :—————- | :——————————————————- | :————————- |<br>| <strong>TTL过期</strong>  | 设置固定过期时间（Redis EXPIRE）       | 简单但可能缓存雪崩 |<br>| <strong>动态过期</strong> | 根据热点动态调整过期时间               | 提高缓存利用率     |<br>| <strong>淘汰策略</strong> | LRU/LFU/FIFO（Redis maxmemory-policy） | 避免内存溢出       |</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>支持全局默认TTL和单个Key自定义TTL</li>
<li>添加随机抖动防止同一时间大批量Key失效（如<code>基础TTL + random(0, 300s)</code>）</li>
</ul>
<p><strong>4. 缓存一致性</strong></p>
<p>| 方案              | 实现方式                                | 时延   | 复杂度 |<br>| :———————— | :——————————————————— | :——- | :——- |<br>| <strong>失效通知</strong>      | 数据库Binlog监听（如Canal+MQ）          | 秒级   | 高     |<br>| <strong>延迟双删</strong>      | 1. 删缓存 → 2. 更新DB → 3. 延迟再删缓存 | 毫秒级 | 中     |<br>| <strong>版本号/时间戳</strong> | 缓存Value带版本号，读写时校验           | 即时   | 低     |</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>关键业务使用版本号校验（如商品库存）</li>
<li>普通业务可用延迟双删（平衡性能与一致性）</li>
</ul>
<p><strong>5. 高可用设计</strong></p>
<p>| 风险点       | 解决方案                                   |<br>| :—————- | :————————————————————- |<br>| <strong>缓存穿透</strong> | 布隆过滤器+空值缓存（设置短TTL）           |<br>| <strong>缓存雪崩</strong> | 多级缓存+过期时间随机化                    |<br>| <strong>缓存击穿</strong> | 分布式锁（Redis SETNX）或热点Key永不过期   |<br>| <strong>集群故障</strong> | Redis Cluster分片+哨兵机制/Proxy层自动切换 |</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>内置熔断机制（如错误率超阈值直连DB）</li>
<li>支持降级开关（可动态关闭缓存层）</li>
</ul>
<p><strong>6. 监控与治理</strong></p>
<p>| 维度     | 监控指标                   | 工具链示例         |<br>| :———- | :————————————- | :————————- |<br>| <strong>性能</strong> | 命中率、平均耗时、QPS      | Prometheus+Grafana |<br>| <strong>资源</strong> | 内存使用、连接数、网络流量 | Redis INFO命令     |<br>| <strong>业务</strong> | 热点Key识别、大Value预警   | 自定义Agent+ELK    |</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>暴露<code>/cache/metrics</code>端点输出监控数据</li>
<li>支持命令行/API动态查询缓存内容（如<code>GET /cache/key/&#123;key&#125;</code>）</li>
</ul>
<p><strong>7. 高级功能扩展</strong></p>
<p>| 功能           | 实现思路                                      |<br>| :——————- | :—————————————————————— |<br>| <strong>热点探测</strong>   | 滑动窗口统计Key访问频次，自动升级为本地缓存   |<br>| <strong>多租户隔离</strong> | 通过Namespace前缀分离不同业务线缓存           |<br>| <strong>缓存预热</strong>   | 启动时加载预设Key，或基于历史访问模式预测加载 |<br>| <strong>透明压缩</strong>   | 对大Value自动Snappy压缩（需权衡CPU/带宽）     |</p>
</blockquote>
</li>
<li><p>高可用有哪些考虑维度</p>
</li>
<li><p>面对瞬时流量高峰场景，系统应该如何设计</p>
<blockquote>
<p><strong>架构设计原则</strong></p>
<ul>
<li><p><strong>无状态化</strong>: 服务去Session化，用户状态存储到Redis/DB，便于水平扩展</p>
</li>
<li><p><strong>异步解耦</strong>: 通过消息队列（Kafka/RocketMQ）削峰填谷，同步调用改为异步任务（如订单创建）</p>
</li>
<li><p><strong>冗余设计</strong>: 多可用区（AZ）部署+跨地域容灾，避免单点故障</p>
</li>
<li><p><strong>极限弹性</strong>: 云原生架构（K8s+HPA）实现秒级扩容，支持0→1000节点的快速伸缩</p>
</li>
</ul>
<p><strong>流量管控体系</strong></p>
<ul>
<li><p><strong>前端</strong>: 静态资源加速、请求合并与延迟加载、客户端限流</p>
</li>
<li><p><strong>接入层</strong>:</p>
<p>| 技术方案            | 作用                            | 实现示例                                           |<br>| :————————— | :——————————————— | :————————————————————————- |<br>| <strong>负载均衡</strong>        | 均匀分发流量到后端集群          | Nginx加权轮询/一致性哈希，AWS ALB跨AZ流量分配      |<br>| <strong>DNS轮询+Anycast</strong> | 分散地理区域流量                | Cloudflare全球智能路由                             |<br>| <strong>Web防火墙</strong>       | 拦截恶意请求（CC攻击、SQL注入） | AWS WAF规则：IP黑名单、速率限制（每个IP≤100次/秒） |<br>| <strong>四层/七层限流</strong>   | 控制入口流量                    | Nginx限流模块：<code>limit_req_zone</code>；Envoy全局限流     |</p>
</li>
<li><p><strong>后端</strong>:</p>
<ul>
<li><strong>缓存优化</strong>：多级缓存、预热热点key</li>
<li><strong>数据库保护</strong>：读写分离、分库分表</li>
<li><strong>降级熔断</strong></li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>拷打项目</p>
<ol>
<li>Spring框架核心点有哪些</li>
<li>有做什么优化吗</li>
</ol>
</li>
<li><p>使用AI上有什么心得</p>
</li>
<li><p>总结一下自己的优势，体现在哪些方面</p>
</li>
</ol>
<h2 id="3-25-美团-核心本地商业-二面"><a href="#3-25-美团-核心本地商业-二面" class="headerlink" title="3.25-美团-核心本地商业-二面"></a>3.25-美团-核心本地商业-二面</h2><ol>
<li><p>拷打项目</p>
<ol>
<li><p>秒杀场景针对突增流量是怎么设计的</p>
<blockquote>
<ol>
<li>前端优化</li>
</ol>
<ul>
<li><strong>静态化页面</strong>：提前生成静态页面，减少服务端压力</li>
<li><strong>CDN加速</strong>：分发静态资源</li>
<li><strong>本地缓存</strong>：商品详情等不变数据缓存在客户端</li>
<li><strong>按钮防重复点击</strong>：点击后立即禁用按钮</li>
</ul>
<ol>
<li>接入层设计</li>
</ol>
<ul>
<li><strong>负载均衡</strong>：多台Nginx服务器分流</li>
<li><strong>限流措施</strong>：<ul>
<li>令牌桶/漏桶算法控制请求速率</li>
<li>IP/用户ID级别限流</li>
</ul>
</li>
<li><strong>恶意请求过滤</strong>：识别并拦截刷单行为</li>
</ul>
<ol>
<li>服务层设计</li>
</ol>
<ul>
<li><strong>缓存策略</strong>：多级缓存（本地缓存+分布式缓存）、预加载库存数据到缓存</li>
<li><strong>库存管理</strong>：采用Redis原子操作扣减库存、分段库存减少锁竞争</li>
<li><strong>异步下单</strong>：请求进入消息队列、后台服务按处理能力消费</li>
</ul>
<ol>
<li>数据层设计</li>
</ol>
<ul>
<li><strong>数据库保护</strong>：读写分离、分库分表、热点数据单独处理</li>
<li><strong>最终一致性</strong>：先扣缓存库存，再异步同步到数据库、采用柔性事务</li>
</ul>
</blockquote>
</li>
<li><p>极端情况下流量很多怎么做</p>
<blockquote>
<p><strong>服务降级</strong>：</p>
<ul>
<li>关闭非核心功能（如评价、推荐）</li>
<li>简化业务流程</li>
</ul>
<p><strong>熔断机制</strong>：</p>
<ul>
<li>当系统负载达到阈值时，拒绝部分请求</li>
<li>返回友好提示而非错误页面</li>
</ul>
<p><strong>弹性扩容</strong>：</p>
<ul>
<li>云环境下自动扩容计算资源</li>
<li>预先准备备用资源池</li>
</ul>
<p><strong>流量调度</strong>：</p>
<ul>
<li>将部分用户引导到备用系统</li>
<li>错峰处理不同地区请求</li>
</ul>
<p><strong>预案准备</strong>：</p>
<ul>
<li>提前准备多个应对方案</li>
<li>建立快速响应机制</li>
</ul>
</blockquote>
</li>
<li><p>假如QPS有100w，但是库存只有10w，除了分段库存还能怎么优化</p>
<blockquote>
<p>答：只选择部分请求通过，限流算法</p>
</blockquote>
</li>
<li><p>你了解的限流组件有哪些，底层的实现是怎么样的</p>
<blockquote>
<p>RateLimiter：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60979444">https://zhuanlan.zhihu.com/p/60979444</a></p>
<p>Sentinel：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuzhenzhao/p/11453649.html">https://www.cnblogs.com/wuzhenzhao/p/11453649.html</a></p>
</blockquote>
</li>
</ol>
</li>
<li><p>有没有遇到过线上的问题，比如某个时间段耗时很高</p>
</li>
<li><p>频繁full gc，如何定位问题，从哪些方面考虑</p>
<blockquote>
<p>答：流量是否是高峰、内存泄漏、参数配置</p>
</blockquote>
</li>
<li><p>什么情况会出现full gc，什么时候对象会进入到老年代</p>
</li>
<li><p>ZGC有了解吗</p>
</li>
<li><p>设计数据结构：容器可以实时显示已放入数字的中位数，时间复杂度和空间复杂度</p>
<blockquote>
<p>最大堆+最小堆</p>
<p>时间复杂度：O(logn)</p>
<p>空间复杂度：O(n)</p>
</blockquote>
</li>
<li><p>为什么说快速排序是最快的排序算法，而不是堆排</p>
<blockquote>
<p>常数因子较小，分区操作简单高效，仅需比较和交换操作，且实际代码的指令数较少。</p>
<p>分区操作通常访问连续的内存区域（如数组首尾指针向中间移动），<strong>缓存命中率高</strong>。</p>
</blockquote>
</li>
<li><p>设计数据结构：存储n个英文单词，当给出m个字母时，返回由这些字母组成的单词，时间复杂度和空间复杂度</p>
<blockquote>
<ol>
<li><p>全排列 + 前缀树，时间复杂度</p>
</li>
<li><p><code>Map&lt;String, List&lt;String&gt;&gt;</code>，O(m)</p>
</li>
</ol>
</blockquote>
</li>
<li><p>最左匹配原则，底层是什么样的</p>
</li>
<li><p>假如你是一个图书管理员，图书馆进了10w本书，需要你把这些书的信息录入到图书管理系统，你要怎么处理</p>
<blockquote>
<p>提高并发：找人</p>
<p>使用OCR提取信息自动录入系统，但是需要训练模型</p>
<p>通过获取网站上的信息（例如电商网站）进行录入</p>
</blockquote>
</li>
<li><p>最近有看过什么技术博客吗</p>
</li>
<li><p>arthas了解吗</p>
</li>
<li><p>平时周末会做些什么</p>
</li>
<li><p>反问：部门是信息安全部-智能决策引擎，做风险识别</p>
</li>
</ol>
<h2 id="3-27-蚂蚁-国际-二面"><a href="#3-27-蚂蚁-国际-二面" class="headerlink" title="3.27-蚂蚁-国际-二面"></a>3.27-蚂蚁-国际-二面</h2><ol>
<li><p>拷打项目</p>
</li>
<li><p>实习编码过程中遇到了哪些技术问题，如何解决的</p>
</li>
<li><p>线上环境如何确保代码是没有异常的，有异常如何处理</p>
<blockquote>
<p><strong>预防措施</strong>：严格测试、代码审查、预发布环境、渐进式发布</p>
<p><strong>异常监控与处理</strong></p>
<ol>
<li>实时监控系统<ul>
<li>应用性能监控(APM)工具(如New Relic, Datadog)</li>
<li>错误日志集中收集(如ELK, Sentry)</li>
<li>关键指标告警(错误率、响应时间等)</li>
</ul>
</li>
<li>优雅降级策略<ul>
<li>非核心功能故障不影响主流程</li>
<li>缓存兜底数据</li>
<li>默认值处理</li>
</ul>
</li>
<li>异常处理机制<ul>
<li>全局异常捕获</li>
<li>事务回滚机制</li>
<li>请求重试策略(对可重试异常)</li>
<li>熔断机制防止级联故障</li>
</ul>
</li>
</ol>
<p><strong>异常发生后的处理流程</strong></p>
<ol>
<li>快速响应<ul>
<li>告警通知到值班人员</li>
<li>根据预案初步处理</li>
<li>评估影响范围</li>
</ul>
</li>
<li>问题诊断<ul>
<li>收集错误日志、堆栈跟踪</li>
<li>分析监控数据</li>
<li>复现问题场景</li>
</ul>
</li>
<li>恢复措施<ul>
<li>热修复或回滚版本</li>
<li>扩容或重启服务</li>
<li>数据修复(如需要)</li>
</ul>
</li>
<li>事后复盘</li>
</ol>
</blockquote>
</li>
<li><p>需要设计一个监控平台，你会采购现有的还是自主设计，如果需要你去调研，哪些特征会让你选择它</p>
<blockquote>
<p>采购or自主设计</p>
<ul>
<li><strong>选择采购现有方案的情况：</strong>团队规模小，监控非核心竞争力、缺乏专业的可观测性工程团队、预算充足但开发资源有限、需要快速上线，时间紧迫</li>
<li><strong>选择自主开发的情况：</strong>监控是业务核心能力(如云服务提供商)、现有方案无法满足特殊业务需求、有足够专业团队和长期投入计划</li>
</ul>
<p>核心能力维度</p>
<ol>
<li><strong>数据采集能力</strong><ul>
<li>支持的协议和格式、无侵入式采集能力、多语言/多框架支持、自定义指标和日志支持</li>
</ul>
</li>
<li><strong>存储与查询</strong><ul>
<li>时间序列数据库性能、日志检索效率(全文搜索、模糊查询)、数据保留策略和压缩能力、分布式存储扩展性</li>
</ul>
</li>
<li><strong>可视化分析</strong><ul>
<li>仪表板定制灵活性、预置行业模板、动态下钻分析能力、多维度数据关联</li>
</ul>
</li>
<li><strong>告警管理</strong><ul>
<li>多通道通知(邮件/SMS/钉钉/企业微信等)、告警抑制和降噪、动态阈值设置、告警依赖关系配置</li>
</ul>
</li>
</ol>
<p>非功能性维度</p>
<ol>
<li><strong>性能指标</strong><ul>
<li>单节点处理能力(EPM - Events Per Minute)、集群扩展方案、查询响应时间(百万级指标查询延迟)</li>
</ul>
</li>
<li><strong>可靠性</strong><ul>
<li>数据持久化保证、多副本机制、灾备恢复方案</li>
</ul>
</li>
<li><strong>安全性</strong><ul>
<li>数据传输加密、细粒度访问控制(RBAC)、审计日志完整性</li>
</ul>
</li>
<li><strong>可观测性成熟度</strong><ul>
<li>Metrics/Logs/Traces三位一体支持、分布式追踪能力、服务拓扑自动发现</li>
</ul>
</li>
</ol>
<p>成本维度</p>
<ol>
<li><strong>定价模型</strong><ul>
<li>按主机/容器/指标量计费、数据保留周期费用、增值功能收费点</li>
</ul>
</li>
<li><strong>TCO比较</strong><ul>
<li>3年总体拥有成本估算、隐性成本(培训、集成开发等)</li>
</ul>
</li>
<li><strong>厂商锁定风险</strong><ul>
<li>数据导出便利性、API开放程度、替代方案迁移成本</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>你在项目过程中有了解大模型相关的内容吗</p>
</li>
<li><p>你是否学习过 Spring 及业界常用的分布式组件</p>
</li>
<li><p>Spring 和 Spring Boot 的核心区别，Spring Boot 提供了哪些新的特征</p>
<blockquote>
<p>自动配置、Starter 依赖、内嵌服务器、Actuator 监控、简化配置、增强的开发工具、简化的测试</p>
</blockquote>
</li>
<li><p>学习 Spring 和 Spring Boot 过程中遇到过哪些复杂的技术问题</p>
</li>
<li><p>分布式缓存了解吗</p>
</li>
<li><p>Redis的关键机制，如何实现缓存，有哪些关键的特征</p>
<blockquote>
<p>高性能、高并发</p>
</blockquote>
</li>
<li><p>为什么Redis要使用单线程</p>
<blockquote>
<p>避免锁竞争和上下文切换</p>
<p>内存操作很快，CPU不是瓶颈</p>
<p>I/O多路复用</p>
</blockquote>
</li>
<li><p>Redis持久化机制</p>
</li>
<li><p>Redis持久化有哪些缺陷</p>
<blockquote>
<p>RDB</p>
<ul>
<li>数据安全性低，RDB是间隔一段时间进行持久化，若期间redis发生故障，可能发生数据丢失。</li>
<li>fork进程的时候，会占用一定的内存空间。</li>
</ul>
<p>AOF</p>
<ul>
<li>AOF的持久化文件比RDB大，恢复速度慢</li>
<li>写入性能开销</li>
</ul>
</blockquote>
</li>
<li><p>如何设计支付的幂等性机制</p>
</li>
<li><p>大促场景下，支付的qps非常高，如何保证支付系统的安全性</p>
<blockquote>
<p>分布式架构 + 水平扩展</p>
<p>MQ削峰填谷 + 限流</p>
<p>缓存优化</p>
</blockquote>
</li>
<li><p>例如对于5000qps，我如何知道应该部署多少台实例支持大促的洪峰</p>
<blockquote>
<p>压测得到单机负载、冗余</p>
</blockquote>
</li>
<li><p>如何预估一个系统的处理能力是怎么样的</p>
<blockquote>
<p>理论计算 → 单机压测 → 依赖验证 → 全链路压测 → 优化迭代。</p>
</blockquote>
</li>
<li><p>了解过mysql的优化机制吗，是否做过mysql的慢优化</p>
</li>
<li><p>有没有经验，哪些类型的sql语句更容易出现慢sql</p>
<blockquote>
<ol>
<li>全表扫描型查询</li>
</ol>
<ul>
<li><strong>无索引或索引失效的查询</strong>：<code>WHERE</code>条件列没有索引或索引未被使用</li>
<li><strong>使用<code>SELECT *</code></strong>：特别是大表查询所有字段</li>
<li><strong>隐式类型转换</strong>：如<code>WHERE varchar_col = 123</code>导致索引失效</li>
</ul>
<ol>
<li>复杂JOIN操作</li>
</ol>
<ul>
<li><strong>多表关联(特别是大表JOIN)</strong>：超过3个表的JOIN容易出问题</li>
<li><strong>笛卡尔积查询</strong>：忘记写JOIN条件或条件不充分</li>
<li><strong>JOIN字段类型不匹配</strong>：导致无法使用索引</li>
</ul>
<ol>
<li>子查询和派生表</li>
</ol>
<ul>
<li><strong>IN/EXISTS子查询</strong>：特别是外层表大而子查询结果集大的情况</li>
<li><strong>FROM子句中的子查询</strong>：MySQL需要先物化派生表</li>
<li><strong>相关子查询</strong>：对每行外部查询执行一次子查询</li>
</ul>
<ol>
<li>排序和分组操作</li>
</ol>
<ul>
<li><strong>无索引的ORDER BY</strong>：特别是大结果集的排序</li>
<li><strong>GROUP BY无索引列</strong>：需要临时表和排序</li>
<li><strong>DISTINCT大结果集</strong>：去重操作消耗资源</li>
</ul>
<ol>
<li>分页查询问题</li>
</ol>
<ul>
<li><strong>大偏移量LIMIT</strong>：如<code>LIMIT 100000, 20</code></li>
<li><strong>错误的分页写法</strong>：未优化COUNT(*)查询</li>
</ul>
<ol>
<li>函数操作列</li>
</ol>
<ul>
<li><strong>对索引列使用函数</strong>：如<code>WHERE DATE(create_time) = &#39;2023-01-01&#39;</code></li>
<li><strong>计算列查询</strong>：如<code>WHERE price*2 &gt; 100</code></li>
</ul>
<ol>
<li>锁相关慢查询</li>
</ol>
<ul>
<li><strong>长时间运行的事务</strong>：持有锁时间过长</li>
<li><strong>锁等待</strong>：被其他事务阻塞</li>
</ul>
<ol>
<li>其他高风险操作</li>
</ol>
<ul>
<li><strong>大表UPDATE/DELETE</strong>：无合适索引的单条操作影响多行</li>
<li><strong>大批量INSERT</strong>：未使用批量插入或LOAD DATA</li>
</ul>
</blockquote>
</li>
<li><p>有哪些典型的慢SQL，哪些写法可能天然就是一个慢SQL</p>
</li>
<li><p>请以你了解的一种RPC框架，解释系统间通讯基于RPC和基于HTTP的异同点是什么</p>
<blockquote>
<p>| 特性           | Dubbo RPC                      | HTTP通信                     |<br>| :——————- | :——————————————- | :—————————————- |<br>| <strong>协议设计</strong>   | 二进制私有协议(默认dubbo协议)  | 文本协议(HTTP/1.1等)         |<br>| <strong>序列化效率</strong> | 高效二进制序列化(hessian2等)   | 文本序列化(JSON/XML)         |<br>| <strong>服务发现</strong>   | 内置服务注册中心(如Zookeeper)  | 通常依赖外部DNS或网关        |<br>| <strong>调用方式</strong>   | 透明化远程调用(像本地方法调用) | 显式的请求构造和解析         |<br>| <strong>性能</strong>       | 更高(节省头部开销，二进制编码) | 相对较低(头部冗余，文本解析) |<br>| <strong>适用场景</strong>   | 内部高性能服务调用             | 对外API或异构系统集成        |</p>
</blockquote>
</li>
<li><p>为什么企业要包装一层使用RPC，而不是直接使用HTTP，有哪些好处</p>
<blockquote>
<p>通信效率提升、序列化优化、透明化远程调用…</p>
</blockquote>
</li>
<li><p>你有使用过哪些RPC</p>
</li>
<li><p>找实习你更关注哪些方面，希望获得哪些东西</p>
</li>
<li><p>除了技术更看重哪些方面</p>
</li>
<li><p>你在个人学习中是如何学习技术的，大概保持什么样的频率</p>
</li>
</ol>
<h2 id="3-28-快手-一面"><a href="#3-28-快手-一面" class="headerlink" title="3.28-快手-一面"></a>3.28-快手-一面</h2><ol>
<li>HashMap底层结构和工作原理</li>
<li>HashMap扩容机制</li>
<li>HashTable和ConcurrentHashMap区别</li>
<li>synchronized修饰普通方法和静态方法的区别</li>
<li>JVM垃圾回收过程</li>
<li>MySQL事务隔离级别</li>
<li>串行化实现原理</li>
<li>MCVV原理</li>
<li>Spring Bean生命周期</li>
<li>Redis内存淘汰机制</li>
<li>手撕：LRU</li>
<li>手撕：编辑距离</li>
</ol>
<h2 id="3-29-阿里云-齐天-三面"><a href="#3-29-阿里云-齐天-三面" class="headerlink" title="3.29-阿里云-齐天-三面"></a>3.29-阿里云-齐天-三面</h2><ol>
<li><p>拷打项目</p>
<ol>
<li>如何保证OCR提取的内容是正确的</li>
<li>滑动窗口</li>
</ol>
</li>
<li><p>Spring AOP怎么实现的</p>
</li>
<li><p>AspectJ怎么实现的，利用了Java什么原理</p>
</li>
<li><p>Spring事务和Mybatis事务管理上的区别</p>
<blockquote>
<ol>
<li>事务管理层次</li>
</ol>
<ul>
<li><strong>Spring事务管理</strong>：<ul>
<li>工作在业务逻辑层(Service层)</li>
<li>提供声明式事务(@Transactional)和编程式事务(TransactionTemplate)</li>
<li>可以管理多种数据访问技术(JDBC、Hibernate、MyBatis等)</li>
</ul>
</li>
<li><strong>MyBatis事务管理</strong>：<ul>
<li>工作在持久层(Dao层)</li>
<li>主要提供编程式事务(SqlSession.commit()/rollback())</li>
<li>仅管理MyBatis自身的数据库操作</li>
</ul>
</li>
</ul>
<ol>
<li>事务控制方式</li>
</ol>
<ul>
<li><strong>Spring事务</strong>：<ul>
<li>通过AOP实现</li>
<li>支持丰富的事务传播行为(PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW等)</li>
<li>支持事务隔离级别配置</li>
<li>支持回滚规则配置</li>
</ul>
</li>
<li><strong>MyBatis事务</strong>：<ul>
<li>基于SqlSession实现</li>
<li>默认自动提交(false)，需要手动控制</li>
<li>传播行为简单，不支持复杂场景</li>
<li>隔离级别依赖数据库默认设置</li>
</ul>
</li>
</ul>
<ol>
<li>集成与协作</li>
</ol>
<ul>
<li><strong>单独使用MyBatis</strong>：<ul>
<li>需要手动获取SqlSession</li>
<li>通过SqlSessionFactory.openSession()获取会话</li>
<li>显式调用commit()/rollback()</li>
</ul>
</li>
<li><strong>Spring集成MyBatis</strong>：<ul>
<li>Spring管理SqlSession的创建和释放</li>
<li>通过Spring事务管理器(如DataSourceTransactionManager)统一管理</li>
<li>MyBatis事务被Spring事务包装</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>Spring事务传递和事务只在方法内部要怎么做</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span>  <span class="hljs-comment">// 默认值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</span><br>&#125;<br><br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">independentTransactionMethod</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 此方法总是启动新事务，不受外部事务影响</span><br> <span class="hljs-comment">// 如果已有事务，则挂起当前事务，创建新事务</span><br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>MySQL出现死锁怎么排查</p>
<blockquote>
<p>查看最近死锁信息: <code>SHOW ENGINE INNODB STATUS;</code></p>
</blockquote>
</li>
<li><p>介绍一下红黑树，Java什么数据结构用到了，Linux哪里用到了</p>
</li>
</ol>
<h2 id="3-29-拼多多-一面"><a href="#3-29-拼多多-一面" class="headerlink" title="3.29-拼多多-一面"></a>3.29-拼多多-一面</h2><ol>
<li><p>拷打实习</p>
<ol>
<li>线程池怎么设置的</li>
<li>EventBus</li>
<li>限流组件</li>
</ol>
</li>
<li><p>手撕：双线程交替打印0-100</p>
</li>
<li><p>手撕：三线程交替打印0-100</p>
</li>
<li><p>OSI 7层模型</p>
</li>
<li><p>SYN攻击</p>
<blockquote>
<p>假设攻击者短时间伪造不同IP地址的SYN报文，服务端每接收到一个SYN报文，就进入SYN_RCVD状态，但服务端发送出去的ACK+SYN报文，无法得到未知IP主机的ACK应答，久而久之就会占满服务端的半连接队列，使得服务端不能为正常用户服务。</p>
</blockquote>
</li>
<li><p>哲学家就餐问题</p>
</li>
<li><p>死锁的四个必要条件，怎么解决</p>
</li>
<li><p>迪杰斯特拉最短路径算法</p>
</li>
<li><p>两个文件，分别有100亿URL，内存只有1G，怎么取交集</p>
<blockquote>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202503291811399.png" alt="image-20250329181141169"></p>
</blockquote>
</li>
<li><p>ZSET是大key，怎么删除</p>
<blockquote>
<ol>
<li><p>渐进式删除，使用 <code>zremrangebyrank</code> 命令，每次删除 top 100个元素。</p>
</li>
<li><p>ZSCAN：<code>ZSCAN</code> 命令通过游标方式分批获取 ZSET 成员，配合 <code>ZREM</code> 实现渐进式删除，避免一次性操作造成 Redis 阻塞。</p>
</li>
<li>UNLINK异步删除</li>
</ol>
</blockquote>
</li>
<li><p>HashSet如何实现去重的</p>
</li>
<li><p>线上SQL执行比较慢，怎么排查</p>
</li>
<li><p>EXPLAIN关注哪些指标</p>
</li>
</ol>
<h2 id="4-1-饿了么-一面"><a href="#4-1-饿了么-一面" class="headerlink" title="4.1-饿了么-一面"></a>4.1-饿了么-一面</h2><ol>
<li>拷打实习<ol>
<li>有没有碰到线上问题</li>
<li>模型识别结果出错有处理吗</li>
<li>websocket语音转文字</li>
<li>Redis限流，技术选型</li>
<li>有哪些可完善的地方</li>
<li>流量提高后，负载均衡、应用层、db层怎么优化</li>
<li>DB扩展可以怎么做</li>
<li>分库分表怎么做，分的时候需要注意哪些点，分完会有哪些副作用</li>
<li>Redis缓存三剑客</li>
<li>数据一致性怎么保证的</li>
<li>事务、索引使用上会关注哪些</li>
<li>建立索引要注意哪些</li>
<li>MySQL隔离级别</li>
<li>可重复读有哪些问题</li>
</ol>
</li>
<li>拷打项目<ol>
<li>难点</li>
<li>单体和微服务的区别，优缺点</li>
<li>使用微服务架构哪些成本会比较高</li>
</ol>
</li>
<li>搭过微服务吗，有没有遇到什么问题</li>
<li>java比起其他语言哪些特性比较突出</li>
<li>java垃圾回收机制，不同版本默认的垃圾回收器</li>
<li>java内存溢出的情况</li>
<li>实习更看重哪些</li>
<li>大模型有了解过吗，会对java开发有哪些影响</li>
</ol>
<h2 id="4-1-拼多多-二面"><a href="#4-1-拼多多-二面" class="headerlink" title="4.1-拼多多-二面"></a>4.1-拼多多-二面</h2><ol>
<li>拷打实习<ol>
<li>双token刷新</li>
<li>websocket和http的区别</li>
<li>能使用http模拟websocket的效果吗</li>
<li>哪些场景会用到websocket，聊天室是怎么实现的</li>
<li>Redis限流</li>
</ol>
</li>
<li>Redis是个什么样的数据库</li>
<li>Redis过期策略</li>
<li>Redis数据结构</li>
<li>Redis数据类型适用场景</li>
<li>Redis持久化</li>
<li>拷打项目</li>
<li>设计模式了解哪些</li>
<li>手撕：单例模式</li>
<li>MySQL索引介绍一下</li>
<li>实际开发中用到的索引、事务</li>
<li>联合索引怎么用、底层</li>
<li>手撕：合并k个有序链表，时间复杂度</li>
<li>git了解哪些命令，cherry-pick、rebase了解吗</li>
<li>linux命令了解哪些，都做过什么</li>
<li>docker底层实现了解吗，怎么做的容器隔离</li>
</ol>
<h2 id="4-3-字节-飞书-一面"><a href="#4-3-字节-飞书-一面" class="headerlink" title="4.3-字节-飞书-一面"></a>4.3-字节-飞书-一面</h2><ol>
<li><p>拷打实习</p>
</li>
<li><p>Redis限流</p>
</li>
<li><p>zset底层结构</p>
</li>
<li><p>跳表是个什么样的结构，查询过程</p>
</li>
<li><p>库存防超卖，分段锁的必要性</p>
</li>
<li><p>Redis分布式锁注意事项</p>
</li>
<li><p>什么时机会触发续期操作，判断条件是什么</p>
<blockquote>
<p>每 过期时间/3 会执行一次续期</p>
<p>看门狗线程作为守护线程运行，会随用户线程终止而自动结束</p>
</blockquote>
</li>
<li><p>为什么不设置一个时间比较长的加锁时间</p>
</li>
<li><p>Spring的理解，循环依赖怎么解决的</p>
</li>
<li><p>代理对象怎么理解，为什么用二级缓存解决不了</p>
</li>
<li><p>使用其他名称来指代代理对象，可以用二级缓存解决吗</p>
</li>
<li><p>MySQL有哪几种索引</p>
</li>
<li><p>b+树有什么特点</p>
</li>
<li><p>什么场景、怎么建索引</p>
</li>
<li><p>MySQL是怎么选择要使用哪个索引</p>
</li>
<li><p>EXPLAIN使用</p>
</li>
<li><p>手撕SQL: 查询每门课程成绩最高的人，要求返回课程名称、人名、成绩</p>
<blockquote>
<p>t_student: sid, sname</p>
<p>t_course: cid, cname</p>
<p>t_score: sid, cid, score</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    c.cname <span class="hljs-keyword">AS</span> 课程名称,<br>    s.sname <span class="hljs-keyword">AS</span> 学生姓名,<br>    sc.score <span class="hljs-keyword">AS</span> 最高成绩<br><span class="hljs-keyword">FROM</span> <br>    t_score sc<br><span class="hljs-keyword">JOIN</span> <br>    t_student s <span class="hljs-keyword">ON</span> sc.sid <span class="hljs-operator">=</span> s.sid<br><span class="hljs-keyword">JOIN</span> <br>    t_course c <span class="hljs-keyword">ON</span> sc.cid <span class="hljs-operator">=</span> c.cid<br><span class="hljs-keyword">WHERE</span> <br>    (sc.cid, sc.score) <span class="hljs-keyword">IN</span> (<br>        <span class="hljs-keyword">SELECT</span> <br>            cid, <br>            <span class="hljs-built_in">MAX</span>(score) <br>        <span class="hljs-keyword">FROM</span> <br>            t_score <br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br>            cid<br>    );<br></code></pre></td></tr></table></figure>
</li>
<li><p>手撕：字符串乘法</p>
</li>
</ol>
<h2 id="4-7-阿里云-HR面"><a href="#4-7-阿里云-HR面" class="headerlink" title="4.7-阿里云-HR面"></a>4.7-阿里云-HR面</h2><ol>
<li>自我介绍、绩点、排名</li>
<li>拷打项目<ol>
<li>团队分工</li>
<li>项目难点</li>
</ol>
</li>
<li>对未来工作的公司、类型有没有规划</li>
<li>城市选择</li>
<li>实习的成长</li>
<li>如何推动他人做事情</li>
<li>做过哪些关键的选择</li>
<li>性格受谁影响比较大</li>
<li>性格怎么样，如何应对压力</li>
</ol>
<h2 id="4-9-字节-飞书-二面"><a href="#4-9-字节-飞书-二面" class="headerlink" title="4.9-字节-飞书-二面"></a>4.9-字节-飞书-二面</h2><ol>
<li><p>拷打实习</p>
<ol>
<li><p>多租户怎么实现的</p>
</li>
<li><p>租户ID是在哪里，怎么校验的</p>
</li>
<li><p>为什么使用RBAC，而不是ABAC,MAC,DAC</p>
</li>
<li><p>双token刷新，token保存了哪些属性（访问权限？登录态？）</p>
</li>
<li><p>后端有没有类似session的机制，为什么要存储两份</p>
</li>
<li><p>token用户端存储在哪</p>
</li>
<li><p>如果token被盗会发生什么，怎么防止被盗</p>
</li>
<li><p>有了解过前后端交互的攻击场景吗，CSRF之类的</p>
</li>
<li><p>怎么防止CSRF</p>
<blockquote>
<ol>
<li>验证用户会话：在服务器端对用户会话进行验证，确保请求的会话标识符与当前会话标识符匹配。这样可以防止攻击者伪造会话标识符。</li>
<li>使用双重验证：除了会话验证，还可以使用其他验证方式，例如验证码、签名验证等。这些验证方式可以增加攻击的难度。</li>
<li>防止跨站请求：通过设置CSP(内容安全策略）来防止跨站请求，限制网页中可执行的脚本源，减少攻击者诱导用户执行恶意操作的可能性。</li>
<li>避免使用自动提交表单：禁用默认的自动提交功能，要求用户在提交表单前确认操作，防止攻击者诱导用户在未经授权的情况下提交表单。</li>
<li>强制Referer头部：在服务器端检查请求的Referer头部，确保请求来自可信来源。</li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p>拷打项目</p>
<ol>
<li>如何保证库存和奖品的一致性，即扣了库存一定会发奖</li>
<li>Redis扣库存和落Task表是怎么保证一致性的</li>
<li>Redis和db库存是怎么保证最终一致性</li>
<li>如果Redis宕机怎么办</li>
<li>库存是怎么设计的，如何支撑高并发，有用过压测工具测试过吗</li>
<li>如果限制用户每天只能抽三次奖，怎么实现</li>
<li>系统性能会不会因为读db而收到限制</li>
</ol>
</li>
<li><p>HTTPS怎么保证安全</p>
</li>
<li><p>HTTPS会被第三方窃听或劫持吗</p>
</li>
<li><p>Spring @Autowired怎么实现</p>
</li>
<li><p>默认Spring注入的Bean是线程安全的吗</p>
</li>
<li><p>如果希望Bean的一个属性被共享，怎么变成线程安全的</p>
</li>
<li><p>使用ThreadLocal会有什么坑吗</p>
</li>
<li><p>Spring提供服务的Handler线程池是复用的还是每次new新的</p>
</li>
<li><p>用volatile会变成线程安全吗，能保证原子性、一致性吗</p>
</li>
<li><p>锁升级</p>
</li>
<li><p>Spring事务，A方法调用B方法，如何只回滚B而不回滚A</p>
</li>
<li><p>平常用的java什么版本，有哪些新特性</p>
</li>
<li><p>虚拟线程的理解，和普通的线程、进程有什么区别</p>
</li>
<li><p>做项目的过程中有遇到过印象比较深、有挑战的问题吗，怎么解决的</p>
</li>
<li><p>手撕：括号生成</p>
</li>
</ol>
<h2 id="4-10-字节-飞书-三面"><a href="#4-10-字节-飞书-三面" class="headerlink" title="4.10-字节-飞书-三面"></a>4.10-字节-飞书-三面</h2><ol>
<li>拷打实习<ol>
<li>前端如何保存token</li>
<li>是否存在被xss的风险，xss的原理</li>
<li>为什么使用双token而不是cookie</li>
<li>解释下CSRF原理，不同域名不会携带cookie</li>
<li>了解OAuth吗</li>
<li>SSE的原理，和websock传输有什么区别</li>
<li>Redis滑动窗口，还有哪些限流机制</li>
</ol>
</li>
<li>拷打项目<ol>
<li>有哪些特色的设计方案</li>
<li>扣库存逻辑</li>
<li>用户抽奖次数限制怎么实现，有没有做过并发测试</li>
</ol>
</li>
<li>场景：一个订单用户支付成功后，订单状态要更新并且要发一个MQ消息，状态和MQ如何保证最终一致性</li>
<li>手撕：给一个字符串“123456789”，在任意一位数字前插入“-”或”+“，要求表达式最终计算结果为100，返回所有可能的表达式</li>
</ol>
<h2 id="4-10-拼多多-三面"><a href="#4-10-拼多多-三面" class="headerlink" title="4.10-拼多多-三面"></a>4.10-拼多多-三面</h2><ol>
<li>询问基本情况</li>
<li>拷打实习<ol>
<li>RBAC介绍</li>
<li>双token介绍，为什么要用双token</li>
<li>多租户怎么实现的</li>
</ol>
</li>
</ol>
<h2 id="4-11-字节-飞书-HR面"><a href="#4-11-字节-飞书-HR面" class="headerlink" title="4.11-字节-飞书-HR面"></a>4.11-字节-飞书-HR面</h2><ol>
<li>自我介绍</li>
<li>实习的目标、期待是什么</li>
<li>什么样的成果觉得ok，有没有衡量标准</li>
<li>花了很多精力但是结果不理想，你怎么考虑</li>
<li>期望在哪些维度有成长</li>
<li>技术层面上有哪些地方不太擅长</li>
<li>实习有哪些帮助</li>
<li>上线项目和自己项目有哪些区别，对你比较大的指引是什么</li>
<li>本科成绩，学习上有什么心得</li>
<li>和前5%的学生差距在哪里</li>
<li>参加过什么比赛吗</li>
<li>如何学习新领域</li>
<li>过往感觉压力最大、最低谷的事情是什么</li>
<li>过往有没有放弃，现在感觉遗憾的事情</li>
<li>设置过的最有挑战性的目标</li>
<li>最有成就感的事情</li>
<li>喜欢技术吗</li>
<li>做事的驱动点是什么</li>
<li>一到三年的规划</li>
<li>和同事方案有分歧要怎么做</li>
<li>如果项目使用的B方案，你想到了A方案，会怎么做</li>
<li>对前三面试官的感觉怎么样</li>
</ol>
<h2 id="4-18-拼多多-HR面"><a href="#4-18-拼多多-HR面" class="headerlink" title="4.18-拼多多-HR面"></a>4.18-拼多多-HR面</h2><p>主要了解个人情况</p>
<h2 id="4-21-蚂蚁-信贷-一面"><a href="#4-21-蚂蚁-信贷-一面" class="headerlink" title="4.21-蚂蚁-信贷-一面"></a>4.21-蚂蚁-信贷-一面</h2><ol>
<li>Spring Bean生命周期</li>
<li>类、静态类、对象的关系和使用方式</li>
<li>static什么时候使用</li>
<li>final什么场景使用</li>
<li>拷打项目<ol>
<li>解决超卖</li>
<li>为什么用Redis</li>
</ol>
</li>
<li>Redis为什么性能好</li>
<li>Redis常见数据类型</li>
<li>Redis内存淘汰</li>
<li>LRU的原理</li>
<li>拷打实习<ol>
<li>有没有使用AI工具</li>
<li>线程池拒绝策略</li>
<li>线程池参数作用</li>
<li>除了EventBus有没有考虑过使用别的解耦手段</li>
<li>为什么用WebSocket而不是轮询</li>
<li>三次握手，为什么不是二、四次握手</li>
</ol>
</li>
<li>业务：花呗借呗的一些决策上的工程平台，处理额度之类的</li>
</ol>
<h2 id="阿里云面试分析-wf"><a href="#阿里云面试分析-wf" class="headerlink" title="阿里云面试分析(wf)"></a>阿里云面试分析(wf)</h2><ol>
<li>CPU占用比较高有哪些情况</li>
</ol>
<p>感觉还是应该先正面回答一下面试官的问题，后面作为补充可以说一下实习的经历。比如可以说实习中是什么样的，可能没有这种情况，但是如果我遇到了我会按哪些方式排查，大概有哪几种情况</p>
<p>可能的回答：先使用top查看进程CPU占用情况，找到CPU占用最高进程后再用ps查看线程详情。</p>
<p>如果是java进程，用jstack获取到线程堆栈信息</p>
<ul>
<li>内部：死循环、锁竞争、频繁full gc</li>
<li>外部：突发流量</li>
</ul>
<p>如果是数据库</p>
<ul>
<li>慢查询</li>
</ul>
<p>上面这些可能就是会啥说啥，面试官可能会就其中几个点继续追问</p>
<ol>
<li>内存占用比较高有哪些情况，怎么排查</li>
</ol>
<p>首先有一些内存监控工具，比如Prometheus + Grafana、arthas、VisualVM</p>
<p>可能情况包括内存泄漏、突发流量、加载大量数据</p>
<p>发生了OOM打印一下内存快照，然后使用各种内存分析工具进行分析，再定位到代码中的问题</p>
<ol>
<li><p>限流怎么实现</p>
</li>
<li><p>其他限流算法</p>
</li>
</ol>
<p>固定窗口、滑动窗口、漏桶、令牌桶</p>
<ol>
<li><p>ThreadLocal底层实现</p>
</li>
<li><p>SpringCloud GateWay介绍</p>
</li>
<li><p>微服务有哪些优缺点</p>
</li>
</ol>
<p>可以讲一下微服务各自可以使用不同语言实现，只需要使用同一种协议交互</p>
<ol>
<li>怎么过滤恶意ip段</li>
</ol>
<p>除了转化为数字，我感觉还有前缀树？布隆过滤器（允许误判的话）？</p>
<ol>
<li><p>单个IP段转成数字怎么比对</p>
</li>
<li><p>能不能用二分的思路</p>
</li>
<li><p>java垃圾回收</p>
</li>
<li><p>java判断对象存活</p>
</li>
<li><p>static变量会被回收吗</p>
</li>
</ol>
<p>类对象被回收的话</p>
<ol>
<li><p>双亲委派机制</p>
</li>
<li><p>动态代理</p>
</li>
<li><p>CGLIB底层实现</p>
</li>
</ol>
<p>asm框架，通过操作字节码实现，但这个应该算是扩展问题</p>
<ol>
<li><p>三次握手</p>
</li>
<li><p>进程线程区别</p>
</li>
<li><p>进程间的通信方式</p>
</li>
<li><p>SQL注入</p>
</li>
<li><p>修复SQL注入</p>
</li>
<li><p>手撕：力扣227简化版</p>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p>什么是慢查询，如何定位慢查询</p>
<blockquote>
<p>慢查询（Slow Query）是指执行时间超过预期阈值的数据库查询操作。这类查询可能会消耗大量数据库资源（如CPU、内存、磁盘I/O），导致数据库性能下降，甚至影响整个系统的稳定性。</p>
<p>启用慢查询日志，使用 <code>mysqldumpslow</code> 分析慢查询日志</p>
<ol>
<li>增删查改<ul>
<li>对于插入可以把多个语句合并成一个语句批量处理。</li>
<li>对于删除，因为删除是<strong>假删除</strong>(减少B+树合并访问磁盘的开销)，如果有太多地方没有使用，B+树层数虚高，增加了访问磁盘的速度，并且全表扫描也会扫描到很多无用数据，可以在数据库空闲的时候通过alter table来重建表使数据排列更紧凑</li>
<li>对于频繁修改的数据</li>
<li>利用最左匹配原则减少索引数量</li>
<li>如果有唯一索引可以考虑改成普通索引，避免修改时为了维护唯一性导致<strong>change buffer</strong>失效。</li>
<li>对于查询:</li>
<li>使用<strong>缓存</strong>, 早期mysql开启查询缓存，mysql8.0没有查询缓存，业务层可以使用缓存例如redis；或者可以把一些特殊的语句定期执行然后保存，后面查保存的数据，不用执行sql，比如我之前做的一个预测成本的功能，每月只需要预测一次，那就可以写一个定时任务每个月定时预测一次保存到另一张表，后续查询直接查这张表就可以了，就不用执行复杂SQL了。</li>
<li>对于<strong>大数据量</strong>的场景，可以<strong>读写分离，分库分表</strong></li>
</ul>
</li>
<li>EXPLAIN分析SQL语句的执行计划，主要关注以下几个字段<ul>
<li>如果<code>type</code>为<code>ALL</code>，说明进行了全表扫描，考虑是否可以通过增加索引来优化。<ul>
<li>All(全表扫描）；index（全索引扫描）；range(索引范围扫描）；ref（非唯一索引扫描）；eq_ref(唯一索引|扫描）；const(结果只有一条的主键或唯一索引扫描)</li>
</ul>
</li>
<li>分析<code>possible_keys （可能使用到的索引）</code>和<code>key（实际使用的索引）</code>，确保相关的列上建立适当的索引并且正确选取索引。</li>
<li>使用<strong>覆盖索引</strong>来避免<strong>回表</strong></li>
<li>使用复合索引来提高多条件查询的性能（<strong>索引下推</strong>）。</li>
<li>利用<strong>最左匹配原则</strong>尽可能的建立更少的索引</li>
<li>分析有没有没有正确选取索引</li>
<li>可能会错误的使用全表扫描的场景</li>
<li>对字段使用了函数：将函数写在判断条件上面，避免对字段使用函数。</li>
<li>字段隐式类型转换（str-&gt;int, 字段使用了utf8但是字符是utf8mb4），需要保证查询目标与字段类型一致</li>
<li>如果没有出现上述问题，还有一种解决思路：使用force index强制使用索引 | order by .. limit 1。</li>
<li>因为选取索引是<strong>优化器</strong>的工作，优化器会分析选取索引的扫描行数加上回表的代价是否比主键全表扫描少，这里采用<strong>采样分析</strong>，因为全表分析代价太大，在多个事务的时候，因为是假删除而且多个事务的时候MVCC多版本数据在undo-log里面，这个时候采样分析会把已经删除的数据也考虑到总量里面去，比如实际上总量是1000行，考虑成了2000行导致考虑的扫描行数翻倍。所以<strong>采样分析针对高并发和大数量的场景是非常不准的</strong></li>
<li>MySQL临时表, CTE会破坏索引结构（例如group后使用了临时表）：想办法优化掉临时表，或者减少临时表的查询、JOIN操作</li>
<li><code>rows</code>字段，表示查询的结果集行数。我们要尽可能的减少rows的数量，以下是一些思路</li>
<li>确保查询条件尽可能具体, 例如在WHERE子句中使用更严格的条件。</li>
<li>对于确定的数量（例如只需要查询一个结果）使用limit</li>
<li>in 替换成 exists，in 是 双重匹配，exists匹配到了一个后就会提前返回</li>
<li>count字段看可不可以替换成count( * ), count(1)</li>
<li>Extra字段，记录一些额外信息</li>
<li>如果有Using filesort，表示使用了文件排序。</li>
<li>可以考虑给需要排序的字段加上索引，因为索引使用的B+树本来就是排序好的，可以减少排序时间。 或者可以把单次排序的内存<code>sort_buffer_size</code>设置大一点，因为排序是取磁盘里的部分数据到内存进行排序最后合并， 把单次排序内存设置大一点这样减少IO次数</li>
<li>如果有Using Join Buffer, 说明Join没有使用索引。没有索引join会用到Block Nested-Loop Join算法，时间复杂度很高，可以看作两层遍历，实际上更复杂一点，考虑到数据很多不能全读到内存里，mysql使用了join_buffer来存一部分数据，可能会因为 join_buffer 不够大，需要对被驱动表做多次全表扫描。</li>
<li>在需要Join的字段加上索引</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>Redis中hash结构如何实现</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/redis/data_struct/data_struct.html#%E5%93%88%E5%B8%8C%E8%A1%A8">https://www.xiaolincoding.com/redis/data_struct/data_struct.html#%E5%93%88%E5%B8%8C%E8%A1%A8</a></p>
<p>使用listpack，哈希表实现</p>
<p><img src="https://whale-picture.oss-cn-hangzhou.aliyuncs.com/img/202503192338711.png" alt="image-20250319233803573" style="zoom: 67%;" /></p>
<p>哈希表是一个数组(dictEntry** table)，数组的每个元素是一个指向「哈希表节点(dictEntry)」的指针。</p>
<p>使用链式哈希解决哈希冲突</p>
</blockquote>
</li>
<li><p>rehash过程</p>
<blockquote>
<ol>
<li>给「哈希表2」分配空间，一般会比「哈希表1」大一倍</li>
<li>将「哈希表1」的数据迁移到「哈希表2」中</li>
<li>迁移完成后，「哈希表1」的空间会被释放，并把「哈希表2」设置为「哈希表1」，然后在「哈希表2」新创建一个空白的哈希表，为下次rehash做准备</li>
</ol>
<p>如果「哈希表1」的数据量非常大，那么在迁移至「哈希表2」的时候，因为会涉及大量的数据拷贝，此时可能会对Redis造成阻塞，无法服务其他请求。</p>
<p><strong>渐进式rehash</strong></p>
<ol>
<li>给「哈希表2」分配空间</li>
<li>在rehash进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作之外，还会顺序将「哈希表1」中索引位置上的所有key-value迁移到「哈希表2」上</li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表1」的所有key-value迁移到「哈希表2」，从而完成rehash操作。</li>
</ol>
<p>触发rehash操作的条件，主要有两个：</p>
<ul>
<li>当负载因子大于等于1，并且Redis没有在执行bgsave命令或者bgrewiteaof命令，也就是没有执行RDB快照或没有进行AOF重写的时候，就会进行rehash操作。</li>
<li>当负载因子大于等于5时，此时说明哈希冲突非常严重了，不管有没有有在执行RDB快照或AOF重写，都会强制进行rehash操作。</li>
</ul>
</blockquote>
</li>
<li><p>set和bitmap如何实现点赞和签到</p>
<blockquote>
<p>点赞：key 是文章id，value 是用户id</p>
<ul>
<li><code>SADD article:1 uid:1</code></li>
</ul>
<p>签到：假设我们要统计ID 100的用户在2022年6月份的签到情况</p>
<ul>
<li><code>SETBIT uid:sign:100:202206 2 1</code> (2是偏移量，代表3号签到)</li>
<li><code>BITCOUNT uid:sign:100:202206</code></li>
</ul>
</blockquote>
</li>
<li><p>RabbitMQ保证消息的可靠性</p>
<blockquote>
<p>不丢失：</p>
<p>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</p>
<p>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</p>
<p>RabbitMQ 到消费者：消费者确认机制，失败重试机制</p>
<p>不重复：</p>
<p>幂等性：唯一ID、业务状态判断</p>
<p>兜底机制：定时任务扫描状态未完成的任务</p>
</blockquote>
</li>
<li><p>innodb的自增id是怎么实现的</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/lock/mysql_lock.html#auto-inc-%E9%94%81">https://www.xiaolincoding.com/mysql/lock/mysql_lock.html#auto-inc-%E9%94%81</a></p>
</blockquote>
</li>
<li><p>epoll过程</p>
<blockquote>
<ol>
<li>服务器调用 listen(fd, backlog) 监听端口，全连接队列初始化。</li>
<li>服务器调用 epoll_create() 创建 epoll 实例。</li>
<li>服务器调用 epoll_ctl(EPOLL_CTL_ADD, listen_fd, EPOLLIN) 将监听socket加入epoll。</li>
<li>客户端发起连接，完成三次握手，内核将连接放入全连接队列。</li>
<li>epoll_wait() 返回，通知应用程序 listen_fd 可读（有新连接）。</li>
<li>服务器调用 accept() 从全连接队列取出连接，得到 conn_fd。</li>
<li>服务器调用 epoll_ctl(EPOLL_CTL_ADD, conn_fd, EPOLLIN) 将 conn_fd 加入 epoll，监听数据到达。</li>
<li>客户端发送数据，epoll_wait() 返回 conn_fd 可读，服务器调用 read() 读取数据。</li>
</ol>
</blockquote>
</li>
</ol>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2025/04/14/Kafka-1/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2025-07-04 22:19:32
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/%E9%9D%A2%E8%AF%95/" title="面试">
                        <b>#</b> 面试
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-27-%E9%98%BF%E9%87%8C%E4%BA%91-%E9%BD%90%E5%A4%A9-%E4%B8%80%E9%9D%A2"><span class="toc-text">2.27-阿里云-齐天-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%AD%97%E8%8A%82-%E8%B4%A2%E7%BB%8F-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.6-字节-财经-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E9%98%BF%E9%87%8C%E6%8E%A7%E8%82%A1-%E6%99%BA%E8%83%BD%E5%BC%95%E6%93%8E-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.7-阿里控股-智能引擎-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E7%BE%8E%E5%9B%A2-AI%E9%9D%A2%E8%AF%95"><span class="toc-text">3.9-美团-AI面试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E9%98%BF%E9%87%8C%E4%BA%91-%E9%BD%90%E5%A4%A9-%E4%BA%8C%E9%9D%A2"><span class="toc-text">3.10-阿里云-齐天-二面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E8%85%BE%E8%AE%AF-CDG-%E9%87%91%E8%9E%8D%E7%A7%91%E6%8A%80-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.10-腾讯-CDG-金融科技-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-%E8%85%BE%E8%AE%AF-PCG-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.14-腾讯-PCG-应用架构-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-18-%E9%98%BF%E9%87%8C%E6%8E%A7%E8%82%A1-%E6%99%BA%E8%83%BD%E5%BC%95%E6%93%8E-%E4%BA%8C%E9%9D%A2"><span class="toc-text">3.18-阿里控股-智能引擎-二面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-19-%E7%BE%8E%E5%9B%A2-%E6%A0%B8%E5%BF%83%E6%9C%AC%E5%9C%B0%E5%95%86%E4%B8%9A-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.19-美团-核心本地商业-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-20-%E5%AD%97%E8%8A%82-%E5%B9%BF%E5%91%8A%E4%B8%9A%E5%8A%A1-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.20-字节-广告业务-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-21-%E8%9A%82%E8%9A%81-%E5%9B%BD%E9%99%85-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.21-蚂蚁-国际-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-21-%E6%90%BA%E7%A8%8B-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.21-携程-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-24-%E8%85%BE%E8%AE%AF-PCG-QQ-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.24-腾讯-PCG-QQ-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-25-%E8%85%BE%E8%AE%AF-PCG-QQ-%E4%BA%8C%E9%9D%A2"><span class="toc-text">3.25-腾讯-PCG-QQ-二面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-25-%E7%BE%8E%E5%9B%A2-%E6%A0%B8%E5%BF%83%E6%9C%AC%E5%9C%B0%E5%95%86%E4%B8%9A-%E4%BA%8C%E9%9D%A2"><span class="toc-text">3.25-美团-核心本地商业-二面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-27-%E8%9A%82%E8%9A%81-%E5%9B%BD%E9%99%85-%E4%BA%8C%E9%9D%A2"><span class="toc-text">3.27-蚂蚁-国际-二面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-28-%E5%BF%AB%E6%89%8B-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.28-快手-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-29-%E9%98%BF%E9%87%8C%E4%BA%91-%E9%BD%90%E5%A4%A9-%E4%B8%89%E9%9D%A2"><span class="toc-text">3.29-阿里云-齐天-三面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-29-%E6%8B%BC%E5%A4%9A%E5%A4%9A-%E4%B8%80%E9%9D%A2"><span class="toc-text">3.29-拼多多-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%A5%BF%E4%BA%86%E4%B9%88-%E4%B8%80%E9%9D%A2"><span class="toc-text">4.1-饿了么-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%8B%BC%E5%A4%9A%E5%A4%9A-%E4%BA%8C%E9%9D%A2"><span class="toc-text">4.1-拼多多-二面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%AD%97%E8%8A%82-%E9%A3%9E%E4%B9%A6-%E4%B8%80%E9%9D%A2"><span class="toc-text">4.3-字节-飞书-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E9%98%BF%E9%87%8C%E4%BA%91-HR%E9%9D%A2"><span class="toc-text">4.7-阿里云-HR面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E5%AD%97%E8%8A%82-%E9%A3%9E%E4%B9%A6-%E4%BA%8C%E9%9D%A2"><span class="toc-text">4.9-字节-飞书-二面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E5%AD%97%E8%8A%82-%E9%A3%9E%E4%B9%A6-%E4%B8%89%E9%9D%A2"><span class="toc-text">4.10-字节-飞书-三面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E6%8B%BC%E5%A4%9A%E5%A4%9A-%E4%B8%89%E9%9D%A2"><span class="toc-text">4.10-拼多多-三面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-%E5%AD%97%E8%8A%82-%E9%A3%9E%E4%B9%A6-HR%E9%9D%A2"><span class="toc-text">4.11-字节-飞书-HR面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-18-%E6%8B%BC%E5%A4%9A%E5%A4%9A-HR%E9%9D%A2"><span class="toc-text">4.18-拼多多-HR面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-21-%E8%9A%82%E8%9A%81-%E4%BF%A1%E8%B4%B7-%E4%B8%80%E9%9D%A2"><span class="toc-text">4.21-蚂蚁-信贷-一面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E4%BA%91%E9%9D%A2%E8%AF%95%E5%88%86%E6%9E%90-wf"><span class="toc-text">阿里云面试分析(wf)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Whale-lyi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F + '&url=' + https%3A%2F%2Fwhale-lyi.github.io%2F2025%2F07%2F04%2F%25E9%259D%25A2%25E7%25BB%258F%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://whale-lyi.github.io/2025/07/04/%E9%9D%A2%E7%BB%8F/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>-->
<!--<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
